@q hyprbola.web @>
@q Created by Laurence D. Finston (LDF) Mon Nov  7 18:26:47 CET 2005 @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation  @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Hyperbolae.@>
@** Hyperbolae\quad ({\tt hyperbola\PERIOD web}).\hfil

\LOG
\initials{LDF 2005.11.07.}
Created this file.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"

@q * (1) Hyperbola class definition.@>
@* {\bf Hyperbola} class definition.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this |class| definition.

\initials{LDF 2005.11.15.}
Added |Path branch_1|.

\initials{LDF 2005.11.15.}
Added |Point center|.  I can't add it in |class Conic_Section|, because
it would interfere with |Reg_Cl_Plane_Curve::center| in |class Ellipse| and 
|class Circle|.
\ENDLOG

@<Define |class Hyperbola|@>=

class Hyperbola : public Path, public Conic_Section
{

   protected:
   
   Path branch_1;
   Point center;

   public:

  @<Declare |Hyperbola| functions@>@;
};

@q ** (2) Static member variable definitions.@>
@*1 Static member variable definitions.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.  It is currently empty.
\ENDLOG

@q *** (3) Code.@> 

@<Define |static| |class Hyperbola| data members@>=

@q * (1) Constructors and setting functions.@>
@* Constructors and setting functions.@>
\initials{LDF 2005.11.07.}

@q ** (2) Default constructor.  No arguments.@>
@*1 Default constructor. No arguments.
@^\cfunc{Hyperbola}{Hyperbola}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.25.}
Now setting |real axis_h| and |real axis_v| to |INVALID_REAL|.

\initials{LDF 2005.11.28.}
Now setting |real max_extent| to |INVALID_REAL|.

\initials{LDF 2005.11.30.}
@:BUG FIX@> BUG FIX: 
Now setting |conic_section_type| to |Shape::HYPERBOLA_TYPE|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Hyperbola| functions@>=
Hyperbola(void);

@q *** (3) Definition.@>

@
@<Define |Hyperbola| functions@>= 
Hyperbola::Hyperbola(void)
{

   conic_section_type = shape_type = HYPERBOLA_TYPE;

   axis_h = axis_v = INVALID_REAL;

   max_extent = INVALID_REAL;

   return;

}

@q ** (2) Setting function.@> 
@*1 Setting function.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.15.}
This function now works.

\initials{LDF 2005.11.25.}
Now setting |Point center| to |*(options->center)|, if the latter is non-null, otherwise
|ORIGIN|.  Now shifting the |Points| on the |Hyperbola| by |center|.
\ENDLOG

@q *** (3) Declaration.  @>

@<Declare |Hyperbola| functions@>=
int
set(Hyperbola_Set_Option_Struct* options = 0, Scanner_Node scanner_node = 0);

@q *** (3) Definition.  @>

@
@<Define |Hyperbola| functions@>= 
int
Hyperbola::set(Hyperbola_Set_Option_Struct* options, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4) |options == static_cast<Hyperbola_Set_Option_Struct*>(0)|.  Use defaults.@>
@ |options == static_cast<Hyperbola_Set_Option_Struct*>(0)|.  Use defaults.
\initials{LDF 2005.11.15.}

@<Define |Hyperbola| functions@>=

   if (options == static_cast<Hyperbola_Set_Option_Struct*>(0))
   {
      /* Do nothing  */

   }  /* |if (options == static_cast<Hyperbola_Set_Option_Struct*>(0))|  */

@q **** (4) |options != static_cast<Hyperbola_Set_Option_Struct*>(0)|.  @>
@ |options != static_cast<Hyperbola_Set_Option_Struct*>(0)|.
\initials{LDF 2005.11.15.}

\LOG
\initials{LDF 2005.11.18.}
@:BUG FIX@> BUG FIX:  Now pushing |".."| onto |connectors|.

\initials{LDF 2005.11.25.}
Now setting |real axis_h| and |real axis_v|.

\initials{LDF 2005.11.25.}
Reversed the |Paths| so that the normal points in the direction of the positive
y-axis, if |*this| is left untransformed.
\ENDLOG

@<Define |Hyperbola| functions@>=

   else /* |options != static_cast<Hyperbola_Set_Option_Struct*>(0)|  */
      {

          real a = 1.0;
          real b = 1.0;
          
          max_extent = DEFAULT_MAX_EXTENT;

          real increment_value = .05;

          if (options->major_axis_length != INVALID_REAL)
             a = options->major_axis_length / 2;             

          if (options->minor_axis_length != INVALID_REAL)
             b = options->minor_axis_length / 2;             


          if (options->max_extent != INVALID_REAL)
             max_extent = options->max_extent;

          axis_h = 2 * a;
          axis_v = 2 * b;

          real x = a;
          real z;
   
          real b_over_a = b / a;
 
          Point* p;

          deque<Point*> d;
          deque<Point*> e;
 
          vertex_0.set(a, 0, 0);
          vertex_1.set(-a, 0, 0);

          if (options->center)
             center = *(options->center);
          else 
             center = ORIGIN;

          linear_eccentricity = sqrt((b * b) + (a * a));

          focus_0.set(linear_eccentricity, 0, 0);
          focus_1.set(-linear_eccentricity, 0, 0);

          for (; x <= max_extent; x += increment_value)
             {
                 if (x > 3)
                    increment_value = .25;
                 else if (x > 1)
                    increment_value = .1;
                                  
                 z = b_over_a * x * sqrt(1 - ((a * a) / (x * x)));

                 p = create_new<Point>(0);
                 p->set(x, 0, z);
                 p->shift(center);
                 d.push_back(p);
                 
                 p = create_new<Point>(0);
                 p->set(x, 0, -z);
                 p->shift(center);
                 d.push_front(p);

                 p = create_new<Point>(0);
                 p->set(-x, 0, z);
                 p->shift(center);
                 e.push_back(p);
                 
                 p = create_new<Point>(0);
                 p->set(-x, 0, -z);
                 p->shift(center);
                 e.push_front(p);

             }

          for (deque<Point*>::reverse_iterator iter = d.rbegin();
               iter != d.rend();
               ++iter)
              points.push_back(*iter);

          d.clear();  

          for (deque<Point*>::reverse_iterator iter = e.rbegin();
               iter != e.rend();
               ++iter)
              branch_1 += *iter;

          e.clear();  

          connectors.push_back("..");

      }     /* |else| (|options != static_cast<Hyperbola_Set_Option_Struct*>(0)|)  */


@q **** (4).@>

@ DO NOT delete |options| here!  It's deleted in 
|Scan_Parse::::set_hyperbola_rule_func_0()|.  This should be done in any other caller, 
too.  Deleting it here causes a bug that's difficult to trace.
\initials{LDF 2005.11.14.}

@<Define |Hyperbola| functions@>= 

 
   return 0;

}  /* End of |Hyperbola::set()| definition.  */

@q * (1) Destructor.@> 
@* Destructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.30.}
@:BUG FIX@> BUG FIX:  Now clearing |branch_1|.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
~Hyperbola(void);

@q *** (3) Definition.  @>

@
@<Define |Hyperbola| functions@>= 
Hyperbola::~Hyperbola(void)
{

   branch_1.clear();
   return;
}

@q * (1) Pseudo-constructor for dynamic allocation.@>
@* Pseudo-constructor for dynamic allocation.

@q ** (2) Pointer argument.@>
@*1 Pointer argument.
@^\cfunc{Hyperbola}{create\_new\_hyperbola}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Hyperbola|@>=
Hyperbola* 
create_new(const Hyperbola* c, Scanner_Node scanner_node);

@q ** (2) Reference argument.@>
@*1 Reference argument.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Hyperbola|@>=
Hyperbola* 
create_new(const Hyperbola& c, Scanner_Node scanner_node);


@q * (1) Assignment.@> 
@* Assignment.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Assignment from a |Hyperbola|.@> 
@*1 Assignment from a |Hyperbola|.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.14.}
Now calling |Conic_Section::operator=(p)|.

\initials{LDF 2005.11.15.}
Now setting |Path branch_1| to |p.branch_1|.

\initials{LDF 2005.11.15.}
Now setting |Point center| to |p.center|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
virtual
Hyperbola&
operator=(const Hyperbola& c);

@q *** (3) Definition.@> 

@
@<Define |Hyperbola| functions@>=

Hyperbola&
Hyperbola::operator=(const Hyperbola& p)
{
    if (this == &p) /* Make sure it's not self-assignment. */
       return *this;

     center = p.center;

     branch_1 = p.branch_1;

     Conic_Section::operator=(p);
     Path::operator=(p);

     return *this;

}  /* End of |Hyperbola::operator=(const Hyperbola& h)| definition.  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return HYPERBOLA_TYPE;
}

@q ** (2) Get discriminant.@>
@*1 Get discriminant.

\LOG
\initials{LDF 2005.11.17.}
Added this function.

\initials{LDF 2005.11.17.}
Changed the return type of this function from |real| to |Real_Triple|.
It now returns |INVALID_REAL_TRIPLE|.

\initials{LDF 2005.11.18.}
Changed |Path&| argument to |const Path&|.  Added optional 
|Transform*| argument with default 0.

\initials{LDF 2005.11.27.}
Finished writing this function.
\ENDLOG

@q *** (3) Declaration.@> 


@<Declare |Hyperbola| functions@>=
Real_Triple
get_discriminant(const Path& p,
                 Transform* t = 0,
                 Scanner_Node scanner_node = 0) const;


@q *** (3) Definition.@> 

@
@<Define |Hyperbola| functions@>=
Real_Triple
Hyperbola::get_discriminant(const Path& p,
                            Transform* t,
                            Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    Transform* u = standardize(scanner_node);

@q **** (4) Error handling:  |Hyperbola::standardize()| failed.@> 

@ Error handling:  |Hyperbola::standardize()| failed.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=

    if (u == static_cast<Transform*>(0))
       {
           cerr_strm << thread_name << "ERROR!  In `Hyperbola::get_discriminant()':"
                     << endl 
                     << "`Hyperbola::standardize()' failed."
                     << endl 
                     << "Deleting `Transform* t', setting it to 0, and"
                     << endl 
                     << "exiting function unsuccesfully with return value "
                     << "`INVALID_REAL_TRIPLE'.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete t;
           t = 0;

           return INVALID_REAL_TRIPLE;
                   

       }  /* |if (u == static_cast<Transform*>(0))|  */

@q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

    Path q = p;

    q *= *u;

    real a = axis_h / 2;
    real b = axis_v / 2;

    if (t)
       *t = *u;

    
    real slope = q.slope('x', 'z');


    Bool_Point bp =  Point::intersection_point(q.get_point(0), q.get_point(1),
                                               ORIGIN, Point(0, 0, 1));

    real z_int = bp.pt.get_z();

    real discriminant = (b * b) + (z_int * z_int) - (a * a * slope * slope);

    delete u;
    u = 0;

    return Real_Triple(discriminant, slope, z_int);
 
}  /* End of |Hyperbola::get_discriminant()| definition. */


@q ** (2) Get Size.@> 
@*1 Get Size.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this section.
\ENDLOG

@q *** (3) Size.@> 
@*2 Size.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
size_t
size(void) const;

@
@<Define |Hyperbola| functions@>=
size_t
Hyperbola::size(void) const
{
   return Path::size() + branch_1.size();

}  /* End of |Hyperbola::size| definition.  */

@q ** (2) Location.@> 
@*1 Location.
\initials{LDF 2005.11.28.}

@q *** (3) Return values.@> 

Return values:\hfil\break
\item{0} 
|Point| lies on the segment of the hyperbola represented 
by the |Hyperbola| object.
\smallskip
%
\item{1} 
|Point| lies on the hyperbola, but not the segment, represented 
by the |Hyperbola| object.
\smallskip
%
\item{2} 
|Point| lies in one of the regions enclosed by one of the branches of 
the hyperbola and the line connecting the end points of that segment.
\smallskip
%
\item{3} 
|Point| lies within one of the branches of the hyperbola, but
outside the region enclosed by them and the line connecting the 
end points of that segment.
\smallskip
%
\item{4} 
|Point| lies between the two branches of the hyperbola.
\smallskip
%
\item{-1} 
|Point| is coplanar with the |Hyperbola|, but does not lie on the curve,
within one of the regions enclosed by the branches, or between the branches.
\smallskip
%
\item{-2} 
|Point| is not coplanar with the |Hyperbola|.
\smallskip
%
\item{-3} 
The |Hyperbola| is not hyperbolic.
\smallskip
%
\item{-4}
The |Point| is invalid.
\smallskip
%
\item{-5}
|Hyperbola::location()| failed.
\smallskip
%
\item{-6}
Something has gone terribly wrong.
%
\par
\initials{LDF 2005.11.28.}

\LOG
\initials{LDF 2005.11.28.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
signed short
location(Point q, 
         Scanner_Node scanner_node = 0, 
         real tolerance = Shape::DEFAULT_TOLERANCE) const;

@q *** (3) Definition.@> 
@
@<Define |Hyperbola| functions@>=
signed short
Hyperbola::location(Point q, 
                   Scanner_Node scanner_node,
                   real tolerance) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (!is_hyperbolic())
      {
          return -3;
      }

    if (q == INVALID_POINT)
       {
           return -4;
       }


    Transform* t = standardize(scanner_node);

@q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

    if (t == static_cast<Transform*>(0))
       {
           cerr_strm << thread_name 
                     << "ERROR!  In `Hyperbola::location()':"
                     << endl 
                     << "`Hyperbola::standardize()' failed."
                     << endl 
                     << "Exiting function unsuccessfully "
                     << "with return value -5.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");
 
           return -5;
                           
       }  /* |if (t == static_cast<Transform*>(0))|  */

@q **** (4)@> 


    q *= *t;

    delete t;
    t = 0;

    if (fabs(q.get_y()) > tolerance)
       return -2;    


    real x     = q.get_x();
    real x_abs = fabs(x);

    real y = q.get_y();
    real z = q.get_z();
    real z_abs = fabs(z);

    real a = axis_h / 2;
    real b = axis_v / 2;

    real a_2 = a * a;
    real b_2 = b * b;
    real x_2 = x * x;

    

@q **** (4) |Point| lies between the center and one of the foci.@> 

@ |Point| lies between the center and one of the foci.
\initials{LDF 2005.11.28.}

@<Define |Hyperbola| functions@>=
    if ((x_abs < a || (a - x_abs) > tolerance))

       {
           return 4;   

       }  /* |Point| lies between the center and one of the foci.  */




@q **** (4) @> 
@
@<Define |Hyperbola| functions@>=

   real equation_value = (b_2 * x_2 / a_2) - b_2;




   if (equation_value < 0)
      { 
           return -5;   
      }

   equation_value = sqrt(equation_value);


@q **** (4) |Point| satisfies hyperbola equation.@> 
@ |Point| satisfies hyperbola equation.
\initials{LDF 2005.11.28.}

@<Define |Hyperbola| functions@>=

    if (fabs(z_abs - equation_value) <= tolerance)
       {

@q ***** (5) |Point| lies on the hyperbola.@> 
@ |Point| lies on the hyperbola.
\initials{LDF 2005.11.28.}

@<Define |Hyperbola| functions@>=

           if ((x_abs >= a || fabs(x_abs - a) <= tolerance))

              {

@q ****** (6) |Point| lies on the hyperbola segment.@> 
@ |Point| lies on the hyperbola segment.
\initials{LDF 2005.11.28.}

@<Define |Hyperbola| functions@>=

               if (x_abs <= max_extent || fabs(x_abs - max_extent) < tolerance)
                   {
                       return 0;       
              
                   }  /* |Point| lies on the hyperbola segment.  */

@q ****** (6) |Point| lies on the hyperbola, but not the segment.@> 
@ |Point| lies on the hyperbola, but not the segment.
\initials{LDF 2005.11.28.}
@<Define |Hyperbola| functions@>=

              else 
                 {
                     return 1;

                 }


@q ****** (6)@> 

       }  /* |Point| lies on the hyperbola.  */

@q ***** (5)@> 

   }  /* |Point| satisfies hyperbola equation.  */

@q **** (4) |Point| doesn't satisfy the hyperbola equation.@> 
@ |Point| doesn't satisfy the hyperbola equation.
\initials{LDF 2005.11.28.}

@<Define |Hyperbola| functions@>=

         else if (z_abs < equation_value)
            {
                if (x_abs < max_extent)
                   return 2;
                else 
                   return 3;
            }

         else if (z_abs > equation_value)
            {
               return -1;
            }

}  /* End of |Hyperbola::location()| definition.  */

@q ** (2) Getting points.@>
@*1 Getting points. 
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this section.
\ENDLOG


@q *** (3) Get point---non-const version.@>
@*2 Get point---non-{\bf const} version. 
@^\cfunc{Hyperbola}{get\_point}@>
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.
\ENDLOG
 
@q **** (4) Declaration.@>

@<Declare |Hyperbola| functions@>=
virtual
const Point&
get_point(const unsigned short a);

@q **** (4) Definition.@> 
@
@<Define |Hyperbola| functions@>=
const Point&
Hyperbola::get_point(const unsigned short a)
{
    if (a < points.size())
    {
        return Path::get_point(a);
    }
    else if (a < (points.size() + branch_1.size()))
    {
       return branch_1.get_point(a - points.size());
    }

    else
      {
        cerr << "ERROR! In Hyperbola::get_point():\n"
             << "Argument is >= size of Hyperbola.\n"
             << "Returning INVALID_POINT.\n\n" ;
        return INVALID_POINT;
      }

}  /* End of |Hyperbola::get_point| definition (non-|const| version).  */

@q *** (3) Get point---const version.@>
@*2 Get point---{\bf const} version. 
@^\cfunc{Hyperbola}{get\_point}@>
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.

\initials{LDF 2007.07.09.}
Changed the calls to |Path::get_size| to calls to |Path::size|.  
Removed the former function, since it simply duplicated the latter one.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Hyperbola| functions@>=
virtual
Point
get_point(const unsigned short a) const;

@q **** (4) Definition.@> 
@
@<Define |Hyperbola| functions@>=
Point
Hyperbola::get_point(const unsigned short a) const
{
    Point p;

    size_t points_size   = Path::size();
    size_t branch_1_size = branch_1.size();

    if (a < points_size)
      {
          p = Path::get_point(a);
          return p;
      }
    else if (a < (points_size + branch_1_size))
    {
       p = branch_1.get_point(a - points_size);
       return p;
    }

    else
      {
        cerr << "ERROR! In Hyperbola::get_point():\n"
             << "Argument is >= size of Hyperbola.\n"
             << "Returning INVALID_POINT.\n\n" ;
        return INVALID_POINT;
      }
}  /* End of |Hyperbola::get_point| definition (|const| version).  */

@q *** (3) Get branch.@>
@*2 Get branch.
@^\cfunc{Hyperbola}{get\_branch}@>
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Hyperbola| functions@>=
Path*
get_branch(const unsigned short a, Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 
@
@<Define |Hyperbola| functions@>=
Path*
Hyperbola::get_branch(const unsigned short a, Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

    if (a == 0 || a == 1)
    {
        Path* p = create_new<Path>(0);

        if (a == 0)
           *p = *static_cast<const Path*>(this); 
        else 
           *p = branch_1;   

        return p;

    }  /* |if (a == 0 || a == 1)|  */

@q **** (4) Error handling:  |a| has invalid value.@>
@ Error handling:  |a| has invalid value.
\initials{LDF 2007.07.09.}

@<Define |Hyperbola| functions@>=

   else  /* |a != 0 && a != 1| */
   {
       cerr_strm << thread_name << "ERROR!  In `Hyperbola::get_branch':"
                 << endl 
                 << "Invalid branch number:  " << a
                 << "Exiting function unsuccessfully with return value "
                 << "`static_cast<Path*>(0)'.";
                       
       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return static_cast<Path*>(0); 

   }  /* |else| (|a != 0 && a != 1|)  */


@q **** (4)@> 

}  /* End of |Hyperbola::get_branch| definition.  */



@q ** (2)@> 

@q * (1) Predicates.@> 
@* Predicates.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Is hyperbolic.@>
@*1 Is hyperbolic.

@q *** (3) |Path| version.@> 
@*2 {\bf Path} version.
@^\cfunc{Path}{is\_hyperbolic}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.  It is declared in \filename{paths.web}.
It currently has a dummy definition and returns |false|.
\ENDLOG

@q **** (4) Definition.@> 
  
@
@<Define |Path| functions@>=
bool
Path::is_hyperbolic(Scanner_Node scanner_node) const
{
   return false;

} /* End of |Path::is_hyperbolic()| definition.  */

@q *** (3) |Hyperbola| version.@> 
@*2 {\bf Hyperbola} version.
@^\cfunc{Hyperbola}{is\_hyperbolic}@>
\initials{LDF 2005.11.28.}

\LOG
\initials{LDF 2005.11.28.}
Added this function.  It currently has a dummy definition and returns |true|
immediately.
\ENDLOG

@q **** (4)@> 
@<Declare |Hyperbola| functions@>=
bool
is_hyperbolic(Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 
  
@
@<Define |Hyperbola| functions@>=
bool
Hyperbola::is_hyperbolic(Scanner_Node scanner_node) const
{
   return true;

} /* End of |Hyperbola::is_hyperbolic()| definition.  */

@q * (1) Transformations.@>
@* Transformations. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG


@q *** (3) Multiplication by a |Transform| with assignment.@>
@*2 Multiplication by a |Transform| with assignment.
@^\cofunc{Hyperbola}{*=}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.21.}
@:BUG FIX@> BUG FIX: 
Now multiplying |center| and |branch_1| by |t|.
\ENDLOG 

@<Declare |Hyperbola| functions@>=
virtual
Transform
operator*=(const Transform& t);

@
@<Define |Hyperbola| functions@>=
Transform
Hyperbola::operator*=(const Transform& t)
{
   center *= branch_1 *= t;
   return Path::operator*=(t);
}


@q ** (2) Rotatation around the main axes.@>
@*1 Rotation  around the main axes. 
@^\cfunc{Hyperbola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
Transform 
rotate(const real x, const real y = 0, const real z = 0);

@
@<Define |Hyperbola| functions@>=
Transform 
Hyperbola::rotate(const real x, const real y, const real z)
{
  Transform t;
  t.rotate(x, y, z);
  return operator*=(t);
}

@q ** (2) Scale. @>
@*1 Scale. 
@^\cfunc{Hyperbola}{scale}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
Transform 
scale(real x, real y = 1, real z = 1);

@
@<Define |Hyperbola| functions@>=
Transform 
Hyperbola::scale(real x, real y, real z)
{
   Transform t;
   t.scale(x, y, z);
   return operator*=(t);
}

@q ** (2) Shear.@>
@*1 Shear. 
@^\cfunc{Hyperbola}{shear}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG


@<Declare |Hyperbola| functions@>=

virtual
Transform 
shear(real xy, real xz = 0, real yx = 0, real yz = 0, 
      real zx = 0, real zy = 0);

@
@<Define |Hyperbola| functions@>=
Transform 
Hyperbola::shear(real xy, real xz, real yx, real yz, 
      real zx, real zy)
{
  Transform t;
  t.shear(xy, xz, yx, yz, zx, zy);
  return operator*=(t);

}

@q ** (2) Shift.@>
@*1 Shift. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG


@q *** (3) |real| arguments.@>
@*2 {\bf real} arguments. 
@^\cfunc{Hyperbola}{shift}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
Transform 
shift(real xx, real yy = 0, real zz = 0);

@
@<Define |Hyperbola| functions@>=
Transform
Hyperbola::shift(real xx, real yy, real zz)
{
  Transform t;
  t.shift(xx, yy, zz);
  return operator*=(t);
}


@q *** (3) Point argument.@>

@*2 {\bf Point} argument. 
@^\cfunc{Hyperbola}{shift}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
Transform 
shift(const Point& p);

@
@<Define |Hyperbola| functions@>=
Transform 
Hyperbola::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}


@q ** (2) Shift times. @>
@*1 Shift times. 
\initials{LDF 2005.11.07.}

@q *** (3) real arguments. @>

@*2 {\bf real} arguments. 
@^\cfunc{Hyperbola}{shift\_times}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.  
\ENDLOG

@<Declare |Hyperbola| functions@>=


virtual
void 
shift_times(real x, real y = 1, real z = 1);


@
@<Define |Hyperbola| functions@>=

void 
Hyperbola::shift_times(real x, real y, real z)
{

    Path::shift_times(x, y, z);
  
    return;
}

@q *** (3) Point argument. @>

@*2 {\bf Point} argument. 
@^\cfunc{Hyperbola}{shift\_times}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=
virtual
void
shift_times(const Point& p);

@
@<Define |Hyperbola| functions@>=
void
Hyperbola::shift_times(const Point& p)
{
  return shift_times(p.get_x(), p.get_y(), p.get_z());
}


@q ** (2) Rotatation around an arbitrary axis.@>
@*1 Rotatation around an arbitrary axis. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) Point arguments.@>

@*2 {\bf Point} arguments.
@^\cfunc{Hyperbola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=

virtual
Transform 
rotate(const Point& p0, const Point& p1, const real angle = 180);

@
@<Define |Hyperbola| functions@>=
Transform 
Hyperbola::rotate(const Point& p0, const Point& p1, const real angle)
{
  Transform t;
  t.rotate(p0, p1, angle);
  return operator*=(t);
}

@q *** (3) Path argument.@>

@*2 {\bf Path} arguments.
@^\cfunc{Hyperbola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Hyperbola| functions@>=

virtual
Transform 
rotate(const Path& p, const real angle = 180);

@
@<Define |Hyperbola| functions@>=

Transform 
Hyperbola::rotate(const Path& p, const real angle)
{
   if (!p.is_linear())
     {
        return INVALID_TRANSFORM;
     }

   return rotate(p.get_point(0),
                 p.get_last_point(), angle);  
}   

@q ** (2) Standardize.@> 
@*1 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.  It currently has a dummy definition.

\initials{LDF 2005.11.27.}
Changed return type from |Transform| to |Transform*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
virtual
Transform*
standardize(Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Hyperbola| functions@>=
Transform*
Hyperbola::standardize(Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    Transform* t = create_new<Transform>(0);

    Point normal = get_normal();
    normal.shift(center);

    t->align_with_axis(center, normal, 'y');

    Point q = get_point(points.size() / 2);

    q *= *t;

    real angle = q.angle(Point(1, 0, 0));

    q.rotate(0, angle);


@q **** (4) Rotation succeeded.@> 

@ Rotation succeeded.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=
    if (   q.get_x() > 0 
        && fabs(q.get_y()) <= Shape::DEFAULT_TOLERANCE 
        && fabs(q.get_z()) <= Shape::DEFAULT_TOLERANCE)
        {
            t->rotate(0, angle);
        }
   
@q **** (4) Rotation failed.  Try the other direction.@> 

@ Rotation failed.  Try the other direction.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=
    else
       { 
           q.rotate(0, -2 * angle);
           t->rotate(0, -angle);
       }


@q **** (4) Error handling:  Transformation failed.@> 
@ Error handling:  Transformation failed.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=

    if (   q.get_x() <=  0 
        || fabs(q.get_y()) > Shape::DEFAULT_TOLERANCE 
        || fabs(q.get_z()) > Shape::DEFAULT_TOLERANCE)
       {
           cerr_strm << thread_name << "ERROR!  In `Hyperbola::standardize()':"
                     << endl 
                     << "Failed to put the `Hyperbola' into standard position."
                     << endl
                     << "Deleting `Transform* t' and exiting function unsuccesfully "
                     << endl 
                     << "with return value 0.";
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");    

           delete t;
           t = 0;
           return 0;

       }  /* Transformation failed.  */

@q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

    return t;

} /* End of |Hyperbola::standardize()| definition.  */

@q * (1) Draw.@>
@* Draw.
\initials{LDF 2005.11.15.}

\LOG
\initials{LDF 2005.11.15.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Hyperbola| functions@>=
virtual
int
draw(Picture& picture,
     Pointer_Vector<Color>* ddraw_color_vector = 0, 
     Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
     Pointer_Vector<Pen>* ppen_vector = 0, 
     unsigned short aarrow = Path::NO_ARROW,
     Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@>

@
@<Define |Hyperbola| functions@>=


int
Hyperbola::draw(Picture& picture,
           Pointer_Vector<Color>* ddraw_color_vector,
           Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
           Pointer_Vector<Pen>* ppen_vector, 
           unsigned short aarrow,
           Scanner_Node scanner_node) const


{

    Path::draw(picture, ddraw_color_vector,
               ddash_pattern_vector,
               ppen_vector, 
               aarrow,
               scanner_node);

    branch_1.draw(picture, ddraw_color_vector,
                  ddash_pattern_vector,
                  ppen_vector, 
                  aarrow,
                  scanner_node);

    return 0;

} /* End of |Hyperbola::draw()| definition.  */

@q * (1) Intersections.@> 
@* Intersections.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) |Path*| argument.@> 
@*1 {\bf Path} pointer argument.
\initials{LDF 2005.11.01.}


\LOG
\initials{LDF 2005.11.28.}
Now setting |bp->b| (for |Bool_Point* bp|) to |!Hyperbola::location()|.

\initials{LDF 2005.11.28.}
Finished this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
virtual 
Pointer_Vector<Bool_Point>*
intersection_points(const Path* p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Hyperbola| functions@>=
Pointer_Vector<Bool_Point>*
Hyperbola::intersection_points(const Path* p, Scanner_Node scanner_node) const
{
 
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4) |*p| is non-linear.@> 
@ |*p| is non-linear.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=

   if (!p->is_linear())
      {
          cerr_strm << thread_name << "ERROR!  In `Hyperbola::intersection_points()':"
                    << endl 
                    << "The `Path' `*p' is non-linear.  Haven't programmed this case yet."
                    << endl
                    << "Function failed.  Exiting with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if (!p->is_linear())|  */


@q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

   Plane q = get_plane();

   Pointer_Vector<Bool_Point>* bpv = 0;
   Bool_Point* bp                  = 0;

@q **** (4) Coplanar case.@> 
@ Coplanar case.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=

    if (p->get_point(0).is_on_plane(q) || p->get_last_point().is_on_plane(q))
       {
#if DEBUG_COMPILE
   if (DEBUG)
      {
            cerr << "Hyperbola and Path are coplanar." << endl;

      }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

            Transform* t = create_new<Transform>(0);

            real a = axis_h / 2;
            real b = axis_v / 2;

            real a_2 = a * a;
            real b_2 = b * b;
  
            real x;
            real z;

            Real_Triple r = get_discriminant(*p, t, scanner_node);

 @q **** (4)@> 
@
@<Define |Hyperbola| functions@>=

            real discriminant = r.first;
            real slope        = r.second;
            real z_int        = r.third;

#if 0 
            cerr << "discriminant == " << discriminant << endl;
            cerr << "slope == " << slope << endl;
            cerr << "z_int == " << z_int << endl;
            t->show("t:");
            cerr << "Type <RETURN> to continue: ";
            getchar(); 
#endif 

@q ***** (5)@> 

            if (!finite(slope) || slope == INVALID_REAL)
              {
                 Point q0 = p->get_point(0);
                 Point q1 = p->get_last_point();

                 q0 *= q1 *= *t;

                 x = q0.get_x();
  
@q ****** (6)@> 

                 if (fabs(x) < a)
                    { 
                        delete t;
                        t = 0;
                        return 0;
                    }
 
@q ****** (6)@> 

                 else if (fabs(x) == a)
                    {
                         bpv = new Pointer_Vector<Bool_Point>;
                         bp = new Bool_Point;

                         bp->pt.set(x, 0, 0);
                         bp->pt *= t->inverse();
                         bp->b = !location(bp->pt);
                         *bpv += bp;

                         delete t;
                         t = 0;

                         return bpv;

                    }

@q ****** (6)@> 

                 else  /* |fabs(x) > a|  */
                    {

                        z = ((b_2 * x * x) / a_2) - b_2;
               

@q ******* (7)@> 
                        if (z < 0)
                            {
                                cerr_strm << thread_name << "ERROR!  "
                                          << "In `Hyperbola::intersection_points()':"
                                          << endl 
                                          << "`z' value is less than 0.  This shouldn't happen."
                                          << "Exiting function unsuccesfully with return value 0.";
 
                                log_message(cerr_strm);          
                                cerr_message(cerr_strm, error_stop_value);
                                cerr_strm.str("");               

                                delete t;
                                t = 0;
                                return 0;
     

                            }  /* |if (z < 0)|  */

@q ******* (7)@> 

                         z =  sqrt(z);
  
                         bpv = new Pointer_Vector<Bool_Point>;
                         bp = new Bool_Point;

                         bp->pt.set(x, 0, z);

                         bp->pt *= t->inverse();
                         bp->b = !location(bp->pt);

                         *bpv += bp;

                         bp = new Bool_Point;

                         bp->pt.set(x, 0, -z);
                         bp->pt *= t->inverse();
                         *bpv += bp;
                         bp->b = !location(bp->pt);

                         delete t;
                         t = 0;

                         return bpv;

@q ******* (7)@> 

                    }    /* |else| (|fabs(x) > a|)  */
             

@q ****** (6)@> 

              }  /* |if (!finite(slope) || slope == INVALID_REAL)|  */

@q **** (4) Error handling:  |Hyperbola::get_discriminant()| failed.@> 

@ Error handling:  |Hyperbola::get_discriminant()| failed.
\initials{LDF 2005.11.27.}

@<Define |Hyperbola| functions@>=

    if (discriminant == INVALID_REAL || z_int == INVALID_REAL)
       {
           cerr_strm << thread_name << "ERROR!  In `Hyperbola::intersection_points()':"
                     << endl 
                     << "`Hyperbola::get_discriminant()' failed."
                     << endl 
                     << "Deleting `Transform* t', setting it to 0,"
                     << endl 
                     << "and exiting function unsuccessfully with return value 0.";
                      
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");
 
           delete t;
           t = 0;
           return 0;

       }  /* |Hyperbola::get_discriminant()| failed.  */

@q **** (4)@> 

            if (discriminant < 0)
               {
                    cerr_strm << thread_name 
                              << "WARNING:  In `Hyperbola::intersection_points()':"
                              << endl 
                              << "`Hyperbola' and `Path' don't intersect."
                              << endl 
                              << "Returning 0.";

                    delete t;
                    t = 0;
                    return 0;
              
 
               }  /* |if (discriminant < 0)|  */

@q **** (4)@> 

           bpv = new Pointer_Vector<Bool_Point>;

           real m = slope;


           real m_2 = slope * slope;
           real n   = z_int;

@q ***** (5)@> 

           if (discriminant == ZERO_REAL)
              {
                  x = (-a_2 * m * n) / ((a_2 * m_2) - b_2);
 
                  z = (-b_2 * n) / ((a_2 * m_2) - b_2);

                  bp = new Bool_Point;

                  bp->pt.set(x, 0, z);
                  bp->pt *= t->inverse();
                  bp->b = !location(bp->pt);

                  *bpv += bp;

                  delete t;
                  t = 0;

                  return bpv;

              }   /* |if (discriminant == ZERO_REAL)|  */

@q ***** (5)@> 

           if (discriminant > ZERO_REAL)
              {

                  real discriminant_root = sqrt(discriminant);

@q ****** (6)@> 

                  x =   ((-a_2 * m * n) + (a * b * discriminant_root))
                      / ((a_2 * m_2) - b_2);
 
                  z =   ((-b_2 * n) + (a * b * m * discriminant_root))
                      / ((a_2 * m_2) - b_2);

                  bp = new Bool_Point;

                  bp->pt.set(x, 0, z);
                  bp->pt *= t->inverse();
                  bp->b = !location(bp->pt);

                  *bpv += bp;

@q ****** (6)@> 

                  x =   ((-a_2 * m * n) - (a * b * discriminant_root))
                      / ((a_2 * m_2) - b_2);
 
                  z =   ((-b_2 * n) - (a * b * m * discriminant_root))
                      / ((a_2 * m_2) - b_2);

                  bp = new Bool_Point;

                  bp->pt.set(x, 0, z);
                  bp->pt *= t->inverse();
                  bp->b = !location(bp->pt);

                  *bpv += bp;

@q ****** (6)@> 

                  delete t;
                  t = 0;

                  return bpv;


              }  /* |if (discriminant > ZERO_REAL)|  */

@q ***** (5)@> 

@q **** (4)@> 

       }  /* End of coplanar case.  */

@q **** (4) Non-coplanar case.@> 
@ Non-coplanar case.
\initials{LDF 2005.11.27.}

\LOG
\initials{LDF 2005.11.28.}
Programmed this case.
\ENDLOG 

@<Define |Hyperbola| functions@>=

    else  
       { 
#if DEBUG_COMPILE
   if (DEBUG)
      {
            cerr << "Hyperbola and Path are non-coplanar." << endl;

      }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

            Bool_Point* bp = new Bool_Point;
 
            *bp = get_plane().intersection_point(*p);

            if (bp->pt == INVALID_POINT)
               {
                   delete bp;
                   bp = 0;
                   return 0;
               }

            bp->b = !location(bp->pt);
            
            Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;
            *bpv += bp;

            return bpv;

       }  /* End of non-coplanar case.  */

@q **** (4)@> 

}  /* End of |Hyperbola::intersection_points(const Path&, [etc.])| definition.  */

@q ** (2) |Plane*| argument.@> 
@*1 {\bf Plane} pointer argument.
\initials{LDF 2005.11.28.}

\LOG
\initials{LDF 2005.11.28.}
Added this function.

\initials{LDF 2005.11.30.}
@:BUG FIX@> BUG FIX:  Now checking the return value of 
|Plane::intersection_line()|.  If it's |INVALID_LINE|, this function returns 0.
Now passing |Scanner_Node scanner_node| argument to |Plane::intersection_line()|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Hyperbola| functions@>=
virtual 
Pointer_Vector<Bool_Point>*
intersection_points(const Plane* p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Hyperbola| functions@>=
Pointer_Vector<Bool_Point>*
Hyperbola::intersection_points(const Plane* p, Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    Plane q = get_plane();

   Line r = p->intersection_line(q, scanner_node);

@q **** (4)@> 

   if (r == INVALID_LINE)
      {
          cerr_strm << thread_name 
                    << "WARNING!  In `Hyperbola::intersection_points()':"
                    << endl;
          if (p->point.is_on_plane(q))
             cerr_strm << "The plane of `*this' and `*p' coincident, ";
    
          else 
             cerr_strm << "The plane of `*this' and `*p' are parallel, ";


          cerr_strm << "i.e., there are infinitely many intersections."
                    << endl 
                    << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if (r == INVALID_LINE)|  */

@q **** (4)@> 

   Path s = r.get_path();

   Pointer_Vector<Bool_Point>* bpv = intersection_points(&s, scanner_node);

   return bpv;

}  /* End of |Hyperbola::intersection_points(const Plane* p, [etc.])| 
      definition.  */

@q * (1) Show.@> 
@* Show.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.15.}
Now showing |Point center| and |Path branch_1|.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Hyperbola| functions@>=

virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1) const;


@q ** (2) Definition.@> 

@
@<Define |Hyperbola| functions@>=
void 
Hyperbola::show(string text, char coords,
            const bool do_persp, const bool do_apply,
            Focus* f, const unsigned short proj,
            const real factor) const

{
    if (text == "")
       text = "Hyperbola";

    center.show("center:");

    Conic_Section::show(text, coords, do_persp, do_apply, f, proj, factor);

    Path::show(text, coords, do_persp, do_apply, f, proj, factor);

    branch_1.show("branch_1:", coords, do_persp, do_apply, f, proj, factor);

    return;

} /* End of |Hyperbola::show()| definition.  */

@q * (1) Hyperbola_Set_Option_Struct.@> 
@* {\bf Hyperbola\_Set\_Option\_Struct}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Struct definition.@> 
@*1 Struct definition.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this |struct| definition.


\initials{LDF 2005.11.14.}
Added the data members
|Point* focus_0|, 
|Point* focus_1|, 
|Point* vertex_0|, 
|Point* vertex_1|, 
|Path*  directrix|, 
|real parameter|, 
|real linear_eccentricity|, and
|real numerical_eccentricity|.

\initials{LDF 2005.11.14.}
Added the data members
|real max_extent| and |real increment_value|.

\initials{LDF 2005.11.15.}
Added the data member |Point* center|.

\initials{LDF 2005.11.15.}
Added the |real| data members |major_axis_length| and |minor_axis_length|.
\ENDLOG

@<Define |struct Hyperbola_Set_Option_Struct|@>=

struct
Hyperbola_Set_Option_Struct
{
   Point* center;
   Point* focus_0;
   Point* focus_1;
   Point* vertex_0;
   Point* vertex_1;
   Path*  directrix;

   real parameter;
   real linear_eccentricity;
   real numerical_eccentricity;

   real major_axis_length;
   real minor_axis_length;

   real max_extent;
   real increment_value;

   @<Declare |Hyperbola_Set_Option_Struct| functions@>@;

};

@q ** (2) |Hyperbola_Set_Option_Struct| functions.@> 
@*1 {\bf Hyperbola\_Set\_Option\_Struct} functions.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) Constructors.@>
@*2 Constructors.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q **** (4) Default constructor.@>   
@*3 Default constructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.14.}
Now setting the data members
|Point* focus_0|, 
|Point* focus_1|, 
|Point* vertex_0|, 
|Point* vertex_1|, and
|Path*  directrix| to 0 and the data members
|real parameter|, 
|real linear_eccentricity|, and
|real numerical_eccentricity| to |INVALID_REAL|.

\initials{LDF 2005.11.14.}
Now setting |real max_extent| and |real increment_value| to 
|INVALID_REAL|.

\initials{LDF 2005.11.15.}
Now setting |Point* center| to 0.

\initials{LDF 2005.11.15.}
Now setting |real major_axis_length| and |real minor_axis_length| to
|INVALID_REAL|.
\ENDLOG

@q ***** (5) Declaration.@>  

@<Declare |Hyperbola_Set_Option_Struct| functions@>=

Hyperbola_Set_Option_Struct(void);

@q ***** (5) Definition.@>  

@
@<Define |Hyperbola_Set_Option_Struct| functions@>=

Hyperbola_Set_Option_Struct::Hyperbola_Set_Option_Struct(void) 
{

    center  = 0;

    focus_0  = 0;
    focus_1  = 0;
    
    vertex_0 = 0;
    vertex_1  = 0;
    
    directrix = 0;

    major_axis_length = INVALID_REAL;
    minor_axis_length = INVALID_REAL;

    parameter              = INVALID_REAL;
    linear_eccentricity    = INVALID_REAL;
    numerical_eccentricity = INVALID_REAL;

    max_extent      = INVALID_REAL;
    increment_value = INVALID_REAL;


    return;
}

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.14.}
Now deleting the data members
|Point* focus_0|, 
|Point* focus_1|, 
|Point* vertex_0|, 
|Point* vertex_1|, and
|Path*  directrix|.

\initials{LDF 2005.11.15.}
Now deleting |Point* center|.
\ENDLOG

@q **** (4) Declaration.@>  

@<Declare |Hyperbola_Set_Option_Struct| functions@>=

~Hyperbola_Set_Option_Struct(void); 

@q **** (4) Definition.@>  

@
@<Define |Hyperbola_Set_Option_Struct| functions@>=

Hyperbola_Set_Option_Struct::~Hyperbola_Set_Option_Struct(void) 
{

    delete center;
    delete focus_0;
    delete focus_1;
    delete vertex_0;
    delete vertex_1;
    delete directrix;

    return;
}

@q *** (3) Clear.@> 
@*2 Clear.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.14.}
Now deleting the data members
|Point* focus_0|, 
|Point* focus_1|, 
|Point* vertex_0|, 
|Point* vertex_1|, and
|Path*  directrix| and setting them to 0.
Also setting |real parameter|, 
|real linear_eccentricity|, and
|real numerical_eccentricity| to |INVALID_REAL|.

\initials{LDF 2005.11.14.}
Now setting |real max_extent| and |real increment_value| to 
|INVALID_REAL|.

\initials{LDF 2005.11.15.}
Now deleting |Point* center| and setting it to 0.

\initials{LDF 2005.11.15.}
Now setting |real major_axis_length| and |real minor_axis_length| to
|INVALID_REAL|.
\ENDLOG

@q **** (4) Declaration.@>  

@<Declare |Hyperbola_Set_Option_Struct| functions@>=

int 
clear(void); 

@q **** (4) Definition.@>  

@
@<Define |Hyperbola_Set_Option_Struct| functions@>=

int
Hyperbola_Set_Option_Struct::clear(void) 
{

    delete center;
    center = 0;

    delete focus_0;
    focus_0 = 0;

    delete focus_1;
    focus_1   = 0;

    delete vertex_0;
    vertex_0  = 0;

    delete vertex_1;
    vertex_1  = 0;

    delete directrix;
    directrix = 0;

    major_axis_length      = INVALID_REAL;
    minor_axis_length      = INVALID_REAL;
    parameter              = INVALID_REAL;
    linear_eccentricity    = INVALID_REAL;
    numerical_eccentricity = INVALID_REAL;
    max_extent             = INVALID_REAL;
    increment_value        = INVALID_REAL;

    return 0;

}  /* End of |Hyperbola_Set_Option_Struct::clear()| definition.  */


@q * (1) Putting Hyperbola together. @>
@* Putting {\bf Hyperbola} together.

@q ** (2) This is what's compiled.@> 

This is what's compiled.

@c
@<Include files@>@;
@<Define |class Hyperbola|@>@;
@<Define |static| |class Hyperbola| data members@>@;
@<Define |struct Hyperbola_Set_Option_Struct|@>@;
@<Define |Hyperbola| functions@>@;
@<Define |Hyperbola_Set_Option_Struct| functions@>@;
@<Declare non-member template functions for |Hyperbola|@>@;
@<Define |Path| functions@>@;

@q ** (2) This is what's written to "hyprbola.h".@> 

@ This is what's written to \filename{hyprbola.h}.

@(hyprbola.h@>=
@<Define |class Hyperbola|@>@;
@<Define |struct Hyperbola_Set_Option_Struct|@>@;
@<Declare non-member template functions for |Hyperbola|@>@;


@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>


@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q run-mp-on-file:"persp.mp" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
