@q utility.web @>
 
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Utility functions.@>
@** Utility functions\quad ({\tt utility\PERIOD web}).\hfil
\initials{LDF 2003.05.13.}

This file contains miscellaneous functions, that don't seem to belong
anywhere else.
\initials{LDF 2003.05.13.}

@:!! TO DO@> TO DO:  Put perspective functions into a namespace. 

\LOG
\initials{LDF 2003.05.13.}  
Created this file.

\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  
Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@q * Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"

#include <cstring>

#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "sprellps.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"
#include "pctfncs0.h++"
#include "scnmptpt.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++" 
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++"
#include "glyphs.h++"
#include "mpoutput.h++"
#include "parser.h++"

@q * Perspective functions.@>
@* Perspective functions.
\initials{LDF 2003.05.13.}  

These functions can be used to make perspective
constructions in the traditional way using vanishing points.  
\initials{LDF 2003.05.13.}  

\LOG
\initials{LDF 2003.05.13.}  
Added this section.
\ENDLOG 

@q * (1) Make perspective frame.@>
@* Make persective frame.

|f_2_cv| $=$ ``Focus to CV'', i.e., the distance of the focus
to the picture plane.
\initials{LDF 2004.05.26.}

|gl_2_cv| $=$ ``Groundline to CV'', i.e., the height of the 
focus above the ground plane.
\initials{LDF 2004.05.26.}

\LOG
\initials{LDF 2003.05.13.}  Added this function.

\initials{LDF 2004.05.02.}  Changed calls to the |Point| constructor
and setting function taking three |real| arguments.  They now require
 three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.

\initials{LDF 2004.05.26.}  Added |Picture& picture| argument.

\ENDLOG 

@q ** Declaration.  @>

@<Declare perspective functions@>=

vector<Point*>
make_perspective_frame(Picture& picture,
                       const vector<real>& angles,
                       const real f_2_cv,  
                       const real gl_2_cv,
                       const real horizon_lft = 6,
                       real horizon_rt = 0, 
                       real gl_lft = 0, 
                       real gl_rt = 0);

@q ** Definition.@>
@
@<Define perspective functions@>=
vector<Point*>
make_perspective_frame(Picture& picture,
                       const vector<real>& angles,
                       const real f_2_cv, 
                       const real gl_2_cv,
                       const real horizon_lft,
                       real horizon_rt = 0, 
                       real gl_lft = 0, 
                       real gl_rt = 0)
{

  using namespace Colors;

  if (horizon_rt == ZERO_REAL)
    horizon_rt = horizon_lft;

  if (gl_lft == ZERO_REAL)
    gl_lft = horizon_lft;

  if (gl_rt == ZERO_REAL)
    gl_rt = horizon_rt; 

  Point f;
  f.dotlabel(picture, "focus", "bot");

  Point cv(f);
  cv.shift(0, f_2_cv);
  cv.dotlabel(picture, "CV"); 

  f.draw(picture, cv);

  Point horizon_l(cv);
  horizon_l.shift(-horizon_lft);
  Point horizon_r(cv);
  horizon_r.shift(horizon_rt);
  horizon_r.dotlabel(picture, "horizon", "bot"); 

  horizon_l.draw(picture, horizon_r);

  Point gl_l;
  real f_2_gl = f_2_cv - gl_2_cv;
  gl_l.shift(-gl_lft, f_2_gl);
  Point gl_r;
  gl_r.shift(gl_rt, f_2_gl);
  gl_r.dotlabel(picture, "ground line", "bot"); 

  gl_l.draw(picture, gl_r);

  Point origin_pt(0, f_2_gl, 0);  

@ Put the |Points| for the frame onto |points| (the return value).  
@<Define perspective functions@>=

  vector<Point*> points; 
  points.push_back(create_new<Point>(f));
  points.push_back(create_new<Point>(cv));
  points.push_back(create_new<Point>(origin_pt));
  points.push_back(create_new<Point>(horizon_l));
  points.push_back(create_new<Point>(horizon_r));
  points.push_back(create_new<Point>(gl_l));
  points.push_back(create_new<Point>(gl_r));                   

@ Calculate the vanishing points on the right side, and put them onto
|points|. 
@<Define perspective functions@>=
  Point p;
  Point q;
  Point q_super;
  stringstream s;
  signed short sign;

  for (vector<real>::const_iterator iter = angles.begin();
       iter != angles.end();
       ++iter)
    {
      sign = static_cast<signed short>(*iter / fabs(*iter));
      p.set(10 * sign, 0, 0);
      p.rotate(0, 0, *iter);
      s << "VP $" << (*iter * sign) << "^\\circ$";
      q = Point::intersection_point(f, p, horizon_l, horizon_r).pt;
#if 0   
      cerr << "points[" << points.size()
           << "]. Angle = " << *iter <<". x = " 
           << q.get_x() << endl;
#endif 
      points.push_back(create_new<Point>(q));                   
      if (*iter == 60 || *iter == 80) /* KLUDGE.  \initials{LDF 2003.05.14.}  */
        {
          q_super = q;
          q_super.shift(0, 1);
          q_super.label(picture, s.str(), "");
          q_super.drawarrow(picture, q);
          q.label(picture, "\\space"); 
        }
      else if (*iter > 10)
        q.dotlabel(picture, s.str());
      s.str("");
    }

  real h_offset = 0;
  real v_offset = 1;

  Point p0(gl_l);

  p0.shift(0, - (gl_l.get_y() - f.get_y()));
  p0.shift(-h_offset, -v_offset);

  Point p1(gl_r);
  p1.shift(0, - (gl_l.get_y() - f.get_y()));
  p1.shift(h_offset, -v_offset);

  Point p2(horizon_r);
  p2.shift(h_offset, v_offset);

  Point p3(horizon_l);
  p3.shift(-h_offset, v_offset);

  Rectangle rect(p0, p1, p2, p3);
  rect.undraw(picture);
  
#if 0 
  p0.dotlabel(picture, 0); 
  p1.dotlabel(picture, 1); 
  p2.dotlabel(picture, 2); 
  p3.dotlabel(picture, 3); 
#endif 

  return points;

}  /* End of |make_perspective_frame| definition  */

@q * Perspective function 0.@>
@ Perspective function 0.
\initials{LDF 2003.05.13.}  This function puts a rectangle in the x-z plane into
perspective using the traditional perspective construction with
vanishing points, focus, horizon line, etc. 
I use it in the {\it 3DLDF User and Reference Manual\/} 
(\filename{3DLDFman.texi}).

|f_2_cv| $=$ ``Focus to CV'', i.e., the distance of the focus
to the picture plane.
\initials{LDF 2004.05.26.}

|gl_2_cv| $=$ ``Groundline to CV'', i.e., the height of
the focus above the ground plane.
\initials{LDF 2004.05.26.}

\LOG
\initials{LDF 2003.05.13.}  Added this function.

\initials{LDF 2004.05.02.}  Changed calls to the |Point| constructor
and setting function taking three |real| arguments.  They now require
 three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.

\initials{LDF 2004.05.25.}  Added |Scanner_Node| argument.  It's
passed to |Picture::output|.

\initials{LDF 2004.05.26.}  Added |Picture& picture| argument.

\initials{LDF 2004.06.07.}  Changed the way code using |Dash_Patterns| is
handled, to reflect the fact that I've changed |string Path::dashed| to 
|Dash_Pattern* Path::dash_pattern|.

\initials{LDF 2004.06.07.}  Added |Focus& ffocus| argument.  It's passed to 
|Picture::output|.  This was necessary because I've gotten rid of
|default_focus|. 

\initials{LDF 2004.06.08.}  Renamed the locally declared |Point origin| |origin_pt|, to
avoid confusion with the predefined variable defined in |Scanner_Type::create|.
\ENDLOG 

@q ** Declaration.  @>

@<Declare perspective functions@>=
void
persp_0(Picture& picture,
        Focus& ffocus,
        Scanner_Node s,
        const real front_corner_x,
        const real front_corner_z,
        const real side_lft, 
        const real side_rt,
        const real angle_rt,
        const real f_2_cv, 
        const real gl_2_cv,
        const real horizon_lft = 6,
        real horizon_rt = 0, 
        real gl_lft = 0, 
        real gl_rt = 0);

@q ** Definition.@>
@
@<Define perspective functions@>=
void
persp_0(Picture& picture,
        Focus& ffocus,
        Scanner_Node s,
        const real front_corner_x,
        const real front_corner_z,
        const real side_lft, 
        const real side_rt,
        const real angle_rt,
        const real f_2_cv, 
        const real gl_2_cv,
        const real horizon_lft,
        real horizon_rt = 0, 
        real gl_lft = 0, 
        real gl_rt = 0)
{

  if (front_corner_z < 0)
    {
      cerr << "ERROR! In persp_0():\n"
           << "front_corner_z < 0.\nReturning.\n\n";

      return;
    }

  using namespace Colors;

  Dash_Pattern ddashed_evenly;
  
  ddashed_evenly.set_type(Dash_Pattern::EVENLY);

  Dash_Pattern ddashed_withdots;
  
  ddashed_withdots.set_type(Dash_Pattern::WITH_DOTS);

  if (horizon_rt == ZERO_REAL)
    horizon_rt = horizon_lft;

  if (gl_lft == ZERO_REAL)
    gl_lft = horizon_lft;

  if (gl_rt == ZERO_REAL)
    gl_rt = horizon_rt; 

  Point f;
  f.dotlabel(picture, "focus", "bot");

  real angle_lft = 90 - angle_rt;

  Point cv(f);
  cv.shift(0, f_2_cv);
  cv.dotlabel(picture, "CV"); 

  Point horizon_l(cv);
  horizon_l.shift(-horizon_lft);
  Point horizon_r(cv);
  horizon_r.shift(horizon_rt);
  horizon_r.dotlabel(picture, "horizon", "llft"); 

  Point gl_l;
  real f_2_gl = f_2_cv - gl_2_cv;
  gl_l.shift(-gl_lft, f_2_gl);
  Point gl_r;
  gl_r.shift(gl_rt, f_2_gl);
  gl_r.dotlabel(picture, "ground line", "ulft"); 

  Point origin_pt(0, f_2_gl, 0);    

  Point p(10, 0, 0);
  p.rotate(0, 0, angle_rt);
  
  Point vpr = Point::intersection_point(f, p, horizon_l, horizon_r).pt;

  stringstream temp_str;  
  temp_str << "VP $" << angle_rt << "^\\circ$r";

#if 0 
  vpr.show(temp_str.str());
#endif 

  vpr.dotlabel(picture, temp_str.str()); 
  real m = vpr.magnitude();
  Point mpr(vpr);
  mpr.shift(-m);

  temp_str.str("");
  temp_str << "MP $" << angle_rt << "^\\circ$r";

  mpr.dotlabel(picture, temp_str.str()); 

  p.set(-10, 0, 0);
  p.rotate(0, 0, -angle_lft);

  Point vpl = Point::intersection_point(f, p, horizon_l, horizon_r).pt;

  temp_str.str("");
  temp_str << "VP $" << angle_lft<< "^\\circ$l";
#if 0
  vpl.show(temp_str.str());
#endif 

  vpl.dotlabel(picture, temp_str.str());
  m = vpl.magnitude();
  Point mpl(vpl);
  mpl.shift(m); 

  temp_str.str("");
  temp_str << "MP $" << angle_lft<< "^\\circ$l";
  mpl.dotlabel(picture, temp_str.str()); 

@q *** Find location of |front_corner|.@>
@ Find location of |front_corner|.  
First, we need a measuring point for the CV.  There are two, namely the
$45^\circ$ vanishing points.  If the vanishing points we're using
anyway happen to be the $45^\circ$ vanishing points, then we just just
use one of them.  Otherwise, we have to find one of them.
If |front_corner_x| is greater than or equal to 0, we use the
right-hand VP $45^\circ$, otherwise we use the left-hand 
VP $45^\circ$. 

After we have a measuring point, we find
the  point |p| |front_corner_x| 
units along the groundline, then we draw a line from |p| to the
CV.  Then, we shift |p| |side_rt| units along the ground line, and
draw a line from |p| to the measuring point.  The intersection of the
two lines is |front_corner|.

@<Define perspective functions@>=
  Point mp_cv; 
  Point mp_cv_super;
  if (angle_rt == 45 && front_corner_x >= 0)
    mp_cv = vpr;
  else if (angle_rt == 45 && front_corner_x < 0)
    mp_cv = vpl;
  else if (front_corner_x >= 0) /* Use VP 45r for measuring point.  */
    {
      p.set(10, 0, 0);
      p.rotate(0, 0, 45);
  
      mp_cv = Point::intersection_point(f, p, horizon_l, horizon_r).pt;
      mp_cv_super = mp_cv;
      mp_cv_super.shift(0, 1);
      mp_cv_super.dotlabel(picture, "MP-CV");
      
    }
  else   /* Use VP 45l for measuring point.  */
    {
      p.set(-10, 0, 0);
      p.rotate(0, 0, -45);
      mp_cv = Point::intersection_point(f, p, horizon_l, horizon_r).pt;
      mp_cv_super = mp_cv;
      mp_cv_super.shift(0, 1);
      mp_cv_super.dotlabel(picture, "MP-CV");
    }

  Point x_pt(origin_pt);

x_pt.shift(front_corner_x);
  temp_str.str("");
  temp_str << "$x_{r_0}=" <<  front_corner_x << "$";

  Point x_pt_sub(x_pt);
  x_pt_sub.shift(0, -1);
  x_pt_sub.dotlabel(picture, temp_str.str(), "bot"); 

  Point z_pt(x_pt);
  
  signed short sign = static_cast<signed short>(front_corner_x / fabs(front_corner_x));

  z_pt.shift(-sign * front_corner_z);

  temp_str.str("");
  temp_str << "$z_{r_0}=" <<  front_corner_z << "$";

  Point z_pt_sub(z_pt);
  z_pt_sub.shift(0, -1);
  z_pt_sub.dotlabel(picture, temp_str.str(), "bot"); 

  Point front_corner = Point::intersection_point(x_pt, cv, z_pt, mp_cv).pt;
  front_corner.dotlabel(picture, "$r_0$", "bot"); 

  Point mpr0 = Point::intersection_point(gl_l, gl_r, mpr, front_corner).pt;
  
  mpr0.dotlabel(picture, "0", "bot"); 
  
  Point mpr_side_length(mpr0);

  mpr_side_length.shift(side_rt);
  
  temp_str.str("");
  temp_str << side_rt;
  mpr_side_length.dotlabel(picture, temp_str.str(), "bot"); 

  Point right_corner = Point::intersection_point(vpr, front_corner,
                                                 mpr, mpr_side_length).pt;
  right_corner.dotlabel(picture, "$r_1$", "rt"); 

  Point mpl0 = Point::intersection_point(gl_l, gl_r, mpl, front_corner).pt;
  mpl0.dotlabel(picture, "0", "bot"); 

  Point mpl_side_length(mpl0);

  mpl_side_length.shift(-side_lft);
  temp_str.str("");
  temp_str << side_lft;
  mpl_side_length.dotlabel(picture, temp_str.str(), "bot");

  Point left_corner = Point::intersection_point(front_corner, vpl,
                                                mpl,
                                                mpl_side_length).pt;
  left_corner.dotlabel(picture, "$r_3$", "lft");

  Point back_corner = Point::intersection_point(right_corner, vpl, left_corner, vpr).pt;
  back_corner.dotlabel(picture, "$r_2$"); 
  Path pa("--", 
          true, 
          &front_corner, 
          &right_corner, 
          &back_corner, 
          &left_corner, 
          static_cast<Point*>(0));

  Point center = Point::intersection_point(front_corner, back_corner,
                                           left_corner, right_corner).pt;
  center.label(picture, "$R$", "");

@q *** Drawing commands.@>
@ Drawing commands.  They're here, so that the lines aren't covered up
by |pa| when it's filled.

@<Define perspective functions@>=

  pa.filldraw(picture, &black, &gray);
  f.draw(picture, cv);
  horizon_l.draw(picture, horizon_r);
  gl_l.draw(picture, gl_r);
  x_pt_sub.drawarrow(picture, x_pt);
  x_pt.draw(picture, cv, &black, &ddashed_withdots);
  z_pt.draw(picture, mp_cv, &black, &ddashed_withdots);
  z_pt_sub.drawarrow(picture, z_pt);

  if (angle_rt != 45)
    {
      right_corner.draw(picture, vpr, &black, &ddashed_evenly);
      mp_cv_super.drawarrow(picture, mp_cv);
    }

  right_corner.draw(picture, vpl, &black, &ddashed_evenly);
  left_corner.draw(picture, vpr, &black, &ddashed_evenly);
  left_corner.draw(picture, vpl, &black, &ddashed_evenly);
  mpr.draw(picture, mpr0, &black, &ddashed_evenly);
  mpr.draw(picture, mpr_side_length, &black, &ddashed_evenly);
  mpl.draw(picture, mpl0, &black, &ddashed_evenly);
  mpl.draw(picture, mpl_side_length, &black, &ddashed_evenly);

#if 0
  front_corner.show("r0");
  right_corner.show("r1");
  back_corner.show("r2");
  left_corner.show("r3");
#endif 

@q *** Labels for the abbreviations.@>
@ Labels for the abbreviations.
@:!! TO DO@> TO DO:  \initials{LDF 2003.08.15.}
Get the colons lined up the way I'd like.  It will involve a bit of
fooling around with hboxes.

\LOG
\initials{LDF 2003.08.15.}  Added this section.
\ENDLOG 
@<Define perspective functions@>=
Point abbrev(gl_r);
abbrev.shift(-2.5, -.4);
abbrev.label(picture, "CV:\\space\\space\\space", "lft");
abbrev.label(picture, "center of vision", "rt");
abbrev.shift(0, -.4);
abbrev.label(picture, "VP:\\space\\space\\space", "lft");
abbrev.label(picture, "vanishing point", "rt");

abbrev.shift(0, -.4);
abbrev.label(picture, "MP:\\space\\space\\space", "lft");
abbrev.label(picture, "measuring point", "rt");

abbrev.shift(0, -.4);
abbrev.label(picture, "l:\\space\\space\\space", "lft");
abbrev.label(picture, "left", "rt");

abbrev.shift(0, -.4);
abbrev.label(picture, "r:\\space\\space\\space", "lft");
abbrev.label(picture, "right", "rt");

@q *** (3)Output.@>
@ Output.

\LOG
\initials{LDF 2004.06.07.}  Now passing |ffocus| to |Picture::output|.
\ENDLOG 

@<Define perspective functions@>=
  current_picture->output(s, ffocus, Projections::parallel_x_y);
}

@q ** (2) Predicates.  @>
@ Predicates.
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this section.
\ENDLOG 

@q *** (3) Predicates for |strings|.  @>
@ Predicates for |strings|.
\initials{LDF 2021.06.25.}

@q **** (4) Equal string.  @>
@ Equal string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
equal_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
equal_str(const string& s, const string& t)
{
  return s == t;
}

@q **** (4) Not equal string.  @>
@ Not equal string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
not_equal_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
not_equal_str(const string& s, const string& t)
{
  return s != t;
}

@q **** (4) Less string.  @>
@ Less string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_str(const string& s, const string& t)
{
  return s < t;
}

@q **** (4) Less or equal string.  @>
@ Less or equal string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_or_equal_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_or_equal_str(const string& s, const string& t)
{
  return s <= t;
}

@q **** (4) Greater string.  @>
@ Greater string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_str(const string& s, const string& t)
{
  return s > t;
}

@q **** (4) Greater or equal string.  @>
@ Greater or equal string.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_or_equal_str(const string& s, const string& t);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_or_equal_str(const string& s, const string& t)
{
  return s >= t;
}

@q **** (4) Equal int.  @>
@ Equal int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
equal_int(const int& i, const int& j);

@q ***** (5) @>
@
@<Define comparison functions@>=
bool
equal_int(const int& i, const int& j)
{
  return i == j;
}

@q **** (4) Not equal int.  @>
@ Not equal int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
not_equal_int(const int& i, const int& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
not_equal_int(const int& i, const int& j)
{
  return i != j;
}

@q **** (4) Less int.  @>
@ Less int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_int(const int& i, const int& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_int(const int& i, const int& j)
{
  return i < j;
}

@q **** (4) Less or equal int.  @>
@ Less or equal int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_or_equal_int(const int& i, const int& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_or_equal_int(const int& i, const int& j)
{
  return i <= j;
}

@q **** (4) Greater int.  @>
@ Greater int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_int(const int& i, const int& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_int(const int& i, const int& j)
{
  return i > j;
}

@q **** (4) Greater or equal int.  @>
@ Greater or equal int.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_or_equal_int(const int& i, const int& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_or_equal_int(const int& i, const int& j)
{
  return i >= j;
}

@q *** (3) Predicates for |reals|.  @>
@ Predicates for |reals|.
\initials{LDF 2021.06.25.}

@q **** (4) Equal real.  @>
@ Equal real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
equal_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
equal_real(const real& i, const real& j)
{
  return i == j;
}

@q **** (4) Not equal real.  @>
@ Not equal real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
not_equal_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
not_equal_real(const real& i, const real& j)
{
  return i != j;
}

@q **** (4) Less real.  @>
@ Less real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_real(const real& i, const real& j)
{
  return i < j;
}

@q **** (4) Less or equal real.  @>
@ Less or equal real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
less_or_equal_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
less_or_equal_real(const real& i, const real& j)
{
  return i <= j;
}

@q **** (4) Greater real.  @>
@ Greater real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_real(const real& i, const real& j)
{
  return i > j;
}

@q **** (4) Greater or equal real.  @>
@ Greater or equal real.  
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration @>

@<Declare comparison functions@>=
bool
greater_or_equal_real(const real& i, const real& j);

@q ***** (5) Definition @>
@
@<Define comparison functions@>=
bool
greater_or_equal_real(const real& i, const real& j)
{
  return i >= j;
}


@q * (1) Read MetaPost output from pipe. @>
@ Read MetaPost output from pipe.
\initials{LDF 2022.01.19.}

\LOG
\initials{LDF 2022.01.19.}
Added this function.
\ENDLOG

@q ** (2) Declaration @>

@<Declare utility functions@>=
int
read_metapost_output_from_pipe(string s, 
                               Pointer_Vector<Path> &path_vector, 
                               Scanner_Node scanner_node = 0);

@q ** (2) Definition @>
@
@<Define utility functions@>=
int
read_metapost_output_from_pipe(string s, 
                               Pointer_Vector<Path> &path_vector, 
                               Scanner_Node scanner_node)
{
@q *** (3) @>

   bool DEBUG = false; /* |true| */ 

   if (DEBUG)
   {
       cerr << "Entering `read_metapost_output_from_pipe'." << endl;

   }

@q *** (3) @>
@
@<Define utility functions@>=

   int status = 0;

   FILE *fp = popen(s.c_str(), "r");

   size_t n = 512;
   char *buffer = (char *) malloc(n);
   memset(buffer, '\0', n);

   size_t pos;

   Point p;
   Path *q = 0;
   char c;
   real r;  
   real x;  
   real y;  
   Connector_Type ct;

   string s0;
   string s1;

   stringstream temp_strm;

@q *** (3) @>

   bool skipping = true;

 
@q *** (3) @>

   while (status != -1)
   {
@q **** (4) @>
      errno = 0;

      status = getline(&buffer, &n, fp);

@q **** (4) @>

      if (status == -1)
      {

         if (DEBUG)
         {
            cerr << "`getline' returned `status' == " << status << endl;

         }

         if (feof(fp))
         {
            if (DEBUG)
               cerr << "Read EOF.  Finished reading from `fp'." << endl;
            break;
         }
         else
         {
            cerr << "ERROR!  In `read_metapost_output_from_pipe':  "
                 << "`getline' failed, returning -1." << endl
                 << "`errno' == " << errno << " == " << strerror(errno) << endl
                 << "Exiting function with return value 1." << endl;

            pclose(fp);
            free(buffer);
            return 1;                
                 
         }
      }  /* |if|  */      

@q **** (4) @>
@
@<Define utility functions@>=

      else  /* |status != -1| */
      {
@q ***** (5) @>
         if (DEBUG)
            cerr << "status == " << status << endl
                 << "buffer == " << buffer << endl;

         s0 = buffer;
         pos = s0.find("Path at line");
   
@q ***** (5) @>

         if (skipping && pos == string::npos)
         {
            if (DEBUG)
               cerr << "`skipping' is `true' and didn't find \"Path at line\"." << endl 
                    << "Continuing." << endl;

            continue;

         }

@q ***** (5) @>

         else if (pos != string::npos)
         {
            if (DEBUG)
               cerr << "Found \"Path at line\".  Creating new `Path'." << endl;
        
            if (skipping)
               skipping = false;
 
            q = create_new<Path>(0);
            continue;
         }
@q ***** (5) @>

         else if ((pos = s0.find("turningnumber")) != string::npos)
         {
             if (path_vector.v.back() == 0)
             {
                if (DEBUG)
                   cerr << "`path_vector.v.back()' == 0.  This shouldn't happen.  "
                        << "Continuing." << endl;
                continue;
             }
             else 
             {
                 temp_strm.str("");
                 temp_strm << s0;
                 temp_strm >> s1;
                 temp_strm >> r;
 
                 if (DEBUG)
                    cerr << "`r' (turning number) == " << r << endl;

                 path_vector.v.back()->turningnumber = r;

                 if (DEBUG)
                    cerr << "path_vector.v.back()->turningnumber == " 
                         << path_vector.v.back()->turningnumber << endl;

             }
          }

@q ***** (5) @>

         else if (s0[0] == 40 || s0[1] == '.')  /* ASCII 40 is the open parenthesis character.  */
         {
@q ****** (6) @>

            temp_strm.str("");
            temp_strm << s0;

            if (s0[0] == 40)
            {
               if (DEBUG)
                  cerr << "Line begins with a point." << endl;
            }

@q ****** (6) @>

            else 
            {
@q ******* (7) @>
                if (DEBUG)
                   cerr << "Line begins with a connector." << endl;

                pos = s0.find("cycle");

                if (pos != string::npos)
                {
                    if (DEBUG)
                       cerr << "Read \"..cycle\".  Finished reading `Path'." << endl;
                    q->set_cycle(true, scanner_node);
                    path_vector.v.push_back(q);
                    q = 0;
                    continue;
                }
                else
                {
                   temp_strm >> c;
                   temp_strm >> c;
                }

@q ******* (7) @>

            }  /* |else| */

@q ****** (6) @>

            temp_strm >> c;
            temp_strm >> x;


            if (DEBUG)
               cerr << "x == " << x << endl;

            temp_strm >> c;
            temp_strm >> y;

            if (DEBUG)
               cerr << "y == " << y << endl;

            x = (x * 2.54) / 72.0;  /* Convert |bp| to |cm|  */
            y = (y * 2.54) / 72.0;

            p.set(x, y, 0);

            if (DEBUG)
               p.show("p:");

            *q += p;

            if (DEBUG)              
               q->show("*q:");

            temp_strm >> c;

            if (DEBUG)              
               cerr << "Read c == " << c << endl;

            temp_strm >> c;
            if (DEBUG)              
               cerr << "Read c == " << c << endl;

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;

            temp_strm >> s1;
            if (DEBUG)             
               cerr << "Read s1 == " << s1 << endl;

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;

            temp_strm >> x;
            if (DEBUG)             
               cerr << "Read x == " << x << endl;

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;

            temp_strm >> y;
            if (DEBUG)             
               cerr << "Read y == " << y << endl;

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;

            x = (x * 2.54) / 72.0;  /* Convert |bp| to |cm|  */
            y = (y * 2.54) / 72.0;

            p.set(x, y, 0);

            if (DEBUG)             
               p.show("p:");

            ct.type0 = Connector_Type::CONTROLS_TYPE;
            ct.type1 = Connector_Type::CT_NULL_TYPE;
            ct.connector_string = "..";
            ct.pt0 = create_new<Point>(p);
 
            temp_strm >> s1;
            if (DEBUG)             
               cerr << "Read s1 == " << s1 << endl;

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;            

            temp_strm >> x;
            if (DEBUG)             
               cerr << "Read x == " << x << endl;            

            temp_strm >> c;
            if (DEBUG)             
               cerr << "Read c == " << c << endl;            

            temp_strm >> y;
            if (DEBUG)             
               cerr << "Read y == " << y << endl;            

            x = (x * 2.54) / 72.0;  /* Convert |bp| to |cm|  */
            y = (y * 2.54) / 72.0;

            p.set(x, y, 0);


            if (DEBUG)             
               p.show("p:");

            ct.pt1 = create_new<Point>(p);

            if (DEBUG)             
               ct.show("ct:");

            *q += ct;

            if (DEBUG)             
               q->show("*q:");

@q ****** (6) @>

         }  /* |else if (s0[0] == 40 || s0[1] == '.')| */

@q ***** (5) @>

         else if (s0[0] == '\n')
         { 
            if (DEBUG)             
               cerr << "Line begins with a newline.  Continuing." << endl;
            continue;
         }

@q ***** (5) @>

         else if (isspace(s0[0]) && isspace(s0[1]))
         {
            if (DEBUG)             
               cerr << "Line begins with at least two whitespace characters.  Continuing." << endl;
            continue;

         }

@q ***** (5) @>

      }  /* |else| (|status != -1|) */
@
@<Define utility functions@>=

      if (feof(fp))
      {
         if (DEBUG)             
            cerr << "Read EOF.  Finished reading from `fp'." << endl;
         break;
      }

@q **** (4) @>

   }  /* |while| */
  
@q *** (3) @>

   free(buffer);
   buffer = 0;
   pclose(fp);
   fp = 0;

@q *** (3) @>

   if (DEBUG)
   {
       cerr << "Exiting `read_metapost_output_from_pipe' successfully with return value 0." 
            << endl;

   }

@q *** (3) @>

   return 0;

}  /* End of |read_metapost_output_from_pipe| definition  */


@q * (1) Round function for |real| values.  @>
@ Round function for |real| values.
\initials{LDF 2022.04.06.}

@<Declare utility functions@>=
int
round_real(real r);

@q ** (2) Definition @>
@
@<Define utility functions@>=
int
round_real(real r)
{
   int i;

#if LDF_REAL_DOUBLE
   i = round(r);
#else
   i = roundf(r);
#endif 

   return i;

}  /* End of |round_real| definition  */

@q * (1) Call MetaPost (|call_metapost|).  @>
@ Call MetaPost (|call_metapost|).
\initials{LDF 2022.05.06.}

\LOG
\initials{LDF 2022.05.06.}
Added this function.
\ENDLOG

@q ** (2) Declaration @>

@<Declare utility functions@>=

int
call_metapost(string& str, Id_Map_Entry_Node path_entry, Id_Map_Entry_Node point_entry, 
              Id_Map_Entry_Node real_entry, Scanner_Node scanner_node);

@q ** (2) Definition @>
@
@<Define utility functions@>=
int
call_metapost(string& str, Id_Map_Entry_Node path_entry, Id_Map_Entry_Node point_entry, 
              Id_Map_Entry_Node real_entry, Scanner_Node scanner_node)
{
@q *** (3) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
       cerr << "Entering `call_metapost'." << endl
            << "`str'     == " << str << endl;
   }

#endif /* |DEBUG_COMPILE|  */@; 

@q *** (3) @>
@
@<Define utility functions@>=

   if (scanner_node == 0)
   {
      cerr << "ERROR!  In `call_metapost':  `scanner_node' is NULL." 
           << endl
           << "Can't call MetaPost.  Exiting function unsuccessfully with "
           << "return value 1." << endl;

      return 1;
   }
   else 
   {
      cerr << "`scanner_node' is non-NULL." << endl;
 
      if (scanner_node->metapost_output_struct == 0)
      {
          cerr << "scanner_node->metapost_output_struct is NULL.  Creating." 
               << endl;

          scanner_node->metapost_output_struct = new Metapost_Output_Struct;
      }
   }

@q *** (3) @>
@
@<Define utility functions@>=

   int status = 0;

   bool save  = false;
   bool clear = true;

   bool do_paths             = false;  
   bool do_points            = false;
   bool do_reals             = false;  
   bool suppress_mp_stdout   = false;


@q *** (3) @>
@
@<Define utility functions@>=

@q *** (3) @>
@
@<Define utility functions@>=

   cerr << "save               == " << save << endl 
        << "clear              == " << clear << endl 
        << "do_paths           == " << do_paths << endl 
        << "do_points          == " << do_points << endl 
        << "do_reals           == " << do_reals  << endl
        << "suppress_mp_stdout == " << suppress_mp_stdout << endl;

@q *** (3) @>
@
@<Define utility functions@>=

   FILE *fp = 0;

   char buffer[64];
   memset(buffer, '\0', 64);

   char temp_in_filename[] = "mp_input.XXXXXX";
    
   errno = 0;
   int fd_in = mkstemp(temp_in_filename);

   if (fd_in == -1)
   {
           cerr << "ERROR!  In `call_metapost':"
                << endl 
                << "`mkstemp' failed, returning -1:"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to create temporary file."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;

           return 1;

   }  /* |if (fd_in == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        cerr << "In `call_metapost':"
             << endl 
             << "`mkstemp' succeeded:  `temp_in_filename' == " << temp_in_filename 
             << endl;

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *** (3) @>
@
@<Define utility functions@>=

    char temp_out_filename[] = "mp_output.XXXXXX";
    
    errno = 0;
    int fd_out = mkstemp(temp_out_filename);

    if (fd_out == -1)
    {
            cerr << "ERROR!  In `call_metapost':"
                 << endl 
                 << "`mkstemp' failed, returning -1:"
                 << endl
                 << strerror(errno)
                 << endl 
                 << "Failed to create temporary file."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;

            return 1;

    }  /* |if (fd_out == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        cerr << "In `call_metapost':"
             << endl 
             << "`mkstemp' succeeded:  `temp_out_filename' == " << temp_out_filename 
             << endl;

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q *** (3) @>
@
@<Define utility functions@>=

    char temp_stdout_stderr_filename[] = "mp_stdout_stderr.XXXXXX";
    
    errno = 0;
    int fd_stdout_stderr = mkstemp(temp_stdout_stderr_filename);

    if (fd_stdout_stderr == -1)
    {
            cerr << "ERROR!  In `call_metapost':"
                 << endl 
                 << "`mkstemp' failed, returning -1:"
                 << endl
                 << strerror(errno)
                 << endl 
                 << "Failed to create temporary file."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;

            return 1;

    }  /* |if (fd_stdout_stderr == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        cerr << "In `call_metapost':"
             << endl 
             << "`mkstemp' succeeded:  `temp_stdout_stderr_filename' == " << temp_stdout_stderr_filename 
             << endl;

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *** (3) @>
@
@<Define utility functions@>=

   errno = 0;
   fp = popen("date", "r");

   if (fp == 0)
   {
      cerr << "ERROR!  In `call_metapost':  `popen' failed, returning 0:"
           << endl
           << "`errno' == " << errno << ":  " << strerror(errno)
           << endl
           << "Exiting function unsuccessfully with return value 1."
           << endl;

            return 1;

   } /* |if (fp == 0)| */

@q *** (3) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
      cerr << "In `call_metapost':  `popen' succeeded."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q *** (3) @>
@
@<Define utility functions@>=

   memset(buffer, '\0', 64);
   errno = 0;

   status = fread(buffer, 1, 64, fp);

   if (status == 0)
   {
      cerr << "Error!  In `call_metapost':  `fread' failed, returning " << status << ":"
           << endl;

      if (ferror(fp))
         cerr << "`errno' == " << errno << ":  " << strerror(errno) << endl;
      if (feof(fp))
         cerr << "Reached EOF." << endl;

      cerr << "Exiting function unsuccessfully with return value 1."
           << endl;


      pclose(fp);

      return 1;

   }  /* |if (status == 0)| */

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
      cerr << "In `call_metapost':  `fread' succeeded, returning " << status << "."
           << endl
           << "`buffer' == " << buffer << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   pclose(fp);

@q *** (3) @>
@
@<Define utility functions@>=

   stringstream temp_strm;

   temp_strm << "%% " << temp_in_filename << endl
             << "%% Generated by GNU 3DLDF " << buffer
             << endl << "tracingonline := 1;" << endl 
             << "input writemcs.mp;" << endl 
             << "string output_filename;" << endl 
             << "output_filename = \"" << temp_out_filename << "\";"  << endl 
             << str << endl << "end;" << endl << endl 
             << "%% Loc" << "al Variables:" << endl  /* Word broken on purpose!  LDF 2022.05.07.  */
             << "%% mode:MetaPost"    << endl 
             << "%% End:"             << endl 
             << endl;

   cerr << "temp_strm.str() == " << endl << temp_strm.str() << endl;

   status = write(fd_in, temp_strm.str().c_str(), temp_strm.str().size());

   errno = 0;

   if (status == -1)
   {
       cerr << "ERROR!  In ``call_metapost':  `write' failed, returning -1:" 
            << endl 
            << "`errno' == " << errno << ":  " << strerror(errno)
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       close(fd_in);

       return 1;

   } 
   else if (status < temp_strm.str().size())
   {
       cerr << "ERROR!  In ``call_metapost':  `write' failed, returning `status' == " << status << ":" 
            << endl 
            << "`status < `temp_strm.str().size()' == " << temp_strm.str().size() << ":"
            << endl
            << "Failed to write `temp_strm.str()' completely to temporary MetaPost input file"
            << endl 
            << "`temp_in_filename' == " << "`" << temp_in_filename << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;

   } 
#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr << "In ``call_metapost':  `write' succeeded, returning `status' == " 
            << status << "."
            << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   close(fd_in);
   fd_in = 0;

@q *** (3) @>
@
@<Define utility functions@>=



   temp_strm.str("");

   temp_strm << "mpost -interaction=batchmode " << temp_in_filename << " 2>&1 >" 
             << temp_stdout_stderr_filename;

   cerr << "temp_strm.str() == " << temp_strm.str() << endl;

   errno = 0;

   status = system(temp_strm.str().c_str());

   if (status != 0)
   {
       cerr << "ERROR!  In ``call_metapost':  `system' failed, returning `status' == " 
            << status << "." 
            << endl 
            << "`errno' == " << errno << " == " << strerror(errno)
            << endl 
            << "Failed to execute `mpost' on temporary input file "
            << "`" << temp_in_filename << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

        return 1;

   } /* |if (status != 0)| */

@q **** (4) @>

#if DEBUG_COMPILE
  else if (DEBUG)
  { 
      cerr << "In ``call_metapost':  `system' succeeded, returning 0."
           << endl 
           << "Executed `mpost' on temporary input file `" << temp_in_filename 
           << "' successfully."
           << endl; 

  }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define utility functions@>=

   errno = 0;   
   fp = 0 ;
   fp = fopen(temp_out_filename, "r");

   if (fp == 0)
   {
      cerr << "ERROR!  In `call_metapost':  `fopen' failed, returning 0:"
           << endl
           << "`errno' == " << errno << ":  " << strerror(errno)
           << endl
           << "Exiting function unsuccessfully with return value 1."
           << endl;

            return 1;

   } /* |if (fp == 0)| */

@q **** (4) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
      cerr << "In `call_metapost':  `fopen' succeeded."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   yyscan_t scanner;
   zzlex_init_extra(static_cast<void*>(scanner_node),  &scanner);
   zzset_in(fp, scanner);
   zzlex(scanner);
   zzlex_destroy(scanner);

   fclose(fp);
   fp = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "In `call_metapost':  After calling zzlex." << endl;

      cerr << "scanner_node->metapost_output_struct->path_vector.size() == " 
           << scanner_node->metapost_output_struct->path_vector.size() 
           << endl
           << "scanner_node->metapost_output_struct->real_vector.size() == " 
           << scanner_node->metapost_output_struct->real_vector.size() << endl;

      for (vector<Path*>::iterator iter = scanner_node->metapost_output_struct->path_vector.begin();
           iter != scanner_node->metapost_output_struct->path_vector.end();
           ++iter)
      {
         (**iter).show("**iter:");
      }
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q *** (3) @>
  
   if (path_entry && scanner_node->metapost_output_struct->path_vector.size() > 0)
   {
      for (vector<Path*>::iterator iter = scanner_node->metapost_output_struct->path_vector.begin();
           iter != scanner_node->metapost_output_struct->path_vector.end();
           ++iter)
      {

          status = Scan_Parse::vector_type_plus_assign<Path>(scanner_node,
                                                             path_entry,
                                                             PATH_VECTOR,
                                                             PATH,
                                                             *iter);
      }
      scanner_node->metapost_output_struct->path_vector.clear();
      delete scanner_node->metapost_output_struct;
      scanner_node->metapost_output_struct = 0;
   }
  
   if (path_entry)
      path_entry->show("path_entry:");

@q *** (3) @>
@
@<Define utility functions@>=

   if (save)
   {
       cerr << "Wrote input file `" << temp_in_filename << "', "
            << "output file `" << temp_out_filename << "' and"
            << endl 
            << "stdout/stderr file `" << temp_stdout_stderr_filename << "'." << endl;
   }
   else
   {
       cerr << "Deleting input file `" << temp_in_filename << "', "
            << "output file `" << temp_out_filename << "' and"
            << endl 
            << "stdout/stderr file `" << temp_stdout_stderr_filename << "'." << endl;

      unlink(temp_in_filename);
      unlink(temp_out_filename);
      unlink(temp_stdout_stderr_filename);
   }

#if DEBUG_COMPILE
   if (DEBUG)
   { 
       cerr << "Exiting `call_metapost' successfully with return value 0." 
            << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

}  /* End of |call_metapost| definition */


@q * (1) Putting utilities together.@>
@* Putting utilities together.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.03.15.}
Not including |@<Declare perspective functions@>| and
|@<Define perspective functions@>|.  They currently don't work because
of changes I've made to the drawing and filling functions for |class Path|.
\ENDLOG 

This is what's compiled.
\initials{LDF Undated.}
@c
@<Include files@>@;

@q Declare perspective functions@>@;
@q Define perspective functions@>@;

@<Declare utility functions@>@;
@<Define utility functions@>@;

@<Declare comparison functions@>@;
@<Define comparison functions@>@;

@ This is what's written to \filename{utility.h}.
\initials{LDF Undated.}

@(utility.h@>=
@q Declare perspective functions@>@;
@<Declare utility functions@>@;
@<Declare comparison functions@>@;

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q eval:(outline-minor-mode) @>
@q End: @>
