@q ddchdrn.web @>

@q Created by Laurence D. Finston (LDF) Fri Oct 12 19:45:56 CEST 2007 @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>




@q * (0) Dodecahedron.@>
@** {\bf Dodecahedron}.

\LOG
\initials{LDF 2007.10.12.}
Created this file.  It contains code for |class Dodecahedron| removed from
\filename{polyhed.web}.
\ENDLOG

@q * (1) Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"
#include "solids.h++"
#include "solfaced.h++"
#include "polyhed.h++"
 
@q * (1)  {\bf Dodecahedron} Class definition.@>
@* {\bf Dodecahedron} class definition.
@f Dodecahedron Polyhedron
@<Declare |class Dodecahedron|@>=

class Dodecahedron : public Polyhedron
{
protected:
static const real dihedral_angle; /* In radians!  */
real pentagon_radius; 
public:
@<Declare |Dodecahedron| functions@>@;
};

@q * (1) Define static const Dodecahedron data members.@>
@* Define {\bf static const Dodecahedron} data members.

\LOG
\initials{LDF 2003.07.18.}  
Now passing ``2.0'' instead of ``2.0'' as the
argument to |atan()|.  GCC 3.3 couldn't compile this file, the way it
was before.
\ENDLOG 

@<Define |static const Dodecahedron| data members@>=
const real Dodecahedron::dihedral_angle = PI - atan(2.0);

@q * (1) |Dodecahedron| functions.@>
@* {\bf Dodecahedron} functions.
\initials{LDF 2007.10.12.}

@q ** (2) Constructors and setting functions.@>
@*1 Constructors and setting functions.

@q *** (3) Default constructor. (No arguments.)@>
@*2 Default constructor. (No arguments.)
@^\cfunc{Dodecahedron}{Dodecahedron}@>


\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.09.29.}
I should set the data members of other classes to
|INVALID_POINT|, |INVALID_REAL|, etc., 
in the default constructors, too. 
\ENDTODO 

\LOG
\initials{LDF 2005.01.24.}
Now setting |shape_type = DODECAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 


@<Declare |Dodecahedron| functions@>=
Dodecahedron(void);

@
@<Define |Dodecahedron| functions@>=
Dodecahedron::Dodecahedron(void)
{

   shape_type = DODECAHEDRON_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   do_output     = true;
   faces    = 12;          /* from |Solid_Faced|.  */
   vertices = 20;
   edges    = 30;

   center = INVALID_POINT;  /* from |Polyhedron|.  */
   number_of_polygon_types = 1;
   face_radius = edge_radius = vertex_radius = INVALID_REAL;

   pentagon_radius = INVALID_REAL;  /* From |Dodecahedron|.  */

}

@q *** (3) Center, diameter of pentagon, and angles. @>
@*2 Center, diameter of pentagon, and angles.

@q **** (4) Constructor.@>
@*3 Constructor.
@^\cfunc{Dodecahedron}{Dodecahedron}@>

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.08.10.}  
Check the way I specify the
rotations.  If its not the way I think it should be, check
|Transform::align_with_axis()| and any other functions that are
involved.  This may be a long-term project.
\ENDTODO 

\LOG
\initials{LDF 2002.10.16.} 
Added shift to |center| and rotation.   

\initials{LDF 2003.08.10.}  
Rewrote this function.  It had suddenly stopped
working properly, probably because of changes I made to
|Transform::align_with_axis()|.  I'm still not entirely happy with the
way I've had to specify the rotations,  see the ``TO DO'' note of this
date, above.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create()|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = DODECAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Dodecahedron| functions@>=
Dodecahedron(const Point& p, const real pentagon_diameter,
real angle_x = 0, real angle_y = 0, real angle_z = 0);


@q ***** (5) Definition.@> 

@
@<Define |Dodecahedron| functions@>=
Dodecahedron::Dodecahedron(const Point& p,
                           const real pentagon_diameter,
                           real angle_x, real angle_y,
                           real angle_z)
{
   bool DEBUG = false; /* |true| */
   if (DEBUG)
      cerr << "Entering Dodecahedron::Dodecahedron().\n";


   shape_type = DODECAHEDRON_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   do_output     = true;

   faces    = 12;  /* from |Solid_Faced|.  */
   vertices = 20;
   edges    = 30;

   number_of_polygon_types = 1;
#if 0 
   /*  !! TO DO.  TO DO:  Must calculate these!  */
   face_radius = 0;
   edge_radius = 0;
   vertex_radius = 0;
#endif 

   Point origin_pt(0, 0, 0);

   pentagon_radius = pentagon_diameter / 2.0;

   reg_polygons = get_net(pentagon_diameter, true);

   Point pts[8];

   int i = 0;
   for (i = 0; i < 5; ++i)
      {
         pts[i] = reg_polygons[0]->get_point(i);
      }     


   real angle = 180 - (dihedral_angle * 180.0/PI);


@ \initials{LDF 2003.08.10.}  Check this, as noted above.
@<Define |Dodecahedron| functions@>=

   reg_polygons[1]->rotate(pts[0], pts[1], angle);
   reg_polygons[2]->rotate(pts[4], pts[0], angle);
   reg_polygons[3]->rotate(pts[3], pts[4], angle);
   reg_polygons[4]->rotate(pts[3], pts[2], angle);
   reg_polygons[5]->rotate(pts[1], pts[2], angle);  


#if 0 
using namespace Colors;
vector<const Color*> col_vec;
col_vec.push_back(&black);
col_vec.push_back(&red);
    col_vec.push_back(&green);
    col_vec.push_back(&blue);
    col_vec.push_back(&cyan);
    col_vec.push_back(&magenta);
    col_vec.push_back(&orange);
#endif 

#if 0 
    if (DEBUG) 
      {
        i = 0;
        for (vector<Reg_Polygon*>::iterator iter = reg_polygons.begin();
             iter != reg_polygons.end(); ++iter)
          {

            (**iter).draw(picture, *(col_vec[i]));


            ++i;
          }
        reg_polygons[0]->draw(picture);
      }
#endif 


    for (i = 0; i < 6; ++i)
      {
        reg_polygons.push_back(create_new<Reg_Polygon>(0));
        *reg_polygons.back() = *reg_polygons[i];
        reg_polygons.back()->rotate(180);
      }


    pts[5] = reg_polygons[1]->get_point(4);
    pts[6] = reg_polygons[10]->get_point(2);

#if 0 
    if (DEBUG)
      {

        pts[5].dotlabel("$p_5$"); 
        pts[6].dotlabel("$p_6$"); 
      }   
#endif 

    pts[7] = pts[5] - pts[6];

    for (i = 6; i < 12; ++i)
      reg_polygons[i]->shift(pts[7]);
    
#if 0 
    if (DEBUG)
      {
        for (i = 6; i < 12; ++i)

            reg_polygons[i]->draw(picture, *(col_vec[i - 6]));
      }
#endif 


    Point center_0 = reg_polygons[0]->get_center();
    Point center_6 = reg_polygons[6]->get_center();
    center = center_0.mediate(center_6);

    Transform t = center.shift(-center);

    if (angle_x != ZERO_REAL || angle_y != ZERO_REAL || angle_z != ZERO_REAL)
      t.rotate(angle_x, angle_y, angle_z);

    if (p != origin_pt)
      center *= t.shift(p);

    for(vector<Reg_Polygon*>::iterator iter = reg_polygons.begin();
        iter != reg_polygons.end(); ++iter)
      (**iter) *= t;

    if (DEBUG)
          cerr << "Exiting Dodecahedron::Dodecahedron().\n";
    return;
}


@q ** (2) Get copy.@>
@* Get copy.
@^\cfunc{Dodecahedron}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Dodecahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Dodecahedron| functions@>=
Shape*
Dodecahedron::get_copy() const
{
  Dodecahedron* p = create_new<Dodecahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}



@q ** (2) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@q *** (3) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Dodecahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return DODECAHEDRON_TYPE;
}

@q *** (3) Is |Dodecahedron|.@> 
@*1 Is {\bf Dodecahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Dodecahedron| functions@>=
virtual
inline
bool
is_dodecahedron(void) const 
{
   return true;
}


@q ** (2) Net and tabs.@>
@*1 Net and tabs.
\initials{LDF 2007.10.12.}

@q *** (3) Get net.@>
@*2 Get net. 
@^\cfunc{Dodecahedron}{get\_net}@>
\initials{LDF Undated.}

\initials{LDF Undated.}
|const Point& center_0| is only ever used when |do_half == false|,
that is, when the net isn't just being generated for use by a
constructor.  If |get_net()| {\it is\/} called by a constructor, the
net is always made with the center of pentagon 0 at the origin.  Even
if |center_0| is used, the net is always generated in a plane parallel
to the x-z plane.

\LOG
\initials{LDF 2002.09.29.}  
Changed this function.  

\initials{LDF 2003.08.12.}  
Removed |center_0| argument.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create()|.

\initials{LDF 2005.12.20.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF Undated.}
I've removed
|rotate()| and now rotate the pentagons in the x-z plane only
in order to avoid having the y-coordinates be off by small amounts.
This might not happen with |rotate()| once I implement the
routine in Salomon (@:!!@> !! Get reference!) for calculating sine and
cosine using integers.  
\ENDTODO 

@q **** (4) Declaration.@>

@<Declare |Dodecahedron| functions@>=
static
vector<Reg_Polygon*>
get_net(const real pentagon_diameter, 
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>
@ 
@<Define |Dodecahedron| functions@>=
vector<Reg_Polygon*>
Dodecahedron::get_net(const real pentagon_diameter, 
                      bool do_half,
                      Scanner_Node scanner_node)
{
  int i;
  vector<Reg_Polygon*> pents;

  Point origin_pt(0, 0, 0);

  for (i = 0; i < 6; ++i)
    pents.push_back(create_new<Reg_Polygon>(0));

  pents[0]->set(origin_pt, 5, pentagon_diameter, 0, 180);  /* The middle 
                                                           pentagon.  */
 
  Point pts[10];



  for (i = 0; i < 5; i++)
    {
      pts[i] = pents[0]->get_point(i);
    }

  *pents[1] = *pents[0];
  pents[1]->rotate(0, 36);

  *pents[5] = *pents[4] = *pents[3] = *pents[2] = *pents[1];  

  for (i = 5; i < 10; i++)
    pts[i] = pents[1]->get_point(i - 5);
  
  pents[1]->shift(pts[0] - pts[8]);
  pents[2]->shift(pts[0] - pts[6]);
  pents[3]->shift(pts[4] - pts[5]);
  pents[4]->shift(pts[3] - pts[9]);
  pents[5]->shift(pts[1] - pts[9]);

  if (do_half == true)  /* \initials{LDF 2002.09.29.}
                          We only need half of the net, if 
                          we're using it to make a polyhedron.
                          In that case, we copy and transform 
                          the half we've already got and the copy
                          on top of the first half.  */
    {
      for (i = 0; i < 6; ++i)
        {
          for (int j = 0; j < 5; j++)
            if (pents[i]->get_point(j).get_y() != ZERO_REAL)
              {
                cerr << "ERROR! In Dodecahedron::get_net():\n"
                  << "y-coordinate != 0!\n"
                    << "You'd better fix this!\n\n";
              }
        }
      return pents;
    }
  
  for (i = 6; i < 12; i++)
    {
      pents.push_back(create_new<Reg_Polygon>(0));
      *pents[i] = *pents[i - 6];
      pents[i]->rotate(0, 180);
    }


  pts[0] = pents[11]->get_point(0);
  pts[1] = pents[5]->get_point(1);


  for (i = 6; i < 12; ++i)
    pents[i]->shift(pts[1] - pts[0]);


  for (i = 0; i < 12; ++i)
    {
      for (int j = 0; j < 5; j++)
        if (pents[i]->get_point(j).get_y() != ZERO_REAL)
          {
            cerr << "ERROR! In Dodecahedron::get_net():\n"
                 << "y-coordinate != 0!\n"
                 << "You'd better fix this!\n\n";
          }
    }
  return pents;

}  /* End of |Dodecahedron::get_net| definition.  */

@q *** (3) Draw net.@>
@*2 Draw net.
@^\cfunc{Dodecahedron}{draw\_net}@>

This function is for drawing the net of a
|Dodecahedron|.  Normally, this will be done in order to make a
cardboard model, which will require tabs for gluing the pentagons
together.  If no tabs are desired, passing |false| as the |make_tabs|
argument will suppress the tabs.
\initials{LDF 2002.11.10.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.11.10.}
The arrays |Point pts| and 
|Path p| have too many members.  In working on this function, I ended
up getting rid of some of the members of these arrays after I'd
already used members following them.  I should go through and reassign
the numbers, so that no members are skipped.

\initials{LDF 2002.11.10.}  
Add the usual arguments for
drawing and filling commands.

\initials{LDF 2002.11.10.}  
|portrait| doesn't work right.
Fix it! @:!! KLUDGE@> !! KLUDGE:  |portrait| is set to |false| at the
beginning of this function and a warning is issued.
\ENDTODO 


\LOG
\initials{LDF 2002.11.10.}  
Added this function.

\initials{LDF 2002.11.10.}  
Tried to get output in portrait format to work, but
it doesn't yet.

\initials{LDF 2004.05.26.}  
Added the |Picture& picture| argument. 
\ENDLOG 

@q ** Declaration.  @>

@<Declare |Dodecahedron| functions@>=
static
void
draw_net(Picture& picture,
         const real pentagon_diameter,
         bool portrait = true,
         bool make_tabs = true);


@q ** Definition.  @>

@ 
@<Define |Dodecahedron| functions@>=
void
Dodecahedron::draw_net(Picture& picture,
                       const real pentagon_diameter,
                       bool portrait,
                       bool make_tabs)
{
  
  vector <Reg_Polygon*> v = get_net(pentagon_diameter);


  for (vector <Reg_Polygon*>::iterator iter = v.begin();
       iter != v.end(); ++iter)
    {
      if (portrait)
        (**iter).rotate(0, 90);
#if 0 
      (**iter).rotate(90);
#endif 
    }

  Point p[32];

  int i;
  for (i = 0; i < 5; i++)
    {
      p[i] = v[3]->get_point(i);
#if 0 
      p[i].dotlabel(i);
#endif 
    }

/* !! TO DO.  */ 
      
  i = 0;
  for (vector <Reg_Polygon*>::iterator iter = v.begin();
       iter != v.end(); ++iter)
    {
      (**iter).draw(picture);
      (**iter).get_center().label(picture, i++); 
    }
  

  if (!make_tabs)
      return;

  return;

}  /* End of |Dodecahedron::draw_net| definition.  */

@q *** (3) Get tabs.@>
@*2 Get tabs. 
@^\cfunc{Dodecahedron}{get\_tabs}@>
\initials{LDF 2007.10.12.}

@q **** (4) Version with multiple arguments.@>
@*3 Version with multiple arguments.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this function.

\initials{LDF 2007.10.16.}
Finished this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Dodecahedron| functions@>=
static
void*
get_tabs(const real pentagon_diameter, 
         bool do_half = false,
         bool do_stitch_lines = true,
         unsigned short stitch_divisions = 5,
         void* parameter = 0);

@q ***** (5) Definition.@>
@ 
@<Define |Dodecahedron| functions@>=
void*
Dodecahedron::get_tabs(const real pentagon_diameter, 
                       bool do_half,
                       bool do_stitch_lines,
                       unsigned short stitch_divisions,
                       void* parameter)
{
@q ****** (6) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_mutex.lock();
       cerr << "Entering `Dodecahedron::get_tabs'."
            << endl;
       cerr_mutex.unlock(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   using namespace Scan_Parse;

   Path tab;
   Path stitch_line;

   Point p[8];
 
   Point q[12][5];

   Point corner[4];
   Point mid_pt[4];

   Transform t;
   Transform u;

@q ****** (6)@>

   if (pentagon_diameter <= 0)
   {
       cerr_strm << thread_name << "ERROR!  In `Dodecahedron::get_tabs':"
                 << endl 
                 << "`pentagon_diameter' <= 0."
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 0;

   }  /* |if (pentagon_diameter <= 0)|  */

@q ****** (6)@>

   vector<Reg_Polygon*> rpv = get_net(pentagon_diameter, do_half, scanner_node);

   {  /* Beginning  of group  */

      int i = 0;   
      for (vector<Reg_Polygon*>::iterator iter = rpv.begin();
           iter != rpv.end();
           ++iter)
      {
          (**iter).rotate(180, 180);
 
          for (int j = 0; j < 5; ++j)
             q[i][j] = (**iter).get_point(j);
          ++i;
      }   
   }  /* End of group  */

   p[0] = rpv[1]->get_point(0);
   p[1] = rpv[1]->get_point(1);

   Pointer_Vector<Path>* pv = new Pointer_Vector<Path>;

   vector<Path> tab_vector;
   vector<Path> stitch_line_vector;

@q ****** (6) First tab on |rpv[1]|.@>
@ First tab on |rpv[1]|.

\LOG
\initials{LDF 2013.11.10.}
@:BUG FIX@> BUG FIX:  Now casting final argument of |Path::set| to |Point *|.
For some reason, this worked when |real| was a ``|typedef|'' for |double|, 
but caused a run-time error when it was changed to |float|.
\ENDLOG

@<Define |Dodecahedron| functions@>=

   corner[0] = p[0].mediate(p[1], .125); 
   corner[1] = p[1].mediate(p[0], .125); 

   p[2] = p[1].mediate(p[0], .333);
   p[3] = corner[1];
   p[3].shift(0, 1);

   corner[2] = p[2];
   corner[2].rotate(corner[1], p[3], -60);

   p[2] = p[0].mediate(p[1], .333);
   p[3] = corner[0];
   p[3].shift(0, 1);

   corner[3] = p[2];
   corner[3].rotate(corner[0], p[3], 60);

   mid_pt[0] = corner[0].mediate(corner[1]);
   mid_pt[1] = corner[1].mediate(corner[2]);
   mid_pt[2] = corner[2].mediate(corner[3]);
   mid_pt[3] = corner[3].mediate(corner[0]);

   tab.set("--", true, &corner[0], &mid_pt[0], &corner[1], &mid_pt[1],
         &corner[2], &mid_pt[2], &corner[3], &mid_pt[3], static_cast<Point*>(0));

   tab_vector.push_back(tab);

@q ******* (7) First stitch line on |rpv[1]|.@>
@ First stitch line on |rpv[1]|.
@<Define |Dodecahedron| functions@>=

   if (do_stitch_lines)
   {

      stitch_line += "--";
      stitch_line += mid_pt[1];

      if (stitch_divisions > 1)
      {

          real r = 1.0 / stitch_divisions;

          for (real n =  r; n < 1.0; n += r)
          {
             stitch_line += mid_pt[1].mediate(mid_pt[3], n);
          }

      }  /* |if (stitch_divisions > 1)|  */

      stitch_line += mid_pt[3];

      stitch_line_vector.push_back(stitch_line);

}  /* |if (do_stitch_lines)|  */

@q ****** (6) Tabs and stitch lines 2 through 4 on |rpv[1]|.@>
@
@<Define |Dodecahedron| functions@>=

   p[0] = rpv[1]->get_center();
   p[1] = p[0];
   p[1].shift(0, 1);

   t.rotate(p[0], p[1], -72);

   for (int i = 1; i < 5; ++i)
   {
   
       tab *= t;

       if (do_stitch_lines)
       {
         stitch_line *= t;

         if (i == 2)
            continue;

         stitch_line_vector.push_back(stitch_line);
       }  

       tab_vector.push_back(tab);

   }  /* |for|  */


@q ****** (6) Tabs and stitch lines on |rpv[2]|.@>
@ Tabs and stitch lines on |rpv[2]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[1] = rpv[2]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);
   t.rotate(p[1], p[2], -72);

   u.rotate(q[2][0], q[2][1]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);
   tab *= u.inverse();

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
       stitch_line *= u.inverse();
   }

   t.reset();
   t.rotate(p[2], p[1], 72);


   tab *= t;

   if (do_stitch_lines)
     stitch_line *= t;

   for (int i = 2; i < 5; ++i)
   {   
       tab *= t;

       if (do_stitch_lines)
       {
         stitch_line *= t;

         stitch_line_vector.push_back(stitch_line);
       }  

       tab_vector.push_back(tab);

   }  /* |for|  */


@q ****** (6) Tabs and stitch lines on |rpv[3]|.@>
@ Tabs and stitch lines on |rpv[3]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[3]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], 144);

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
     
       stitch_line_vector.push_back(stitch_line);

   }

   t.reset();
   t.rotate(p[2], p[1], 72);

   for (int i = 2; i < 4; ++i)
   {
   
       tab *= t;

       if (do_stitch_lines)
       {
         stitch_line *= t;

         stitch_line_vector.push_back(stitch_line);
       }  

       tab_vector.push_back(tab);

   }  /* |for|  */

   u.reset();

   u.rotate(q[3][0], q[3][4]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   tab *= u.inverse();

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
     
       stitch_line_vector.push_back(stitch_line);

       stitch_line *= u.inverse();

   }

@q ****** (6) Tabs and stitch lines on |rpv[4]|.@>
@ Tabs and stitch lines on |rpv[4]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[4]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], 72);

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line_vector.push_back(stitch_line);
   }

   t.reset();
   t.rotate(p[2], p[1], 72);

   for (int i = 1; i < 3; ++i)
   {
   
       tab *= t;

       tab_vector.push_back(tab);

       if (do_stitch_lines)
       {
         stitch_line *= t;

         stitch_line_vector.push_back(stitch_line);
       }  


   }  /* |for|  */

   u.reset();

   u.rotate(q[4][3], q[4][4]); 

   tab *= t;
   tab *= u;


   tab_vector.push_back(tab);

   tab *= u.inverse();

   if (do_stitch_lines)
   {
     stitch_line *= t;
     stitch_line *= u;
     
     stitch_line_vector.push_back(stitch_line);

     stitch_line *= u.inverse();

   }  

@q ****** (6) Tabs and stitch lines on |rpv[5]|.@>
@ Tabs and stitch lines on |rpv[5]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[5]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], -144);

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line_vector.push_back(stitch_line);
   }

   t.reset();
   t.rotate(p[2], p[1], 72);

   tab *= t;

   u.reset();

   u.rotate(q[5][2], q[5][3]);

   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;

       stitch_line_vector.push_back(stitch_line);
   }  


   tab *= t;
   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= t;

       stitch_line_vector.push_back(stitch_line);
   }  


@q ****** (6) Tabs and stitch lines on |rpv[7]|.@>
@ Tabs and stitch lines on |rpv[7]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[7]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], -108);

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line_vector.push_back(stitch_line);
   }

   t.reset();

   t.rotate(p[1], p[2], -72);

   u.reset();

   u.rotate(q[7][1], q[7][2]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
      stitch_line *= t;
      stitch_line *= u;
      stitch_line_vector.push_back(stitch_line);
   }

   tab *= t;
   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
      stitch_line *= t;
      stitch_line *= t;
      stitch_line_vector.push_back(stitch_line);
   }

   u.reset();

   u.rotate(q[7][4], q[7][0]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
      stitch_line *= t;
      stitch_line *= u;
      stitch_line_vector.push_back(stitch_line);
   }

@q ****** (6) Tabs and stitch lines on |rpv[8]|.@>
@ Tabs and stitch lines on |rpv[8]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[8]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   tab *= t;

   if (do_stitch_lines)
      stitch_line *= t;

   t.reset();

   t.rotate(p[2], p[1], 72);

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line_vector.push_back(stitch_line);
   }

   tab *= t;
   tab *= t;

   u.reset();
   u.rotate(q[8][2], q[8][3]);

   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }

   u.reset();
   u.rotate(q[8][3], q[8][4]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }

   tab *= t;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line_vector.push_back(stitch_line);
   }

@q ****** (6) Tabs and stitch lines on |rpv[9]|.@>
@ Tabs and stitch lines on |rpv[9]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[9]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], 144);

   u.reset();
   u.rotate(q[9][2], q[9][1]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }

   t.reset();
   t.rotate(p[2], p[1], 72);

   u.reset();
   u.rotate(q[9][2], q[9][3]);

   tab *= t;
   tab *= u;
  
   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }

   for (int i = 0; i < 2; ++i)
   {   
      tab *= t;
  
      tab_vector.push_back(tab);

      if (do_stitch_lines)
      {
          stitch_line *= t;
          stitch_line_vector.push_back(stitch_line);
      }  
   }

@q ****** (6) Tabs and stitch lines on |rpv[10]|.@>
@ Tabs and stitch lines on |rpv[9]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[10]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], 72);


   u.reset();
   u.rotate(q[10][0], q[10][1]);

   
   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }
   
   t.reset();
   t.rotate(p[2], p[1], 72);

   u.reset();
   u.rotate(q[10][1], q[10][2]);

   tab *= t;
   tab *= u;

   tab_vector.push_back(tab);

   if (do_stitch_lines)
   {
       stitch_line *= t;
       stitch_line *= u;
       stitch_line_vector.push_back(stitch_line);
   }


   for (int i = 0; i < 2; ++i)
   {
       tab *= t;

       tab_vector.push_back(tab);

       if (do_stitch_lines)
       {
           stitch_line *= t;
           stitch_line_vector.push_back(stitch_line);
       }   

   }  /* |for|  */


@q ****** (6) Tabs and stitch lines on |rpv[11]|.@>
@ Tabs and stitch lines on |rpv[11]|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   p[0] = p[1];
   p[1] = rpv[11]->get_center();
   p[2] = p[1];
   p[2].shift(0, 1);
 
   t.reset();
   t.shift(p[1] - p[0]);

   t.rotate(p[2], p[1], 144);

   tab *= t;

   stitch_line *= t;

   t.reset();

   t.rotate(p[2], p[1], 72);
   
   for (int i = 0; i < 4; ++i)
   {
      tab *= t;

      if (do_stitch_lines)
      {
          stitch_line *= t;

          if (i == 2)
            continue;

         stitch_line_vector.push_back(stitch_line);

      }

      tab_vector.push_back(tab);

   }  /* |for|  */

@q ****** (6)@>

@ Put |tab_vector| and |stitch_line_vector| onto |*pv|.
\initials{LDF 2007.10.16.}

@<Define |Dodecahedron| functions@>=

   *pv = tab_vector;
   *pv += stitch_line_vector;

   return static_cast<void*>(pv);

}  /* End of |Dodecahedron::get_tabs| definition.  */



@q **** (4) Version with required |void*| argument only.@>
@*3 Version with required {\bf void*} argument only.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Dodecahedron| functions@>=
static
void*
get_tabs(void* parameter);

@q ***** (5) Definition.@>
@ 
@<Define |Dodecahedron| functions@>=
void*
Dodecahedron::get_tabs(void* parameter)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

   real pentagon_diameter = 5;
   bool do_half = false;
   bool do_stitch_lines = true;
   unsigned short stitch_divisions = 5;

   if (scanner_node->polyhedron_options)
   {
       pentagon_diameter = scanner_node->polyhedron_options->polygon_0_diameter;
       do_half = scanner_node->polyhedron_options->do_half;
       do_stitch_lines = scanner_node->polyhedron_options->do_stitch_lines;
       stitch_divisions = scanner_node->polyhedron_options->stitch_divisions;

       delete scanner_node->polyhedron_options;
       scanner_node->polyhedron_options = 0;

   }

   return get_tabs(pentagon_diameter, 
                   do_half, 
                   do_stitch_lines, 
                   stitch_divisions, 
                   parameter);

}  /* End of |Dodecahedron::get_tabs(void* parameter)| definition.  */


@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Dodecahedron}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Dodecahedron| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.  Following a system update, having |Shape*| 
as the return value no longer worked.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Dodecahedron| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;


@q ** (2) Definition.@>

@
@<Define |Dodecahedron| functions@>=
int
Dodecahedron::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const


{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);


@q *** (3).@> 

  Dodecahedron* dodecahedron_reflection = static_cast<Dodecahedron*>(v);  

@q *** (3) If |dodecahedron_reflection == static_cast<Dodecahedron*>(0)|, @>
@q *** (3) try to allocate memory on the free store for it.               @> 

@ If |dodecahedron_reflection == static_cast<Dodecahedron*>(0)|, 
try to allocate memory on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Dodecahedron| functions@>=

 if (dodecahedron_reflection == static_cast<Dodecahedron*>(0))
 {
  try
     {
       dodecahedron_reflection = create_new<Dodecahedron>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Dodecahedron| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Dodecahedron| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>=


  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Dodecahedron::reflect_in()':" 
                 << endl
                 << "`create_new<Dodecahedron>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

       
     } /* |catch (bad_alloc)|  */

  
@q *** (3).@> 

  } /* |if (dodecahedron_reflection == static_cast<Dodecahedron*>(0))|  */

@q *** (3) Call |Polyhedron::reflect_in()|.@> 

@ Call |Polyhedron::reflect_in()|.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>=

  Polyhedron polyhedron_reflection;

  int status;


  try
     {
       status = Polyhedron::reflect_in(p,
                            static_cast<void*>(&polyhedron_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Polyhedron::reflect_in()| threw |bad_alloc|.@> 

@ Error handling:  |Polyhedron::reflect_in()| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Dodecahedron::reflect_in():'"
                 << endl 
                 << "`Polyhedron::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `dodecahedron_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete dodecahedron_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Polyhedron::reflect_in()| returned 1.@> 

@ Error handling:  |Polyhedron::reflect_in()| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Dodecahedron| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Dodecahedron::reflect_in():'"
                << endl 
                << "`Polyhedron::reflect_in()' failed and returned 1."
                << endl << "Deleting `dodecahedron_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete dodecahedron_reflection;

      return 1;

      
    }  /* |if (status == 1)|  */

@q **** (4) |Polyhedron::reflect_in()| succeeded.@> 

@ |Polyhedron::reflect_in()| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Dodecahedron::reflect_in()':"
                  << endl << "`Polyhedron::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   dodecahedron_reflection->Polyhedron::operator=(
                            polyhedron_reflection);

@q *** (3) Set other data members of |*dodecahedron_reflection|.@> 

@ Set other data members of |*dodecahedron_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>=

   dodecahedron_reflection->pentagon_radius = pentagon_radius; 

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Dodecahedron| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Dodecahedron::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Dodecahedron::reflect_in()| definition.  */



@q * (1) Putting |class Dodecahedron| together.@>
@ Putting {\bf class Dodecahedron} together.
@ This is what's compiled.
@c
@<Include files@>@;
@<Declare |class Dodecahedron|@>@;
@<Define |static const Dodecahedron| data members@>@;
@<Define |Dodecahedron| functions@>@;

@ This is what's written to \filename{ddchdrn.h}. 
@(ddchdrn.h@>=
@<Declare |class Dodecahedron|@>@;


@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>


@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>

