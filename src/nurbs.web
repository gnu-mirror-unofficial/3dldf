@q nurbs.web @>
@q Created by Laurence Finston Wed Jan 26 16:43:19 CET 2005 @>
      
@q * Copyright and License.@>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) |Nurbs|.@>
@** {\bf Nurbs}.\quad ({\tt nurbs\PERIOD web}).\hfil
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Created this file.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.
\initials{LDF 2005.01.26.}

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "gsltmplt.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"

@q * (1) class Nurb definition.@> 
@* |class Nurb| definition.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this |class| definition.

\initials{LDF 2005.03.23.}
Added |valarray <real> projective_extremes|.

\initials{LDF 2005.04.04.}
Added |valarray <real> world_extremes|.

\initials{LDF 2005.06.30.}
Added |valarray <real> pre_projective_extremes|.
\ENDLOG

@q ** (2) Definition.@> 

@<Define |class Nurb|@>=
class Nurb : public Shape
{

   vector<real*>  knots;
   vector<real*>  weights;
   vector<Point*> control_points;

   valarray <real> world_extremes;
   valarray <real> pre_projective_extremes;      
   valarray <real> projective_extremes;      

   public:
      @<Declare |Nurb| functions@>@;

@q *** (3) Dummy function definitions.@> 

@ Dummy function definitions.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.02.01.}
Changed the return value of |decompose| from |Pointer_Vector<Shape>*|
to |Pointer_Vector<Path>*|.  Removed the |unsigned short level|
argument and the default for the |const Path* p| argument.

\initials{LDF 2005.02.01.}
Made the |Path*| argument of |decompose| non-|const| and
added optional |Scanner_Node scanner_node| argument 
with default 0.

\initials{LDF 2005.03.23.}
Added optional |Scanner_Node scanner_node| argument to |set_extremes| 
with default 0.

\initials{LDF 2005.03.23.}
Changed the return value of |get_extremes| 
from |const valarray <real>| to |const valarray <real>&|, 
i.e., I've made it a reference.

\initials{LDF 2005.04.04.}
Changed the name of |set_extremes| to 
|set_projective_extremes|.  Changed all references to it without comment.

\initials{LDF 2005.04.04.}
Changed the name of |get_extremes| to 
|get_projective_extremes|.  Changed all references to it without comment.

\initials{LDF 2005.04.04.}
Added the functions |set_world_extremes| and |get_world_extremes|.

\initials{LDF 2005.04.04.}
Removed the definition of |decompose(Path*, Scanner_Node)| to its own section.

\initials{LDF 2005.04.19.}
Added dummy definitions for 
|get_minimum_x|, |get_maximum_x|, |get_mean_x|, |get_minimum_y|, 
|get_maximum_y|, and |get_mean_y|.

\initials{LDF 2005.06.30.}
Added dummy definitions for |set_pre_projective_extremes| 
and |get_pre_projective_extremes|.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument to
|get_minimum_x|, |get_maximum_x|,
|get_mean_x|, |get_minimum_y|,
|get_maximum_y|, |get_mean_y|,
|get_minimum_z|, |get_maximum_z|, and |get_mean_z|.
The default is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
This argument isn't used in these functions yet.
\ENDLOG 

@q **** (4) Code.@>   

@<Define |class Nurb|@>=

  virtual Shape* get_copy(void) const  {return 0;}
  virtual void clear(void) {return;}
  virtual void output(Scanner_Node) {return;}
  virtual vector<Shape*> extract(const Focus&,
                                 const unsigned short proj,
                                 real factor) {vector<Shape*> v;  return v;}

  virtual Transform rotate(const real, const real, const real) 

   {Transform t;  t.reset(); return t;}

  virtual Transform scale(real, real, real) 
     {Transform t;  t.reset(); return t;}

  virtual Transform shear(real xy, real xz, real yx, real yz, 
                          real zx, real zy) 
     {Transform t;  t.reset(); return t;}

  virtual Transform shift(real, real, real) 
     {Transform t;  t.reset(); return t;}
  
  virtual Transform rotate(const Point&, const Point&,
                                  const real) 
     {Transform t;  t.reset(); return t;}

  virtual Transform operator*=(const Transform&) 
   {Transform t;  t.reset(); return t;}

  virtual void apply_transform(void) {return;}

  virtual int reflect_in(const Plane&,
                         void*,
                         const Scanner_Node = 0) const {return 0;}

  virtual bool set_pre_projective_extremes(Scanner_Node scanner_node = 0) 
     {return true;}

  virtual bool set_projective_extremes(Scanner_Node scanner_node = 0) {return true;}

  virtual bool set_world_extremes(Scanner_Node scanner_node = 0) {return true;}

  virtual real get_minimum_x(const unsigned short s 
                                = Shape::PROJECTIVE_COORDINATES_VALUE) 
                             const {return 0;}

  virtual real get_maximum_x(const unsigned short s 
                             = Shape::PROJECTIVE_COORDINATES_VALUE) 
                            const {return 0;}

  virtual real get_mean_x(const unsigned short s 
                          = Shape::PROJECTIVE_COORDINATES_VALUE) 
                         const {return 0;}

  virtual real get_minimum_y(const unsigned short s 
                                = Shape::PROJECTIVE_COORDINATES_VALUE) 
                             const {return 0;}

  virtual real get_maximum_y(const unsigned short s 
                             = Shape::PROJECTIVE_COORDINATES_VALUE) 
                            const {return 0;}

  virtual real get_mean_y(const unsigned short s 
                          = Shape::PROJECTIVE_COORDINATES_VALUE) 
                         const {return 0;}

  virtual real get_minimum_z(const unsigned short s 
                                = Shape::PROJECTIVE_COORDINATES_VALUE) 
                             const {return 0;}

  virtual real get_maximum_z(const unsigned short s 
                             = Shape::PROJECTIVE_COORDINATES_VALUE) 
                            const {return 0;}

  virtual real get_mean_z(const unsigned short s 
                          = Shape::PROJECTIVE_COORDINATES_VALUE) 
                         const {return 0;}

  virtual const valarray<real>& get_world_extremes(void) const 
    {return world_extremes;}

  virtual const valarray<real>& get_pre_projective_extremes(void) const 
    {return pre_projective_extremes;}

  virtual const valarray<real>& get_projective_extremes(void) const 
    {return projective_extremes;}

  virtual void suppress_output(void) {return;}

  virtual void unsuppress_output(void) {return;}

@q *** (3).@> 

};

@q * (1) |Nurb| functions.@> 
@* |Nurb| functions.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG

@q ** (2) Constructors and setting functions.@> 
@*1 Constructors and setting functions.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG

@q *** (3) Default constructor.@> 
@*2 Default constructor.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this function.

\initials{LDF 2005.03.18.}
Now setting |shape_type| to |Shape::NURB_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG

@<Declare |Nurb| functions@>=
Nurb(void);

@
@<Define |Nurb| functions@>=

Nurb::Nurb(void)
{

   shape_type = NURB_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   return;
}

@q ** (2) Destructor.@> 
@*1 Destructor.
\initials{LDF 2005.01.28.}

\LOG
\initials{LDF 2005.01.28.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
~Nurb(void);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
Nurb::~Nurb(void)
{
   for(vector<real*>::iterator iter = knots.begin();
       iter != knots.end();  
       ++iter)
       {
           delete *iter;
       }

   for(vector<real*>::iterator iter = weights.begin();
       iter != weights.end();  
       ++iter)
       {
           delete *iter;
       }

   for(vector<Point*>::iterator iter = control_points.begin();
       iter != control_points.end();  
       ++iter)
       {
           delete *iter;
       }

   knots.clear();
   weights.clear();
   control_points.clear();

   return;

} /* End of |Nurb::~Nurb(void)| definition.  */

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return NURB_TYPE;
}

@q * (1) Copy coordinates.@> 
@* Copy coordinates.
\initials{LDF 2005.04.09.}

\LOG
\initials{LDF 2005.04.09.}
Added this function.

\initials{LDF 2005.04.11.}
Removed the defaults for the |const char| 
arguments |from| and |to|.  Added the |Scanner_Node scanner_node| argument with
the default 0.

\initials{LDF 2005.04.15.}
Added the optional argument |bool set_z_to_zero| 
with the default |false|.
\ENDLOG

@<Declare |Nurb| functions@>=

virtual 
int 
copy_coords(const char from, 
            const char to, 
            bool set_z_to_zero = false,
            Scanner_Node scanner_node = 0);

@
@<Define |Nurb| functions@>=
int 
Nurb::copy_coords(const char from, 
                  const char to, 
                  bool set_z_to_zero,
                  Scanner_Node scanner_node)
{
   return 0;
}

@q ** (2) Functions for checking types.@> 
@*1 Functions for checking types.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this section.
\ENDLOG

@q *** (3) Is |Point|.@> 
@*2 Is {\bf Point}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_point(void) const
{
   return false;
}

@q *** (3) Is |Nurb|.@> 
@*2 Is {\bf Nurb}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_nurb(void) const
{
   return true;
}

@q *** (3) Is |Path|.@> 
@*2 Is {\bf Path}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_path(void) const
{
   return false;
}

@q *** (3) Is |Polygon|.@> 
@*2 Is {\bf Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_polygon(void) const
{
   return false;
}

@q *** (3) Is |Triangle|.@> 
@*2 Is {\bf Triangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_triangle(void) const
{
   return false;
}

@q *** (3) Is |Rectangle|.@> 
@*2 Is {\bf Rectangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_rectangle(void) const
{
   return false;
}

@q *** (3) Is |Reg_Polygon|.@> 
@*2 Is {\bf Reg\_Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_reg_polygon(void) const
{
   return false;
}

@q *** (3) Is |Ellipse|.@> 
@*2 Is {\bf Ellipse}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_ellipse(void) const
{
   return false;
}

@q ** (2) Is |Ellipse_Slice|.@> 
@*1 Is {\bf Ellipse\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_ellipse_slice(void) const
{
   return false;
}

@q *** (3) Is |Circle|.@> 
@*2 Is {\bf Circle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_circle(void) const
{
   return false;
}

@q ** (2) Is |Circle_Slice|.@> 
@*1 Is {\bf Circle\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_circle_slice(void) const
{
   return false;
}

@q ** (2) Is |Parabola|.@> 
@*1 Is {\bf Parabola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_parabola(void) const
{
   return false;
}

@q ** (2) Is |Hyperbola|.@> 
@*1 Is {\bf Hyperbola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_hyperbola(void) const
{
   return false;
}

@q ** (2) Is |Arc|-type.@> 
@*1 Is {\bf Arc}-type.
\initials{LDF 2007.10.13.}

\LOG
\initials{LDF 2007.10.13.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_arc_type(void) const
{
   return false;
}

@q ** (2) Is |Helix|.@> 
@*1 Is {\bf Helix}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_helix(void) const
{
   return false;
}

@q ** (2) Is |Helix_Slice|.@> 
@*1 Is {\bf Helix\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_helix_slice(void) const
{
   return false;
}

@q *** (3) Is |Solid|.@> 
@*2 Is {\bf Solid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_solid(void) const
{
   return false;
}

@q *** (3) Is |Solid_Faced|.@> 
@*2 Is {\bf Solid\_Faced}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_solid_faced(void) const
{
   return false;
}

@q *** (3) Is |Polyhedron|.@> 
@*2 Is {\bf Polyhedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_polyhedron(void) const
{
   return false;
}

@q ** (2) Is |Polyhedron_Slice|.@> 
@*1 Is {\bf Polyhedron\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_polyhedron_slice(void) const
{
   return false;
}

@q *** (3) Is |Cuboid|.@> 
@*2 Is {\bf Cuboid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cuboid(void) const
{
   return false;
}

@q ** (2) Is |Cuboid_Slice|.@> 
@*1 Is {\bf Cuboid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cuboid_slice(void) const
{
   return false;
}

@q *** (3) Is |Tetrahedron|.@> 
@*2 Is {\bf Tetrahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_tetrahedron(void) const
{
   return false;
}

@q *** (3) Is |Octahedron|.@> 
@*2 Is {\bf Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_octahedron(void) const
{
   return false;
}

@q *** (3) Is |Dodecahedron|.@> 
@*2 Is {\bf Dodecahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_dodecahedron(void) const
{
   return false;
}

@q *** (3) Is |Icosahedron|.@> 
@*2 Is {\bf Icosahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_icosahedron(void) const
{
   return false;
}

@q *** (3) Is |Trunc_Octahedron|.@> 
@*2 Is {\bf Trunc\_Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_trunc_octahedron(void) const
{
   return false;
}

@q ** (2) Is |Great_Rhombicosidodecahedron|.@> 
@*1 Is {\bf Great\_Rhombicosidodecahedron}.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_great_rhombicosidodecahedron(void) const
{
   return false;
}

@q ** (2) Is |Cone|.@> 
@*1 Is {\bf Cone}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cone(void) const
{
   return false;
}

@q ** (2) Is |Cone_Slice|.@> 
@*1 Is {\bf Cone\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cone_slice(void) const
{
   return false;
}

@q ** (2) Is |Cylinder|.@> 
@*1 Is {\bf Cylinder}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cylinder(void) const
{
   return false;
}

@q ** (2) Is |Cylinder_Slice|.@> 
@*1 Is {\bf Cylinder\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_cylinder_slice(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid|.@> 
@*1 Is {\bf Ellipsoid}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_ellipsoid(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid_Slice|.@> 
@*1 Is {\bf Ellipsoid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_ellipsoid_slice(void) const
{
   return false;
}

@q ** (2) Is |Sphere|.@> 
@*1 Is {\bf Sphere}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_sphere(void) const
{
   return false;
}

@q ** (2) Is |Sphere_Slice|.@> 
@*1 Is {\bf Sphere\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_sphere_slice(void) const
{
   return false;
}

@q ** (2) Is |Paraboloid|.@> 
@*1 Is {\bf Paraboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_paraboloid(void) const
{
   return false;
}

@q ** (2) Is |Hyperboloid|.@> 
@*1 Is {\bf Hyperboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
bool
is_hyperboloid(void) const
{
   return false;
}

@q * (1) Functions for checking integrity of form.@> 
@* Functions for checking integrity of form.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this section.
\ENDLOG

@q ** (2) Is whatever.@>
@*1 Is whatever. 
@^\cfunc{Nurb}{is\_whatever}@>
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
bool
is_whatever(Scanner_Node scanner_node = 0,
            real tolerance = Shape::DEFAULT_TOLERANCE) const;

@
@<Define |Nurb| functions@>=

bool
Nurb::is_whatever(Scanner_Node scanner_node,
                  real tolerance) const
{
  return true;
}

@q * (1).@> 

@q ** (2) Set |surface_hiding_ctr|.@> 
@*1 Set {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
void
set_surface_hiding_ctr(unsigned long u)
{
   surface_hiding_ctr = u;
}

@q ** (2) Reset |surface_hiding_ctr|.@> 
@*1 Reset {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
unsigned long
reset_surface_hiding_ctr(unsigned long u = 0)
{
   unsigned long old_value = surface_hiding_ctr;
   surface_hiding_ctr = u;
   return old_value;
}

@q ** (2) Get |surface_hiding_ctr|.@> 
@*1 Get {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
unsigned long
get_surface_hiding_ctr(void)
{
   return surface_hiding_ctr;
}

@q ** (2) Set |decomposition_level|.@> 
@*1 Set {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
void
set_decomposition_level(unsigned long u)
{
   decomposition_level = u;
}

@q ** (2) Reset |decomposition_level|.@> 
@*1 Reset {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
unsigned long
reset_decomposition_level(unsigned long u = 0)
{
   unsigned long old_value = decomposition_level;
   decomposition_level = u;
   return old_value;
}

@q ** (2) Get |decomposition_level|.@> 
@*1 Get {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Nurb| functions@>=
virtual
inline
unsigned long
get_decomposition_level(void)
{
   return decomposition_level;
}

@q ** (2) Decompose.@> 
@*1 Decompose.
LDF 2005.04.01.

\LOG
\initials{LDF 2005.04.01.}
Added this section.
\ENDLOG

@q *** (3) |Path*| argument.@> 
@*2 |Path*| argument.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.04.04.}
Added this section and moved this function to it from 
|@<Declare |Nurb| functions@>|.
Made the |Path*| argument and this function itself |const|.

\initials{LDF 2005.04.05.}
Made the |Path*| argument, and this function itself, non-|const| again.
\ENDLOG

@q **** (4) Declaration.@>   

@<Declare |Nurb| functions@>=

virtual 
Pointer_Vector<Path>* 
decompose(Path* p, Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>   

@
@<Define |Nurb| functions@>=
Pointer_Vector<Path>* 
Nurb::decompose(Path* p, Scanner_Node scanner_node)  
{
   return 0;
}

@q *** (3) |Shape*| argument.@> 
@*2 {\bf Shape*} argument.
\initials{LDF 2005.04.01.}

\LOG
\initials{LDF 2005.04.01.}
Added this function.  Currently, it returns 0 immediately.

\initials{LDF 2005.04.04.}
Made the |Shape*| argument, and this function itself, |const|.

\initials{LDF 2005.04.05.}
Made the |Shape*| argument, and this function itself, non-|const| again.
\ENDLOG

@<Declare |Nurb| functions@>=

virtual 
Pointer_Vector<Shape>* 
decompose(Shape* s, Scanner_Node scanner_node = 0);

@
@<Define |Nurb| functions@>=
Pointer_Vector<Shape>*
Nurb::decompose(Shape* s, Scanner_Node scanner_node) 
{
   return 0;
}

@q *** (3) Self-decomposition:  |unsigned short| argument.@> 
@*2 Self-decomposition:  {\bf unsigned short} argument.
\initials{LDF 2005.04.10.}

\LOG
\initials{LDF 2005.04.10.}
Added this function.  Currently, it returns 0 immediately.

\initials{LDF 2005.04.14.}
Changed the arguments to this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual
Pointer_Vector<Shape>*
decompose(const unsigned short limit, 
          const bool use_rectangles = false,
          Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>   

@
@<Define |Nurb| functions@>=
Pointer_Vector<Shape>*
Nurb::decompose(const unsigned short limit, 
                const bool use_rectangles,
                Scanner_Node scanner_node)
{
   return 0;

}  /* End of |Pointer_Vector<Shape>*
              Nurb::decompose(const unsigned short limit, 
                              const bool use_rectangles,
                              Scanner_Node scanner_node)|
      definition.  */

@q ** (2) Appending elements.@> 
@*1 Appending elements.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG

@q *** (3) Appending |Points|.@> 
@*2 Appending {\bf Points}.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
void 
operator+=(Point* p);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
void 
Nurb::operator+=(Point* p)
{
   control_points.push_back(p);
}

@q *** (3) Appending knots and weights.@> 
@*2 Appending knots.
\initials{LDF 2005.01.27.}

\LOG
\initials{LDF 2005.01.27.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
int
append_knot_or_weight(real r, 
                      unsigned short knot_or_weight, 
                      Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
int
Nurb::append_knot_or_weight(real r, 
                            unsigned short knot_or_weight,
                            Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering `Nurb::append_knot_or_weight()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

   real* q;

   try 
      {
          q  = new real;
      }

@q **** (4) @>   

   catch (bad_alloc)
      {
          cerr_strm << thread_name 
                    << "ERROR!  In `Nurb::append_knot_or_weight()':"
                    << endl << "`new real' failed, throwing `bad_alloc'.  "
                    << "Rethrowing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          throw;

      } /* |catch (bad_alloc)|  */

@q **** (4) @>   

   *q = r;
  
   if (knot_or_weight == 0)
      knots.push_back(q);

   else if (knot_or_weight == 1)
      weights.push_back(q);

   else  /* Invalid value for |knot_or_weight|.  */
      {
          cerr_strm << thread_name 
                    << "WARNING!  In `Nurb::append_knot_or_weight()':"
                    << endl << "Invalid value for `knot_or_weight':  "
                    << knot_or_weight << endl << "Pushing " << r 
                    << " onto `knots'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          knots.push_back(q);

      }  /* |else| (Invalid value for |knot_or_weight|).  */
 
@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Exiting `Nurb::append_knot_or_weight()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

   return 0;

}  /* End of |Nurb::append_knot_or_weight| definition.  */

@q *** (3) Generate.@> 
@*2 Generate.
\initials{LDF 2005.01.27.}

\LOG
\initials{LDF 2005.01.27.}
Added this function.

\initials{LDF 2005.01.28.}
Changed |real oorder| argument to |real power|.

\initials{LDF 2005.01.28.}
Removed |void* nurb| argument.  It's not needed 
because it simply duplicated |this|.

\initials{LDF 2005.01.28.}
Moved the definition from this file (\filename{nurbs.web})
to \filename{paths.web}.  This was necessary in order to be able to
access |Path| functions, since |class Path| is an incomplete type in
this file.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
int
generate(Scanner_Node scanner_node,
         real power,
         real time,
         Path* p);

@q ** (2) Pushing |Colors|.@> 
@*1 Pushing {\bf Colors}.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this section.
\ENDLOG

@q *** (3) Push draw color.@>
@*1 Push draw color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual
int
push_draw_color(Color*& c, bool copy = true);

@q **** (4) Definition.@> 

@
@<Define |Nurb| functions@>=
int
Nurb::push_draw_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      d = c;

   c = 0;

   *draw_color_vector += d;

   return 0;

}  /* End of |Nurb::push_draw_color|  */

@q *** (3) Push fill color.@>
@*1 Push fill color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual
int
push_fill_color(Color*& c, bool copy = true);

@q **** (4) Definition.@> 

@
@<Define |Nurb| functions@>=
int
Nurb::push_fill_color(Color*& c, bool copy)
{
   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      d = c;

   c = 0;

   *fill_color_vector += d;

   return 0;

}  /* End of |Nurb::push_fill_color|  */

@q *** (3) Push color.@>
@*1 Push color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual
int
push_color(Color*& c, bool copy = true);

@q **** (4) Definition.@> 

@
@<Define |Nurb| functions@>=
int
Nurb::push_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   d = create_new<Color>(c);

   *draw_color_vector += d;

   if (copy == true)
      d = create_new<Color>(c);
   else
      d = c;

   *fill_color_vector += d;

   c = 0;

   return 0;

}  /* End of |Nurb::push_color|  */

@q ** (2) Push pen.@>
@*1 Push pen.
@^\cfunc{Nurb}{push\_pen}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
int 
push_pen(Pen*& p, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
int 
Nurb::push_pen(Pen*& p, bool copy)
{
   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      pen_vector = new Pointer_Vector<Pen>;

   Pen* q;

   if (copy == true)
      q = create_new<Pen>(p);

   else
     {
         q = p;
         p = 0;
     }

   *pen_vector += q;

   return 0;

}  /* End of |Nurb::push_pen| definition.  */

@q ** (2) Push dash_pattern.@>
@*1 Push {\bf Dash\_Pattern}.
@^\cfunc{Nurb}{push\_dash\_pattern}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
int 
push_dash_pattern(Dash_Pattern*& d, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
int 
Nurb::push_dash_pattern(Dash_Pattern*& d, bool copy)
{
   if (dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
      dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;

   Dash_Pattern* e;

   if (copy == true)
      e = create_new<Dash_Pattern>(d);

   else
     {
         e = d;
         d = 0;
     }

   *dash_pattern_vector += e;

   return 0;

}  /* End of |Nurb::push_dash_pattern| definition.  */

@q ** (2) Blending function.@> 
@*1 Blending function.
\initials{LDF 2005.01.28.}

\LOG
\initials{LDF 2005.01.28.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual
real
blending_func(unsigned int i, 
              unsigned int p, 
              real u,
              Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
real
Nurb::blending_func(unsigned int i, 
                    unsigned int p, 
                    real u,
                    Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering `Nurb::blending_func()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
    
@q **** (4) |p == 0U|.@>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`p' == " << p << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   if (p == 0U)
      {

@q ***** (5).@> 

          if (   u >= *(knots[i]) && u < *(knots[i + 1]) 
              && *(knots[i]) < *(knots[i + 1]))
             {
                
#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "In `Nurb::blending_func()' with `p' == " 
             << p << ":  Returning 1." << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
                return 1;
             }

@q ***** (5).@> 

          else
             {

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "In `Nurb::blending_func()': with `p' == " 
             << p << ":  Returning 0." << endl;

     }
#endif /* |DEBUG_COMPILE|  */@; 

                return 0;
             }

@q ***** (5).@> 

      }  /* |if (p == 0U)|  */

@q **** (4) |p != 0U|.@>   

   else  /* |p != 0U|  */
      {
          real coefficient_1;
          real coefficient_2;

          real value_1;
          real value_2;

          coefficient_1 = *(knots[i + p]) - *(knots[i]);
 
#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`coefficient_1' == " << coefficient_1 << endl;
     }
#endif /* |DEBUG_COMPILE|  */@;

if (coefficient_1 != ZERO_REAL)
             {
                coefficient_1 = (u - *(knots[i])) / coefficient_1;
                value_1 = coefficient_1 * blending_func(i, p - 1, u, scanner_node);
             }
          else
             value_1 = 0;

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`value_1' == " << value_1 << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

          coefficient_2 = *(knots[i + p + 1]) - *(knots[i + 1]);
 
#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`coefficient_2' == " << coefficient_2 << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

          if (coefficient_2 != ZERO_REAL)
             {
                coefficient_2 =  (*(knots[i + p + 1]) - u) / coefficient_2;
                value_2 = coefficient_2 * blending_func(i + 1, p - 1, u, scanner_node);
             }
          else 
             value_2 = 0;

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "In `Nurb::blending_func()': with `p' == " 
             << p << ":  Returning `value_1 + value_2' == " 
             << value_1 << " + " << value_2 << " == "
             << value_1 + value_2 << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

          return value_1 + value_2;

      }  /* |else| (|p != 0U|)  */

@q **** (4).@>

}  /* End of |Nurb::blending_func| definition.  */

@q ** (2) Show.@> 
@*1 Show.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this function.

\initials{LDF 2005.01.27.}
Corrected minor errors.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=
virtual 
void 
show(string text = "", char coords = 'w',
     const bool do_persp = true, const bool do_apply = true,
     Focus* f = 0, const unsigned short proj = 0,
     const real factor = 1) const;

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
void 
Nurb::show(string text, 
           char coords,
           const bool do_persp, 
           const bool do_apply,
           Focus* f, 
           const unsigned short proj,
           const real factor) const
{
   if (text == "")
      text = "Nurb:";

   cerr << text << endl << "Control points:" << endl;

   int i = 0;
   stringstream s;

@q **** (4) @>   

   for (vector<Point*>::const_iterator iter = control_points.begin();
        iter != control_points.end();
        ++iter)
      {
          s << "Point " << i++ << ":";
          (**iter).show(s.str());
          s.str("");
      }

@q **** (4) @>   

   i = 0;

   cerr << "`knots.size()' == " << knots.size() << endl;

   for (vector<real*>::const_iterator iter = knots.begin();
        iter != knots.end();
        ++iter)
      {
          cerr << "Knot " << i++ << ":  " << **iter << endl;
        
      }
      
@q **** (4) @>   

   i = 0;

   cerr << "`weights.size()' == " << weights.size() << endl;

   for (vector<real*>::const_iterator iter = weights.begin();
        iter != weights.end();
        ++iter)
      {
          cerr << "Weight " << i++ << ":  " << **iter << endl;
      }

@q **** (4) @>   

}  /* End of |Nurb::show| definition.  */

@q ** (2) Enclosing Cuboids Intersect.@>
@*1 Enclosing Cuboids Intersect.
@^\cfunc{Nurb}{enclosing\_cuboids\_intersect}@>
\initials{LDF 2005.03.23.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.

\initials{LDF 2005.03.31.}
Changed the name of this function from |enclosing_prisms_intersect|
to |enclosing_cuboids_intersect|.

\initials{LDF 2005.04.01.}
Changed the return type of this function from |unsigned short|
to |Unsigned_Byte|.

\initials{LDF 2005.04.04.}
Added optional |Scanner_Node scanner_node| argument with default 0.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual 
Unsigned_Byte
enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=

Unsigned_Byte
Nurb::enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node)
{
   return 0;
}

@q ** (2) Intersection with |Shape|.@>
@*1 Intersection with |Shape|.
@^\cfunc{Nurb}{intersection}@>
\initials{LDF 2005.03.23.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Nurb| functions@>=

virtual 
Int_Void_Ptr
intersection(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=

Int_Void_Ptr
Nurb::intersection(Shape* s, Scanner_Node scanner_node)
{

   Int_Void_Ptr ivp;

   return ivp;
}

@q * (1) Projections intersect.@>  
@* Projections intersect.
@^\cfunc{Nurb}{projections\_intersect}@>
\initials{LDF 2005.04.11.}

\LOG
\initials{LDF 2005.04.11.}
Added this function.  Currently, it just returns 0 immediately.
\ENDLOG

@q ** (2) Declaration.@>  

@<Declare |Nurb| functions@>=
virtual 
Unsigned_Byte
projections_intersect(Shape* s,
                      Scanner_Node scanner_node = 0);

@q ** (2) Definition.@>  

@ 
@<Define |Nurb| functions@>=
Unsigned_Byte
Nurb::projections_intersect(Shape* s,
                            Scanner_Node scanner_node)
{
   return 0;
}

@q * (1) Putting |Nurbs| together.@>
@* Putting {\bf Nurbs} together.
  
@q ** (2).@> 

@ This is what's compiled.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG

@c
@<Include files@>@;
@<Define |class Nurb|@>@;
@<Define |Nurb| functions@>@;

@q ** (2).@> 

@ This is what's written to \filename{nurbs.h}.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG

@(nurbs.h@>=
@<Define |class Nurb|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 70))    @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
 
