%%%% sample0.ldf
%%%% Created by Laurence D. Finston (LDF) Thu Sep  2 13:40:59 CEST 2004

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing. 
%%%% Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation 

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version. 

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details. 

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html. 
  

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for the maintainer of 
%%%% GNU 3DLDF to send announcements to users. 
%%%% To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% Kreuzbergring 41 
%%%% D-37075 Goettingen 
%%%% Germany 

%%%% Laurence.Finston@gmx.de 


%% * (1) !! Now putting testing code in `sample1.ldf', since this 
%%       file has gotten so large.
%%       LDF 2007.08.19.

%% * (1) Beginning of 3DLDF code.

%% ** (2) Notes to myself.

%% !! TO DO:  Add missing rules for intersections of planar figures.
%%            LDF 2005.10.27.

%% 	      Add rule for `bool_point is_on_sphere sphere'.
%% 	      LDF 2005.10.29.

%% 	      Add rules for assigning planar figures to `path'.
%% 	      LDF 2005.10.30.

%% 	      Add rule for labeling `bool_points'.
%% 	      LDF 2005.10.30.

%% 	      Add `pickupdot_color'.
%% 	      LDF 2005.11.03.

%%            Add rule for finding intersection points of `Ellipse' and 
%%            `Polygon'.
%%            LDF 2005.11.03.

%%            Make it possible to pass a `pen' argument to `dotlabel'.
%%            LDF 2005.11.21.

%%            Add rules and functions for finding the intersections of
%%            objects with `circles' and `spheres'.
%%            LDF 2005.11.21.

%%            Add rules and functions for finding the intersections of
%%            `polygons' and `polyhedra'.
%%            LDF 2005.11.21.

%%            Find out why the same size pen has a different size, depending
%%            on whether I use verbatim MetaPost code to pick it up, or not.
%%            LDF 2005.11.21.

%%  	      URGENT!  See the "TODO" comment in `sctpfncs.web'.  I've changed
%%            the code I was using, so I may not get the warning anymore.
%%            (Working on `Cylinders'.)
%%            LDF 2006.11.06.

%% ** (2) Current sample code.

%% !! Now putting testing code in `sample1.ldf', since this 
%% file has gotten so large.
%% LDF 2007.08.19.

%% *** (3) Intersection of a `conic_section_lattices' and a linear `path'.
%%         LDF 2007.08.16.

ellipse e[];
point_vector pv;
conic_section_lattice c;
point p[];
bool_point_vector bpv;
path q[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3);

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25) e0;
p5 := get_point (19) e0;

%% **** (4) 

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

beginfig(1); 

draw e0;

draw_lattice c, .5;

dotlabel_lattice.top (c, .5)  with_text_color blue with_dot_color red;  

p0 := (-4, 0, -4);
p1 := (4, 0, 4);

q0 := p0 -- p1;

draw q0;

dotlabel.bot("$p_0$", p0);
dotlabel.top("$p_1$", p1);

q1 := get_hexagon c;
q2 := get_pentagon c;

draw q1 with_color red;
draw q2 with_color blue;

%% The `intersection_points' command can now be called,
%% but it doesn't find the intersection points yet.
%% Working on this.
%% 
%% The `conic_section_lattice' and `path' arguments can be used
%% in either order.
%%
%% LDF 2007.08.17.

%bpv := c intersection_points q0;
%bpv := q0 intersection_points c;

message "bpv:"; 
show bpv;

endfig with_projection parallel_x_z; 

end;


%% *** (3) Leave at end of code to be executed.

%% ** (2) Code that's not executed.


%% *** (3) Drawing and labelling `conic_section_lattices'.

%%         `label_lattice' and `dotlabel_lattice' now
%%         take the same arguments as the labelling commands for 
%%         other types.

%%         The command for drawing `conic_section_lattices', on the other hand,
%%         is fairly primitive and doesn't take all the arguments that
%%         the drawing commands for other types do.
%%         For example, there are no `pen', `color', or `dash_pattern' 
%%         arguments.
%%         LDF 2007.08.16.

ellipse e[];
point_vector pv;
conic_section_lattice c;
point p[];

%point A, B, C, D, E, F;

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3);

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25) e0;
p5 := get_point (19) e0;

%% **** (4) 

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

beginfig(1); 

draw e0;

p10 := get_approx_center c;
dotlabel.top("${\approx}M$", p10);

p11 := get_point_six c;

pickup pencircle scaled (.5mm, .5mm);

draw_lattice c, p11;

%% The `point' argument is optional.  If there is one, it is used as the `F'
%% point on the lattice.  Whether it is actually on the curve is _not_ checked!

%% In this variant, no parentheses are used.

%dotlabel_lattice.top c, p11  with_text_color blue with_dot_color red;  

%% In this variant, parentheses surround the `conic_section_lattice' and 
%% the `point'.

dotlabel_lattice.bot (c, p11) with_text_color green with_dot_color yellow;  

%% No parentheses are used with there is no `point' argument.

%dotlabel_lattice.rt  c        with_text_color cyan with_dot_color magenta;  

% **** (4) 

endfig with_projection parallel_x_z; 

end;

%% *** (3) Reversing vector-type objects (actually variables).
%%         Added code for reversing objects of all vector-types.
%%         I've tested a few and it seems to work.
%%         LDF 2007.08.16.

ellipse e[];

e0 := unit_ellipse scaled (5, 0, 3);

beginfig(1);
draw e0;

%% **** (4) numeric_vector

numeric_vector nv;

nv += .1;
nv += .2;
nv += .3;

message "nv before reversal:"; 
show nv;
message "nv0 before reversal:"; 
show nv0;

reverse nv;

message "nv after reversal:"; 
show nv;
message "nv0 after reversal:"; 
show nv0;


%% **** (4) transform_vector

transform_vector tv;

transform t[];

t0 := identity shifted (1, 0);
t1 := identity shifted (10, 0);
t2 := identity shifted (100, 0);

tv += t0;
tv += t1;
tv += t2;

message "tv before reversal:"; 
show tv;
message "tv0 before reversal:"; 
show tv0;

reverse tv;

message "tv after reversal:"; 
show tv;
message "tv0 after reversal:"; 
show tv0;


% **** (4) 

endfig with_projection parallel_x_z; 

end;

%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  
%% Traversing an ellipse.

%% Working on the `traverse' command.  It's now possible for the start value
%% to be greater than or equal to the end value.  In the latter case, a `point_vector'
%% containing a single `point' is returned.
%% LDF 2007.08.14.

%% It's now possible to reverse the order of the `points' on a `point_vector' 
%% by using the `reverse' command.  `reverse' can be called on other vector-type
%% objects (actually vector-type variables), but this doesn't work yet for any  
%% other types.  Instead, a warning is issued. 
%% LDF 2007.08.14.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E; %% The lattice points  
point F;             %% The point found using `get_point'
point X, Y, Z;       %% The intersection points


pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

string s;

ellipse e[];
%parabola e[];

point p[];

path q[];

conic_section_lattice c;

point_vector pv;
point_vector qv;

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (0, 0, .5) ;

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25) e0;
p5 := get_point (19) e0;

%% **** (4) 

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

%% **** (4) Figures

beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

A := get_lattice_point 0, c;
dotlabel.top("$A$", A); 

B := get_lattice_point 1, c;
dotlabel.urt("$B$", B); 

C := get_lattice_point 2, c;
dotlabel.top("$C$", C); 

D := get_lattice_point 3, c;
dotlabel.top("$D$", D); 

E := get_lattice_point 4, c;
dotlabel.top("$E$", E); 


numeric_vector nv;

nv += .1;
nv += .2;

reverse nv;  

%% It now works to have the start value greater than the end value.
%% LDF 2007.08.14.

qv := traverse c (0, 1) with_increments (.1, .1);  

%message "size qv:"; 
%show size qv;

%message "qv:"; 
%show qv;

%message "D"; 
%show D;

%message "last qv"; 
%show last qv;

for i = 0 upto (size qv - 1):
   dotlabel.bot((i), qv[i]) with_text_color red; 
endfor;

%message "qv";
%show qv;

reverse qv;  

for i = 0 upto (size qv - 1):
   dotlabel.top((i), qv[i]) with_text_color green; 
endfor;

clear qv; 

%% It also works to have the start value equal to the end value.
%% In this case, the `point_vector' will contain a single point.
%% LDF 2007.08.14.

qv := traverse c (.5, .5);

%dotlabel.urt("$0.5$", qv0) with_text_color blue;
                                                  
draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.


end;

%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  
%% Traversing a parabola.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E; %% The lattice points  
point F;             %% The point found using `get_point'
point X, Y, Z;       %% The intersection points


pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

string s;

%ellipse e[];
parabola e[];

point p[];

path q[];

conic_section_lattice c;

point_vector pv;
point_vector qv;

%% **** (4) Set parabola and initial points.

set e0 with_parameter 1 with_extent 12;
shift e0 (-5, 0);

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25)  e0;
p5 := get_point (19) e0;

%% **** (4) 

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

shift_lattice c, 1;

%% **** (4) Figures

beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

A := get_lattice_point 0, c;
dotlabel.top("$A$", A); 

B := get_lattice_point 1, c;
dotlabel.urt("$B$", B); 

C := get_lattice_point 2, c;
dotlabel.top("$C$", C); 

D := get_lattice_point 3, c;
dotlabel.top("$D$", D); 

E := get_lattice_point 4, c;
dotlabel.top("$E$", E); 


numeric_vector nv;

nv += .1;
nv += .2;

qv := traverse c (0, 4.5) with_increments (.1, .1);  %% This works, 
                                                     %% LDF 2007.08.14.
                                                   
                                                    

message "size qv:"; 
show size qv;

message "qv:"; 
show qv;

message "D"; 
show D;

message "last qv"; 
show last qv;

for i = 0 upto (size qv - 1):
   dotlabel.bot((i), qv[i]) with_text_color red; 
endfor;

draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;

%% *** (3) Leave at end of code to be executed.


%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  
%% Traversing an ellipse.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E; %% The lattice points  
point F;             %% The point found using `get_point'
point X, Y, Z;       %% The intersection points


pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

string s;

ellipse e[];

point p[];

path q[];

conic_section_lattice c;

point_vector pv;
point_vector qv;

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (0, 0, .5) ;

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25) e0;
p5 := get_point (19) e0;

%% **** (4) 

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

%% **** (4) Figures

beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

A := get_lattice_point 0, c;
dotlabel.top("$A$", A); 

B := get_lattice_point 1, c;
dotlabel.urt("$B$", B); 

C := get_lattice_point 2, c;
dotlabel.top("$C$", C); 

D := get_lattice_point 3, c;
dotlabel.top("$D$", D); 

E := get_lattice_point 4, c;
dotlabel.top("$E$", E); 


numeric_vector nv;

nv += .1;
nv += .2;

qv := traverse c (1, 5) with_increments (.2, .1, .5);  %% This seems to 
                                                       %% be working now.
                                                       %% LDF 2007.08.13.
                                                    

message "size qv:"; 
show size qv;

message "qv:"; 
show qv;

message "D"; 
show D;

message "last qv"; 
show last qv;

for i = 0 upto (size qv - 1):
   dotlabel.bot((i), qv[i]) with_text_color red; 
endfor;

draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;

%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E; %% The given points
point F;             %% The point found using `get_point'
point X, Y, Z;       %% The intersection points

point save_A, save_B, save_C, save_D, save_E;

bool_point bp;

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

ellipse e[];

point p[];

path q[];

conic_section_lattice c;

point label_pt;

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (0, 0, .5) ;

p0 := get_point (6)  e0;
p1 := get_point (11)  e0;
p2 := get_point (18) e0;
p3 := get_point (2) e0;
p4 := get_point (25)  e0;
p5 := get_point (19) e0;

%% **** (4) 

point_vector pv;

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

%shift_lattice c, 1;

%% **** (4) Set label point

label_pt := (0, 0, .5frame_h -1.5);

%% **** (4) Commands for labels

verbatim_metapost "verbatimtex \font\largebf=cmbx12 etex;";

%% **** (4) Figures


%% ***** (5) Figures 0 to 9

for i = 0 upto 9:

beginfig(i);

draw e0 with_pen path_pen;

A := get_point c with_increment 0;
B := get_point c with_increment 1;
C := get_point c with_increment 2;
D := get_point c with_increment 3;
E := get_point c with_increment 4;

if (i) == 0:
   F := A;
else:
      F := get_point c with_increment i / 10 with_no_shift;
fi;

pickup dot_pen;

dotlabel.llft("$A$", A) with_text_color red;
dotlabel.ulft("$B$", B) with_text_color red;
dotlabel.top("$C$", C) with_text_color red;
dotlabel.urt("$D$",  D) with_text_color red;
dotlabel.bot("$E$", E) with_text_color red;

label.llft("$A'$", A shifted (0, 0, -.5));
label.ulft("$B'$", B shifted (0, 0, .5));
label.top("$C'$",  C shifted (0, 0, .5));
label.urt("$D'$",  D shifted (.5, 0, .5));
label.bot("$E'$",  E shifted (0, 0, -.5));


dotlabel.bot("$F$", F) with_text_color red;


pickup path_pen;

draw A -- C;
draw B -- D;
draw B -- E;
draw E -- A;

draw C -- F;
draw F -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;


bp := (C -- F) intersection_point (B -- E);

Y := bp;

bp := (F -- D) intersection_point (E -- A);

if (i) == 0:
     Z := A;
else:
   Z := bp;
fi;

draw X -- Z with_color green;

pickup dot_pen;

dotlabel.ulft("$X$", X) with_dot_color blue;

dotlabel.urt("$Y$", Y) with_dot_color blue;

dotlabel.lrt("$Z$", Z) with_dot_color blue;

if false: 
if (i) == 0:
    s :=     "\vtop{\centerline{{\largebf The Braikenridge-Maclaurin Construction 3}}"
          &  "\vskip.5\baselineskip"
       	 &  "\centerline{Copyright {\copyright} 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation}"
       	 &  "\centerline{Author:  Laurence D. Finston}}"; 
    label(s, label_pt);
fi;
fi;

draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 
endfor;



%% ***** (5) Figures 10 to 19

save_A := A;
save_B := B;
save_C := C;
save_D := D;
save_E := E;

shift_lattice c, 1;

for i = 0 upto 9:

beginfig(10 + i);

draw e0 with_pen path_pen;

dotlabel.llft("$A$", save_A) with_text_color red;
dotlabel.ulft("$B$", save_B) with_text_color red;
dotlabel.top("$C$", save_C) with_text_color red;
dotlabel.urt("$D$",  save_D) with_text_color red;
dotlabel.bot("$E$", save_E) with_text_color red;


A := get_point c with_increment 0;
B := get_point c with_increment 1;
C := get_point c with_increment 2;
D := get_point c with_increment 3;
E := get_point c with_increment 4;

label.llft("$B'$", B shifted (0, 0, -.5));
label.ulft("$C'$", C shifted (0, 0, .5));
label.top("$D'$",  D shifted (0, 0, .5));
label.urt("$E'$",  E shifted (.5, 0, .5));
label.bot("$A'$",  A shifted (0, 0, -.5));


if (i) == 0:
   F := A;
else:
   F := get_point c with_increment i / 10;
fi;

dotlabel.bot("$F$", F) with_text_color red;

pickup path_pen;

draw A -- C;
draw B -- D;
draw B -- E;
draw E -- A;

draw C -- F;
draw F -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

bp := (C -- F) intersection_point (B -- E);


Y := bp;

bp := (F -- D) intersection_point (E -- A);

if (i) == 0:
   Z := F;
else:
   Z := bp;
fi;

draw X -- Z with_color green;

pickup dot_pen;

dotlabel.ulft("$X$", X) with_dot_color blue;

dotlabel.urt("$Y$", Y) with_dot_color blue;

dotlabel.lrt("$Z$", Z) with_dot_color blue;


draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 
endfor;

%% ***** (5) Figures 20 to 29

shift_lattice c, 1;

for i = 0 upto 9:

beginfig(20 + i);

draw e0 with_pen path_pen;

dotlabel.llft("$A$", save_A) with_text_color red;
dotlabel.ulft("$B$", save_B) with_text_color red;
dotlabel.top("$C$",  save_C) with_text_color red;
dotlabel.urt("$D$",  save_D) with_text_color red;
dotlabel.bot("$E$",  save_E) with_text_color red;

A := get_point c with_increment 0;
B := get_point c with_increment 1;
C := get_point c with_increment 2;
D := get_point c with_increment 3;
E := get_point c with_increment 4;


label.llft("$C'$", C shifted (0, 0, -.5));
label.ulft("$D'$", D shifted (0, 0, .5));
label.top("$E'$",  E shifted (0, 0, .5));
label.urt("$A'$",  A shifted (.5, 0, .5));
label.bot("$B'$",  B shifted (0, 0, -.5));



if (i) == 0:
   F := A;
else:
   F := get_point c with_increment i / 10;
fi;

dotlabel.bot("$F$", F) with_text_color red;

pickup path_pen;

draw A -- C;
draw B -- D;
draw B -- E;
draw E -- A;

draw C -- F;
draw F -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

bp := (C -- F) intersection_point (B -- E);


Y := bp;

bp := (F -- D) intersection_point (E -- A);

if (i) == 0:
   Z := F;
else:
   Z := bp;
fi;

draw X -- Z with_color green;

pickup dot_pen;

dotlabel.ulft("$X$", X) with_dot_color blue;

dotlabel.urt("$Y$", Y) with_dot_color blue;

dotlabel.lrt("$Z$", Z) with_dot_color blue;


draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 
endfor;

%% ***** (5) Figures 30 to 39

shift_lattice c, 1;

for i = 0 upto 9:

beginfig(30 + i);

draw e0 with_pen path_pen;

dotlabel.llft("$A$", save_A) with_text_color red;
dotlabel.ulft("$B$", save_B) with_text_color red;
dotlabel.top("$C$",  save_C) with_text_color red;
dotlabel.urt("$D$",  save_D) with_text_color red;
dotlabel.bot("$E$",  save_E) with_text_color red;

A := get_point c with_increment 0;
B := get_point c with_increment 1;
C := get_point c with_increment 2;
D := get_point c with_increment 3;
E := get_point c with_increment 4;


label.llft("$D'$", D shifted (0, 0, -.5));
label.ulft("$E'$", E shifted (0, 0, .5));
label.top("$A'$",  A shifted (0, 0, .5));
label.urt("$B'$",  B shifted (.5, 0, .5));
label.bot("$C'$",  C shifted (0, 0, -.5));

if (i) == 0:
   F := A;
else:
   F := get_point c with_increment i / 10;
fi;

dotlabel.bot("$F$", F) with_text_color red;

pickup path_pen;

draw A -- C;
draw B -- D;
draw B -- E;
draw E -- A;

draw C -- F;
draw F -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

bp := (C -- F) intersection_point (B -- E);


Y := bp;

bp := (F -- D) intersection_point (E -- A);

if (i) == 0:
   Z := F;
else:
   Z := bp;
fi;

draw X -- Z with_color green;

pickup dot_pen;

dotlabel.ulft("$X$", X) with_dot_color blue;

dotlabel.urt("$Y$", Y) with_dot_color blue;

dotlabel.lrt("$Z$", Z) with_dot_color blue;


draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 
endfor;


%% ***** (5) Figures 40 to 49

shift_lattice c, 1;

for i = 0 upto 9:

beginfig(40 + i);

draw e0 with_pen path_pen;

dotlabel.llft("$A$", save_A) with_text_color red;
dotlabel.ulft("$B$", save_B) with_text_color red;
dotlabel.top("$C$",  save_C) with_text_color red;
dotlabel.urt("$D$",  save_D) with_text_color red;
dotlabel.bot("$E$",  save_E) with_text_color red;

A := get_point c with_increment 0;
B := get_point c with_increment 1;
C := get_point c with_increment 2;
D := get_point c with_increment 3;
E := get_point c with_increment 4;


label.llft("$E'$", E shifted (0, 0, -.5));
label.ulft("$A'$", A shifted (0, 0, .5));
label.top("$B'$",  B shifted (0, 0, .5));
label.urt("$C'$",  C shifted (.5, 0, .5));
label.bot("$D'$",  D shifted (0, 0, -.5));

if (i) == 0:
   F := A;
else:
   F := get_point c with_increment i / 10;
fi;

dotlabel.bot("$F$", F) with_text_color red;

pickup path_pen;

draw A -- C;
draw B -- D;
draw B -- E;
draw E -- A;

draw C -- F;
draw F -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

bp := (C -- F) intersection_point (B -- E);


Y := bp;

bp := (F -- D) intersection_point (E -- A);

if (i) == 0:
   Z := F;
else:
   Z := bp;
fi;

draw X -- Z with_color green;

pickup dot_pen;

dotlabel.ulft("$X$", X) with_dot_color blue;

dotlabel.urt("$Y$", Y) with_dot_color blue;

dotlabel.lrt("$Z$", Z) with_dot_color blue;


draw frame with_pen pensquare scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z no_sort; 
endfor;

%% **** (4) End.

end;



%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  

%% `shift_lattice' and `get_point' now work for `conic_section_lattices'.
%% LDF 2007.08.07.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E, F;  %% The given points.

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

ellipse e[];

point p[];

path q[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (0, 0, .5) ;

p0 := get_point (0)  e0;
p1 := get_point (5)  e0;
p2 := get_point (10) e0;
p3 := get_point (15) e0;
p4 := get_point (22) e0;
p5 := get_point (25) e0;

%% **** (4) 

point_vector pv;

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

if false: % true
   dotlabel.bot(0, p0) with_text_color blue;
   dotlabel.bot(1, p1) with_text_color blue; 
   dotlabel.bot(2, p2) with_text_color blue; 
   dotlabel.bot(3, p3) with_text_color blue; 
   dotlabel.bot(4, p4) with_text_color blue; 
   dotlabel.bot(5, p5) with_text_color blue; 
fi;

conic_section_lattice c;

c := get_conic_section_lattice pv;

shift_lattice c, 1;

dotlabel.bot("$A$", get_point c with_increment 0) with_text_color red;
dotlabel.bot("$B$", get_point c with_increment 1) with_text_color red;
dotlabel.top("$C$", get_point c with_increment 2) with_text_color red;
dotlabel.rt("$D$", get_point c with_increment 3) with_text_color red;
dotlabel.bot("$E$", get_point c with_increment 4) with_text_color red;

%message "`c' before `get_point':";
%show c;

%% This works.
if true: % false
for i = 1 upto 50:
   p[i] := get_point c with_increment (i/10);
   drawdot p[i]  with_pen dot_pen with_color blue; 
endfor;
else:
    p[0] := get_point c with_increment  .5;
    p[1] := get_point c with_increment 1.5;
    p[2] := get_point c with_increment 2.5;
    p[3] := get_point c with_increment 3.5;
    p[4] := get_point c with_increment 4.5;

    dotlabel.lft("$p_0$", p0);
    dotlabel.lft("$p_1$", p1);
    dotlabel.lft("$p_2$", p2);
    dotlabel.lft("$p_3$", p3);
    dotlabel.lft("$p_4$", p4);
fi;

%message "`c' after `get_point':";
%show c;

point label_pt;

label_pt := (0, 0, .5frame_h -1.5);

verbatim_metapost "verbatimtex \font\largebf=cmbx12 etex;";


s :=     "\vtop{\centerline{{\largebf The Braikenridge-Maclaurin Construction 3}}"
      &  "\vskip.5\baselineskip"
      &  "\centerline{Copyright {\copyright} 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation}"
      &  "\centerline{Author:  Laurence D. Finston}}"; 

label(s, label_pt);

label_pt := (-.5frame_w + 1.5, 0, -.5frame_h + 1.75);

s :=    "\vbox{\leftline{The blue points on the ellipse are found by using the}" 
      & "\leftline{Braikenridge-Maclaurin construction with points $A$,}"
      & "\leftline{$B$, $C$, $D$, and $E$ as the ``lattice points''.}"
      & "\leftline{The lattice is shifted as the the ellipse is traversed.}}";

label.rt(s, label_pt);

draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;


%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  

%% "Rectifying" points now works.  This means arranging them in order about an
%% approximate center.  This is needed for `get_ellipse', `get_circle', 
%% `get_parabola', and `get_hyperbola'.
%% LDF 2007.07.29.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E, F;  %% The given points.

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

ellipse e[];

point p[];

path q[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (2, 0, 3) ;

A := get_point (0)  e0;
B := get_point (5)  e0;
C := get_point (10) e0;
D := get_point (15) e0;
E := get_point (22) e0;
F := get_point (25) e0;

%% **** (4) 

point_vector pv;

pv += A;
pv += C;  
pv += D;  
pv += B;  
pv += F;  
pv += E;  

beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

dotlabel.rt("$A$",   A) with_dot_color red;
dotlabel.rt("$B$",  B) with_dot_color red;
dotlabel.rt("$C$",  C) with_dot_color red;
dotlabel.rt("$D$",  D) with_dot_color red;
dotlabel.rt("$E$", E) with_dot_color red;
dotlabel.rt("$F$",  F) with_dot_color red;

label.urt(0, pv[0]) with_text_color red;
label.urt(1, pv[1]) with_text_color red;
label.urt(2, pv[2]) with_text_color red;
label.urt(3, pv[3]) with_text_color red;
label.urt(4, pv[4]) with_text_color red;
label.urt(5, pv[5]) with_text_color red;

%message "pv before rectification:"; 
%show pv;

rectify pv;

%message "pv after rectification:"; 
%show pv;

conic_section_lattice c;

c := get_conic_section_lattice pv with_test false;

message "c:";
show c;

conic_section_lattice_vector cv;

cv += c;

%message "cv:";
%show cv;


% b := are_on_conic_section pv;
% message "are_on_conic_section pv after culling:";
% show b; 

p0 := get_point (0, c) with_cycle_value 0;

p0 := get_lattice_point (0, c) with_cycle_value 1;


message "p0:"; 
show p0;


label.llft(0, pv[0]) with_text_color blue;
label.llft(1, pv[1]) with_text_color blue;
label.llft(2, pv[2]) with_text_color blue;
label.llft(3, pv[3]) with_text_color blue;
label.llft(4, pv[4]) with_text_color blue;
label.llft(5, pv[5]) with_text_color blue;


draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;





%% *** (3) Pascal's Theorem and Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 or 6 points.  

%% Got culling of `point_vectors' to work.
%% LDF 2007.07.27.

%% Working on the predicate `are_on_conic_section'.
%% LDF 2007.07.09.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

boolean b;

numeric i;
numeric j;

point A, B, C, D, E, F;  %% The given points.

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

ellipse e[];

point p[];

path q[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (15, 15, 15) shifted (1, 2, 3) ;

A := get_point (0)  e0;
B := get_point (5)  e0;
C := get_point (10) e0;
D := get_point (15) e0;
E := get_point (22) e0;
F := get_point (25) e0;

%% **** (4) 

point_vector pv;

pv += A;  
pv += A;  
pv += B;  
pv += B;  
pv += B;  
pv += C;  
pv += C;  
pv += D;  
pv += D;  
pv += E;  
pv += F;
pv += F;


beginfig(1);

draw e0 with_pen path_pen;

pickup dot_pen;

b := are_distinct A, A, A, B, B, C, D, E, F;

message "are_distinct (point list --- should be false):";
show b; 

b := are_distinct A, B, C, D, E, F;

message "are_distinct (point list --- should be true):";
show b; 

b := are_distinct pv;

b := are_on_conic_section pv;

message "are_distinct (pv) before culling:";
show b; 

message "are_on_conic_section pv after culling:";
show b; 

message "pv before culling:"; 
show pv;

cull pv;

message "pv after culling:"; 
show pv;

b := are_distinct pv;

message "are_distinct (pv) after culling:";
show b; 

b := are_on_conic_section pv;

message "are_on_conic_section pv after culling:";
show b; 

endfig with_projection parallel_x_z no_sort; 

end;





increment_value := 10;

%e1 := get_ellipse pv (increment_value);

%% **** (4) 

dotlabel.rt("$A$",   A) with_dot_color red;
dotlabel.top("$B$",  B) with_dot_color red;
dotlabel.top("$C$",  C) with_dot_color red;
dotlabel.lft("$D$",  D) with_dot_color red;
dotlabel.llft("$E$", E) with_dot_color red;
dotlabel.lrt("$F$",  F) with_dot_color red;


%% **** (4) 

draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;



%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 points.  

%% Example with a hyperbola.
%% LDF 2007.07.09.

%% This example shows that the Braikenridge-Mclaurin construction
%% works for hyperbolae when the five starting points are not on 
%% the same branch!
%%
%% However, it's not obvious how to figure out which points 
%% belong on which branch.
%%
%% This will have to go on my "TODO" list, because there are more
%% basic features that I have to implement.
%%
%% LDF 2007.07.09.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

numeric i;
numeric j;

point A, B, C, D, E;  %% The given points.

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

hyperbola h[];

point p[];

path q[];

%% **** (4) Set hyperbola and initial points.

set h0 with_parameter 1 with_extent 5;
%shift h0 (-5, 0);

message "size h0";
show size h0;

B := get_point (58)  h0;
C := get_point (10)  h0;
D := get_point (30) h0;
E := get_point (45) h0;
A := get_point (115) h0;

%% **** (4) 

point_vector pv;

pv += A;
pv += B;
pv += C;
pv += D;
pv += E;


beginfig(1);
draw h0 with_pen path_pen;

pickup dot_pen;

%% **** (4)

increment_value := 12;

h1 := get_hyperbola pv (increment_value);

message "size h1:";
show size h1;

border_value := 9;

 for i = 0 step 2 until size h1 - 1:
    s := "$p_{" & decimal (i) & "}$";
    p[i] := get_point (i) h1;
    if (xpart p[i] > -border_value) and (xpart p[i] < border_value)
       and (zpart p[i] > -border_value) and (zpart p[i] < border_value):
       dotlabel.rt(s, p[i]) with_dot_color blue;
    fi;
 endfor;

% message "h0:"; 
% show h0;

% message "h1:"; 
% show h1;

%% **** (4) 

dotlabel.lft("$A$", A) with_dot_color red;
dotlabel.lft("$B$", B) with_dot_color red;
dotlabel.lft("$C$", C) with_dot_color red;
dotlabel.lft("$D$", D) with_dot_color red;
dotlabel.lft("$E$", E) with_dot_color red;


%% **** (4) 

draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;

%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 points.  

%% Working on the C++ function.  
%% Example with a parabola works.
%% LDF 2007.07.03.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

numeric i;
numeric j;

point A, B, C, D, E;  %% The given points.

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);


string s;

parabola prb[];

%% **** (4) Set parabola and initial points.

set prb0 with_parameter 1 with_extent 12;
shift prb0 (-5, 0);

message "size prb0";
show size prb0;

B := get_point (0) prb0;
C := get_point (3) prb0;
D := get_point (10)  prb0;
E := get_point (22)  prb0;
A := get_point (26) prb0;

%% **** (4) 

point_vector pv;

pv += A;
pv += B;
pv += C;
pv += D;
pv += E;


beginfig(1);
draw prb0 with_pen path_pen;

pickup dot_pen;

dotlabel.lrt("$A$", A) with_dot_color red;
dotlabel.llft("$B$", B) with_dot_color red;
dotlabel.lft("$C$", C) with_dot_color red;
dotlabel.ulft("$D$", D) with_dot_color red;
dotlabel.top("$E$", E) with_dot_color red;

increment_value := 12;

prb1 := get_parabola pv (increment_value);

% draw A -- C with_pen path_pen dashed evenly;
% draw B -- D with_pen path_pen dashed evenly;
% draw A -- E with_pen path_pen dashed evenly;
% draw B -- E with_pen path_pen dashed evenly;

message "size prb1:";
show size prb1;

point p[];

for i = 0 upto 50:
   p[i] := get_point (i) prb1;
   drawdot p[i] with_color green with_pen dot_pen;
endfor;

for i = 0 step 10 until 50:
   s := "$p_{" & decimal (i) & "}$";
   p[i] := get_point (i) prb1;
   dotlabel.bot(s, p[i]) with_dot_color blue;
endfor;

%% **** (4) 

draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;

%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 points.  

%% Example with parabola.

%% LDF 2007.06.29.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

numeric i;
numeric j;

point A, B, C, D, E;  %% The given points.

point F;              %% determined below.

point p[];
point_vector pv;


point X;
point Y;
point Z;

path q[];

p0 := (5, 0);

bool_point bp;

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

macro_vector mv;

parabola prb;

%% **** (4) Set parabola and initial points.

set prb with_parameter 1 with_extent 12;
shift prb (-5, 0);

message "size prb";
show size prb;


%% **** (4) 

def mv {numeric sstart, numeric ccount, boolean bbool,
    point aa, point bb, point cc, point dd, point ee} +=


j := 0;

for i = (sstart + ccount - 1) downto sstart:
beginfig(i); 

draw prb;

dotlabel.bot("$A$", A);
dotlabel.bot("$B$", B);
dotlabel.lft("$C$", C);
dotlabel.top("$D$", D);
dotlabel.top("$E$", E);

draw A -- C dashed evenly;
draw B -- D dashed evenly;

q0 := A -- C;
q1 := B -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

dotlabel.top("$X$", X);

draw A -- E dashed evenly;
draw B -- E dashed evenly;

Z := mediate(A, E, (j / 10.0));

j += 1;

dotlabel.bot("$Z$", Z);

bp := (X -- Z) intersection_point (B -- E);

Y := bp;

dotlabel.bot("$Y$", Y);

%% **** (4) 

p0 := mediate (Z, X, 1.5);
p1 := mediate (X, Z, 1.5);

draw p0 -- p1 with_color green;

bp := (C -- Y) intersection_point (D -- Z);

F := bp;

dotlabel.top("$F$", F);

draw C -- F -- D with_color blue;


%% **** (4) 

draw frame;

endfig with_projection parallel_x_z;
endfor;
enddef;

%% **** (4) Figure 0.

A := get_point (20) prb;
B := get_point (15)  prb;
C := get_point (8)  prb;
D := get_point (2)  prb;
E := get_point (24) prb;

beginfig(0); 

draw prb;

dotlabel.bot("$A$", A);
dotlabel.bot("$B$", B);
dotlabel.lft("$C$", C);
dotlabel.top("$D$", D);
dotlabel.top("$E$", E);

draw A -- C dashed evenly;
draw B -- D dashed evenly;

q0 := A -- C;
q1 := B -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

dotlabel.top("$X$", X);

draw A -- E dashed evenly;
draw B -- E dashed evenly;

Z := mediate(A, E, (j / 10.0));

j += 1;

dotlabel.bot("$Z$", Z);

%% ***** (5) 

p0 := mediate (Z, X, 1.5);
p1 := mediate (X, Z, 1.5);

%draw p0 -- p1 with_color green;

draw C -- E -- D with_color blue;

%% **** (4) 

draw frame;

endfig with_projection parallel_x_z;

%% **** (4) Call macro. 

%% Points set above.  Don't currently need to be set here.

% A := get_point (20) prb;
% B := get_point (15)  prb;
% C := get_point (8)  prb;
% D := get_point (2)  prb;
% E := get_point (24) prb;

mv0 {1, 10, true, A, B, C, D, E};

E := get_point (20) prb;
A := get_point (15)  prb;
B := get_point (8)  prb;
C := get_point (2)  prb;
D := get_point (24) prb;

mv0 {11, 10, true, A, B, C, D, E};

D := get_point (20) prb;
E := get_point (15)  prb;
A := get_point (8)  prb;
B := get_point (2)  prb;
C := get_point (24) prb;

mv0 {21, 10, true, A, B, C, D, E};

C := get_point (20) prb;
D := get_point (15)  prb;
E := get_point (8)  prb;
A := get_point (2)  prb;
B := get_point (24) prb;

mv0 {31, 10, true, A, B, C, D, E};


%% **** (4) 

j := 0;

for i = 40 upto 45:

beginfig(i); 

draw prb;

dotlabel.bot("$A$", A);
dotlabel.bot("$B$", B);
dotlabel.lft("$C$", C);
dotlabel.top("$D$", D);
dotlabel.top("$E$", E);

draw A -- C dashed evenly;
draw B -- D dashed evenly;

q0 := A -- C;
q1 := B -- D;

bp := (A -- C) intersection_point (B -- D);

X := bp;

dotlabel.top("$X$", X);

draw A -- E dashed evenly;
draw B -- E dashed evenly;

Z := mediate(A, E, (j / 10.0));

j += -1;

dotlabel.bot("$Z$", Z);

bp := (X -- Z) intersection_point (B -- E);

Y := bp;

dotlabel.bot("$Y$", Y);

%% **** (4) 

p0 := mediate (Z, X, 1.1);
p1 := mediate (X, Z, 1.1);

draw p0 -- p1 with_color green;

bp := (C -- Y) intersection_point (D -- Z);

F := bp;

dotlabel.top("$F$", F);

draw C -- F -- D with_color blue;


%% **** (4) 

draw frame;

endfig with_projection parallel_x_z;
endfor;


end;

%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 points.  

%% Finished the C++ function.  I need to add error handling.

%% LDF 2007.06.26.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

numeric i;
numeric j;

point A, B, C, D, E;  %% The given points.

point F;              %% determined below.

point p[];


point X;
point Y;
point Z;

path q[];

p0 := (5, 0);

bool_point bp;

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

ellipse e[];

string s;

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (4, 0, 3);

A := get_point (15) e0;
B := get_point (11) e0;
C := get_point (8)  e0;
D := get_point (6)  e0;
E := get_point (4)  e0;

point_vector pv;

pv += A;
pv += B;
pv += C;
pv += D;
pv += E;

beginfig(1);
draw e0 with_pen path_pen;

pickup dot_pen;

dotlabel.lrt("$A$", A) with_dot_color red;
dotlabel.llft("$B$", B) with_dot_color red;
dotlabel.lft("$C$", C) with_dot_color red;
dotlabel.ulft("$D$", D) with_dot_color red;
dotlabel.top("$E$", E) with_dot_color red;

increment_value := 10;

e1 := get_ellipse pv (increment_value);


% draw A -- C with_pen path_pen dashed evenly;
% draw B -- D with_pen path_pen dashed evenly;
% draw A -- E with_pen path_pen dashed evenly;
% draw B -- E with_pen path_pen dashed evenly;

message "size e1:";
show size e1;

  for i = 0 upto (size e1 - 1):
     dotlabel.rt(i, get_point (i) e1);
  endfor;

%% **** (4) 

draw frame;

endfig with_projection parallel_x_z no_sort; 

%% **** (4) End.

end;

%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing a conic section from 5 points.  

%% This now works.

%% LDF 2007.06.26.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 16cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Declarations

numeric i;
numeric j;

point A, B, C, D, E;  %% The given points.

point F;              %% determined below.

point p[];
point_vector pv;


point X;
point Y;
point Z;

path q[];

p0 := (5, 0);

bool_point bp;

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pen path_pen;
path_pen := pencircle scaled (.7mm, .7mm);

macro_vector mv;

ellipse e;

%% **** (4) Set ellipse and initial points.

e := unit_ellipse scaled (4, 0, 3);

A := get_point (15) e;
B := get_point (11) e;
C := get_point (8)  e;
D := get_point (6)  e;
E := get_point (4)  e;

point axis[]; 

%% **** (4) Macro definitions.

%% ***** (5) Inner macro.

%% If the `boolean bbool' argument is `true', there are two images 
%% where `F' is at the same position as `B', `C', `D', and `E'.
%% LDF 2007.06.26.

def mv {numeric sstart, 
       	numeric ccount,
       	boolean bbool,
       	point aa, point bb, point cc, point dd, point ee} +=

numeric eend;

if bbool:
   eend := ccount;
else:
   eend := ccount - 1;
fi;

%% ****** (6)

for i = 0 upto eend:
beginfig(sstart + i);

pickup path_pen;

draw e;

pickup dot_pen;

dotlabel.rt("$A$", A) with_dot_color red;
dotlabel.bot("$B$", B) with_dot_color red;
dotlabel.lft("$C$", C) with_dot_color red;
dotlabel.top("$D$", D) with_dot_color red;
dotlabel.top("$E$", E) with_dot_color red;

%% ****** (6)

pickup path_pen;
draw aa -- cc dashed evenly;
draw bb -- dd dashed evenly;

bp := (aa -- cc) intersection_point (bb -- dd);

X := bp;

pickup dot_pen;

dotlabel.urt("$X$", X) with_dot_color red;

%% ****** (6)

pickup path_pen;

draw aa -- ee dashed evenly;
draw bb -- ee dashed evenly;

Z := mediate(aa, ee, (i / ccount));

pickup dot_pen;
dotlabel.bot("$Z$", Z) with_dot_color red;

bp := (X -- Z) intersection_point (bb -- ee);

Y := bp;

pickup dot_pen;

dotlabel.urt("$Y$", Y) with_dot_color red;

%% ****** (6)

pickup dot_pen;

dotlabel.urt("$Y$", Y) with_dot_color red;

p1 := mediate(Z, X, 1.5);

%dotlabel.bot("$p_1$", p1) with_dot_color red;

p2 := mediate(X, Z, 1.5);

%dotlabel.bot("$p_2$", p2) with_dot_color red;

draw p1 -- p2 with_color green with_pen path_pen;


%% ****** (6)

bp := (cc -- Y) intersection_point (dd -- Z);

F := bp;

pickup dot_pen;
dotlabel.llft("$F$", F) with_dot_color red;

pickup path_pen;

draw cc -- F with_color blue;
draw dd -- F with_color blue;

%% ****** (6)

pickup path_pen;
draw frame;

pickup path_pen;
draw frame;
endfig with_projection parallel_x_z no_sort; 
endfor;

%% ****** (6)

enddef;

%% ***** (5) Outer macro.  It calls the `mv0' (the "inner" macro).

def mv {numeric Sstart, 
        numeric Ccount, 
        boolean Bbool,
        point AA, point BB, point CC, point DD, point EE} +=

%% ****** (6)  First set of images.

  mv0 {Sstart, Ccount, Bbool, AA, BB, CC, DD, EE};  %% 0 -- 20 or 0 -- 19

%% ****** (6)  Second set of images.

  Sstart += Ccount;

  if Bbool:
     Sstart += 1;
     %% message "Incrementing `Sstart'.";
  % else:
  % message "Not incrementing `Sstart'.";
  fi;


%   message "`Sstart' before second set:";
%   show Sstart;

  mv0 {Sstart, Ccount, Bbool, EE, AA, BB, CC, DD}; %% 21 -- 41 or 20 -- 39

%% ****** (6) Third set of images.

  Sstart += Ccount;

  if Bbool:
     Sstart += 1;
     %% message "Incrementing `Sstart'.";
  % else:
  % message "Not incrementing `Sstart'.";
  fi;

%   message "`Sstart' before third set:";
%   show Sstart;

  mv0 {Sstart, Ccount, Bbool, D, E, A, B, C}; %% 42 -- 62 or 40 -- 59

%% ****** (6) Fourth set of images.

  Sstart += Ccount;

  if Bbool:
     Sstart += 1;
     %% message "Incrementing `Sstart'.";
  % else:
  % message "Not incrementing `Sstart'.";
  fi;

%   message "`Sstart' before fourth set:";
%   show Sstart;

  mv0 {Sstart, Ccount, Bbool, C, D, E, A, B}; %% 63 -- 83 or 60 -- 79

%% ****** (6) Fifth set of images.

  Sstart += Ccount;

  if Bbool:
     Sstart += 1;
     %% message "Incrementing `Sstart'.";
  % else:
  % message "Not incrementing `Sstart'.";
  fi;

%   message "`Sstart' before fifth set:";
%   show Sstart;

  mv0 {Sstart, Ccount, Bbool, B, C, D, E, A}; %% 84 -- 104 or 80 -- 99

  Sstart += Ccount;

%   message "`Sstart' after fifth set:";
%   show Sstart;

%% ****** (6) End of `mv1' definition.

enddef;

%% **** (4) Call outer macro.

%% If the third argument is `true', there are two images where `F' 
%% is at the same position as `B', `C', `D', and `E'.
%% LDF 2007.06.26.

mv1 {0, 30, true, A, B, C, D, E};
%mv1 {0, 20, false, A, B, C, D, E};

%% **** (4) End.

end;


%% *** (3) 


%% *** (3) Working on decomposition.
%%         LDF 2007.06.19.

%%         Decomposing a `path' using a `point'.
%%         LDF 2007.06.19.

focus f;
set f with_position (-3, 25, -20) 
   with_direction (-3, 25, 100) with_distance 20; 

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 22cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

point p[];
path q[];

transform t;

t := identity;

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm, 1.5mm);

picture save_picture;

beginfig(1); 

p0 := (-2, 3, -1);
p1 := (2, 2, 3);

q0 := p0 -- p1;

p2 := mediate(p0, p1);

draw q0;

label.lrt("$q_0$", p2);

p3 := mediate(p0, p1, 1/3); 

p4 := p3 shifted (0, 1);

dotlabel.ulft("$p_3$", p3);

dotlabel.top("$p_4$", p4);

path_vector pv;

message "Testing `p3' (on `path'):";
pv := q0 / p3;

message "Testing `p4' (not on `path'):";
pv := q0 / p4;

message "pv:";
show pv;

endfig with_focus f;

end;

%% *** (3) Started working on decomposition again.
%%         LDF 2007.06.19.

%%         Working on decomposing polygonal objects.
%%         Decomposing a `polygon-like' object using two `points'
%%         or a linear `path'.
%%         LDF 2007.06.19.

%%         Added parser rules for decomposing `reg_polygons'.
%%         LDF 2007.06.19.

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 16cm;
h := 22cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

point p[];
p0 := (-4, 0);
p1 := (4, 0);

reg_polygon rpoly;
rpoly := unit_pentagon scaled 3 rotated 90;

polygon_vector pv;
point_vector bpv;

path ppath;

transform t;

t := identity rotated (0, 0, 12);

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm, 1.5mm);

for i = 1 upto 31:
   beginfig(i); 
 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);

   ppath := (p0 -- p1);

   draw ppath;

   draw rpoly;

   %% pv := rpoly decompose (p0, p1);

   pv := rpoly decompose ppath;

   %% pv := rpoly / ppath;

   bpv := rpoly intersection_points ppath;


   if xpart p0 >= xpart p1:
      fill pv0 with_color red;
      fill pv1 with_color green;
      shift pv0 (0, -7);
      shift pv1 (0, 7);
      fill pv0 with_color red;
      fill pv1 with_color green;
   else:
      fill pv0 with_color green;
      fill pv1 with_color red;
      shift pv0 (0, 7);
      shift pv1 (0, -7);
      fill pv0 with_color green;
      fill pv1 with_color red;

   fi;

   drawdot bpv0 with_pen dot_pen;
   drawdot bpv1 with_pen dot_pen;

   draw frame;

   endfig with_projection parallel_x_y;

   clear pv;
   clear bpv;

   p0 *= p1 *= t;

endfor;
end;

%% *** (3) Cylinders.
%%         It is now possible to set, transform, and draw right circular
%%         and elliptical cylinders.  I'm still working on the 
%%         functions and rules for this type.
%%         LDF 2006.11.08.

%% Working on this again.  
%% LDF 2007.05.08.

verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

picture axis_picture;

point p[];
point axis_pt[];

focus f;
set f with_position (-3, 25, -20) 
   with_direction (-3, 25, 100) with_distance 20; 

%% **** (4) `axis_picture'.

pickup pencircle scaled (.75mm, .75mm);

axis_x_lft   := 10;
axis_x_rt    := 7.5;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 5;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0) on_picture axis_picture;
drawarrow origin -- (axis_x_rt, 0) on_picture axis_picture;

drawarrow origin -- (0, -axis_y_bot) on_picture axis_picture;
drawarrow origin -- (0, axis_y_top) on_picture axis_picture;


drawarrow origin -- (0, 0, -axis_z_front) on_picture axis_picture;
drawarrow origin -- (0, 0, axis_z_back) on_picture axis_picture;

axis_pt3 := (axis_x_rt, 0, 0);
label.bot("x", axis_pt3) axis_picture;

axis_pt4 := (0, axis_y_top, 0);
label.rt("y", axis_pt4) axis_picture;

axis_pt5 := (-.25, 0, axis_z_back);
label.lft("z", axis_pt5) axis_picture;

%% **** (4) 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);

cylinder c;

set c with_type elliptical with_axis_x 10 with_axis_z 3 with_axis_y 10 
   with_point_count 32 with_divisions 6 with_center origin;

%rotate c (90, 45);

%% with_center (1, 2, 3);

draw c with_color black;

p0 := get_center c;

%message "Center of c:";
%show p0;

dotlabel.urt("$c$", p0); 

p1 := get_base_center c;

%message "Center of base of c:";
%show p1;

dotlabel.lft("$b_c$", p1); 

p2 := get_cap_center c;

%message "Center of cap of c:";
%show p2;

dotlabel.urt("$c_c$", p2); 

output axis_picture with_focus f;
endfig with_focus f;

end; 





%% *** (3) Filldrawing a cuboid.
%%         LDF 2007.03.16.

verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

picture axis_picture;
picture save_picture;

point axis_pt[];

focus f;
set f with_position (10, -5, 2)
       with_direction (0, 2, 0)
       with_distance 100;

pickup pencircle scaled (.5mm, .5mm);

axis_y_rt    := 1;
axis_z_top   := 1;
axis_x_front := 1;

axis_pt0 := (axis_y_rt, 0, 0);
axis_pt1 := (0, axis_z_top, 0);
axis_pt2 := (0, 0, -axis_x_front);

drawarrow origin -- axis_pt0 on_picture axis_picture;
drawarrow origin -- axis_pt1 on_picture axis_picture;
drawarrow origin -- axis_pt2 on_picture axis_picture;

label.bot("", axis_pt0) axis_picture;
%label.rt("z", axis_pt1) axis_picture;
%label.lft("x", axis_pt2) axis_picture;

%pickup pencircle scaled (.1mm, .1mm);

beginfig(0);

cuboid c;
c := unit_cuboid;

rectangle r[];

for i = 0 upto 5:
   r[i] := get_rectangle (i) c;
%%   label(i, get_center r[i]);
endfor;

filldraw r0 with_draw_color blue with_fill_color green;
filldraw r2 with_draw_color blue with_fill_color green;
filldraw r4 with_draw_color blue with_fill_color green;

save_picture := current_picture;
clear current_picture;

output save_picture with_projection parallel_x_z;
output axis_picture with_projection parallel_x_z;

output save_picture with_focus f no_sort;

output axis_picture with_focus f no_sort;

endfig;

verbatim_metapost "end";

end;


%% *** (3) Filldrawing a cuboid.
%%         LDF 2007.03.14.

beginfig(1); 

color_vector cv;

cv += red;
cv += blue;
cv += green;
cv += yellow;
cv += cyan;
cv += magenta;

cuboid c;
rectangle r[];

c := unit_cuboid scaled (2, 3, 4) rotated (15, 15);

draw c;

%% Comment this out when you've found the faces you need.
%% LDF 2007.03.14.

for i = 0 upto 5:
   r[i] := get_rectangle (i) c;
   label(i, get_center r[i]);
endfor;

endfig no_sort;

beginfig(2); 
filldraw r[0] with_fill_color cv[0];
filldraw r[2] with_fill_color cv[2];
filldraw r[4] with_fill_color cv[4];
endfig no_sort; 

end;



%% *** (3) Find a circle given an arc.
%%         LDF 2007.03.01.

%% verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

%% **** (4) 


focus f;
set f with_position (-3, 15, -30) 
   with_direction (-3, 15, 100) with_distance 15; 

picture save_picture;

pickup pencircle scaled (.6mm, .6mm);

%% **** (4) 

pen_width := .75mm; 

w := 12cm;
h := 16cm;


frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

rad := 5;
circle circ;
point M;
point p[];

%% **** (4) 

beginfig(1); 

circ := unit_circle scaled (rad, 0, rad) rotated 90;

M := get_center circ;

dotlabel.bot("$M$", M);

draw circ;

p0 := (rad, 0)  rotated (0, 0, 45);
p1 := (-rad, 0) rotated (0, 0, -39);

dotlabel.rt("$p_0$", p0);
dotlabel.top("$p_1$", p1);

draw p0 -- p1;

p2 := mediate(p0, p1);
dotlabel.llft("$p_2$", p2);

bool_point_vector bpv;

bpv := circ intersection_points (M -- p2);

p3 := bpv[0];

dotlabel.top("$p_3$", p3);

p4 := mediate(p0, p3);

bpv := circ intersection_points (M -- p4);

p5 := bpv[1];

dotlabel.top("$p_5$", p5);

draw p3 -- p0;

draw M -- p5;
draw M -- p3;

a := magnitude (p3 - p2);
b := magnitude (p0 - p2);
c := magnitude (p0 - p3);

point A;
point B;
point C;
point D;

A := mediate (p3, p2);
B := mediate (p0, p2);
C := mediate (p0, p3);
D := mediate (p0, p3, .75);

label.lft("$a$", A); 
label.lrt("$b$", B); 
label.urt("$c$", C shifted (3mm, -1mm)); 
label.urt("$d$", D shifted (0mm, -.5mm)); 

alpha := arcsind (a / c);
beta  := arcsind (b / c);

% message "alpha:";
% show alpha;

% message "beta:";
% show beta;

label.lrt("$\beta$", p3 shifted (0, -1mm));

label.lft("$\alpha$", p0 shifted (-4mm, 1mm));

p6 := M shifted (.1, .5);

p7 := p6 shifted (.5, 0);

drawarrow p7 -- p6;
label.rt("$\delta = \alpha$", p7);

point R;
R := mediate(M, p3);
label.lft("$r$", R);

d := .5c;

r := d / sind alpha;

message "r:";
show r;

p8 := p0 rotated (0, 0, 67.5);
label.top("$q$", p8);

message "alpha:";
show alpha;

ang := (p0 - M) angle (p1 - M);
show ang;


draw frame;
endfig with_projection parallel_x_y;
end;

%% *** (3) Tangents to a circle.
%%         Find the tangents to a circle from a given point,
%%         coplanar to the circle.
%%         LDF 2007.02.06.

%% verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

%% **** (4) 


focus f;
set f with_position (-3, 15, -30) 
   with_direction (-3, 15, 100) with_distance 15; 

picture save_picture;

pickup pencircle scaled (.6mm, .6mm);

%% **** (4) 

pen_width := .75mm; 

w := 60cm;
h := 80cm;


frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

circle c;
point C;
point P;
point S[];
point T[];
point Q[];
bool_point_vector bpv;
point D[];

r := 5;

D0 := (-1.5r, 0, 0);
D1 := (1.5r, 0, 0);

c := unit_circle scaled (r, 0, r) rotated (90, 0);

C := get_center c;

%% **** (4) 

beginfig(0); 

draw c;

label.rt("$r$", (0, .5r));

P := C;

d := r + i;

shift P (0, d, 0);

draw D0 -- D1 dashed evenly;

dotlabel.top("$P = T$", P);
dotlabel.bot("$C$", C);

draw P -- C;

draw (-5, r, 0) -- (5, r, 0);

draw frame;
endfig with_projection parallel_x_y with_factor .25;

%% **** (4) 

for i = 1 step 1 until 30:
beginfig(i); 

draw c;

P := C;

d := r + i;

shift P (0, d, 0);

draw D0 -- D1 dashed evenly;

dotlabel.top("$P$", P);
dotlabel.bot("$C$", C);

draw P -- C;

label.rt("$d$", (0, .5d));

beta := arcsind (r / d );

% % message "beta:";
% % show beta;

S0 := C;

point normal;
normal := P shifted (0, 0, -1);

rotate_around S0 (P, normal) beta;

S1 := C;

rotate_around S1 (P, normal) -beta;

Q0 := 5 * unit_vector(S0 - P) shifted S0;

Q1 := 5 * unit_vector(S1 - P) shifted S1;

draw P -- Q0;
draw P -- Q1;

a := sqrt((d * d) - (r * r));

T0 := (a * unit_vector(Q0 - P)) shifted P;
T1 := (a * unit_vector (Q1 - P)) shifted P;

drawdot T0 withpen pencircle scaled (1mm, 1mm);
label.lft("$T_0$", T0 shifted (-.25, 0));
draw C -- T0;

label.llft("$r$", mediate(C, T0));
label.lrt("$r$", mediate(C, T1));


drawdot T1 withpen pencircle scaled (1mm, 1mm);
label.rt("$T_1$", T1 shifted (.25, 0));
draw C -- T1;

label.lft("$a$", mediate(T0, P));
label.rt("$a$", mediate(T1, P));


draw frame;
endfig with_projection parallel_x_y with_factor .25;
endfor;

%% **** (4) 

beginfig(31); 

draw c;
dotlabel.bot("$C$", C);

P := C;

d := r + 31;

draw D0 -- D1 dashed evenly;

drawarrow (-r, 0, 0) -- (-r, d, 0);
drawarrow (r, 0, 0) -- (r, d, 0);

label.lft("$d = \infty$", (-r, .5d, 0));
label.rt("$d = \infty$", (r, .5d, 0));

draw (-r, 0, 0) -- (r, 0, 0);

label.bot("$r$", (-.5r, 0, 0));
label.bot("$r$", (.5r, 0, 0));

draw frame;
endfig with_projection parallel_x_y with_factor .25;

%% **** (4) 

end;


%% ***** (5) 


% beginfig(2); 
% output save_picture with_projection parallel_x_z;
% endfig; 

% end;

%% *** (3) Trigonometric functions.
%%         Added code for the tangent, arcsine, arccosine, and arctangent
%%         functions.
%%         LDF 2007.02.06.

beginfig(1); 
drawdot origin;

message "arctand -1.57079:";
show arctand -1.57079;

message "arctand 1.57079:";
show arctand 1.57079;

% message "arctand 5:";
% show arctand 5;

message "arccosd 1:";
show arccosd 1;

message "arccosd .5:";
show arccosd .5;

% message "arccosd 5:";
% show arccosd 5;

message "arcsind 1:";
show arcsind 1;

message "arcsind .5:";
show arcsind .5;

% message "arcsind 5:";
% show arcsind 5;

a := tand 30;
message "tand 30:";
show a;

a := tand 45;
message "tand 45:";
show a;

a := tand 0;
message "tand 0:";
show a;

if is_valid a:
   message "a is valid.";
else:
   message "a isn't valid.";
fi;

% a := tand 90;
% message "tand 90:";
% show a;

% if is_valid a:
%    message "a is valid.";
% else:
%    message "a isn't valid.";
% fi;

endfig with_projection parallel_x_y no_sort;

end;


%% *** (3) Cones.
%%         The shadow of a double-napped cone.
%%         LDF 2006.11.09.

verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

focus f;
set f with_position (-3, 15, -30) 
   with_direction (-3, 15, 100) with_distance 15; 

picture save_picture;

pickup pencircle scaled (.75mm, .75mm);

%% **** (4) 

beginfig(1); 

%% ***** (5) 

cone c;

y_value := 16;

set c with_type circular with_type double_napped with_radius 10 with_axis_y y_value 
   with_point_count 32 with_divisions 6;

shift c(10, 0, 20);

rectangle r;

r := unit_rectangle scaled (100, 0, 100);
shift r (0, 0, 20);

%% ***** (5) 

point p[];
p0 := (1, 0, 0);
rotate p0(0, 0, 32);
rotate p0(0, 25);

p0 *= -1;

%% ***** (5) 

point q[];
path s[];

path proj[];


bool_point_vector bpv;

point apex[];

apex0 := get_apex c;


q0 := apex0;
q0 += p0 * 10;


s0 := apex0 -- q0;


bpv := s0 intersection_points r;

q2 := bpv0;
q3 := bpv1;



if not is_invalid q2:
  apex1 := q2;

else:
    if not is_invalid q3:
       apex1 := q3;
fi;
fi;


path cap;
path base;

cap  := get_cap c;
base := get_base c;

p1 := get_base_center c;
p2 := get_cap_center c;

message "base center:";
show p1;
message "cap center:";
show p2;

for i = 0 upto 31:
    q0 := get_point (i) cap;
    q4 := get_point (i) base;
    q1 := q0 + (p0 * 10);
    s0 := q0 -- q1;
    bpv := s0 intersection_points r;

    q2 := bpv0;
    q3 := bpv1;

    if not is_invalid q2:
       proj0 += q2;
       draw q4 -- apex1 -- q2;
    fi;

    if not is_invalid q3:
       proj0 += q3;
       draw q4 -- apex1 -- q3;
   fi;

endfor;

proj0 += ..;
proj0 += cycle;

draw proj0;




draw c;
%draw r;

%label("point light source:  angle $25^\circ$, elevation $32^\circ$", (5, 0, 0));

save_picture := current_picture;
endfig with_focus f no_sort; 

end;

beginfig(2); 
output save_picture with_projection parallel_x_z;
endfig; 

end;


%% *** (3) Cones.
%%         It's now possible to use single and double-napped 
%%         elliptical and circular.
%%         I still need to write many functions and parser rules for this 
%%         type, and for `cylinders', too.
%%         LDF 2006.11.09.

verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

picture axis_picture;
picture save_picture;

point p[];
point axis_pt[];

focus f;
set f with_position (-3, 15, -30) 
   with_direction (-3, 15, 100) with_distance 20; 

%% **** (4) `axis_picture'.

if true:
pickup pencircle scaled (.75mm, .75mm);

axis_x_lft   := 10;
axis_x_rt    := 7.5;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 5;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0) on_picture axis_picture;
drawarrow origin -- (axis_x_rt, 0) on_picture axis_picture;

drawarrow origin -- (0, -axis_y_bot) on_picture axis_picture;
drawarrow origin -- (0, axis_y_top) on_picture axis_picture;


drawarrow origin -- (0, 0, -axis_z_front) on_picture axis_picture;
drawarrow origin -- (0, 0, axis_z_back) on_picture axis_picture;

axis_pt3 := (axis_x_rt, 0, 0);
label.bot("x", axis_pt3) axis_picture;

axis_pt4 := (0, axis_y_top, 0);
label.rt("y", axis_pt4) axis_picture;

axis_pt5 := (-.25, 0, axis_z_back);
label.lft("z", axis_pt5) axis_picture;
fi;

%% **** (4) 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);

cone c;

bool b;

b := false;  % true

if b:

set c with_type circular with_type double_napped with_radius 5 with_axis_y 10 
   with_point_count 32 with_divisions 6;

else:

   set c with_type elliptical with_type double_napped with_axis_x 12 with_axis_z 7.5 with_axis_y 10 
      with_point_count 32 with_divisions 6;
fi

%rotate c (90, 0);

%% with_center (1, 2, 3);

% message "c:";
% show c;

draw c with_color black;

path_vector q;

color_vector cv;

cv += red;
cv += blue;
cv += green;

q += get_path 1 c;
q += get_path 8 c;
q += get_path 15 c;

draw q with_color_vector cv;


if false: 
q += get_base c;
q += get_cap c;

draw q0 with_color red;
draw q1 with_color blue;
fi; 

% circle k;

% k := get_circle 1 c;

% draw k with_color green;

if false: 
circle_vector k;
ellipse_vector e;

if b:
    k += get_circle 1 c;
    draw k0 with_color green;
 else:
     e += get_ellipse 1 c;
     draw e0 with_color green;
 fi;
fi;

%message "q0:";
%show q0;


save_picture := current_picture;

%output axis_picture with_focus f;
endfig with_focus f;

beginfig(2); 
output save_picture with_projection parallel_x_z;
endfig;;

end; 


%% *** (3) Cylinders.
%%         It is now possible to set, transform, and draw right circular
%%         and elliptical cylinders.  I'm still working on the 
%%         functions and rules for this type.
%%         LDF 2006.11.08.


verbatim_metapost "verbatimtex \magnification=\magstep3 etex";

picture axis_picture;

point p[];
point axis_pt[];

focus f;
set f with_position (-3, 25, -20) 
   with_direction (-3, 25, 100) with_distance 20; 

%% **** (4) `axis_picture'.

pickup pencircle scaled (.75mm, .75mm);

axis_x_lft   := 10;
axis_x_rt    := 7.5;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 5;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0) on_picture axis_picture;
drawarrow origin -- (axis_x_rt, 0) on_picture axis_picture;

drawarrow origin -- (0, -axis_y_bot) on_picture axis_picture;
drawarrow origin -- (0, axis_y_top) on_picture axis_picture;


drawarrow origin -- (0, 0, -axis_z_front) on_picture axis_picture;
drawarrow origin -- (0, 0, axis_z_back) on_picture axis_picture;

axis_pt3 := (axis_x_rt, 0, 0);
label.bot("x", axis_pt3) axis_picture;

axis_pt4 := (0, axis_y_top, 0);
label.rt("y", axis_pt4) axis_picture;

axis_pt5 := (-.25, 0, axis_z_back);
label.lft("z", axis_pt5) axis_picture;

%% **** (4) 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);

cylinder c;

set c with_type elliptical with_axis_x 10 with_axis_z 3 with_axis_y 10 
   with_point_count 32 with_divisions 6 with_center origin;

%rotate c (90, 45);

%% with_center (1, 2, 3);

draw c with_color black;

p0 := get_center c;

%message "Center of c:";
%show p0;

dotlabel.urt("$c$", p0); 

p1 := get_base_center c;

%message "Center of base of c:";
%show p1;

dotlabel.lft("$b_c$", p1); 

p2 := get_cap_center c;

%message "Center of cap of c:";
%show p2;

dotlabel.urt("$c_c$", p2); 

output axis_picture with_focus f;
endfig with_focus f;

end; 


%% *** (3) Bug fix:  This works now.  The solution was a kludge, however.
%%         See the definition of `Scan_Parse::vector_type_decl' in 
%%         `scanprse.web' for more information.
%%         LDF 2006.10.08.

beginfig(1); 

point_vector pv;

%pv += (1, 1);

%show pv;

drawdot origin;
endfig; 
end;


%% *** (3) Alignment with an axis.  Started working on this.
%%         LDF 2006.10.01.

beginfig(1);
transform t;
path p;
p := origin -- (1, 1, 1);
%t := p align with_axis x_axis; 
drawdot origin;
endfig; 

end;

%% *** (3) Ellipses.  Projecting ellipses onto a plane using a point.
%%         LDF 2006.10.01.

focus f;
set f with_position (3, 10, -20) 
   with_direction (3, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);

%% **** (4) Projection onto the x-z plane.

beginfig(1);

rectangle r;
r := unit_rectangle scaled (100, 0, 100);
%draw r with_color blue;

ellipse e[];

set e0 with_point_count 32;  
scale e0 (5, 0, 8);
rotate e0 (-10, 0, -10);  
%rotate e0 (10, 0);
shift e0 (1, 3, 10); 
message "e0:";
show e0; 

point c;
c := get_center e0;

label.("$e_0$", c);
draw e0 with_color red;
%message "e0:";
%show e0;

point n[];
n0 := get_normal e0;
%message "n0:";
%show n0;

n1 := mediate(c, c + n0, 5);
dotlabel.top("$n_1$", n1);


%% ***** (5) 

point q[];
bool_point_vector bpv;
string s;
path A;


for i = 0 upto 31:
    bpv := (n1 -- get_point (i) e0) intersection_points r;
    q[i] := bpv0;
    s := "$q_{" & decimal i & "}$";
    A += q[i];
endfor;

A += ..;
A += cycle;

draw A with_color blue;
message "A:";
show A;


for i = 0 step 2 until 30:
   drawarrow n1 -- q[i] dashed with_dots with_pen pencircle scaled (.5mm, .5mm);
endfor;

bpv := (n1 -- get_center e0) intersection_points r;
q100 := bpv0;

label.rt("$A$", q100);


%% ***** (5) 


%% Draw axes.

drawdblarrow (-5, 0) -- (5, 0);
drawdblarrow (0, -5) -- (0, 5);
drawdblarrow (0, 0, -5) -- (0, 0, 5);

endfig with_focus f no_sort;


%% **** (4) Projection onto a tilted plane.

beginfig(2);

rotate r (-15, 0, 15);

label.("$e_0$", c);
draw e0 with_color red;
%message "e0:";
%show e0;

%message "n0:";
%show n0;

dotlabel.top("$n_1$", n1);


%% ***** (5) 

path B;


for i = 0 upto 31:
    bpv := (n1 -- get_point (i) e0) intersection_points r;
    q[i] := bpv0;
    s := "$q_{" & decimal i & "}$";
    B += q[i];
endfor;

B += ..;
B += cycle;

draw B with_color blue;

message "B:";
show B;

for i = 0 step 2 until 30:
   drawarrow n1 -- q[i] dashed with_dots with_pen pencircle scaled (.5mm, .5mm);
endfor;

bpv := (n1 -- get_center e0) intersection_points r;
q101 := bpv0;

label.rt("$B$", q101);

%% ***** (5) 


%% Draw axes.

drawdblarrow (-5, 0) -- (5, 0);
drawdblarrow (0, -5) -- (0, 5);
drawdblarrow (0, 0, -5) -- (0, 0, 5);

endfig with_focus f no_sort;


end;


%% *** (3) Ellipses.  Projecting ellipses onto a plane using a vector.
%%         LDF 2006.10.01.

focus f;
set f with_position (3, 10, -20) 
   with_direction (3, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);
ellipse e[];

set e0 with_point_count 32;  
scale e0 (5, 0, 8);
rotate e0 (60, 30);  %% &60 deg. about x-axis, 30 deg. about y-axis.
shift e0 (5, 5, 3); 

label.("$e_0$", get_center e0);
draw e0 with_color red;
%message "e0:";
%show e0;

point v[];
v0 := (-1, 0);
rotate v0 (-45, 0, 45);
%message "v0:";
%show v0;

rectangle r;
r := unit_rectangle scaled (100, 0, 100);

point p[];
point q[];
point t[];
point u[];
string s;
path w;

bool_point_vector bpv;


for i = 0 upto 31:
p[i] := get_point (i) e0;
q[i] := p[i] + v0;
bpv := (p[i] -- q[i]) intersection_points r;
u[i] := bpv0;
w += u[i];
endfor;

w += ..;
w += cycle;

draw w with_color blue;

label("$w$", mediate(u8, u24, .6));

%message "w:";
%show w;

pickup pencircle scaled (.5mm, .5mm, .5mm);

drawarrow origin -- v0;
label.lft("$v_0$", v0);

for i = 0 step 8 until 24:
   s := "$p_{" & decimal i & "}$";
   dotlabel.top(s, p[i]);
   s := "$q_{" & decimal i & "}$";
   dotlabel.top(s, q[i]);
   s := "$u_{" & decimal i & "}$";
   dotlabel.bot(s, u[i]);
   drawarrow p[i] -- u[i] dashed with_dots;
endfor;

%% Draw axes.

drawdblarrow (-5, 0) -- (5, 0);
drawdblarrow (0, -5) -- (0, 5);
drawdblarrow (0, 0, -5) -- (0, 0, 5);


endfig with_focus f;


%% **** (4) 

beginfig(2);

pickup pencircle scaled (.75mm, .75mm, .75mm);

label.("$e_0$", get_center e0);
draw e0 with_color red;

rotate r (15, 15);


plane a;

a := get_plane r;
%message "a:";
%show a;

path b;

b := null_path;

for i = 0 upto 31:
p[i] := get_point (i) e0;
q[i] := p[i] + v0;
bpv := (p[i] -- q[i]) intersection_points r;
u[i] := bpv0;
b += u[i];
endfor;


b += ..;
b += cycle;

draw b with_color blue;

label("$b$", mediate(u8, u24, .5));

%message "b:";
%show b;

pickup pencircle scaled (.5mm, .5mm, .5mm);

pickup pencircle scaled (.5mm, .5mm, .5mm);

drawarrow origin -- v0;
label.lft("$v_0$", v0);

for i = 0 step 8 until 24:
   s := "$p_{" & decimal i & "}$";
   dotlabel.top(s, p[i]);
   s := "$q_{" & decimal i & "}$";
   dotlabel.top(s, q[i]);
   s := "$u_{" & decimal i & "}$";
   dotlabel.bot(s, u[i]);
   drawarrow p[i] -- u[i] dashed with_dots;
endfor;

%% Normal of b.

point n[];
n0 := get_normal b;

message "n0:";
show n0;

u100 := mediate(u8, u24, .75);

n1 := n0 + u100;

drawarrow u100 -- n1;
label.lft("$n$", n1);


%% Draw axes.

drawdblarrow (-5, 0) -- (5, 0);
drawdblarrow (0, -5) -- (0, 5);
drawdblarrow (0, 0, -5) -- (0, 0, 5);


endfig with_focus f;

end;



%% *** (3) Ellipses.
%%         LDF 2006.09.28.


focus f;
set f with_position (3, 10, -20) 
   with_direction (3, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);
ellipse e[];

set e0 with_point_count 32;  %% Center at origin, in x-z plane.
scale e0 (3, 0, 4);
label.lrt("$e_0$", get_center e0);
draw e0;
message "e0:";
show e0;

set e1 with_point_count 32;  
scale e1 (5, 0, 8);
rotate e1 (60, 30);  %% &60 deg. about x-axis, 30 deg. about y-axis.
shift e1 (6, 10, 5); %% Translated 6cm in x-direction, 
                     %% 10cm in y-direction,
                     %% and 5cm in z-direction (left-handed coordinate
                     %% system).

label.("$e_1$", get_center e1);
draw e1 with_color red;
message "e1:";
show e1;


set e2 with_point_count 32;
scale e2 (7, 0, 3);
rotate e2 (70, 0, 70);
shift e2 (-6, 3, 1);
label.("$e_2$", get_center e2);
draw e2 with_color blue;
message "e2:";
show e2;

drawdblarrow (-5, 0) -- (5, 0);
drawdblarrow (0, -5) -- (0, 5);
drawdblarrow (0, 0, -5) -- (0, 0, 5);

endfig with_focus f;
end;


%% *** (3) Wave form 3.  LDF 2006.03.04.
%%         Working on this.

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .75mm; 

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (0, -.5frame_h);

picture frame_picture;

beginfig(0); 
draw frame with_pen pencircle scaled (.5mm, .5mm, .5mm);
frame_picture := current_picture;
endfig; 

point p;

path q;

pen medium_pen;
pen thick_pen;

medium_pen := pencircle scaled (.75mm, .75mm);
thick_pen := pencircle scaled (1mm, 1mm);

pickup medium_pen;

picture save_picture;

k := 0;
r := 1;

curve_divisions  := 64;
curve_increment  := 360 / curve_divisions;
frequency_factor := .125;
amplitude_factor := .25;

path first_path[];

path x_axis_path;
x_axis_path := (0,0) -- (frame_w, 0);


for j = 0 upto 32:
   q := null_path;
   beginfig(j); 
      draw x_axis_path with_color red;
      for i = 0 upto 32:
         m := i * curve_increment;
         n := amplitude_factor * j * sind m;

         p := (frequency_factor * i, n); 

         q += p;
         endfor;
   draw q with_pen thick_pen;
   q += ..;
   first_path[j] := q;
   output current_picture with_projection parallel_x_y;
   clear current_picture;
   clip_to frame;
   output frame_picture with_projection parallel_x_y;
   endfig;
endfor;

j := 31;
for i = 33 upto 64:
   beginfig(i);
   draw x_axis_path with_color red;
   draw first_path[j] with_pen thick_pen;
   output current_picture with_projection parallel_x_y;
   clear current_picture;
   clip_to frame;
   output frame_picture with_projection parallel_x_y;
   endfig;
   j -= 1;
endfor;

for j = 65 upto 96:
   k := j - 64;
   q := null_path;
   beginfig(j); 
      draw x_axis_path with_color red;
      for i = 0 upto 32:
         m := i * curve_increment;
         n := amplitude_factor * k * sind m;

         p := (frequency_factor * i, -n); 

         q += p;
         endfor;
   draw q with_pen thick_pen;
   q += ..;
   first_path[j] := q;
   output current_picture with_projection parallel_x_y;
   clear current_picture;
   clip_to frame;
   output frame_picture with_projection parallel_x_y;
   endfig;
endfor;


j := 95;
for i = 97 upto 127:
   beginfig(i);
   draw x_axis_path with_color red;
   draw first_path[j] with_pen thick_pen;
   output current_picture with_projection parallel_x_y;
   clear current_picture;
   clip_to frame;
   output frame_picture with_projection parallel_x_y;
   endfig;
   j -= 1;
endfor;

end; 

%% *** (3) Wave form 2.  LDF 2006.03.03.

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .75mm; 

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (0, -.5frame_h);

picture frame_picture;

beginfig(0); 
draw frame with_pen pencircle scaled (.5mm, .5mm, .5mm);
frame_picture := current_picture;
endfig; 

point p;

path q;

pen medium_pen;
pen thick_pen;

medium_pen := pencircle scaled (.75mm, .75mm);
thick_pen := pencircle scaled (1mm, 1mm);

pickup medium_pen;

picture save_picture;

for k = 0 upto 6:
   r := k + 1;
   for j = 0 upto 19:
      q := null_path;
      beginfig(j + k * 38); 
      	 draw (0,0) -- (frame_w, 0) with_color red;
      	 for i = 16 * k upto 16 * r:
      	     m := i * 360 / 32;
      	     n := .25 * j * sind m;

      	     p := (.25 * i, n); 

      	     q += p;
      	 endfor;
      draw q with_pen thick_pen;
      q += ..;
      draw origin -- (.25 * 16 * k, 0) with_pen thick_pen;
      save_picture := current_picture;
      output current_picture with_projection parallel_x_y;
      clear current_picture;
      clip_to frame;
      output frame_picture with_projection parallel_x_y;
      endfig;

      beginfig(r * 38 - j) ; 
         output save_picture with_projection parallel_x_y;
         clip_to frame;
         output frame_picture with_projection parallel_x_y;
      endfig;
   endfor;
endfor;
end; 

%% *** (3) Wave form 1.  LDF 2006.03.03.

picture frame_picture;

beginfig(0); 
path frame;
frame := unit_rectangle rotated 90 scaled (16, 16) shifted (8, 0);
draw frame with_pen pencircle scaled (.5mm, .5mm, .5mm);
frame_picture := current_picture;
endfig; 

point p;

path null_path;


k := 36;
sign := 1;


t := 143;

for j = 0 upto 71:
   path q;   

   if (j == 36):
      sign *= -1;
   fi;

   k -= sign;

   for i = 0 upto 36:
      m := i * 360 / 16;
      n := (sind m) * k / 36;

     p := (.5 * i, 2 * n * sign); 

     q += p;

   endfor;

   q += ..;


   beginfig(j + 1);
   draw q with_pen pencircle scaled (1mm, 1mm);
   output current_picture with_projection parallel_x_y;
   clip_to frame;
   clear current_picture;
   output frame_picture with_projection parallel_x_y;
   endfig; 

   beginfig(t);
   draw q with_pen pencircle scaled (1mm, 1mm);
   output current_picture with_projection parallel_x_y;
   clip_to frame;
   clear current_picture;
   output frame_picture with_projection parallel_x_y;
   endfig; 
   
   t -= 1;
   
endfor;



end; 

%% *** (3) Working on the `paraboloid' type.  
%%         LDF 2006.01.25.

picture axis_picture;
picture save_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 5;
axis_x_rt    := 15;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 7;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0);
drawarrow origin -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, 0, -.1));

drawarrow origin -- (0, -axis_y_bot);
drawarrow origin -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawarrow origin -- (0, 0, -axis_z_front);
drawarrow origin -- (0, 0, axis_z_back);
label.lft("z", (-.25, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1); 

parabola q[];

set q0 with_parameter 1 with_extent 13;
set q1 with_parameter 9 with_extent 13;

rotate q0 (0, 0, 90);

rotate q1 (90, 0, 90);

message "size q0:";
show size q0;

message "size q1:";
show size q1;

draw q0 with_color red;
draw q1 with_color blue;

rectangle r[];
bool_point_vector bpv;
point pt[];
point v[];
ellipse e[];


pt0 := get_point 0 q0;

message "point 0 of q0:";
show pt0;


pt1 := get_point 0 q1;

message "point 0 of q1:";
show pt1;

%pause;

i := 1;
curr_extent := 12;


forever:
   
   message "i:";
   show i;

   r0 := unit_rectangle scaled 8 shifted (0, i);
   %draw r0 with_color green;
   bpv := q0 intersection_points get_plane r0;
   pt0 := bpv0;
   pt1 := bpv1;

   bpv := q1 intersection_points get_plane r0;
   pt2 := bpv0;
   pt3 := bpv1;

   % dotlabel.top("$i_0$", pt0);
   % dotlabel.top("$i_1$", pt1);
   % dotlabel.top("$i_2$", pt2);
   % dotlabel.top("$i_3$", pt3);

   v0 := pt0 - pt1;

%    message "v0:";
%    show v0;

   v1 := pt3 - pt2;

%    message "v1:";
%    show v1;

   curr_z := zpart v0;

%    message "curr_z:";
%    show curr_z;

   curr_x := xpart v1;

%    message "curr_x:";
%    show curr_x;

%    pause;

   set e0 with_point_count 64;
   scale e0 (curr_x, 0, curr_z);
   shift e0 (0, i);

   draw e0 with_color magenta;
   i := i + 1;
   exit_if i > curr_extent;
endfor;

paraboloid p[];

set p0 with_type elliptical with_max_extent 12;
message "p0:";
show p0;

save_picture := current_picture;

output axis_picture with_focus f;
endfig with_focus f;

beginfig(2); 
output axis_picture with_projection parallel_x_y;
output save_picture with_projection parallel_x_y;
endfig; 

beginfig(3); 
output axis_picture with_projection parallel_x_z;
output save_picture with_projection parallel_x_z;
endfig; 

beginfig(4); 
output axis_picture with_projection parallel_z_y;
output save_picture with_projection parallel_z_y;
endfig; 

end;

%% Assigning to a `numeric' from a `numeric_vector'.  If the `numeric_vector' is 
%% non-null and contains at least one element, the first element is used for 
%% the assignment.  Otherwise, the `numeric' is set to `INVALID_NUMERIC'.
%% I will need this for the determining the location of a `point' with respect
%% to a `polyhedron'.

%% LDF 2006.01.23.

beginfig(1); 
numeric_vector nv;
numeric_vector mv;
numeric_vector qv;

nv += 1;
nv += 2;
nv += 3;

a := nv;

message "a:";
show a;

message "is_invalid a:";
show is_invalid a;

b := mv;

message "b:";
show b;

message "is_invalid b:";
show is_invalid b;


qv += 1;
c := qv;

message "c before pop:";
show c;

message "is_invalid c:";
show is_invalid c;

pop qv;

c := qv;

message "c after pop:";
show c;


message "is_invalid c:";
show is_invalid c;

drawdot origin;
endfig; 
end;

%% *** (3)  The intersection points of a `polyhedron' and a linear `path'.
%%          Changed the right-hand side of the corresponding rules
%%          from `point_vector' to `bool_point_vector'.
%%          LDF 2006.01.23.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (0, 0, -20) with_direction (0, 0, 10) 
       with_distance 20;

picture save_picture;

pickup pencircle scaled .12;

beginfig(1); 
polyhedron d;
d := unit_dodecahedron scaled 3;

draw d;

point p[];

p0 := (-5, -5, -5);
p1 := (5, 5, 5);

path q;
q := p0 -- p1;

draw q;

bool_point_vector bpv;

bpv := d intersection_points q;

drawdot bpv0 with_color red with_pen pencircle scaled .2;
drawdot bpv1 with_color red with_pen pencircle scaled .2;

label.ulft("$i_0$", bpv0);
label.ulft("$i_1$", bpv1);

save_picture := current_picture;
endfig with_focus f no_sort; 

beginfig(2); 
output save_picture with_projection parallel_x_z;
endfig;

beginfig(3); 
output save_picture with_projection parallel_x_y;
endfig;

beginfig(4); 
output save_picture with_projection parallel_z_y;
endfig;

end;

%% *** (3)  The intersection of a `polyhedron' and a `plane'.  It is a `polygon',
%%          except for the degenerate cases.
%%          LDF 2006.01.20.

focus f;
set f with_position (0, 0, -20) with_direction (0, 0, 10) 
       with_distance 20;

picture save_picture;


pickup pencircle scaled .1;

beginfig(1);
polyhedron p;
p := unit_icosahedron scaled 4;
draw p;

rectangle r;
r := unit_rectangle scaled 15 rotated (85, 15);

draw r with_color red;

polygon q;

q := p intersection get_plane r;

draw q with_color blue;

save_picture := current_picture;
endfig with_focus f no_sort; 

beginfig(2); 
output save_picture with_projection parallel_x_z;
endfig;

beginfig(3); 
output save_picture with_projection parallel_x_y;
endfig;

beginfig(4); 
output save_picture with_projection parallel_z_y;
endfig;

end;


%% *** (3) Disentangling the `points' on a `point_vector' to produce a convex `polygon'.
%%         LDF 2006.01.20.

focus f;
set f with_position (0, 0, -20) with_direction (0, 0, 10) 
       with_distance 20;


beginfig(1);

point_vector pv;
polygon q[];

q0 := unit_pentagon scaled 2 rotated 90;

dotlabel.top(0, q0);

pv += get_point 1 q0;
pv += get_point 0 q0;
pv += get_point 2 q0;
pv += get_point 3 q0;
pv += get_point 4 q0;

path r;

for i = 0 upto 4:
   r += pv[i];
endfor;

r += cycle;

draw r;

q2 := disentangle pv;

draw q2 with_color red;

endfig with_focus f no_sort; 
end; 

%% *** (3) Added `get_net' for great rhombicosidodecahedra.
%%         LDF 2005.12.20. 

beginfig(1); 

reg_polygon_vector rpv;

rpv := get_net great_rhombicosidodecahedron with_diameter 2;% with_half;

draw rpv;

endfig with_projection parallel_x_z; 
end;


%% *** (3) The Great_Rhombicosidododecahedron.
%%         LDF 2005.12.20.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";
pickup pencircle scaled (1.5mm, 1.5mm);

color dull_red;
color dull_yellow;
color dull_blue;

set dull_red (.925, 0, 0);
set dull_yellow (.925, .925, 0);
set dull_blue (0, 0, .925);

focus f;
set f with_position (0, 1, -20) with_direction (0, 1, 10) 
       with_distance 20;

picture save_picture;

beginfig(1); 
polyhedron gr;
gr := unit_great_rhombicosidododecahedron scaled 4;

%message "size gr:";
%show size gr;

polygon poly[];

point center[];

string s;

for i = 0 upto size gr - 1:
   poly[i] := get_reg_polygon (i) gr;
   center[i] := get_center poly[i];
   if zpart center[i] < 0:
      if (size poly[i] == 4):
         filldraw poly[i] with_fill_color dull_blue;
      else:
         if (size poly[i] == 6):
            filldraw poly[i] with_fill_color dull_yellow;
         else:
            if (size poly[i] == 10):
               filldraw poly[i] with_fill_color dull_red;
            fi;
         fi;
      fi;
   fi;
endfor;

save_picture := current_picture;

%% **** (4) 

label_start := -1;
label_end   := 0;

if false:
for i = label_start upto label_end:
   label.bot(i, center[i]) with_text_color green;
endfor;
fi;

%label.top(26, center[26]) with_text_color dull_red;
%label.bot(57, center[57]) with_text_color green;

% message "center[26]:";
% show center[26];

% message "center[57]:";
% show center[57];
% pause;

%dotlabel.top(0, poly55); 
%dotlabel.top(0, poly2); 

%% **** (4) Labels for the columns.

%% ***** (5) Column 1.

if (label_start < 6) and (label_end >= 5):

label.top("$d_0$", center0) with_text_color green;  % poly  0 
label.top("$h_0$", center1) with_text_color green;  % poly  1
label.top("$s_0$", center2) with_text_color green;  % poly  2
label.top("$h_1$", center3) with_text_color green;  % poly  3
label.top("$s_1$", center4) with_text_color green;  % poly  4
label.top("$s_2$", center5) with_text_color green;  % poly  5

fi; 

%% ***** (5) Column 2.

if (label_start > 5) and (label_end >= 10):

label.top("$h_2$", center6) with_text_color green;  % poly  6
label.top("$d_1$", center7) with_text_color green;  % poly  7
label.top("$s_3$", center8) with_text_color green;  % poly  8
label.top("$h_3$", center9) with_text_color green;  % poly  9
label.top("$s_4$", center10) with_text_color green; % poly 10


fi;



%% ***** (5) Column 3.

if (label_start < 18) and (label_end >= 17):

label.top("$s_5$", center11) with_text_color green; % poly 11
label.top("$d_2$", center12) with_text_color green; % poly 12
label.top("$h_4$", center13) with_text_color green; % poly 13
label.top("$s_6$", center14) with_text_color green; % poly 14
label.top("$h_5$", center15) with_text_color green; % poly 15
label.top("$s_7$", center16) with_text_color green; % poly 16
label.top("$d_3$", center17) with_text_color green; % poly 17
fi;

%% ***** (5) Column 4.

if (label_start < 23) and (label_end >= 23):

label.top("$s_8$", center18) with_text_color green; % poly 18
label.top("$d_4$", center19) with_text_color green; % poly 19
label.top("$h_6$", center20) with_text_color green; % poly 20
label.top("$s_9$", center21) with_text_color green; % poly 21
label.top("$h_7$", center22) with_text_color green; % poly 22
label.top("$s_{10}$", center23) with_text_color green; % poly 23

fi;

%% ***** (5) Column 5.

if (label_start < 30) and (label_end >= 30):

label.top("$d_5$", center24) with_text_color green;    % poly 24
label.top("$s_{11}$", center25) with_text_color green; % poly 25
label.top("$h_8$", center26) with_text_color green;    % poly 26
label.top("$s_{12}$", center27) with_text_color green; % poly 27
label.top("$h_9$", center28) with_text_color green;    % poly 28
label.top("$s_{13}$", center29) with_text_color green; % poly 29
label.top("$s_{14}$", center30) with_text_color green; % poly 30

fi;

%% ***** (5) Column 6.

if (label_start < 36) and (label_end >= 36):

label.top("$d_6$", center31) with_text_color green;    % poly 31
label.top("$h_{10}$", center32) with_text_color green; % poly 32
label.top("$s_{15}$", center33) with_text_color green; % poly 33
label.top("$h_{11}$", center34) with_text_color green; % poly 34
label.top("$s_{16}$", center35) with_text_color green; % poly 35
%label.top("$s_{17}$", center36) with_text_color green; % poly 36

fi;

%% ***** (5) Column 7.

if (label_start < 41) and (label_end >= 41):

label.top("$d_7$",    center37) with_text_color green; % poly 37
label.top("$h_{12}$", center38) with_text_color green; % poly 38
label.top("$s_{18}$", center39) with_text_color green; % poly 39
label.top("$h_{13}$", center40) with_text_color green; % poly 40
label.top("$s_{19}$", center41) with_text_color green; % poly 41


fi;

%% ***** (5) Column 8.

if (label_start < 48) and (label_end >= 47):

label.top("$s_{20}$", center42) with_text_color green; % poly 42
label.top("$d_8$",    center43) with_text_color green; % poly 43
label.top("$h_{14}$", center44) with_text_color green; % poly 44
label.top("$s_{21}$", center45) with_text_color green; % poly 45
label.top("$h_{15}$", center46) with_text_color green; % poly 46
label.top("$s_{22}$", center47) with_text_color green; % poly 47

fi;

%% ***** (5) Column 9.

if (label_start < 55) and (label_end >= 54):

label.top("$s_{23}$", center48) with_text_color green; % poly 48
label.top("$d_9$",    center49) with_text_color green; % poly 49
label.top("$d_{10}$", center50) with_text_color green; % poly 50
label.top("$h_{16}$", center51) with_text_color green; % poly 51
label.top("$s_{24}$", center52) with_text_color green; % poly 52
label.top("$h_{17}$", center53) with_text_color green; % poly 53
label.top("$s_{25}$", center54) with_text_color green; % poly 54

fi;

%% ***** (5) Column 10.

if (label_start < 61) and (label_end >= 61):
label.top("$s_{26}$", center55) with_text_color green; % poly 55
label.top("$d_{11}$", center56) with_text_color green; % poly 56
label.top("$h_{18}$", center57) with_text_color green; % poly 57
label.top("$s_{27}$", center58) with_text_color green; % poly 58
label.top("$h_{19}$", center59) with_text_color green; % poly 59
label.top("$s_{28}$", center60) with_text_color green; % poly 60
label.top("$s_{29}$", center61) with_text_color green; % poly 61

fi;

%% **** (4) 


point p[];

%rotate current_picture (0, 90);

endfig with_focus f;

%% **** (4) 

beginfig(2); 
for i = 0 upto size gr - 1:
   poly[i] := get_reg_polygon (i) gr;
   center[i] := get_center poly[i];
   if ypart center[i] >= 0:
      if (size poly[i] == 4):
         filldraw poly[i] with_fill_color dull_blue;
      else:
         if (size poly[i] == 6):
            filldraw poly[i] with_fill_color dull_yellow;
         else:
            if (size poly[i] == 10):
               filldraw poly[i] with_fill_color dull_red;
            fi;
         fi;
      fi;
   fi;
endfor;
endfig with_projection parallel_x_z;  

beginfig(3); 
output save_picture with_projection parallel_x_y;  
endfig; 

beginfig(4); 
for i = 0 upto size gr - 1:
   poly[i] := get_reg_polygon (i) gr;
   center[i] := get_center poly[i];
   if xpart center[i] >= 0:
      if (size poly[i] == 4):
         filldraw poly[i] with_fill_color dull_blue;
      else:
         if (size poly[i] == 6):
            filldraw poly[i] with_fill_color dull_yellow;
         else:
            if (size poly[i] == 10):
               filldraw poly[i] with_fill_color dull_red;
            fi;
         fi;
      fi;
   fi;
endfor;
endfig with_projection parallel_z_y; 

end;

%% *** (3) The intersection of a `plane' and an `ellipsoid'.
%%         This seems to work now.
%%         LDF 2005.12.15.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-12, 15, -30) with_direction (-12, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 
ellipsoid E;

Ew := 20;
Eh := 16;
Ed := 8;

rw := Ew + 10;
rd := Ed + 15;

set E with_center origin with_axis_x Ew with_axis_y Eh with_axis_z Ed
       with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
       with_point_count 64;


rectangle r[];

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 20) shifted (0, 0, 4);  %% These work.
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 0);
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (30, 15, 0);
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (45, 0, 0);
                                                          
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (45, 11, 0);  

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (80, 0, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 90, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 0, 90) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 10, 80) shifted (0, 0, 1);  %% This works.

r0 := unit_rectangle scaled (rw, 0, rd) rotated (60, 25, 10) shifted (0, 0, 1);  %% This works.

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 20) shifted (0, 0, 4);  %% This works.

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 2);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 1);  %% This works.

%% **** (4) 

transform t;
t := identity rotated (5, 5) shifted (2, 3);
%t := identity;

E *= t;
r0 *= t;

cuboid c;
c := out_cuboid E;

plane q;
q := get_plane r0;

ellipse e;
e := E intersection q;

message "is_elliptical e:";  %% It fails the test, but all of its `points' are
                             %% on the `ellipsoid'.
show is_elliptical e;


point v[];
point f[];

string s;

f0 := get_focus 0 e;
f1 := get_focus 1 e;

dotlabel.top("$f_0$", f0);
dotlabel.top("$f_1$", f1);

for i = 0 upto 3:
   s := "$v_" & decimal (i) & "$";
   v[i] := get_vertex (i) e;
   dotlabel.top(s, v[i]);
endfor;

filldraw e with_color red;

draw r0 with_color blue;
draw E;

save_picture := current_picture;

endfig with_focus f no_sort;

point label_pt;
label_pt := (0, -10);


beginfig(2); 
output save_picture with_projection parallel_x_z;
%label("Parallel Projection, X-Z Plane", label_pt shifted 6);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
%label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
%label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;

end;

%% *** (3) The intersection of a `cuboid' and a `plane'.  It is a `polygon'.
%%         LDF 2005.12.16.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 
cuboid c;

cw := 20;
ch := 16;
cd := 10;

rw := cw + 20;
rd := cd + 14;

c := unit_cuboid scaled (cw, ch, cd);

rectangle r;
r := unit_rectangle scaled (rw, 0, rd) rotated (70, 30)  shifted (4, 1, 4);

transform t;
t := identity rotated (15, 15);

r *= c *= t;

draw c;
draw r with_color red;

plane q;
q := get_plane r;

polygon poly;
poly := c intersection q;
draw poly with_color blue;

point p[];

for i = 0 upto 5:
   p[i] := get_point (i) poly; 
   drawdot p[i] with_color green with_pen dot_pen;
endfor;


label.lrt("$i_0$", p0);  
label.lft("$i_1$",  p1);   
label.lft("$i_2$", p2);   
label.top("$i_3$",  p3);   
label.rt("$i_4$",  p4);   
label.lft("$i_5$",  p5 shifted -.375);   

save_picture := current_picture;

endfig with_focus f no_sort;

point label_pt;
label_pt := (0, -10);


beginfig(2); 
output save_picture with_projection parallel_x_z with_factor .75;
%label("Parallel Projection, X-Z Plane", label_pt shifted 6);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y with_factor .75;
%label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y with_factor .75;
%label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;


end;

%% *** (3) The intersection points of a linear `path' and a `cuboid'.
%%         LDF 2005.12.16.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

pen dot_pen;
dot_pen := pencircle scaled (2mm, 2mm);

beginfig(1); 

cuboid c;

w := 20;
h := 16;
d := 10;

c := unit_cuboid scaled (w, h, d) rotated (15, 15);
draw c;

path q[];
q0 := ((-12, -12, -2) -- (12, 12, 2)) shifted (1, 1, 1);

draw q0;

bool_point_vector bpv;
bpv := c intersection_points q0;

point p[];

p0 := bpv0;
p1 := bpv1;

drawdot p0 with_pen dot_pen with_color blue;
drawdot p1 with_pen dot_pen with_color blue;

label.lrt("$i_0$", p0);
label.lrt("$i_1$", p1);

save_picture := current_picture;

endfig with_focus f no_sort; 

point label_pt;
label_pt := (0, -5);

beginfig(2); 
output save_picture with_projection parallel_x_z;
%label("Parallel Projection, X-Z Plane", label_pt);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
%label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
%label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;


end;

%% *** (3) Classifying `points' with respect to a `cuboid'.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pen dot_pen;
dot_pen := pencircle scaled (2mm, 2mm);

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-12, 15, -30) with_direction (-12, 15, 100) with_distance 20; 


beginfig(1);
cuboid c;
c := unit_cuboid scaled (20, 16, 10) rotated (-20, 15);
draw c;

point p[];

p0 := (0, 1, 1);

message "p0 location c:";
show p0 location c;

string s;

s :=   "\\setbox0=\\hbox{$p_0$}\\hbox to \\wd0{\\box0 , $l = " 
     & decimal (p0 location c) & "$\\hss}"; 

drawdot p0 with_pen dot_pen with_color blue;
label.top(s, p0 shifted (0, .25));


rectangle r[];
r0 := get_rectangle 0 c;

p1 := mediate(get_point 0 r0, get_point 3 r0, 1/3);

message "p1 location c:";
show p1 location c;


s :=   "\\setbox0=\\hbox{$p_1$}\\hbox to \\wd0{\\box0 , $l = " 
     & decimal (p1 location c) & "$\\hss}"; 

drawdot p1 with_pen dot_pen with_color blue;
label.rt(s, p1 shifted .25);

r1 := get_rectangle 4 c;

p2 := mediate(get_point 0 r1, get_point 2 r1) shifted (0, 2);

message "p2 location c:";
show p2 location c;

s :=   "\\setbox0=\\hbox{$p_2$}\\hbox to \\wd0{\\box0 , $l = " 
     & decimal (p2 location c) & "$\\hss}"; 

drawdot p2 with_pen dot_pen with_color blue;
label.top(s, p2 shifted (0, .25));

endfig with_focus f no_sort;  

end;

%% *** (3) The intersection of a `plane' and an `ellipsoid'.
%%         This seems to work now.
%%         LDF 2005.12.15.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-12, 15, -30) with_direction (-12, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 
ellipsoid E;

Ew := 20;
Eh := 16;
Ed := 8;

rw := Ew + 10;
rd := Ed + 15;

set E with_center origin with_axis_x Ew with_axis_y Eh with_axis_z Ed
       with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
       with_point_count 64;


rectangle r[];

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 20) shifted (0, 0, 4);  %% These work.
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 0);
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (30, 15, 0);
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (45, 0, 0);
                                                          
%r0 := unit_rectangle scaled (rw, 0, rd) rotated (45, 11, 0);  

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (80, 0, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 90, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 0, 90) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (0, 10, 80) shifted (0, 0, 1);  %% This works.

r0 := unit_rectangle scaled (rw, 0, rd) rotated (60, 25, 10) shifted (0, 0, 1);  %% This works.

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (15, 15, 20) shifted (0, 0, 4);  %% This works.

%r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 1);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 2);  %% This works.

% r0 := unit_rectangle scaled (rw, 0, rd) rotated (90, 0) shifted (0, 0, 1);  %% This works.

%% **** (4) 

transform t;
t := identity rotated (5, 5) shifted (2, 3);
%t := identity;

E *= t;
r0 *= t;

cuboid c;
c := out_cuboid E;

plane q;
q := get_plane r0;

ellipse e;
e := E intersection q;

message "is_elliptical e:";  %% It fails the test, but all of its `points' are
                             %% on the `ellipsoid'.
show is_elliptical e;

filldraw e with_color red;

draw r0 with_color blue;
draw E;

save_picture := current_picture;

endfig with_focus f no_sort;

point label_pt;
label_pt := (0, -10);


beginfig(2); 
output save_picture with_projection parallel_x_z;
%label("Parallel Projection, X-Z Plane", label_pt shifted 6);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
%label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
%label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;

end;

%% *** (3) Working on |Great_Rhombicosidododecahedron::get_net()|.
%%         LDF 2005.12.14.

beginfig(1); 
polyhedron gr;
gr := unit_great_rhombicosidododecahedron;% scaled (2, 0, 2);
draw gr;

polygon poly[];

point center[];

for i = 0 upto 23:
   poly[i] := get_reg_polygon (i) gr;
   center[i] := get_center poly[i];
   label.bot(i, center[i]) with_text_color green;
endfor;

label.top("$d_0$", center0) with_text_color green;  % poly  0 
label.top("$h_0$", center1) with_text_color green;  % poly  1
label.top("$s_0$", center2) with_text_color green;  % poly  2
label.top("$h_1$", center3) with_text_color green;  % poly  3
label.top("$s_1$", center4) with_text_color green;  % poly  4
label.top("$s_2$", center5) with_text_color green;  % poly  5
label.top("$h_2$", center6) with_text_color green;  % poly  6
label.top("$d_1$", center7) with_text_color green;  % poly  7
label.top("$s_3$", center8) with_text_color green;  % poly  8
label.top("$h_3$", center9) with_text_color green;  % poly  9
label.top("$s_4$", center10) with_text_color green; % poly 10
label.top("$s_5$", center11) with_text_color green; % poly 11
label.top("$d_2$", center12) with_text_color green; % poly 12
label.top("$h_4$", center13) with_text_color green; % poly 13
label.top("$s_6$", center14) with_text_color green; % poly 14
label.top("$h_5$", center15) with_text_color green; % poly 15
label.top("$s_7$", center16) with_text_color green; % poly 16
label.top("$d_3$", center17) with_text_color green; % poly 17
label.top("$s_8$", center18) with_text_color green; % poly 18
label.top("$d_4$", center19) with_text_color green; % poly 19
label.top("$h_6$", center20) with_text_color green; % poly 20
label.top("$s_9$", center21) with_text_color green; % poly 21
label.top("$h_7$", center22) with_text_color green; % poly 22
label.top("$s_{10}$", center23) with_text_color green; % poly 23

dotlabel.top(0, poly13); 
dotlabel.top(0, poly5); 

point p[];


endfig with_projection parallel_x_z;  

end;




%% *** (3) BUG FIX:  Plain `label' and `dotlabel' now work correctly for `bool_points', 
%%                   whose `boolean' part is `false'.  That is, the label or dotlabel 
%%                   is created.
%%                   LDF 2005.12.12.

beginfig(1);



bool_point b[];



for i = 0 step 1 until 9:
   b[i] := false;
   b[i] := origin shifted i;
endfor;

b8 := true;
b9 := true;
b3 := true;
b4 := true;

label.top("$b_0$", b0);  %% Should print

label_if.top("$b_1$", b1);  %% Shouldn't print.

label_unless.top("$b_2$", b2);  %% Should print.

label_if.top("$b_3$", b3);  %% Should print.

label_unless.top("$b_4$", b4);  %% Shouldn't print.


dotlabel.top("$b_5$", b5);  %% Should print

dotlabel_if.top("$b_6$", b6);  %% Shouldn't print.

dotlabel_unless.top("$b_7$", b7);  %% Should print.

dotlabel_if.top("$b_8$", b8);  %% Should print.

dotlabel_unless.top("$b_9$", b9);  %% Shouldn't print.


endfig;
end;  

%% *** (3) The intersection of a `cuboid' and a `plane'.  It is a `polygon'.
%%         LDF 2005.12.11.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 
cuboid c;

cw := 20;
ch := 16;
cd := 10;

rw := cw + 10;
rd := cd + 15;

c := unit_cuboid scaled (cw, ch, cd);
draw c;

rectangle r;
r := unit_rectangle scaled (rw, 0, rd) rotated (70, 60)  shifted (3, -2, 4);

draw r with_color red;

plane q;
q := get_plane r;

polygon poly;

poly := c intersection q;

if known poly:
   draw poly with_color blue;
   drawdot get_point 0 poly;
   label.ulft("$i_0$",  (get_point 0 poly) shifted -.25); 
   dotlabel.lrt("$i_1$", get_point 1 poly); 
   dotlabel.ulft("$i_2$", get_point 2 poly); 
   dotlabel.top("$i_3$", get_point 3 poly); 
fi;

save_picture := current_picture;

endfig with_focus f no_sort;

point label_pt;
label_pt := (0, -10);


beginfig(2); 
output save_picture with_projection parallel_x_z;
label("Parallel Projection, X-Z Plane", label_pt shifted 6);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;


end;


%% *** (3) The intersection points of a linear `path' and an `ellipsoid'.
%%         LDF 2005.12.09.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 

transform t;
%t := identity rotated (15, 15) shifted (1, 1, 1);
t := identity;

ellipsoid e;
 set e with_center origin with_axis_x 20 with_axis_y 16 with_axis_z 10
       with_divisions_x 6 with_divisions_y 6 with_divisions_z 2
       with_point_count 64;

e *= t;

draw e;

% cuboid c;
% c := out_cuboid e;
% draw c with_color red;

path q[];
q0 := ((-10, -10) -- (10, 10)) rotated -90 shifted (0, 1);
%q0 := (0, -10) -- (0, 10);

q0 *= t;

draw q0 with_color blue;

bool_point_vector bpv;
bpv := e intersection_points q0;

message "bpv:";
show bpv;

point p[];
p0 := bpv0;
p1 := bpv1;

message "p0 location e:";
show p0 location e;

drawdot bpv0 with_color green with_pen pencircle scaled (1.5mm, 1.5mm);
label.top("$i_0$", p0 shifted (0, .2));

drawdot bpv1 with_color green with_pen pencircle scaled (1.5mm, 1.5mm);
label.lrt("$i_1$", p1 shifted (0, .2));

save_picture := current_picture;

label("Perspective Projection", (0, -11));

endfig with_focus f no_sort; 

point label_pt;
label_pt := (0, -10);

beginfig(2); 
output save_picture with_projection parallel_x_z;
label("Parallel Projection, X-Z Plane", label_pt);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;


end;

%% *** (3) The intersection points of a linear `path' and a `cuboid'.
%%         LDF 2005.12.09.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 

% ellipsoid e;
%  set e with_center origin with_axis_x 12 with_axis_y 8 with_axis_z 5
%        with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
%        with_point_count 64;


%draw e;

%point_vector pv;
%pv := e intersection_points q;

% message "pv:";
% show pv;

cuboid c;

w := 20;
h := 8;
d := 5;

c := unit_cuboid scaled (w, h, d);
draw c with_color red;

path q[];
q0 := ((-10, -10) -- (10, 10)) shifted (1, 1, 1);

draw q0;

bool_point_vector bpv;
bpv := c intersection_points q0;

dotlabel.top("$i_0$", bpv0);
dotlabel.top("$i_1$", bpv1);


q1 := ((-10, 10) -- (10, 10)) shifted (1, 1, 1);
q2 := ((-10, 4) -- (10, 4));
q3 := ((-10, 4, -2.5) -- (10, 4, -2.5));

%draw q1;
%draw q2;
%draw q3;

save_picture := current_picture;

endfig with_focus f; 

end;

point label_pt;
label_pt := (0, -5);

beginfig(2); 
output save_picture with_projection parallel_x_z;
label("Parallel Projection, X-Z Plane", label_pt);
endfig with_projection parallel_x_y;


beginfig(3); 
output save_picture with_projection parallel_x_y;
label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;


end;

%% *** (3) The location of a `point p' with respect to an `ellipsoid e'.
%%         `location' returns 0 if `p' lies on the surface of `e',
%%         1 if `p' lies within `e', -1 if it lies outside of `e',
%%         and `INVALID_NUMERIC' if an error occurs.
%%
%%         LDF 2005.12.07.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (1mm, 1mm);

picture save_picture;

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

beginfig(1);

ellipsoid E;
set E with_center origin with_axis_x 24 with_axis_y 16 with_axis_z 10
      with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
      with_point_count 64;

%rotate E (15, 15);
%shift E (1, 2, 3);

draw E;

point p[];

p0 := (1, 2, 1);  %% Inside.
p1 := (4, 9, 0);  %% Outside.

ellipse e;
e := get_ellipse 3 E;

p2 := get_point 60 e; %% On the surface.

message "p0 location E:";
show p0 location E;

message "p1 location E:";
show p1 location E;

message "p2 location E:";
show p2 location E;

pickup pencircle scaled (1.5mm, 1.5mm);

pickup red;

drawdot p0;
drawdot p1;
drawdot p2;

label.ulft("$p_0$", p0); 
label.top("$p_1$", p1); 
label.urt("$p_2$", p2); 

endfig with_focus f no_sort;

end;



%% *** (3) The surrounding `cuboid' of an `ellipsoid'.
%%         The problem of finding the inscribed `cuboid' is more 
%%         difficult, and I don't know how to do it yet.
%%
%%         LDF 2005.12.07.

verbatim_metapost "verbatimtex \font\large=cmr17 scaled \magstep4 etex";

pickup pencircle scaled (1mm, 1mm);

picture save_picture;

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

beginfig(1);

ellipsoid E;
set E with_center origin with_axis_x 24 with_axis_y 16 with_axis_z 10
      with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
      with_point_count 64;

%rotate E (15, 15);
%shift E (1, 2, 3);

draw E;

ellipse e[];

cuboid c[];

%c0 := in_cuboid E;
c1 := out_cuboid E;

draw c1 with_color blue;

save_picture := current_picture;

point label_pt;
label_pt := (0, -6);

%label("{\large Perspective Projection}", label_pt shifted (0, -3));
endfig with_focus f;

beginfig(2);
output save_picture with_projection parallel_x_z;  
%label("{\large Parallel Projection, X-Z Plane}", label_pt);
endfig with_projection parallel_x_y no_sort;

beginfig(3);
output save_picture with_projection parallel_x_y;  
%label("{\large Parallel Projection, X-Y Plane}", label_pt);
endfig with_projection parallel_x_y  no_sort;

beginfig(4);
output save_picture with_projection parallel_z_y;  
%label("{\large Parallel Projection, Z-Y Plane}", label_pt);
endfig with_projection parallel_x_y no_sort;


end;



%% *** (3) Added parser rules and functions for `ulong_long_vector'
%%         and `get_prime_vector'.
%%
%%         LDF 2005.12.07.

beginfig(1);
ulong_long_vector LV;

LV := get_prime_vector 0 125;

message "size LV:";
show size LV;

message "LV:";
show LV;

message "LV3:";
show LV3;

ulong_long L;
L := LV4;
message "L:";
show L;

drawdot origin;
endfig;  
end;

%% *** (3) Added the types `ulong_long' and `ulong_long_vector'.  
%%         `ulong_long' corresponds to the C++ type `unsigned long long'.
%%         Added code for `get_prime'.
%%
%%         LDF 2005.12.05.

beginfig(1);

ulong_long L;

L := get_prime 24;
message "The 24th prime number is:";
show L;

L := get_prime 103;
message "The 103rd prime number is:";
show L;

L := get_prime 11;
message "The 11th prime number is:";
show L;

endfig;  
end;




%% *** (3) Added complete sets of rules for `parabola_vector', `hyperbola_vector', 
%%         `ellipsoid_vector', and `sphere_vector'.
%%         LDF 2005.12.01.

beginfig(1);

%% **** (4) Declarations.

parabola_vector ppv;  
hyperbola_vector hpv;
ellipsoid_vector epv;
sphere_vector spv;

%% **** (4) Type predicates.

%% ***** (5) 

if is_parabola_vector ppv:                    
   message "`ppv' is a `parabola_vector'.";
else:
   message "`ppv' is not a `parabola_vector'.";
fi

if is_parabola_vector a:
   message "`a' is a `parabola_vector'.";
else:
   message "`a' is not a `parabola_vector'.";
fi

%% ***** (5) 

if is_hyperbola_vector hpv:                    
   message "`hpv' is a `hyperbola_vector'.";
else:
   message "`hpv' is not a `hyperbola_vector'.";
fi

if is_hyperbola_vector a:
   message "`a' is a `hyperbola_vector'.";
else:
   message "`a' is not a `hyperbola_vector'.";
fi

%% ***** (5) 

if is_ellipsoid_vector epv:                    
   message "`epv' is an `ellipsoid_vector'.";
else:
   message "`epv' is not an `ellipsoid_vector'.";
fi

if is_ellipsoid_vector a:
   message "`a' is a `ellipsoid_vector'.";
else:
   message "`a' is not a `ellipsoid_vector'.";
fi

%% ***** (5) 

if is_sphere_vector spv:                    
   message "`spv' is a `sphere_vector'.";
else:
   message "`spv' is not a `sphere_vector'.";
fi

if is_sphere_vector a:
   message "`a' is a `sphere_vector'.";
else:
   message "`a' is not a `sphere_vector'.";
fi


%% ***** (5) 


%% **** (4) Addition with assignment.

%% ***** (5) 

parabola p;

set p;

ppv += p;
ppv += p;
ppv += p;
ppv += p;

message "size of `ppv' after assignment:";
show size ppv;

%% ***** (5) 

hyperbola h;

set h;

hpv += h;
hpv += h;
hpv += h;
hpv += h;

message "size of `hpv' after assignment:";
show size hpv;

%% ***** (5) 

ellipsoid e;


set e with_center (0, 0, 0) with_axis_x 15 with_axis_y 8 with_axis_z 10
      with_divisions_x 4 with_divisions_y 4 with_divisions_z 2
      with_point_count 64;

epv += e;
epv += e;
epv += e;
epv += e;

message "size of `epv' after assignment:";
show size epv;

%% ***** (5) 

sphere s;
set s with_center (0, -2.75, 0) with_radius 5 with_point_count 64 with_divisions 6;

spv += s;
spv += s;
spv += s;
spv += s;

message "size of `spv' after assignment:";
show size spv;


%% ***** (5) 


%% **** (4) Assignment from a `parabola_vector_expression'.

%% ***** (5) 

parabola_vector pppv;

pppv := ppv;

message "`size pppv':";
show size pppv;


%% ***** (5) 

hyperbola_vector hhpv;

hhpv := hpv;

message "`size hhpv':";
show size hhpv;

%% ***** (5) 

sphere_vector sspv;

sspv := spv;

message "`size sspv':";
show size sspv;


%% ***** (5) 


%% **** (4) pop_back.

%% ***** (5) 

for i = 1 upto size ppv / 2:
message "`i' == ";
show i;
pop_back ppv;
message "`size ppv' after pop_back:";
show size ppv;
endfor;

message "size `ppv' after the loop:";
show size ppv;

%% ***** (5) 

for i = 1 upto size hpv / 2:
message "`i' == ";
show i;
pop_back hpv;
message "`size hpv' after pop_back:";
show size hpv;
endfor;

message "size `hpv' after the loop:";
show size hpv;

%% ***** (5) 

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "size `epv' after the loop:";
show size epv;

%% ***** (5) 

for i = 1 upto size spv / 2:
message "`i' == ";
show i;
pop_back spv;
message "`size spv' after pop_back:";
show size spv;
endfor;

message "size `spv' after the loop:";
show size spv;


%% **** (4) This code works, but produces a lot of terminal output.

%% ***** (5) 

% message "`ppv[1]':";
% show ppv1;

% message "`last ppv':";
% show last ppv;

%% ***** (5) 

% message "`hpv[1]':";
% show hpv1;

% message "`last hpv':";
% show last hpv;


%% ***** (5) 

% message "`epv[1]':";
% show epv1;

% message "`last epv':";
% show last epv;


%% ***** (5) 

%message "`spv[1]':";
%show spv1;

%message "`last spv':";
%show last spv;

%% ***** (5) 

%% **** (4) 

%% ***** (5) 

clear ppv;
message "`ppv' after clearing:";
show ppv;

% parabola_vector pq;   %% Causes error, but 3dldf can recover.
% message "last pq:";  
% show last pq;

%% ***** (5) 

clear hpv;
message "`hpv' after clearing:";
show hpv;

% hyperbola_vector hq;   %% Causes error, but 3dldf can recover.
% message "last hq:";  
% show last hq;

%% ***** (5) 

clear epv;
message "`epv' after clearing:";
show epv;

% ellipsoid_vector eq;   %% Causes error, but 3dldf can recover.
% message "last eq:";  
% show last eq;

%% ***** (5) 

clear spv;
message "`spv' after clearing:";
show spv;

% sphere_vector sq;   %% Causes error, but 3dldf can recover.
% message "last sq:";  
% show last sq;

endfig;
end;

%% *** (3) Bug fix:  Trying to label unknown objects of type `path', and types
%%                   derived form `path', now fails gracefully.
%%
%%         LDF 2005.12.01.

focus f;
set f with_position (-5, 15, -30) with_direction (-5, 15, 100) with_distance 20; 

beginfig(1);

bool_point_vector bpv;


ellipse e[];
e0 := unit_ellipse scaled (2, 0, 5);
draw e0;
circle c[];
c0 := unit_circle scaled (2, 0, 2);
c1 := unit_circle scaled (2, 0, 2) shifted (1, 0);
e1 := e0 shifted (0, 1);

label("$e_0$", get_center e0);
label("$e_1$", get_center e1);

draw c0 with_color red;
draw c1 with_color red;

draw e0 with_color red;
draw e1 with_color red;

path q;
%dotlabel.top("$q$", 0, q);  %% These commands fail gracefully now.  
                             %% LDF 2005.12.01.
%label.top(0, q);
%label.top(0, e2);

%label.top("$q$", q);
%label("$q$", q);

bpv := e0 intersection_points e1;
bpv := c0 intersection_points c1;

message "bpv:";
show bpv;

point p[];

p0 := bpv0;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

%dotlabel_if.top(4, bpv4);  %% Doesn't exist.

endfig with_projection parallel_x_z;
end;

%% *** (3) Bug fix:  Trying to label an unknown `point' now 
%%         fails gracefully.
%%
%%         LDF 2005.12.01.

focus f;
set f with_position (-5, 15, -30) with_direction (-5, 15, 100) with_distance 20; 

beginfig(1);

bool_point_vector bpv;


ellipse e[];
e0 := unit_ellipse scaled (2, 0, 5);
draw e0;
circle c[];
c0 := unit_circle scaled (2, 0, 2);
c1 := unit_circle scaled (2, 0, 2) shifted (1, 0);
e1 := e0 shifted (0, 1);

label("$e_0$", get_center e0);
label("$e_1$", get_center e1);

draw c0 with_color red;
draw c1 with_color red;

draw e0 with_color red;
draw e1 with_color red;

point q;
dotlabel.top("$q$", q);
label.top("$q$", q);
label("$q$", q);


bpv := e0 intersection_points e1;
bpv := c0 intersection_points c1;

message "bpv:";
show bpv;

point p[];

p0 := bpv0;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

%dotlabel_if.top(4, bpv4);  %% Doesn't exist.

endfig with_projection parallel_x_z;
end;

%% *** (3) Bug fix:  Trying to label an unknown `bool_point' now 
%%         fails gracefully.
%%
%%         LDF 2005.12.01.


%% *** (3) Tried fixing some bugs involving vector-types, but it didn't work out.
%%         I ended up having to revert files to the state they were in before.
%%         However, things seem to be working properly now.  I don't know what
%%         was causing the problem before.  If I have problems again, I'll 
%%         have to be very careful about making changes.  The code for the 
%%         vector types is quite complicated, and it's been a long time
%%         since I wrote it, so I don't remember all the details.
%%         
%%         LDF 2005.11.30.


%% *** (3) Intersection points of two `ellipses'.
%%         Most of the following code is from 2004.11.06, but it 
%%         worked without modification!
%%
%%         LDF 2005.11.30.

focus f;
set f with_position (-5, 15, -30) with_direction (-5, 15, 100) with_distance 20; 

beginfig(1);

bool_point_vector bpv;


ellipse e[];
e0 := unit_ellipse scaled (2, 0, 5);
draw e0;
circle c[];
c0 := unit_circle scaled (2, 0, 2);
c1 := unit_circle scaled (2, 0, 2) shifted (1, 0);
e1 := e0 shifted (0, 1);

label("$e_0$", get_center e0);
label("$e_1$", get_center e1);

draw c0 with_color red;
draw c1 with_color red;

draw e0 with_color red;
draw e1 with_color red;

bool_point q;
%label_unless.top("$q$", q);  %% This works now.  LDF 2005.12.01.

bpv := e0 intersection_points e1;
bpv := c0 intersection_points c1;

message "bpv:";
show bpv;

point p[];

p0 := bpv0;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

%dotlabel_if.top(4, bpv4);  %% Doesn't exist.

endfig with_projection parallel_x_z;
end;

%% *** (3) The intersection points of a `parabola' or `hyperbola' and a `plane':
%%         Added code for testing whether the planes are coincident or parallel.
%%         In this case, there are infinitely many intersection points,
%%         so `intersection_points' returns 0.
%%
%%         Fixed more bugs involving vector types.
%% 
%%         LDF 2005.11.30.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 15, -30) with_direction (-5, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 

%parabola h;
hyperbola h;

set h with_max_extent 12;

rectangle r;
r := unit_rectangle scaled (20, 0, 10) shifted (0, 1);

bool_point_vector bpv;

%bpv := get_plane r intersection_points h;  %% Commented-out, to prevent pauses resulting 
                                          %% from the warnings.  LDF 2005.11.30.

message "bpv:";
show bpv;

draw r;
draw h with_color blue;

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

endfig with_projection parallel_x_z;

end;

%% *** (3) The intersection points of a `hyperbola' `h' and a linear `path' `q',
%%         such that `h' and `q' are non-coplanar.
%%
%%         LDF 2005.11.28.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

picture save_picture;

beginfig(1); 
hyperbola h;
set h with_max_extent 10;

transform t;

t := identity shifted (0, 0, 3);

path q[];

point p[];
p0 := get_point 30 h;
p1 := p0 shifted (-2, -5, -1);
p2 := mediate(p1, p0, 2);

q0 := p1 -- p2;
q1 := q0 rotated (0, 100) shifted -2;

h *= q0 *= t;

draw h with_color blue;
draw q0;
draw q1;

bool_point_vector bpv;

bpv := h intersection_points q0;

if size bpv > 0:
    p3 := bpv0;
fi;

%%clear bpv;  %% This is no longer necessary!  LDF 2005.11.28.

bpv := h intersection_points q1;

if size bpv > 0:
    p4 := bpv0;
fi;

%% **** (4) Labels.

pickup pencircle scaled (1.5mm, 1.5mm); 

drawdot p3 with_color red;
label.lrt("$i_0$, {\\tt true}", p3 shifted .25);

drawdot p4 with_color red;
label.lft("$i_1$, {\\tt false}", p4 shifted -.25);

label.rt("$q_0$", (get_point 1 q0) shifted (.225, -.75)); 
label.lft("$q_1$", (get_point 1 q1) shifted (-.225, -.75)); 

save_picture := current_picture;


endfig with_focus f no_sort;

end;

beginfig(2);
output save_picture with_projection parallel_x_y;  
endfig;

beginfig(3);
output save_picture with_projection parallel_x_z;  
endfig;

beginfig(4);
output save_picture with_projection parallel_z_y;  
endfig;

%% *** (3) The intersection of a `hyperbola' and a `plane'.
%%
%%         LDF 2005.11.28.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 15, -30) with_direction (-5, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 
hyperbola h;
set h with_max_extent 12;

transform t;

t := identity shifted (0, 0, 10);

rectangle r;
r := unit_rectangle scaled (20, 0, 10) rotated (45, 40) shifted (2, 0, 2);

bool_point_vector bpv;

bpv := get_plane r intersection_points h;

draw r;
draw h with_color blue;

pen dot_pen;
dot_pen := pencircle scaled (1.5mm, 1.5mm);

point p[];
p0 := bpv0;
p1 := bpv1;

clear bpv;
bpv := (p0 -- p1) intersection_points r;

p2 := bpv0;
p3 := bpv1;

draw p2 -- p3 dashed with_dots;

drawdot p0 with_color red with_pen dot_pen;
label.lft("$i_0$", p0 shifted (-.25, .375));

drawdot p1 with_color red with_pen dot_pen;
label.lrt("$i_1$", p1);

save_picture := current_picture;

endfig with_focus f no_sort; 

beginfig(2);
output save_picture with_projection parallel_x_y;  
endfig;

beginfig(3);
output save_picture with_projection parallel_x_z;  
endfig;

beginfig(4);
output save_picture with_projection parallel_z_y;  
endfig;

end;



%% *** (3) The intersection points of a `hyperbola' `h' and a linear `path' `q',
%%         such that `h' and `q' are non-coplanar.
%%
%%         LDF 2005.11.28.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

picture save_picture;

beginfig(1); 
hyperbola h;
set h with_max_extent 10;

transform t;

t := identity shifted (0, 0, 3);

path q[];

point p[];
p0 := get_point 30 h;
p1 := p0 shifted (-2, -5, -1);
p2 := mediate(p1, p0, 2);

q0 := p1 -- p2;
q1 := q0 rotated (0, 100) shifted -2;

h *= q0 *= t;

draw h with_color blue;
draw q0;
draw q1;

bool_point_vector bpv;

bpv := h intersection_points q0;

if size bpv > 0:
    p3 := bpv0;
fi;

clear bpv;

bpv := h intersection_points q1;

if size bpv > 0:
    p4 := bpv0;
fi;

%% **** (4) Labels.

pickup pencircle scaled (1.5mm, 1.5mm); 

drawdot p3 with_color red;
label.lrt("$i_0$, {\\tt true}", p3 shifted .25);

drawdot p4 with_color red;
label.lft("$i_1$, {\\tt false}", p4 shifted -.25);

label.rt("$q_0$", (get_point 1 q0) shifted (.225, -.75)); 
label.lft("$q_1$", (get_point 1 q1) shifted (-.225, -.75)); 




save_picture := current_picture;


endfig with_focus f no_sort;

beginfig(2);
output save_picture with_projection parallel_x_y;  
endfig;

beginfig(3);
output save_picture with_projection parallel_x_z;  
endfig;

beginfig(4);
output save_picture with_projection parallel_z_y;  
endfig;

end;

%% *** (3) Classifying `points' with respect to a `hyperbola' using 
%%         the `location' operator.
%%
%%         LDF 2005.11.28.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

beginfig(1); 
hyperbola h[];
set h0 with_max_extent 10;
set h1 with_max_extent 7;

point p[];
numeric L[];

%% **** (4) On hyperbola segment:

p0 := get_point 32 h1;
L0 := p0 location h1;
message "L0:";
show L0;

%% **** (4) On hyperbola, but not segment:

p1 := get_point 5 h0;
L1 := p1 location h1;
message "L1:";
show L1;


%% **** (4) Between center and one of the foci:

p2 := (.5, 0, 3);
L2 := p2 location h1;
message "L2:";
show L2;

%% **** (4) Within the region enclosed by the branches of 
%% one of the halves of the hyperbola segment.

p3 := p0 rotated (180, 0, 180) shifted -1;

L3 := p3 location h1;
message "L3:";
show L3;

%% **** (4) Within the region enclosed by the branches of 
%% one of the halves of the hyperbola, but not the segment.

p4 := p1 rotated (180, 0, 180) shifted -1;

L4 := p4 location h1;
message "L4:";
show L4;

%% **** (4) `point' is coplanar with the hyperbola, but does not lie on the curve,
%%          within one of the regions enclosed by the branches, or between the branches.
%% 

p5 := p1 rotated 180 shifted -1;

L5 := p5 location h1;
message "L5:";
show L5;

%% **** (4) `point' is not coplanar with the hyperbola.

p6 := p0 shifted (-1, 1, -5);

L6 := p6 location h1;
message "L6:";
show L6;

%% **** (4) Drawing commands.

pickup pencircle scaled (.75mm, .75mm);

draw h0 dashed with_dots;
draw h1 with_color blue;

%% **** (4) Labels.

pickup pencircle scaled (2mm, 2mm);

for i = 0 upto 6:
   drawdot p[i] with_color red;
endfor;

string s;

s := "$p_0$, $l = " & decimal L[0] & "$";
label.rt(s, p0 shifted .25);

s := "$p_1$, $l = " & decimal L[1] & "$";
label.lft(s, p1 shifted -.25);

s := "\setbox0=\hbox{$l = " & decimal L[2] & "$}\vbox{\hbox to \wd0{\hfil$p_2$,\hfil}\box0}";
label.top(s, p2 shifted (0, 0, .25));

s := "$p_3$, $l = " & decimal L[3] & "$";
label.lft(s, p3 shifted -.25);

s := "$p_4$, $l = " & decimal L[4] & "$";
label.lft(s, p4 shifted -.25);

s := "$p_5$, $l = " & decimal L[5] & "$";
label.lft(s, p5 shifted -.25);

s := "\setbox0=\hbox{$p_6$ ($y \\neq 0$),}\vbox{\copy0\hbox to \wd0{\hfil $l = " 
   & decimal L[6] & "$\hfil}}";
label.bot(s, p6 shifted (0, 0, -.25));


%% **** (4) 

endfig with_projection parallel_x_z;
end;

%% *** (3) The intersection points of a `hyperbola' `h' and a linear `path' `q',
%%         such that `h' and `q' are coplanar, and the slope of `q' is infinite.
%%
%%         LDF 2005.11.27.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

beginfig(1); 
hyperbola h;
set h with_max_extent 10;

transform t;

t := identity rotated (45, 45);

path q[];

q0 := ((-10, 0) -- (10, 0)) rotated (0, 90) shifted 2;

%q0 *= h *= t;

draw h;
draw q0;

bool_point_vector bpv;

bpv := h intersection_points q0;

pen p;
p := pencircle scaled (1.5mm, 1.5mm);

if true: % false
if size bpv > 0:
   point A;
   A := bpv0;
   drawdot bpv0 with_color red with_pen p;
   label.lrt("$i_0$", bpv0);  % A shifted (0, 0, .2)
fi;

if size bpv > 1:
   drawdot bpv1 with_color red with_pen p;
   label.urt("$i_1$", bpv1);
fi;
fi;

endfig with_projection parallel_x_z;
end;



%% *** (3) The intersection points of a `hyperbola' `h' and a linear `path' `q',
%%         such that `h' and `q' are coplanar, and the slope of `q' is 0.
%%
%%         LDF 2005.11.27.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

beginfig(1); 
hyperbola h;
set h with_max_extent 10;

transform t;

t := identity rotated (45, 45);

path q[];

q0 := (-12, 0, 2) -- (12, 0, 2);  % rotated (0, 30, 0) shifted 1;

%q0 *= h *= t;


draw h;
draw q0;

bool_point_vector bpv;

bpv := h intersection_points q0;

pen p;
p := pencircle scaled (1.5mm, 1.5mm);

if size bpv > 0:
   point A;
   A := bpv0;
   drawdot bpv0 with_color red with_pen p;
   label.urt("$i_0$", bpv0);  % A shifted (0, 0, .2)
fi;

if size bpv > 1:
   drawdot bpv1 with_color red with_pen p;
   label.ulft("$i_1$", bpv1);
fi;


endfig with_projection parallel_x_z;
end;

%% *** (3) The intersection points of a `hyperbola' `h' and a linear `path' `q',
%%         such that `h' and `q' are coplanar, and the slope of `q' is finite
%%         and non-zero.
%%         LDF 2005.11.27.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

beginfig(1); 
hyperbola h;
set h with_max_extent 10;

transform t;

t := identity rotated (45, 45);

path q[];

q0 := (-12, 0) -- (12, 0) rotated (0, 30, 0) shifted 1;

%q0 *= h *= t;


draw h;
draw q0;


%dotlabel.top(0, h);
%dotlabel.urt("$o$", origin);

bool_point_vector bpv;

bpv := h intersection_points q0;

pen p;
p := pencircle scaled (1.5mm, 1.5mm);

if size bpv > 0:
   point A;
   A := bpv0;
   drawdot bpv0 with_color red with_pen p;
   label.urt("$i_0$", A shifted (0, 0, .2));
fi;

if size bpv > 1:
   drawdot bpv1 with_color red with_pen p;
   label.ulft("$i_1$", bpv1);
fi;


endfig with_projection parallel_x_z;
end;

%% *** (3) The intersection of a `parabola' and coplanar linear `paths',
%%         whose slopes are 0 or infinite.  I had neglected to program
%%         these cases before.
%%
%%         LDF 2005.11.24.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);
parabola p;
set p with_parameter 3 with_extent 12;


path q[];
q0 := (2, 0, -4) -- (2, 0, 4);
q1 := (-2, 0, 1) -- (10, 0, 1);

%transform t;
%t := identity rotated (15, 15);

% p *= q0 *= t;

draw q0;
draw p;
draw q1;

bool_point_vector bpv;
bpv := p intersection_points q0;

if size bpv > 0:
   dotlabel.ulft("$i_0$", bpv0) with_dot_color red;
fi;

if size bpv > 1:
   dotlabel.llft("$i_1$", bpv1) with_dot_color red;
fi;

clear bpv;


bpv := p intersection_points q1;

if size bpv > 0:
   dotlabel.ulft("$i_2$", bpv0) with_dot_color red;
fi;

endfig with_projection parallel_x_z;  

end;

%% *** (3) 

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 


pickup pencircle scaled (.75mm, .75mm);




beginfig(1);

ellipse e;
set e with_point_count 64;
scale e (6, 0, 8);

rectangle r[];
r0 := unit_rectangle scaled (5, 0, 6) rotated (90, 30);

draw e;

draw r0;

point_vector pv;

pv := e intersection_points get_plane r0;

%% START HERE.  The problem seems to be in |vector_type_assign()| 
%% in `scanprse.web'.  LDF 2005.11.21.

clear pv;

pv := e intersection_points get_plane r0;

message "pv:";
show pv;

endfig with_focus f; 

end;


%% *** (3) The intersection of a `parabola' and linear `paths' that do 
%%        not lie in the same plane as the `parabola'.
%%        LDF 2005.11.21.

picture axis_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 5;
axis_x_rt    := 15;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 7;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0);
drawarrow origin -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, 0, -.1));

drawarrow origin -- (0, -axis_y_bot);
drawarrow origin -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawarrow origin -- (0, 0, -axis_z_front);
drawarrow origin -- (0, 0, axis_z_back);
label.lft("z", (-.25, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 



verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (.75mm, .75mm);


beginfig(1);
parabola prb[];

point p[];

set prb0 with_parameter 3 with_extent 12;

p0 := get_point 3 prb0;

p1 := p0 shifted (3, 5, 3);

p2 := mediate(p1, p0, 2);

path q[];

q0 := p2 -- p1;

q1 := q0 rotated (-15, 30) shifted (15, 0, -1);

draw q0;
draw q1;

draw prb0 with_color red;

output axis_picture with_focus f no_sort;
output current_picture with_focus f no_sort;
clear current_picture;

%% **** (4) 

verbatim_metapost "pickup pencircle scaled .75mm";

bool_point_vector bpv;

bpv := prb0 intersection_points q0;

message "bpv:";
show bpv;

if size bpv > 0:
   dotlabel.ulft("$i_0$", bpv0) with_dot_color blue;
fi;

clear bpv; %% This shouldn't be necessary!  Fix it.  LDF 2005.11.21.

bpv := prb0 intersection_points q1;

message "bpv:";
show bpv;

if size bpv > 0:
   dotlabel.urt("$i_1$", bpv0) with_dot_color blue;
fi;

endfig with_focus f no_sort; 

end;

%% *** (3) The intersection of a `parabola' and a `plane'.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (1mm, 1mm);


beginfig(1);
parabola prb[];

set prb0 with_parameter 3 with_extent 12;
set prb1 with_parameter 3 with_extent 30;

draw prb1 dashed with_dots;
draw prb0;

rectangle r;
r := unit_rectangle scaled (30, 0, 15) rotated (75, 20) shifted (5, 0, 3);

draw r with_color red;

plane pln;

pln :=get_plane r;

bool_point_vector bpv;

bpv := prb0 intersection_points pln;

message "bpv:";
show bpv;

point p[];

p0 := bpv0;
p1 := bpv1;

path pth[];
pth0 := p0 -- p1;

bool_point_vector cpv;
cpv := r intersection_points pth0;

p2 := cpv0;
p3 := cpv1;

pth1 := p2 -- p3;

draw pth1 dashed with_dots with_color red;

output current_picture with_focus f no_sort;  
clear current_picture;

%% **** (4) 

pickup pencircle scaled (1mm, 1mm);

verbatim_metapost "pickup pencircle scaled .75mm";

if size bpv > 0:
   dotlabel.top("$p_0$", bpv0) with_dot_color blue;
fi;

if size bpv > 1:
   dotlabel.ulft("$p_1$", bpv1) with_dot_color blue;
fi;

if false: 
   if size cpv > 0:
      dotlabel.urt(2, cpv0) with_dot_color blue;
   fi;

   if size cpv > 1:
      dotlabel.lft(3, cpv1) with_dot_color blue;
   fi;
fi;

%% **** (4) 


endfig with_focus f;  

%verbatim_metapost "end";

end;



%% *** (3) The location of a `point' with respect to a `parabola'.
%%         LDF 2005.11.21.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

picture axis_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 5;
axis_x_rt    := 15;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 7;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0);
drawarrow origin -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, 0, -.1));

drawarrow origin -- (0, -axis_y_bot);
drawarrow origin -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawarrow origin -- (0, 0, -axis_z_front);
drawarrow origin -- (0, 0, axis_z_back);
label.lft("z", (-.25, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (1mm, 1mm);

beginfig(1);
parabola parab[];
set parab0 with_parameter 3 with_extent 7;

set parab1 with_parameter 3 with_extent 12;

transform t;
t := identity rotated (60, 15)  shifted (1, 0, -2);

parab0 *= parab1 *= t;

draw parab1 with_color red dashed with_dots;

draw parab0 with_color blue;

point p[];

%% **** (4) 

%% ***** (5) 0:  On parabola segment.

p0 := get_point 4 parab0;

numeric pos[];

pos0 := p0 location parab0;  

message "pos0:";
show pos0;

%% ***** (5) 1:   On parabola, but not segment.

p1 := get_point 2 parab1;

numeric pos[];

pos1 := p1 location parab0;  

message "pos1:";
show pos1;

%% ***** (5) 2:  Within the region enclosed by the branches of  
%%               the parabola and the line connecting the end points 
%%               of the segment.

p10 := get_point (size parab0 - 2) parab0;

p2 := mediate(p0, p10);

pos2 := p2 location parab0;  

message "pos2:";
show pos2;

%% ***** (5) 3:  Between the branches of the parabola, but
%%               outside the region enclosed by them and the 
%%               line connecting the end points of the segment.

p11 := get_point (size parab1 - 2) parab1;

p3 := mediate(p1, p11);

draw p1 -- p11 dashed withdots with_color red;

pos3 := p3 location parab0;  

message "pos3:";
show pos3;

%% ***** (5) -1: Coplanar with the parabola, but
%%               does not lie on the curve or between the branches.

p4 := mediate(p0, p10, 1.25);

draw p0 -- p4 dashed withdots with_color dark_gray;

pos4 := p4 location parab0;  

message "pos4:";
show pos4;

%% ***** (5) -2: Not coplanar with the parabola.

p5 := (13, 9, -2);

pos5 := p5 location parab0;  

message "pos5:";
show pos5;

%% ***** (5) 

%% **** (4) 

output axis_picture with_focus f;
output current_picture with_focus f;

clear current_picture;

%% **** (4) 

verbatim_metapost "pickup pencircle scaled 1mm;";

%pickup pencircle scaled (1mm, 1mm);

dotlabel.ulft("\vbox{\hbox{$p_0$,}\hbox{$l = 0$}}", p0);

drawdot p1;
label.rt("$p_1$, $l = 1$", p1 shifted (.25, 0)); 

dotlabel.lrt("$p_2$, $l = 2$", p2); 

drawdot p3;
label.urt("$p_3$, $l = 3$", p3 shifted (.25, 0));

dotlabel.lrt("$p_4$, $l = -1$", p4);

label.top("$p_5$", p5 shifted (0, .25));
dotlabel.bot("$l = -2$", p5);

%dotlabel.llft("$p_{10}$", p10); 

%dotlabel.bot("$p_{11}$", p11); 

%% **** (4) 

endfig with_focus f no_sort;  %with_projection parallel_x_z;
end;

%% *** (3) The intersection of a `parabola p' and a linear `path q', such
%%         that `p' and `q' are coplanar.
%%         LDF 2005.11.21.

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

focus f;
set f with_position (0, 10, -20) with_direction (0, 10, 100) with_distance 15; 

pickup pencircle scaled (1mm, 1mm);

beginfig(1);
parabola p;
set p with_parameter 3 with_extent 7;

path q;
q := ((-5, 0, -5) -- (7, 0, 12)) shifted (5, 0, -2);

draw p with_color blue;
draw q;

pickup pencircle scaled (2mm, 2mm);

drawdot get_vertex p;
drawdot get_focus p;

label.lft("$v$", get_vertex p); 
label.rt("$f$", get_focus p); 

bool_point_vector bpv;
bpv := p intersection_points q;

if size bpv > 0:
   drawdot bpv0 with_color red;
   label.lrt("$i_0$", bpv0);
fi;

if size bpv > 1:
   point A;
   A := bpv1;
   shift A by -.333;
   drawdot bpv1 with_color red;
   label.lft("$i_1$", A);
fi;

endfig with_projection parallel_x_z;
end;


%% *** (3) "Standardizing" a `parabola'.
%%         The `standardize' operator takes a `parabola' argument
%%         and returns a `transform'.  This is the `transform' that
%%         would put the `parabola' into "standard position", i.e.,
%%         in the x-z plane, with its vertex
%%         at the origin and its focus on the positive x-axis.
%%         `standardize' leaves the `parabola' unchanged.
%%         To actually put it into standard position, you must 
%%         multiply it by the `transform' that was returned.
%%
%%         LDF 2005.11.18.

verbatim_metapost "ahlength := .25cm;";

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";

picture axis_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 10;
axis_x_rt    := 10;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 10;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0);
drawarrow origin -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, 0, -.1));

drawarrow origin -- (0, -axis_y_bot);
drawarrow origin -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawarrow origin -- (0, 0, -axis_z_front);
drawarrow origin -- (0, 0, axis_z_back);
label.lft("z", (-.25, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

focus f;
set f with_position (-5, 10, -20) with_direction (-5, 10, 100) with_distance 15; 

pickup pencircle scaled (1mm, 1mm);

picture save_picture;

beginfig(1);
parabola p;
set p with_parameter 3 with_extent 7;

rotate p (75, 50);
shift p (3.5, 8, -1.75);

draw p;

transform t;

t := standardize p;

p *= t;

draw p with_color blue;

save_picture := current_picture;

output axis_picture with_focus f;
endfig with_focus f;

beginfig(2);
output save_picture with_projection parallel_x_y;  
endfig;

beginfig(3);
output save_picture with_projection parallel_x_z;  
endfig;

beginfig(4);
output save_picture with_projection parallel_z_y;  
endfig;

end;

%% *** (3) Making a `parabola' cyclical and filling it.
%%         Enough points must be used for the curve, because using `&' 
%%         to connect it with the line segment connecting the
%%         end points causes an error in MetaPost.
%%
%%         It also works to make it non-cyclical again.
%%         LDF 2005.11.18.

pickup pencircle scaled (1mm, 1mm);

beginfig(1);
parabola p;
set p with_parameter 3 with_extent 7;

p += cycle;

filldraw p with_fill_color blue;

shift p (0, 0, -15);

p -= cycle;

draw p;

endfig with_projection parallel_x_z;
end;







%% *** (3) `hyperbolae' now work.
%%         LDF 2005.11.15.


verbatim_metapost "ahlength := .25cm;";

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";
verbatim_metapost "verbatimtex \font\Large=cmr17 etex";

picture axis_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 10;
axis_x_rt    := 10;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 10;
axis_z_back  := 10;

drawarrow origin -- (-axis_x_lft, 0);
drawarrow origin -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, 0, -.1));

%drawarrow origin -- (0, -axis_y_bot);
%drawarrow origin -- (0, axis_y_top);
%label.lft("y", (0, axis_y_top)); 

drawarrow origin -- (0, 0, -axis_z_front);
drawarrow origin -- (0, 0, axis_z_back);
label.lft("z", (-.25, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

pickup pencircle scaled (1mm, 1mm);

beginfig(1);
output axis_picture with_projection parallel_x_z;
hyperbola h;
set h with_max_extent 10; 
draw h with_color blue;
point F[];
F0 := get_focus 0 h;
pickup pencircle scaled (2mm, 2mm);
drawdot F0;
label.lrt("$F_0$", F0);
F1 := get_focus 1 h;
drawdot F1;
label.llft("$F_1$", F1);
endfig with_projection parallel_x_z;   
end;

%% *** (3) `parabolae' are now usable.
%%         LDF 2005.11.09.

verbatim_metapost "ahlength := .25cm;";

verbatim_metapost "verbatimtex \magnification=\magstep5 \font\large=cmr12 etex";
verbatim_metapost "verbatimtex \font\Large=cmr17 etex";

focus f;
set f with_position (0, 10, -20) with_direction (0, 10, 100) with_distance 15; 

picture axis_picture;
picture save_picture;

%% **** (4) axis_picture.

beginfig(0);
pickup blue;

pickup pencircle scaled (1mm, 1mm);

axis_x_lft   := 10;
axis_x_rt    := 10;
axis_y_bot   := 10;
axis_y_top   := 10;
axis_z_front := 10;
axis_z_back  := 10;

%drawarrow origin -- (-axis_x_lft, 0) with_color blue;
drawarrow origin -- (axis_x_rt, 0) with_color blue;
label.bot("x", (axis_x_rt, 0, -.1));

%drawarrow origin -- (0, -axis_y_bot) with_color blue;
drawarrow origin -- (0, axis_y_top) with_color blue;
label.lft("y", (0, axis_y_top)); 

%drawarrow origin -- (0, 0, -axis_z_front) with_color blue;
%drawarrow origin -- (0, 0, axis_z_back) with_color blue;
%label.lft("z", (0, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 


color_vector cv;
cv += red;
cv += green;
cv += blue;
cv += cyan;
cv += yellow;
cv += magenta;

beginfig(1);


parabola p;

path q[];

set p 
   with_parameter 3
%  with_vertex vertex  
%  with_focus p_focus  
   with_extent 7cm;

draw p; % with_color cv0;

p_last := size p - 1;

for j = 0 upto 6:
   q[j] += get_point (j * 3) p;
   q[10 + j] += get_point (p_last - (j * 3)) p;
endfor;

%dotlabel.top(0, p);


for i = 1 upto 23:
   rotate p by 7.5;

   for j = 0 upto 6:
      q[j] += get_point (j * 3) p;
      q[10 + j] += get_point (p_last - (j * 3)) p;
   endfor;

if is_even i:
   draw p ;% with_color cv[i];
fi;

endfor;

for j = 0 upto 6:
   q[20 + j] := q[j] .. q[10 + j];
   clear_connectors q[20 + j];
   q[20 + j] += ..;
   q[20 + j] += cycle;
   draw q[20 + j];
endfor;

%dotlabel.lft(0, p); 

save_picture := current_picture;


%output axis_picture with_focus f;
output current_picture with_focus f;
clear current_picture;

if false:
   verbatim_metapost "verbatimtex \setbox0=\hbox{parabola:\space} etex"; 
   verbatim_metapost "verbatimtex \setbox1=\hbox{focus:\space} etex"; 

   y_value     := -11;
   shift_value := -1;


   label.rt("{\large Perspective Projection}", (0, y_value));

   y_value -= .5;
   y_value += shift_value;

   label.rt("\copy0", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd0 vertex at origin", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd0 parameter $=$ 3cm", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd0 axis $=$ positive x-axis", (0, y_value));

   y_value -= .5;
   y_value += shift_value;

   label.rt("\copy1", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd1 position: (0, 10, -20)", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd1 direction: (0, 10, 100)", (0, y_value));
   y_value += shift_value;
   label.rt("\hskip\wd1 distance: 10", (0, y_value));
   y_value += shift_value;
fi;

endfig with_projection parallel_x_y;

beginfig(2); 
output save_picture with_projection parallel_x_y;
if false: 
   label.rt("{\large Parallel Projection, X-Y Plane}", (0, -8));
fi; 
endfig with_projection parallel_x_y;

beginfig(3); 
output save_picture with_projection parallel_x_z;
if false: 
   label.rt("{\large Parallel Projection, X-Z Plane}", (0, -8));
fi; 
endfig with_projection parallel_x_y;

beginfig(4); 
output save_picture with_projection parallel_z_y;
if false: 
   label("{\large Parallel Projection, Z-Y Plane}", (0, -8));
fi; 
endfig with_projection parallel_x_y;

end;

%% *** (3) Working on the function for finding the 
%%         intersection of an `ellipsoid' and the plane of a `rectangle'.
%%         It doesn't work yet.
%%         LDF 2005.10.31.

verbatim_metapost "verbatimtex  \magnification=\magstep3 \font\large=cmr17 etex";

picture save_picture;

focus f;

set f with_position (-1, 5, -20) with_direction (-1, 5, 10) 
      with_distance 20;

picture frame_picture;
picture axis_picture;

%% **** (4) axis_picture.

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft := 9;
axis_x_rt := 9.5;
axis_y_bot := 9;
axis_y_top := 7;
axis_z_front := 13;
axis_z_back := 500;

drawdblarrow (-axis_x_lft, 0) -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, -.1));

drawdblarrow (0, -axis_y_bot) -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawdblarrow (0, 0, -axis_z_front) -- (0, 0, axis_z_back);
label.lft("z", (0, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

%% **** (4) frame_picture.

beginfig(0);

h := 14;
v := 11;

draw ((-h, -v) -- (h, -v) -- (h, v) -- (-h, v) -- cycle)
shifted (1, -7);

%; % with_color white;

frame_picture := current_picture;
clear current_picture;
endfig; 






%% **** (4) The intersection of an `ellipsoid' and a `plane'.
%%          The figure formed is an `ellipse'.  Working on this.
%%          I can now find points on the ellipse and sort them.
%%          LDF 2005.11.05.


%% **** (4) Added a parser rule and functions for finding the intersection
%%          points of an `ellipse' and a `plane'.
%%          LDF 2005.11.04.

ellipsoid e;
set e with_center (0, 0, 0) with_axis_x 15 with_axis_y 8 with_axis_z 10
      with_divisions_x 4 with_divisions_y 4 with_divisions_z 2
      with_point_count 64;


rotate e (15, 0, 15);
shift e (5, 5, 5);

ellipse g;

rectangle r;
r := unit_rectangle scaled 15;

rotate r (0, 15, 45);
shift r by 1;

string s;

path_vector pv;
point_vector qv;

color_vector cv;
cv += red;
cv += green;
cv += blue;
cv += cyan;
cv += yellow;
cv += magenta;
cv += orange;
cv += purple;


%% ***** (5) Figure 1.

beginfig(1); 

%%   rotate r (0, 0, 5);




%g := unit_ellipse scaled (4, 0, 3) rotated 90;

%draw g;

% qv := g intersection_points get_plane r;
% message "pv:";
% show pv;

% drawdot pv0 with_color red;
% drawdot pv1 with_color green;

draw e; % with_color_vector cv;

%output frame_picture with_projection parallel_x_y;

pv := e intersection get_plane r;

message "size pv:";
show size pv;

%draw pv0 with_color blue;
%draw pv1 with_color red;
draw pv2 with_color green;

%show pv;

for i = 0 upto size pv2 - 1:
if is_even i:
   dotlabel.top(i, get_point (i) pv2); 
else: 
   dotlabel.bot(i, get_point (i) pv2);
fi;
endfor;

%if size pv > 0:    
%   for i = 0 upto size pv - 1:
%      draw pv[i];
%   endfor;
%fi;

%   draw g with_color violet;

    draw r with_color blue;
%   draw e;
   
   string s;

   pickup pencircle scaled (1.5mm, 1.5mm);


   save_picture := current_picture;
   output current_picture with_focus f no_sort;   

   clear current_picture;

   output axis_picture with_focus f;   
    label("{\large Perspective}", (2, -15));

endfig with_projection parallel_x_y;

%% ***** (5) 

beginfig(2);
output save_picture with_projection parallel_x_y;  
label("{\large X-Y}", (0, -10));
endfig with_projection parallel_x_y;


%% ***** (5) 

beginfig(3);
output save_picture with_projection parallel_x_z;  
label("{\large X-Z}", (0, -10));
endfig with_projection parallel_x_y;

%% ***** (5) 

beginfig(4);
output save_picture with_projection parallel_z_y;  
label("{\large Z-Y}", (0, -10));
endfig with_projection parallel_x_y;

end;

%% *** (3) Braikenridge-Maclaurin Construction.
%% Constructing an ellipse from 6 points.  
%% LDF 2005.11.03.

verbatim_metapost "verbatimtex  \magnification=\magstep2 etex";

beginfig(1);

ellipse e;
e := unit_ellipse scaled (4, 0, 3);

pen path_pen;

path_pen := pencircle scaled (.7mm, .7mm);
pickup path_pen;

draw e;

point A, B, C, D, E, F;

A := get_point (15) e;
B := get_point (11) e;
C := get_point (8)  e;
D := get_point (6)  e;
E := get_point (3)  e;
F := get_point (0)  e;

pen dot_pen;
dot_pen := pencircle scaled (1mm, 1mm);

pickup dot_pen;

dotlabel.rt("A", A) with_dot_color red;
dotlabel.bot("B", B) with_dot_color red;
dotlabel.lft("C", C) with_dot_color red;
dotlabel.lft("D", D) with_dot_color red;
dotlabel.top("E", E) with_dot_color red;
dotlabel.rt("F", F) with_dot_color red;

pickup pencircle scaled (.7mm, .7mm);

%% **** (4) Point X

path q[];

q0 := A -- C;
q1 := B -- D;

pickup path_pen;

draw q0;
draw q1;

point X;
X := q0 intersection_point q1;

pickup dot_pen;

dotlabel.llft("$X$", X) with_dot_color red;

%% **** (4) Point Y

q2 := B -- E;
q3 := C -- F;

pickup path_pen;

draw q2;
draw q3;

point Y;
Y := q2 intersection_point q3;

pickup dot_pen;

dotlabel.ulft("$Y$", Y) with_dot_color red;

%% **** (4) Point Z

q4 := A -- E;
q5 := D -- F;

pickup path_pen;

draw q4;
draw q5;

point Z;
Z := q4 intersection_point q5;

pickup dot_pen;

dotlabel.urt("$Z$", Z) with_dot_color red;

%% **** (4) 

point Z';
Z' := mediate(Z, E, .5);

dotlabel.urt("$Z'$", Z')  with_dot_color red;

point Y';

Y' := (B -- E) intersection_point (Z' -- X);

dotlabel.lrt("$Y'$", Y') with_dot_color red;

point G;
G := mediate(C, Y', 2);

dotlabel.rt("G", G);

draw C -- G with_pen path_pen dashed evenly;

point H;
H := mediate(D, Z', 2);

dotlabel.rt("$H$", H);

draw D -- H with_pen path_pen dashed evenly;

point J;
J := (C -- G) intersection_point (D -- H);

pickup dot_pen;

drawdot J with_color red; 
label.urt("$J$", J shifted (0, 0, .25));


endfig with_projection parallel_x_z no_sort;  
end;


%% *** (3) Revised `message_command':  It now takes a `string_expression' argument
%%         rather than a |STRING| token.
%%         LDF 2005.11.03.

%%         `strings' can now contain control characters:  `\n' for a newline,
%%         `\"' for a double-quote, `\t' for a tab, `\\' for a backslash.
%%         `\' is also interpreted as a backslash, _unless_ it's followed
%%         by `\', `n', `"', or `t'.  `\\' thus makes it possible to get the
%%         literal string "\n" by typing "\\n".
%%         LDF 2005.11.03.


string s;
s := "PI with 13 digits of precision---" & decimal 3.141592653589793 with_precision 13 & "---";
message s;

s := "three tabs--- \t\t\t ---three tabs";
message s;

s := "quote--- \" ---quote";
message s;

s := "single backslash a--- \a ---single backslash a, not a control character.";
message s;

s := "double backslash--- \\ --- double backslash";
message s;


s := "double backslash n--- \\n --- double backslash n";
message s;

s := "newline--- \n ---newline";
message s;

beginfig(1);
drawdot origin;
endfig; 
end;









%% *** (3) Added parser rules and functions for `ellipsoids'.
%%         LDF 2005.10.31.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

focus f;

set f with_position (-6, 7, -20) with_direction (-1, 7, 10) 
      with_distance 20;


picture frame_picture;
picture axis_picture;

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft := 15;
axis_x_rt := 20;
axis_y_bot := 10;
axis_y_top := 10;
axis_z_front := 10;
axis_z_back := 500;

drawdblarrow (-axis_x_lft, 0) -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, -.1));

drawdblarrow (0, -axis_y_bot) -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawdblarrow (0, 0, -axis_z_front) -- (0, 0, axis_z_back);
label.llft("z", (0, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;

h := 14;
v := 11;

draw ((-h, -v) -- (h, -v) -- (h, v) -- (-h, v) -- cycle)
shifted (1, -7);

%; % with_color white;

frame_picture := current_picture;
clear current_picture;
endfig; 

picture save_picture;

color_vector cv;
% cv += red;
% cv += green;
% cv += blue;
 cv += black;
% cv += black;
% cv += black;

ellipsoid e;

set e with_center origin with_axis_x 25 with_axis_y 10 with_axis_z 6
      with_divisions_x 12 with_divisions_y 12;
%rotate e (0, 90);

%shift e (0, 0, 10);

%message "e:";
%show e;

beginfig(1);

draw e with_color_vector cv;

save_picture := current_picture;

%output frame_picture with_projection parallel_x_y;
output axis_picture with_focus f;

endfig with_focus f;


beginfig(2);
%output frame_picture with_projection parallel_x_y;
%output axis_picture with_projection parallel_x_y; 
output save_picture with_projection parallel_x_y; 
endfig;

beginfig(3);
%output frame_picture with_projection parallel_x_y;
%output axis_picture with_projection parallel_x_z; 
output save_picture with_projection parallel_x_z; 
endfig;

beginfig(4);
%output frame_picture with_projection parallel_x_y;
%output axis_picture with_projection parallel_z_y; 
output save_picture with_projection parallel_z_y; 
endfig;

end;

%% *** (3) Replaced code in the parser rules for showing some kinds of 
%%         expressions.  
%%         LDF 2005.10.31.

beginfig(1);
path p;
p := (origin -- (3, 0) -- (3, 3) -- (0, 3) -- cycle) shifted (0, 0, 1);

draw p;

plane q[];

q0 := p;

message "q0:";
show q0;

message "q1:";
show q1;

transform t[];
t0 := identity;
show t0;
show t1;


point p[];
p0 := (1, 2, 3);
show p0;
show p1;

endfig with_projection parallel_x_y; 
end;



%% *** (3) Intersection of a `sphere' and the plane of a `rectangle'
%%         or an `ellipse'.
%%         LDF 2005.10.30.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";


focus f;

set f with_position (-1, 5, -20) with_direction (-1, 5, 10) 
      with_distance 20;

picture frame_picture;
picture axis_picture;

beginfig(0);

pickup pencircle scaled (1mm, 1mm);

axis_x_lft := 9;
axis_x_rt := 9.5;
axis_y_bot := 9;
axis_y_top := 7;
axis_z_front := 13;
axis_z_back := 500;

drawdblarrow (-axis_x_lft, 0) -- (axis_x_rt, 0);
label.bot("x", (axis_x_rt, -.1));

drawdblarrow (0, -axis_y_bot) -- (0, axis_y_top);
label.lft("y", (0, axis_y_top)); 

drawdblarrow (0, 0, -axis_z_front) -- (0, 0, axis_z_back);
label.lft("z", (0, 0, axis_z_back)); 

axis_picture := current_picture;
clear current_picture;
endfig; 

beginfig(0);

h := 14;
v := 11;

draw ((-h, -v) -- (h, -v) -- (h, v) -- (-h, v) -- cycle)
shifted (1, -7);

%; % with_color white;

frame_picture := current_picture;
clear current_picture;
endfig; 

sphere s;
set s with_center (0, -2.75, 0) with_radius 5 with_point_count 64 with_divisions 6;

rotate s (5, 5);

circle c;

ellipse e;
set e with_point_count 64;
scale e (20, 0, 20);

rectangle r;
r := unit_rectangle scaled 15;

rotate e (5, 0, 5);
shift e by -.75;

rotate r (5, 0, 5);
shift r by -.75;

for i = 1 upto 5:
   beginfig(i); 

   output frame_picture with_projection parallel_x_y;

   rotate r (5, 0, 5);
   rotate e (5, 0, 5);

   shift s (0, 1);

%   c := s intersection get_plane r;

    c := s intersection get_plane e;

   path q[];

   filldraw c with_fill_color gray with_draw_color blue;
  
   draw s;

%   draw r with_color red;
    draw e with_color red;

   output current_picture with_focus f no_sort;   

   clear current_picture;

   output axis_picture with_focus f;   
   
   endfig;
endfor;

%% *** (3) Added parser rule and function for finding the intersection
%%         points of a `sphere' and a linear `path'.

%verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (1mm, 1mm);

focus f;

set f with_position (-1, 5, -20) with_direction (-1, 5, 10) 
      with_distance 20;

beginfig(5);
drawdot origin;

path p;
p := (-6, -6) -- (10, 10);
rotate p (0, 75);

draw p with_color blue;

sphere s;
set s with_radius 6 with_divisions 10;

rotate s (15, 0, 15);

draw s;

bool_point_vector bpv;

bpv := s intersection_points p;

pickup pencircle scaled (.375cm, .375cm);

drawdot bpv0 with_color red;
drawdot bpv1 with_color red;

point i[];
i0 := bpv0;
i1 := bpv0;
shift i1 (1, 3);;

pickup pencircle scaled (.75mm, .75mm);

drawarrow i1 -- i0;

i2 := bpv1;
i3 := bpv1;
shift i3 (-1, -1);

drawarrow i3 -- i2;

label.rt("$i_0$",  i1);
label.lft("$i_1$", i3);

endfig with_focus f no_sort;  
end;

%% *** (3) Intersection points of a `polygon' and a `reg_polygon'.

beginfig(1);

point_vector pv;
point_vector qv;

polygon p;
reg_polygon q;

p := unit_pentagon scaled 2 rotated 90;
q := unit_hexagon scaled 2 rotated 90;

draw p;
draw q;

pv := p intersection_points q;

for i = 0 upto size pv - 1:
   dotlabel.top(i, pv[i]); 
endfor;

qv := q intersection_points p;

for i = 0 upto size qv - 1:
   dotlabel.bot(i, qv[i]) with_text_color red with_dot_color red; 
endfor;

endfig with_projection parallel_x_y; 
end;



%% *** (3) Intersection points of two `polygons'.

beginfig(1);

point_vector pv;

polygon p;
polygon q;

p := unit_pentagon scaled 2 rotated 90;
q := unit_hexagon scaled 2 rotated 90;

draw p;
draw q;

pv := p intersection_points q;

for i = 0 upto size pv - 1:
   dotlabel.top(i, pv[i]); 
endfor;

endfig with_projection parallel_x_y; 
end;


%% *** (3) Intersection points of a `triangle' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point_vector bpv;

triangle q;

set q with_points ((-3, -1), (3, -1), (0, 3));

draw q;


bpv := q intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;

cpv := p1 intersection_points q;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

endfig with_projection parallel_x_y; 
end;



%% *** (3) Intersection points of a `rectangle' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point_vector bpv;

rectangle q;

q := unit_rectangle scaled (2, 3) rotated 90;
draw q;

bpv := q intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;

cpv := p1 intersection_points q;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

endfig with_projection parallel_x_y; 
end;



%% *** (3) Intersection points of a `reg_polygon' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point_vector bpv;

reg_polygon q;

q := unit_pentagon scaled 2 rotated 90;
draw q;

bpv := q intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;

cpv := p1 intersection_points q;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

endfig with_projection parallel_x_y; 
end;

%% *** (3) Intersection points of a `polygon' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point_vector bpv;

polygon q;

q := unit_pentagon scaled 2 rotated 90;
draw q;

bpv := q intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;

cpv := p1 intersection_points q;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

endfig with_projection parallel_x_y; 
end;



%% *** (3) Intersections of a `circle' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point bp;
bp := p0 intersection_point p1;

dotlabel_if.top("bp", bp);


bool_point_vector bpv;

circle c;

c := unit_circle rotated 90;
draw c;

bpv := c intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;


cpv := p1 intersection_points c;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

 
endfig with_projection parallel_x_y; 

end;



%% *** (3) Intersections of an `ellipse' and a linear `path'.

beginfig(1);

path p[];
p0 := (-5, -5) -- (5, 5);
p1 := (-5, 5) -- (5, -5);

draw p0;
draw p1;

bool_point bp;
bp := p0 intersection_point p1;

dotlabel_if.top("bp", bp);


bool_point_vector bpv;

ellipse e;

e := unit_ellipse scaled (2, 3) rotated 90;
draw e;

bpv := e intersection_points p0;

dotlabel_if.rt("bpv${}_0$", bpv0); 
dotlabel_if.lft("bpv${}_1$", bpv1); 

bool_point_vector cpv;


cpv := p1 intersection_points e;

dotlabel_if.rt("cpv${}_0$", cpv0); 
dotlabel_if.lft("cpv${}_1$", cpv1); 

 
endfig with_projection parallel_x_y; 

end;

%% *** (3) Intersection points of an `ellipse' and a `circle'.

beginfig(1); 

bool_point_vector bpv_a;
bool_point_vector bpv_b;

path p[];

circle c[];
ellipse e[];

c0 := unit_circle scaled 2 rotated 90;

draw c0;

e0 := unit_ellipse scaled (3, 1) rotated 90;

draw e0;

bpv_a := c0 intersection_points e0;

dotlabel_if.bot("bpv-a 0", bpv_a0);
dotlabel_if.bot("bpv-a 1", bpv_a1);
dotlabel_if.bot("bpv-a 2", bpv_a2);
dotlabel_if.bot("bpv-a 3", bpv_a3);

transform t;
t := identity shifted (0, -5);

c0 *= e0 *= t;

draw c0;
draw e0;

bpv_b := e0 intersection_points c0;

dotlabel_if.bot("bpv-b 0", bpv_b0);
dotlabel_if.bot("bpv-b 1", bpv_b1);
dotlabel_if.bot("bpv-b 2", bpv_b2);
dotlabel_if.bot("bpv-b 3", bpv_b3);

endfig with_projection parallel_x_y; 
end;

%% *** (3) `circle' intersections.  

beginfig(1); 

bool_point_vector bpv_a;
bool_point_vector bpv_b;

path p[];

circle c[];

c0 := unit_circle scaled 2 rotated 90;

draw c0;

c1 := unit_circle scaled 3 rotated 90 shifted 2;

draw c1;

bpv_b := c0 intersection_points c1;

% show bpv_b;

dotlabel_if.bot("bpv-b 0", bpv_b0);
dotlabel_if.bot("bpv-b 1", bpv_b1);
dotlabel_if.bot("bpv-b 2", bpv_b2);
dotlabel_if.bot("bpv-b 3", bpv_b3);

endfig with_projection parallel_x_y; 
end;



%% *** (3) `ellipse' intersections.  
%%          Working on the rules for intersections.  Some need to be
%%          replaced because I've gotten rid of the "x-like" expressions 
%%          (see below).  I'm taking the opportunity to put the code for 
%%          these rules into functions, in order to reduce the amount of
%%          code in `parser.c++' and thus reduce compilation time.

%%          I had some trouble with the rule 
%%          `bool_point_vector_tertiary: ellipse_tertiary INTERSECTION_POINTS
%%          ellipse_secondary'.  I discovered a puzzling bug.  I seem to have
%%          fixed it, but I don't understand why it caused the incorrect behavior.
%%          The program got "hung up" when CWEB source files were checked in, but 
%%          not when they weren't.  This doesn't make sense to me.
%%          LDF 2005.10.28.

%% TO DO:  Add `sphere' assignment.  Check rule for intersection points of linear
%%         `path' and plane.  Add missing rules for intersections.
%%         LDF 2005.10.27.


beginfig(1); 

bool_point_vector bpv_a;
bool_point_vector bpv_b;

path p[];

ellipse e[];

e0 := unit_ellipse scaled (3, 0, 4) rotated 90;

draw e0;

e1 := unit_ellipse scaled (5, 0, 2) rotated 90;

draw e1;

bpv_b := e0 intersection_points e1;

% show bpv_b;

dotlabel.bot("bpv-b 0", bpv_b0);
dotlabel.bot("bpv-b 1", bpv_b1);
dotlabel.bot("bpv-b 2", bpv_b2);
dotlabel.bot("bpv-b 3", bpv_b3);

endfig with_projection parallel_x_y; 
end;




%% *** (3) Added parser rules and functions for `is_spherical'
%%         and `is_on_sphere'.  The latter works, the former
%%         currently always returns `true'.
%%         LDF 2005.10.26.

pickup pencircle scaled (.75mm, .75mm);

beginfig(1);
sphere s;
bool b[];
set s with_diameter 5 with_point_count 64;
point p[];
p0 := origin;

b0 := p0 is_on_sphere s;
message "b0 (should be false):";
show b0;

p1 := (2.5, 0, 0);

rotate p1 (15, 15, 25);

b1 := p1 is_on_sphere s with_tolerance .005;
message "b1 (should be true):";
show b1;

dotlabel.top("$p_1$", p1) with_dot_color red; 

%% It works to transform `spheres'.  LDF 2005.10.26.
%scale s (1, 2, 3);  
%shear s (2, 3, 4, 5, 6, 7);

draw s;
endfig;

end;  


%% *** (3) Added `get_center' rules for all missing types.
%%         LDF 2005.10.25.

beginfig(1);
ellipse e;
e := unit_ellipse rotated 90;
point p[];
p0 := get_center e;
dotlabel.top("$p_0$", p0);
draw e;

sphere s;
set s;
shift s (3, 2, 1);
p1 := get_center s;
dotlabel.top("$p_1$", p1);
draw s;

endfig;

end;


%% *** (3) `spheres' can now be constructed, drawn, and transformed.
%%         I have not yet written a complete set of parser rules for them, though.
%%         LDF 2005.10.25.

%% PLEASE NOTE:  Since I've removed the code involving `x_like' expressions 
%% (e.g., `path_like_primary', `ellipse_like_secondary', `solid_like_expression', 
%% etc.), some things that used to work are temporarily unavailable.  I will 
%% be replacing the "collective" rules that I've removed with individual rules
%% for the individual types.  It will probably take me awhile before I've 
%% replaced all of the ones that were formerly available.
%% LDF 2005.10.25.

pickup pencircle scaled (.75mm, .75mm, .75mm);

picture save_picture;

focus f;

set f with_position (-1, 5, -20) with_direction (-1, 5, 10) 
      with_distance 20;

color_vector cv;
cv += red;
cv += blue;

if false: % true
   cv += green;
   cv += cyan;
   cv += yellow;
   cv += magenta;
fi;

circle c[];
point p[];
path q[];
sphere s[];

boolean b;
b := false; % true

beginfig(1); 

if false: % true
   p0 := (3, 0);
   rotate p0 (0, 0, 45);
   dotlabel.top("$p_0$", p0);
   draw origin -- p0;
fi;

set c0 with_diameter 5 with_point_count 64;
c1 := c0;
c2 := c0;
rotate c1 by 90;
rotate c2 (90, 90);

if b:
   draw c0;
   draw c1;
   draw c2;
fi;

set s0 with_diameter 5 with_point_count 64 
       with_divisions_vertical 10 
       with_divisions_horizontal 10
       with_type globe_type;

p1 := (0, -3);
label("Globe-Type Sphere", p1);

set s1 with_center (0, -10, 0)
       with_diameter 5 with_point_count 64 
       with_divisions_vertical 10 
       with_divisions_horizontal 10
       with_type panel_type;


p2 := (0, -14);
label("Panel-Type Sphere", p2);

draw s0;% with_color_vector cv;
draw s1;% with_color_vector cv;

save_picture := current_picture;
endfig with_focus f;

beginfig(2); 
output save_picture with_projection parallel_x_y; 
label("x-y", origin);
endfig;

beginfig(3); 
output save_picture with_projection parallel_x_z; 
label("x-z", origin);
endfig;

beginfig(4); 
output save_picture with_projection parallel_z_y; 
label("z-y", origin);
endfig;

end;

%% ** (2) 


%%  Removed all of the declarations and rules for "x_like" expressions,
%%  e.g., `path_like_variable', `path_like_primary', `ellipse_like_secondary',
%%  etc.  These rules tended to cause conflicts, so I've decided to replace 
%%  them with separate rules for each type.  
%%  I've also removed the debugging code from the rules that I had
%%  to change.  This substantially reduces the size of the file `parser.c++',
%%  generated by GNU Bison from the parser input files.  It is not possible
%%  to break this file up into parts and compile them separately.  The
%%  length of time it takes to compile it is a bottleneck in development
%%  and installation.  I am therefore trying to reduce its size.  
%%  Removing these unnecessary rules and reducing the amount of debugging 
%%  code seems to have helped.  I also plan to replace a lot of code in 
%%  the parser actions with function calls.
%%  LDF 2005.10.24.

%%  Replaced the individual types for polyhedra
%%  with a single `polyhedron' type.  Also replaced the
%%  corresponding "vector" types with `polyhedron_vector'.
%%  LDF 2005.10.24.

pickup pencircle scaled (1mm, 1mm);

beginfig(1);

polyhedron p;

p := unit_trunc_octahedron rotated (15, 15, 15) scaled (2, 2, 2);

draw p with_color red;;

polyhedron_vector pv;
pv += unit_trunc_octahedron rotated (15, 15, 15) scaled (2, 2, 2) shifted (3, 3);
pv += unit_dodecahedron rotated (15, 15, 15) scaled (2, 2, 2) shifted (3, -3);

draw pv0;
draw pv1;

endfig;
end;

%% *** (3) The options `with_color', `with_draw_color', and `with_fill_color'
%%         seem to work properly.  I thought I'd had problems with them before.
%%         LDF 2005.10.19.


pickup pencircle scaled (1mm, 1mm);

beginfig(1);
circle c[];
set c0 with_point_count 64;

c1 := c0;
c2 := c0;
c3 := c0;
c4 := c0;

rotate c0 by 90;
rotate c1 by 90;
rotate c2 by 90;
rotate c3 by 90;
rotate c4 by 90;

shift c1 by 1.5;
shift c2 by 3;
shift c3 by 4.5;
shift c4 by 6;

filldraw c0 with_color red;
filldraw c1 with_draw_color blue with_fill_color orange;
filldraw c2 with_color green with_draw_color yellow;
filldraw c3 with_fill_color green with_draw_color yellow;
filldraw c4 with_fill_color green with_color yellow;
endfig; 
end;



%% *** (3) Added rules for creating `strings' to represent numbers in
%%        octal, decimal, and hexadecimal notation.
%%        LDF 2005.09.09.

%%        LDF 2005.09.09.
%%        Added a parser rule and two functions for 
%%        creating `strings' to represent numbers in
%%        binary notation.  

%%        LDF 2005.09.10.
%%        Fixed the problems I was having with large numbers.
%%        Integers are always stored in `ints' before being
%%        converted to `reals', so a decimal point 
%%        should always be used in numbers greater than
%%        `INT_MAX'.  For best results, decimal points
%%        should be used for large numbers.  I haven't yet
%%        found exactly where the problems start, but it's 
%%        well `INT_MAX'.

%% 	  LDF 2005.09.13.
%% 	  Debugged the code for handling `INTEGERS' in the 
%%        function
%% 	  `sub_yylex()' in the file `scan.web'.

%%        LDF 2005.09.13.
%%        When strings representing integer values greater than `LONG_LONG_MAX'
%%        are scanned in, and converted to a `long long', the resulting 
%%        `long long' will have the value `LONG_LONG_MAX'.  It is therefore
%%        impossible to distinguish whether a `long long' created in this way
%%        and having this value has been created from a valid or invalid input.
%%        Added code to catch the case that an integer value is greater than
%%        or equal to `LONG_LONG_MAX'.  If it is, an error message is issued
%%        and the `numeric' object is set to `INVALID_REAL'.  The user is not
%%        prompted to type <RETURN> to continue, because the error message is 
%%        produced in the function `sub_yylex()' in the file `scan.web', and
%%        <RETURN>s entered within this function interfere with 3DLDF's 
%%        scanning and cause parser errors. 

%%        LDF 2005.09.13. 
%%        Added optional `fixed' keyword for outputting `numerics' in
%%        fixed point notation.  I have to find out how to get rid of the
%%        trailing zeroes.

beginfig(1);

%% On my machine:  LDF 2005.09.10.
%% LDF 2005.09.13.  BUG FIX:  Corrected the values.

%% Integral limits:

%% SHRT_MAX  	  ==                32767
%% USHRT_MAX 	  ==                65535
%% INT_MAX   	  ==           2147483647
%% INT_MIN        ==          -2147483648
%% UINT_MAX  	  ==           4294967295
%% LONG_MAX  	  ==           2147483647
%% ULONG_MAX 	  ==           4294967295
%% LONG_LONG_MAX  ==  9223372036854775807
%% ULONG_LONG_MAX == 18446744073709551615

%% Floating point limits:

%% FLT_MAX == 3.40282e+38
%% DBL_MAX == 1.79769e+308
%% LDBL_MAX == 1.18973e+4932
%% sizeof(long double) * CHAR_BIT == 96 (12 8-bit bytes).

%% Sizes of types:

%% sizeof(short)          == 2
%% sizeof(int)            == 4
%% sizeof(long)           == 4
%% sizeof(float)          == 4
%% sizeof(double)         == 8
%% sizeof(long double)    == 12

a := -24;
message "a == ";
show a;

a := 2147483647;
message "a == ";
show a;

a := 2147483648;
message "a (fixed) == ";
show a fixed;

a := 2147483648;
message "a (unfixed) == ";
show a;

a := 9223372036854775806;
message "a (fixed) == ";
show a fixed;

a := 9223372036854775806;
message "a (unfixed) == ";
show a;

endfig;

end;



string s;

s := decimal a;

message "s (decimal):";
show s;

s := octal a;

message "s (octal):";
show s;

s := hexadecimal a;

message "s (hexadecimal):";
show s;


message "a == ";
show a;

s := binary a;

message "s (binary):";
show s;

dotlabel.top("(0, 0, 0)", origin);

endfig; 
end;

%% *** (3) Measuring text.
%%        `measure_text_header' is written to the TeX file used
%%        for measuring text.  It serves a similar to `verbatimtex' 
%%        in MetaPost.  When the TeX code in `measure_text_header'
%%        is no longer desired, it can be reset to `""', as shown 
%%        below.
%%        LDF 2005.08.31.

beginfig(1);

measure_text_header 
   := "\setbox1=\hbox to 3cm{\lower .25cm\vbox to 1cm{\vfil}\hfil}%";

numeric_vector nv;
nv := measure_text "\box1";
message "nv:";
show nv;

measure_text_header := "";  

nv := measure_text "AAAAyyyy";
message "nv:";
show nv;

dotlabel.top("(0, 0, 0)", origin);

endfig; 
end;




%% *** (3) Speech balloon test.  LDF 2005.08.25.

verbatim_metapost "verbatimtex \font\Largebx=cmbx17 scaled \magstep3 etex";

verbatim_metapost "verbatimtex \font\Large=cmr17 scaled \magstep3 etex";


%% **** (4) 

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .75mm; 

%% Bug fix:  Changed `.5pen_width' to `pen_width'.  
%% LDF 2005.09.01.

frame_w := w - pen_width;
frame_h := h - pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

picture frame_picture;

%% **** (4) Set up frames.

beginfig(0);
draw frame with_pen pensquare scaled (pen_width, pen_width, pen_width) with_color red;
%undraw outer_frame;
frame_picture := current_picture;
endfig with_projection parallel_x_y;  


%% **** (4) Set up box.

picture song_picture;

rectangle balloon;

balloon := unit_rectangle rotated 90 scaled (6, 4)  shifted (-7, 5);

picture balloon_picture;

string song_string;

song_string :=   "\hbox to 90cm{\Largebx " 
               & "Good-bye, Old Paint, I'm leavin' Cheyenne."
               & "\hskip2cm" & "Good-bye, Old Paint, I'm leavin' Cheyenne."
               & "\hskip2cm" & "My horses ain't hungry, they won't eat your hay,"
               & "\hskip2cm" & "My wagon is loaded and rollin' away."
               & "\hskip2cm\hss}";

point p[];

p0 := mediate(get_point 1 balloon, get_point 2 balloon);

beginfig(0);

draw balloon with_pen pencircle scaled (.75mm, .75mm, .75mm);
balloon_picture := current_picture;
clear current_picture;

label.rt(song_string, p0 shifted (-2mm, 0));
song_picture := current_picture;
clear current_picture;


%output song_picture with_projection parallel_x_y; 
clip_to balloon;

output balloon_picture with_projection parallel_x_y; 

output frame_picture with_projection parallel_x_y; 

endfig;


pickup pencircle scaled (.75mm, .75mm, .75mm);

shift_value := -1mm;

%% **** (4) 

for i = 1 upto 5:
   beginfig(i);
      shift song_picture (shift_value, 0);
      output song_picture with_projection parallel_x_y; 
      clip_to balloon;
      output balloon_picture with_projection parallel_x_y; 
      output frame_picture with_projection parallel_x_y; 
      endfig;
endfor;

verbatim_metapost "end";

end; 




%% *** (3) Added code for clipping 'pictures' to cyclical 'paths'.
%%         LDF 2005.08.16.


path outer_frame_path;
path inner_frame_path;
path a_inner_frame_path;
pen frame_pen;
frame_pen_width := .75cm;

frame_pen := pensquare scaled (frame_pen_width, frame_pen_width);

w := 2.5 * 6.4cm;
h := 2.5 * 4.8cm;

o := frame_pen_width;

outer_frame_path := (-o, -o) -- (w + o, -o) -- (w + o, h + o) -- (-o, h + o)
                    -- cycle;

inner_frame_path := (o, o) -- (w - o, o) -- (w - o, h - o) 
                    -- (o, h - o) -- cycle;

a_inner_frame_path := (2o, 2o) -- (w - 2o, 2o) -- (w - 2o, h - 2o) 
                    -- (2o, h - 2o)
                    -- cycle;

shift inner_frame_path (-.5w, -.5h);

shift outer_frame_path (-.5w, -.5h);

shift a_inner_frame_path (-.5w, -.5h);

path big_frame;

big_frame := outer_frame_path scaled (1.25, 1.25);

beginfig(1);
fill outer_frame_path with_color blue;

unfill inner_frame_path;

fill a_inner_frame_path with_color green;
% draw e1 with_color blue;
output current_picture with_projection parallel_x_y;
clear current_picture;
endfig; 


beginfig(2);
draw outer_frame_path;
ellipse e[];
e0 := unit_ellipse rotated 90 scaled (1, 2);
draw e0 with_color red with_pen pencircle scaled (5mm, 5mm, 5mm);
e1 := unit_ellipse rotated 90 scaled (2, 1);
draw e1 with_color blue with_pen pencircle scaled (5mm, 5mm, 5mm);
output current_picture with_projection parallel_x_y;
clear current_picture;
endfig; 

end; 





%% *** (3) Scrolling Text.
%% Run these commands:
%% make run
%% cnepspng
%% Convert the filenames so they have the correct number of leading
%%     zeroes.
%% mogrify -geometry 640x480! 3DLDFmp_*.png

%% TO DO:  The periods in the leaders are too small.  Fix this!
%% LDF 2005.08.15.

verbatim_metapost "verbatimtex \font\Largebx=cmbx12 scaled \magstep3 etex";

verbatim_metapost "verbatimtex \font\Large=cmr12 scaled \magstep3 etex";

verbatim_metapost 
   "verbatimtex \def\leaderfill{\leaders\hbox to 1em{\hss.\hss}\hfil}etex";



%% ** (2) 

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .75mm; 

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

string clip_string;


clip_string := "clip currentpicture to ";

clip_string := clip_string &
"(-11.233997cm, -8.420810cm) -- (11.233997cm, -8.420810cm) -- ";

clip_string := clip_string & 
"(11.233997cm, 8.420810cm) -- (-11.233997cm, 8.420810cm) -- cycle;";

picture frame_picture;

%% ** (2) Set up frame.

beginfig(0);
draw frame with_pen pensquare scaled (pen_width, pen_width, pen_width);
frame_picture := current_picture;
endfig with_projection parallel_x_y;  


%% ** (2) Set up box.

hoffset_value := .25cm;
voffset_value := .25cm;

vskip_value := 2cm;


title_w := frame_w - hoffset_value;
title_h := frame_h - voffset_value;

picture title_picture;

beginfig(0);
label("{\Largebx Joe Schmo Productions}", (0, .5title_h - voffset_value));
%
label("{\Largebx Hollywood, California}", 
   (0, .5title_h - voffset_value - vskip_value));
%
label("{\Largebx Look Before You Leap}", 
   (0, .5title_h - voffset_value - 2vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Producer}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 3vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Executive Producer}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 4vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Director}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 5vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Screenplay}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 6vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Character Design}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 7vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Storyboard}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 8vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Layout}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 9vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Backgrounds}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 10vskip_value));
%
label.rt("\hbox to 21.25cm{{\Largebx Character Animation}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 11vskip_value));

%
label.rt(
  "\hbox to 21.25cm{{\Largebx Effect Animation}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 12vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Sound Recording}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 13vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Sound Editing}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 14vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Camera}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 15vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Film Editing}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 16vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Gaffer}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 17vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Grip}\leaderfill {\Largebx Joe Schmo}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 18vskip_value));
%
label.rt(
  "\hbox to 21.25cm{{\Largebx Josephine Schmo's Gowns}\leaderfill {\Largebx Joe}}", 
   (-.5title_w + .5cm, .5title_h - voffset_value - 19vskip_value));
%
label("{\Large Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation}", 
   (0, .5title_h - voffset_value - 21vskip_value));
%

title_picture := current_picture;
shift title_picture (0, -frame_h);

output title_picture with_projection parallel_x_y; 
output frame_picture with_projection parallel_x_y; 

verbatim_metapost clip_string;

clear current_picture;
endfig;

beginfig(0); 
output title_picture with_projection parallel_x_y; 
output frame_picture with_projection parallel_x_y; 
verbatim_metapost clip_string;

clear current_picture;

endfig;

for i = 1 upto 100:
beginfig(i); 
shift title_picture (0, .3vskip_value);
output title_picture with_projection parallel_x_y; 
output frame_picture with_projection parallel_x_y; 
verbatim_metapost clip_string;

clear current_picture;

endfig;
endfor;

end; 



%% *** (3) Reflected and rotated text.
%%         LDF 2005.08.15.

%% **** (4) It's possible to do this in 3DLDF.
 %%         LDF 2005.08.15.

beginfig(1);
transform t;
t := identity rotated (0, 180);
label("ABC", origin);
label("ABC", (0, -9pt)) rotated (180, 0, 0);
label("DEF", (2, 0)) transformed t;
endfig with_projection parallel_x_y;
end;

%% **** (4) It's not necessary to use 'verbatim_metapost', but
%%          it's possible.
%%          LDF 2005.08.15.


beginfig(1);
string s;
s := "label(btex ABC etex  ";
s := s & "reflectedabout ((-1, 0), (1, 0)) ";
s := s & "rotated 180 ";
s := s & ", origin);";

show s;

verbatim_metapost s;
endfig with_projection parallel_x_y;  
end;






%% *** (3) Run these commands:
%% make run
%% cnepspng 3DLDFmp 0 47
%% mogrify -geometry 640x480! 3DLDFmp_*.png 
%% Convert filenames so that 3DLDFmp.0 through 3DLDFmp.9 have leading zeroes.
%%    Use the Emacs-Lisp code in 'convert.el' to do this.
%% convert -delay 7 3DLDFmp_*.png cmgsn_0.gif
%% animate cmgsn_0.gif

%% *** (3) Fonts.

verbatim_metapost "verbatimtex \font\Largebx=cmbx12 etex";
verbatim_metapost "verbatimtex \font\Large=cmr12 scaled 2000 etex";
verbatim_metapost "verbatimtex \font\large=cmr17 etex";
verbatim_metapost "verbatimtex \font\largebx=cmbx17 etex";
verbatim_metapost "verbatimtex \font\bigit=cmti11 etex";
verbatim_metapost "verbatimtex \font\normal=cmr10 etex";
verbatim_metapost "verbatimtex \font\small=cmr6 etex";


%% *** (3) 

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .75mm; 

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

picture frame_picture;

%% *** (3) 

%% **** (4) 

for i = 0 upto 4:
beginfig(i);
draw frame with_pen pensquare scaled (pen_width, pen_width, pen_width);
frame_picture := current_picture;
endfig with_projection parallel_x_y;  
endfor;

%% **** (4)

j := 0;
for i = 5 upto 19:
scale_value := 1 + .5j;
beginfig(i);
label("{\Largebx Coming Soon}", origin) scaled (scale_value, scale_value)
   with_text_color red;
current_picture += frame_picture;
endfig with_projection parallel_x_y;  
j += 1;
endfor;


scale_value := 8;

for i := 20 upto 23:
beginfig(i);
label("{\Largebx Coming Soon}", origin) scaled (scale_value, scale_value)
   with_text_color red;
current_picture += frame_picture;
endfig with_projection parallel_x_y;  
endfor;

%% *** (3) 


for i = 24 upto 28:
beginfig(i);
draw frame with_pen pensquare scaled (pen_width, pen_width, pen_width);
frame_picture := current_picture;
endfig with_projection parallel_x_y;  
endfor;



%% **** (4)

j := 0;
for i = 29 upto 43:
scale_value := 1 + .5j;



beginfig(i);
text_scale_value := 1/4scale_value;
message "scale_value:";
show scale_value;
message "text_scale_value:";
show text_scale_value;
label("{\Largebx To a Theater}", (0, text_scale_value)) 
   scaled (scale_value, scale_value)
   with_text_color blue;
label("{\Largebx Near You}", (0, -text_scale_value)) 
    scaled (scale_value, scale_value)
    with_text_color blue;
current_picture += frame_picture;
endfig with_projection parallel_x_y;  
j += 1;
endfor;

scale_value := 8;
text_scale_value := 1/4scale_value;

message "scale_value:";
show scale_value;
message "text_scale_value:";
show text_scale_value;


for i := 44 upto 47:
beginfig(i);

label("{\Largebx To a Theater}", (0, text_scale_value)) 
   scaled (scale_value, scale_value)
   with_text_color blue;
label("{\Largebx Near You}", (0, -text_scale_value))
   scaled (scale_value, scale_value) with_text_color blue;
current_picture += frame_picture;
endfig with_projection parallel_x_y;  
endfor;

%% *** (3) Flipbook.

%% **** (4) 

% make run
% cnepspng 3DLDFmp 0 17
% ** convert files (convert.el):
%    Flip images 2, 3, 5, 8, 9, 12, 14, and 15
%    Convert PNG to EPS.
% tex flipbook
% dvips -o f.ps flipbook

boolean landscape;
landscape := false;  %% true

%% **** (4) Set up frame.


verbatim_metapost "verbatimtex \font\Large=cmbx12 scaled 6000 etex";
verbatim_metapost "verbatimtex \font\large=cmr17 etex";
verbatim_metapost "verbatimtex \font\largebx=cmbx17 etex";
verbatim_metapost "verbatimtex \font\normal=cmr10 etex";
verbatim_metapost "verbatimtex \font\small=cmr6 etex";

pickup pencircle scaled (.75mm, .75mm, .75mm);



% \vsize=(/ 27 4.0) 6.75
% \hsize=(/ 19 4.0) 4.75

if landscape:
   w := 6.75;
   h := 4.75;
   text_shift_value := -1.5;
else:
   w := 4.75;
   h := 6.75;
   text_shift_value := -2;
fi;

path frame;

frame := origin -- (w, 0) -- (w, h)
                -- (0, h) -- cycle;

shift frame (-.5w, -.5h);

beginfig(0); 
%draw frame;
endfig with_projection parallel_x_y; 

beginfig(1); 
%draw frame;
label("{\Large 1}", origin);
endfig with_projection parallel_x_y; 

beginfig(2); 
%draw frame;
label("{\Large 2}", origin);
endfig with_projection parallel_x_y;  

beginfig(3); 
%draw frame;
label("{\Large 3}", origin);
endfig with_projection parallel_x_y;  

beginfig(4); 
%draw frame;
label("{\Large 4}", origin);
endfig with_projection parallel_x_y;  

beginfig(5); 
%draw frame;
label("{\Large 5}", origin);
endfig with_projection parallel_x_y;  

beginfig(6); 
%draw frame;
label("{\Large 6}", origin);
label("{\large (six)}", (0, text_shift_value));
endfig with_projection parallel_x_y;  

beginfig(7); 
%draw frame;
label("{\Large 7}", origin);
endfig with_projection parallel_x_y;  

beginfig(8); 
%draw frame;
label("{\Large 8}", origin);
label("{\large (eight)}", (0, text_shift_value));
endfig with_projection parallel_x_y;  

beginfig(9); 
%draw frame;
label("{\Large 9}", origin);
label("{\large (nine)}", (0, text_shift_value));
endfig with_projection parallel_x_y;  

beginfig(10); 
%draw frame;
label("{\Large 10}", origin);
endfig with_projection parallel_x_y;  

beginfig(11); 
%draw frame;
label("{\Large 11}", origin);
endfig with_projection parallel_x_y;  

beginfig(12); 
%draw frame;
label("{\Large 12}", origin);
endfig with_projection parallel_x_y;  

beginfig(13); 
%draw frame;
label("{\Large 13}", origin);
endfig with_projection parallel_x_y;  

beginfig(14); 
%draw frame;
label("{\Large 14}", origin);
endfig with_projection parallel_x_y;  

beginfig(15); 
%draw frame;
label("{\Large 15}", origin);
endfig with_projection parallel_x_y;  

beginfig(16); 
%draw frame;
label("{\Large 16}", origin);
endfig with_projection parallel_x_y;  

beginfig(17); 
%draw frame;
if landscape:
   label("{\largebx Flipbook Pattern}", (0, .5));
   label("{\normal Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation}", 
         (0, -1));
else:
   label("{\largebx Flipbook}", (0, 1));
   label("{\largebx Pattern}", (0, .375));
   label("{\normal Copyright (C) 2005}", (0, -1));
   label("{\normal The Free Software Foundation}", (0, -1.5));
fi;
endfig with_projection parallel_x_y;  

end;

%% *** (3) !! START HERE:  Change 'get_minimum_z()', etc.,
%%         so that the argument is used.
%%
%%         Trying to get surface hiding to work for three objects.
%%         LDF 2005.04.20.
%%         Started working on this again.  LDF 2005.06.30. 
%%         My idea is to perform surface hiding using the "pre-projective"
%%         coordinates of the points belonging to the objects on the
%%         picture.  These are the coordinates after the transformation 
%%         that puts the focus on the z-axis, but before the projective
%%         projection.  The projective projection often causes the extreme
%%         x and y values of the projective coordinates of objects 
%%         to overlap, whose world and pre-projective coordinates 
%%         do not overlap.  I believe I can eliminate the problems
%%         that result from this overlapping by sorting the objects
%%         according to the pre-projective coordinates instead of the
%%         projective coordinates.  LDF 2005.06.30. 

pickup pencircle scaled (3mm, 3mm, 3mm);

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;

rectangle rp[];

picture save_picture;

rp0 := unit_rectangle scaled 5 rotated 90;

rp1 := unit_rectangle scaled 5 shifted (0, -1);
rp2 := unit_rectangle scaled 5 shifted (0, 1);


beginfig(1); 

draw rp0 with_draw_color blue;
draw rp1 with_draw_color red;
draw rp2 with_draw_color yellow;

save_picture := current_picture;

clear current_picture;

filldraw rp0 with_draw_color blue with_fill_color orange;
filldraw rp1 with_draw_color red with_fill_color green;
filldraw rp2 with_draw_color yellow with_fill_color violet;

dotlabel.top("origin", origin);
endfig with_focus f with_surface_hiding;

beginfig(2); 
output save_picture with_projection parallel_x_y; 
label("Parallel x-y", (0, -3)); 
endfig with_projection parallel_x_y; 

beginfig(3); 
output save_picture with_projection parallel_x_z;
label("Parallel x-z", (0, 0, -3)); 
endfig with_projection parallel_x_z;

beginfig(4); 
output save_picture with_projection parallel_z_y;
drawarrow origin -- (0, 0, 2);
dotlabel.lft("Origin", origin);
label.bot("z", (0, 0, 2));
drawarrow origin -- (0, 2);
label.lft("y", (0, 2));
label("Parallel z-y", (0, -3)); 
endfig with_projection parallel_z_y;

end;

%% *** (3) Working on generating images of cubes for combining with 
%%         graph paper.  The 3DLDF input file for the graph paper is 
%%         in the directory '../GRAPHPAP/'.
%%         LDF 2005.06.27.

focus f;
set f with_position (-5, 10, -15) with_direction (-5, 10, 10) 
   with_distance 12.5;

beginfig(1);

cuboid c;
c := unit_cuboid scaled 3;

rectangle r[];

for i = 0 upto 5:
r[i] := get_rectangle (i) c;
%label(i, get_center r[i]);
endfor;

fill r0 with_color red;
fill r4 with_color blue;
fill r2 with_color green;


picture cube_picture;

cube_picture := current_picture;

clear current_picture;

output cube_picture with_focus f;  

path frame;

point p[];

% p0 := (0,          0);
% p1 := (569.1875pt, 0);
% p2 := (569.1875pt, 426.59375pt);
% p3 := (0,          426.59375pt);

w := 10cm;
h := 10cm;

p0 := (0, 0);
p1 := (w, 0);
p2 := (w, h);
p3 := (0, h);

p4 := mediate(p0, p2);

frame := p0 -- p1 -- p2 -- p3 -- cycle;

shift frame (2cm, -12cm);

draw frame with_pen pencircle scaled (2mm, 2mm, 2mm);

endfig with_projection parallel_x_y;



beginfig(2);

output cube_picture with_focus f;  

shift frame (-4.5cm, -3cm);

draw frame with_pen pencircle scaled (2mm, 2mm, 2mm);

endfig with_projection parallel_x_y;


end;

%% *** (3) Started working on 'beginchar' and 'endchar'.
%%         LDF 2005.06.11.

beginchar("A", 1, 15pt, 30pt);  %% No comment.
endchar;

%% !! Please note:  No semi-colon before the comment.  
%% This differs from Metafont's syntax.  It wasn't possible
%% to implement MF's syntax because it causes a conflict
%% in the Bison parser.
%% LDF 2005.06.11.

beginchar("B", 1, 15pt, 30pt) "The letter B";  
endchar;

beginfig(1); 
drawdot origin;
endfig; 



%% *** (3) Added "skeleton" code for 'glyphs'.
%%         This means that I've defined parser rules and functions
%%         for declaring objects of this type and performing basic 
%%         operations on them, such as setting, showing, and 
%%         transforming.  However, they are not really functional,
%%         since no 'paths' or 'solids' are generated to represent the
%%         glyphs.
%%         LDF 2005.06.09.


beginfig(1);

drawdot origin;

glyph g;

message "g:";
show g;

glyph_vector gv;

message "gv:";
show gv;

endfig;
end; 





%% *** (3) Added "skeleton" code for 'spheres'.
%%         This means that I've defined parser rules and functions
%%         for declaring objects of this type and performing basic 
%%         operations on them, such as setting, showing, and 
%%         transforming.  However, they are not really functional,
%%         since no surfaces are generated to represent the
%%         spherical shapes.
%%         LDF 2005.05.25.


beginfig(1);
drawdot origin;

sphere s;

set s with_center origin;

message "s:";
show s;

endfig;
end; 




%% *** (3) Added "skeleton" code for 'ellipsoids'.
%%         This means that I've defined parser rules and functions
%%         for declaring objects of this type and performing basic 
%%         operations on them, such as setting, showing, and 
%%         transforming.  However, they are not really functional,
%%         since no surfaces are generated to represent the
%%         ellipsoidal shapes.
%%         LDF 2005.05.25.

beginfig(1);
drawdot origin;

ellipsoid e;

set e with_center origin;

message "e:";
show e;

endfig;
end; 

%% *** (3) Added "skeleton" code for 'cones' and 'cylinders'.
%%         This means that I've defined parser rules and functions
%%         for declaring objects of these types and performing basic 
%%         operations on them, such as setting, showing, and 
%%         transforming.  However, they are not really functional,
%%         since no surfaces are generated to represent the
%%         conical or cylindrical shapes.
%%         LDF 2005.05.25.

beginfig(1);
drawdot origin;

cone c;

cylinder d;

set c with_center origin;

message "c:";
show c;

set d with_center origin with_direction (1, 2, 3);

message "d:";
show d;

endfig;
end; 




%% *** (3) Added options for setting 'helices'.  No path is generated yet, though.
%%         LDF 2005.05.21.

beginfig(1);
drawdot origin;

helix h;

point_vector pv;

pv += (1, 1, 1);
pv += (2, 2, 2);

message "pv:";
show pv;

set h with_center origin with_direction (1, 2, 3) 
   with_start_diameter 1.2 with_points_per_cycle 16 with_cycles 3
   with_angle 72 with_type archimedean with_direction_vector pv;  

message "h:";
show h;

endfig;
end; 



%% *** (3) "Fade" example.
%%         LDF 2005.05.17.

verbatim_metapost "verbatimtex \font\large=cmbx12 scaled 5000 etex"; 
color c; 
color d; 
for i = 0 upto 30: 
j := i / 30; 
k := (30 - i) / 30; 
set c (j, j, j); 
set d (k, k, k); 
beginfig(i); 
label.rt("{\large Fade out}", origin shifted (0, 1.25)) with_text_color c; 
label.rt("{\large Fade in}", origin shifted (0, -1.25)) with_text_color d; 
endfig with_projection parallel_x_y; 
endfor; 
verbatim_metapost "bye;"; 
end;

%% *** (3) "Blur" example.
%%         LDF 2005.05.13.

verbatim_metapost "verbatimtex \font\large=cmbx12 scaled 5000 etex";
beginfig(1);
label.rt("{\large Blur}", origin);
endfig with_projection parallel_x_y;

verbatim_metapost "bye;";

end;


%% *** (3) "Fade out" and "Fade in" example.
%%         LDF 2005.05.13.

verbatim_metapost "verbatimtex \font\large=cmbx12 scaled 5000 etex";
color c;
color d;
for i = 0 upto 30:
j := i / 30;
k := (30 - i) / 30;
set c (j, j, j);
set d (k, k, k);
beginfig(i);
label.rt("{\large Fade out}", origin shifted (0, 1.25)) with_text_color c;
label.rt("{\large Fade in}", origin shifted (0, -1.25)) with_text_color d;
endfig with_projection parallel_x_y;
endfor;

verbatim_metapost "bye;";

end;



%% *** (3) Bug fix:  Setting 'colors' now works properly.
%%
%%        Added a parser rule and a function in order to implement
%%        addition and assignment for 'pictures', i.e., the "+=" 
%%        operation.  To be precise, the rule is 
%%        'operation_assignment: picture_variable PLUS_ASSIGN 
%%        picture_expression' in 'popassgn.w'.  It calls the function
%%        'Scan_Parse::operation_assignment_picture_rule_func_0()'
%%        in 'prrfnc0.web'.
%%        LDF 2005.05.12.

rectangle r[];

r0 := unit_rectangle scaled 3 rotated 90;

r1 := unit_rectangle rotated 90 scaled (3, 4) shifted 1;

picture save_picture;

pickup pencircle scaled (2, 2, 2);

color c;

color_vector cv;

cv0 := red;
cv1 := green;
cv2 := blue;
cv3 := yellow;

circle q;
q := unit_circle scaled 2 rotated 90;

for i = 0 upto 3:
beginfig(i);
draw q;
c := cv[i];
shift r0 by i;
draw r0 with_color c;
save_picture += current_picture;
clear current_picture;
output save_picture with_projection parallel_x_y;
endfig; 
endfor;

end;



%% *** (3) Rotating Sphere.  Revised.  Added an invisible frame 
%%         in order to make all of the images the same size.
%%         This prevents the "jump" in the browsers when running
%%         the JavaScript animation using the "sphere_1.*" images.
%% 
%%         LDF 2005.05.09.

% verbatim_metapost "verbatimtex \\magnification=\\magstep3 etex";
% verbatim_metapost "input boxes;";
% verbatim_metapost "input boxes;";
% verbatim_metapost "pickup pencircle scaled .25mm;";
% verbatim_metapost "defaultdx:=.75cm;";
% verbatim_metapost "defaultdy:=.75cm;";

circle c[];

division_value := 64;
one_quarter_division_value := 1/4division_value;
three_quarters_division_value := 3/4division_value;

set c0 with_point_count division_value;
scale c0 (8, 0, 8);
rotate c0 by 90;

point p;
path q[];

p := get_point 0 c0;


q[division_value] += p;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

pickup thick_pen;

step_value := 360 / division_value;
j := 1;
for i = 0 step step_value until 360 - step_value:
   rotate c0 (0, step_value);
   if (is_even j):
      draw c0;
   fi;
   for k = 2 step 2 until one_quarter_division_value - 2:
      q[k] += get_point (k) c0;
      q[three_quarters_division_value + k] 
         += get_point (three_quarters_division_value + k) c0;
   endfor; 
   q[division_value] += get_point 0 c0;
   j += 1;
endfor;

q[division_value] += cycle;
q[division_value] += ..;
draw q[division_value];

for i = 2 step 2 until one_quarter_division_value - 2:
      q[i] += ..;
      q[i] += cycle;
      q[three_quarters_division_value + i] += ..;
      q[three_quarters_division_value + i] += cycle;
      draw q[i];
      draw q[three_quarters_division_value + i];
endfor;

rotate current_picture by -25;

picture save_picture;

save_picture := current_picture;
clear current_picture;

message "Starting figures.";

beginfig(0); 
output save_picture;
verbatim_metapost "boxit.b(currentpicture);";
verbatim_metapost "path q; q = bpath b; undraw q withpen pencircle scaled 3mm;";
endfig; 

for i = 1 upto 35:
   rotate save_picture (0, 10);
   beginfig(i);
      output save_picture;
   verbatim_metapost "undraw q withpen pencircle scaled 1mm;";
   endfig;
   message "Finished figure:";
   show i;
endfor;

end;

%% *** (3) Dodecahedron logo.
%%
%%        LDF 2005.05.04.

verbatim_metapost "verbatimtex \font\large=cmbx12 scaled 5000 etex";
verbatim_metapost "verbatimtex \font\normal=cmr17 etex";

point p[];

p0 := (0,     0);
p1 := (569.1875pt, 0);
p2 := (569.1875pt, 426.59375pt);
p3 := (0,          426.59375pt);

p4 := mediate(p0, p2);

%% **** (4) Empty frame.

reg_polygon r[];

r0 := unit_pentagon scaled (2cm, 0, 2cm) rotated (0, 180);

focus f;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

picture save_picture;
picture frame_picture;

p0 := (0,          0, 0);
p1 := (569.1875pt, 0, 0);
p2 := (569.1875pt, 0, 426.59375pt);
p3 := (0,          0, 426.59375pt);

p4 := mediate(p0, p2);

dihedral_angle := 116.565;
a := 180 - dihedral_angle;

pickup thick_pen;

point q[];

x_value := 569.1875pt; %%  == 20.0047cm
y_value := 426.59375pt; %% == 14.9931cm

path frame;

transform t;

t := identity shifted (-4.5, 0, -15);

p0 *= p1 *= p2 *= p3 *= p4 *= t;

frame := p0 -- p1 -- p2 -- p3 -- cycle;

set f with_position (0, 10, -15) with_direction (0, 10, 10) 
   with_distance 12.5;

for i = 0 upto 4:
   q[i] := get_point (i) r0;
endfor;

r1 := r0 rotated_around (q2, q3) 60;

rotate_around r1 (q2, q3) 60;
rotate_around r1 (q2, q3) 60;

for i = 0 upto 4:
  q[i + 5] := get_point (i) r1;
endfor;

r2 := r1 rotated_around (q8, q9) 60;
rotate_around r2 (q8, q9) 60;
rotate_around r2 (q8, q9) 60;

r3 := r1 rotated_around (q9, q5) 60;
rotate_around r3 (q9, q5) 60;
rotate_around r3 (q9, q5) 60;
r4 := r1 rotated_around (q5, q6) 60;
rotate_around r4 (q5, q6) 60;
rotate_around r4 (q5, q6) 60;
r5 := r1 rotated_around (q6, q7) 60;
rotate_around r5 (q6, q7) 60;
rotate_around r5 (q6, q7) 60;

for i = 0 upto 4:
  q[i + 10] := get_point (i) r5;
endfor;

r6 := r5 rotated_around (q14, q13) 60;

rotate_around r6 (q14, q13) 60;
rotate_around r6 (q14, q13) 60;

for i = 0 upto 4:
  q[i + 15] := get_point (i) r6;
endfor;

r7 := r6 rotated_around (q15, q16) 60;
rotate_around r7 (q15, q16) 60;

rotate_around r7 (q15, q16) 60;

for i = 0 upto 4:
  q[i + 20] := get_point (i) r7;
endfor;

r8 := r7 rotated_around (q22, q21) 60;

rotate_around r8 (q22, q21) 60;
rotate_around r8 (q22, q21) 60;

r9 := r7 rotated_around (q23, q22) 60;

rotate_around r9 (q23, q22) 60;
rotate_around r9 (q23, q22) 60;

r10 := r7 rotated_around (q24, q23) 60;

rotate_around r10 (q24, q23) 60;
rotate_around r10 (q24, q23) 60;
r11 := r7 rotated_around (q24, q20) 60;
rotate_around r11 (q24, q20) 60;
rotate_around r11 (q24, q20) 60;

%% **** (4) Start rotating by `dihedral_angle'.


rotate_around r0 (q7, q8) a;


rotate_around r2 (q9, q8) a;


rotate_around r3 (q5, q9) a;



rotate_around r4 (q6, q5) a;

rotate_around r8 (q21, q22) a;



rotate_around r9 (q22, q23) a;


rotate_around r10 (q23, q24) a;


rotate_around r11 (q20, q24) a;

%% **** (4) Start rotating top "cup".  


for i = 7 upto 11:
   rotate_around r[i] (q21, q20) a;
endfor;

%% **** (4) Cut.  Change focus.
%%          LDF 2005.05.07.

set f with_position (-3, 8, -10) with_direction (-3, 8, 10) 
   with_distance 15;


for i = 6 upto 11:
   rotate_around r[i] (q13, q14) a;
endfor;

for i = 5 upto 11:
   rotate_around r[i] (q12, q11) a;
endfor;

set f with_position (0, 7, -10) with_direction (0, 7, 10) 
   with_distance 15;


shift frame (-5, 0, 3);
shift p4 (-5, 0, 3);

beginfig(1);

pickup pencircle  scaled (1.5, 1.5, 1.5);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color red with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;
filldraw r9 with_fill_color yellow with_draw_color black;
filldraw r8 with_fill_color green with_draw_color black;
filldraw r6 with_fill_color red with_draw_color black;
filldraw r7 with_fill_color violet with_draw_color black;

output current_picture with_focus f no_sort;

clear current_picture;

label("{\large GNU 3DLDF}", p4);
undraw frame;

endfig with_projection parallel_x_z;




verbatim_metapost "bye;";

end;

%% *** (3) "The Birth of a Dodecahedron".  Text dissolve.  
%%
%%        LDF 2005.05.04.

verbatim_metapost "verbatimtex \font\large=cmbx12 scaled 5000 etex";
verbatim_metapost "verbatimtex \font\normal=cmr17 etex";


point p[];

p0 := (0,     0);
p1 := (569.1875pt, 0);
p2 := (569.1875pt, 426.59375pt);
p3 := (0,          426.59375pt);

p4 := mediate(p0, p2);

path q;

q := p0 -- p1 -- p2 -- p3 -- cycle;

color_vector gray_vector;

%% This is necessary, because calling `set color' 
%% in the second loop caused a segmentation fault.  
%% I don't know what the problem is.
%%
%% LDF 2005.05.04.


for i = 0 upto 131:
j := i / 131;
set gray_vector[i] (j, j, j);
endfor;

text_shift_value := 2.5cm;

offset := 0;

% for i = 0 upto 131:
%    beginfig(i + offset);
%       draw q with_pen pencircle scaled (2, 2, 2);

%       label("{\large The Birth}", p4 shifted (0, text_shift_value)) 
%          with_text_color gray_vector[i];

%       label("{\large of a}", p4) with_text_color gray_vector[i];

%       label("{\large Dodecahedron}", p4 shifted (0, -text_shift_value)) 
%          with_text_color gray_vector[i];

%    endfig with_projection parallel_x_y;    
% endfor;

% %% **** (4) Empty frame.

% beginfig(132 + offset);
%    draw q with_pen pencircle scaled (2, 2, 2);
% endfig with_projection parallel_x_y;


%% **** (4) Director's credit.

offset += 133;

text_shift_value /= 2;

% for i = 0 upto 131:
%    beginfig(i + offset);
%       draw q with_pen pencircle scaled (2, 2, 2);

%       label("{\large by}", p4 shifted (0, text_shift_value)) 
%          with_text_color gray_vector[i];

%       label("{\large Laurence Finston}", p4 shifted (0, -text_shift_value)) 
%          with_text_color gray_vector[i];

%       label("{\normal Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation}",
%             p4 shifted (0, -6.75cm)) 
%          with_text_color gray_vector[i];

%    endfig with_projection parallel_x_y;    
% endfor;

% %% **** (4) Empty frame.

% beginfig(132 + offset);
%    draw q with_pen pencircle scaled (2, 2, 2);
% endfig with_projection parallel_x_y;

%%offset += 133;




%% ** (2) "The Birth of a Dodecahedron".  The dodecahedron.
%%
%%        LDF 2005.05.04.

point p[];


reg_polygon r[];

r0 := unit_pentagon scaled (2cm, 0, 2cm) rotated (0, 180);

focus f;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

picture save_picture;
picture frame_picture;

p0 := (0,          0, 0);
p1 := (569.1875pt, 0, 0);
p2 := (569.1875pt, 0, 426.59375pt);
p3 := (0,          0, 426.59375pt);

p4 := mediate(p0, p2);


dihedral_angle := 116.565;
a := 180 - dihedral_angle;

pickup thick_pen;

point q[];

x_value := 569.1875pt; %%  == 20.0047cm
y_value := 426.59375pt; %% == 14.9931cm

path frame;

transform t;

t := identity shifted (-4.5, 0, -15);

p0 *= p1 *= p2 *= p3 *= p4 *= t;

frame := p0 -- p1 -- p2 -- p3 -- cycle;

set f with_position (0, 10, -15) with_direction (0, 10, 10) 
   with_distance 12.5;

offset := 265;

beginfig(1 + offset);

draw r0;

for i = 0 upto 4:
   q[i] := get_point (i) r0;
%%   dotlabel.bot(i, q[i]);
endfor;

save_picture := current_picture;

output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(2 + offset);
r1 := r0 rotated_around (q2, q3) 60;
draw r1;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(3 + offset);
rotate_around r1 (q2, q3) 60;
draw r1;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(4 + offset);

rotate_around r1 (q2, q3) 60;

for i = 0 upto 4:
  q[i + 5] := get_point (i) r1;
endfor;

draw r1 on_picture save_picture;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 



beginfig(5 + offset);
r2 := r1 rotated_around (q8, q9) 60;
draw r2;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(6 + offset);
rotate_around r2 (q8, q9) 60;
draw r2;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(7 + offset);
rotate_around r2 (q8, q9) 60;
draw r2 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(8 + offset);
r3 := r1 rotated_around (q9, q5) 60;
draw r3;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(9 + offset);
rotate_around r3 (q9, q5) 60;
draw r3;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(10 + offset);
rotate_around r3 (q9, q5) 60;
draw r3 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(11 + offset);
r4 := r1 rotated_around (q5, q6) 60;
draw r4;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(12 + offset);
rotate_around r4 (q5, q6) 60;
draw r4;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(13 + offset);
rotate_around r4 (q5, q6) 60;
draw r4 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(14 + offset);
r5 := r1 rotated_around (q6, q7) 60;
draw r5;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(15 + offset);
rotate_around r5 (q6, q7) 60;
draw r5;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(16 + offset);
rotate_around r5 (q6, q7) 60;
draw r5 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(17 + offset);

for i = 0 upto 4:
  q[i + 10] := get_point (i) r5;
%  dotlabel.bot(i + 10, q[i + 10]);
endfor;

r6 := r5 rotated_around (q14, q13) 60;
draw r6;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(18 + offset);
rotate_around r6 (q14, q13) 60;
draw r6;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(19 + offset);
rotate_around r6 (q14, q13) 60;
draw r6 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(20 + offset);

for i = 0 upto 4:
  q[i + 15] := get_point (i) r6;
endfor;

r7 := r6 rotated_around (q15, q16) 60;
draw r7;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(21 + offset);
rotate_around r7 (q15, q16) 60;
draw r7;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(22 + offset);
rotate_around r7 (q15, q16) 60;
draw r7 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(23 + offset);

for i = 0 upto 4:
  q[i + 20] := get_point (i) r7;
endfor;

r8 := r7 rotated_around (q22, q21) 60;
draw r8;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(24 + offset);
rotate_around r8 (q22, q21) 60;
draw r8;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(25 + offset);
rotate_around r8 (q22, q21) 60;
draw r8 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(26 + offset);

r9 := r7 rotated_around (q23, q22) 60;
draw r9;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(27 + offset);
rotate_around r9 (q23, q22) 60;
draw r9;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(28 + offset);
rotate_around r9 (q23, q22) 60;
draw r9 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(29 + offset);

r10 := r7 rotated_around (q24, q23) 60;
draw r10;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(30 + offset);
rotate_around r10 (q24, q23) 60;
draw r10;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(31 + offset);
rotate_around r10 (q24, q23) 60;
draw r10 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;




%% **** (4) 

beginfig(32 + offset);

r11 := r7 rotated_around (q24, q20) 60;
draw r11;

output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

beginfig(33 + offset);
rotate_around r11 (q24, q20) 60;
draw r11;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(34 + offset);

rotate_around r11 (q24, q20) 60;

draw r11 on_picture save_picture;
output save_picture with_focus f;
output current_picture with_focus f;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) Start rotating by `dihedral_angle'.

clear save_picture;

beginfig(35 + offset);

for i = 1 upto 11:
   draw r[i];
endfor;

rotate_around r0 (q7, q8) a;

draw r0;
output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 


beginfig(36 + offset);

draw r0;
draw r1;

for i = 3 upto 11:
   draw r[i];
endfor;

rotate_around r2 (q9, q8) a;

draw r2;
output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 


beginfig(37 + offset);

for i = 0 upto 2:
   draw r[i];
endfor;

for i = 4 upto 11:
   draw r[i];
endfor;

rotate_around r3 (q5, q9) a;

draw r3;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 


beginfig(38 + offset);

for i = 0 upto 3:
   draw r[i];
endfor;

for i = 5 upto 11:
   draw r[i];
endfor;

rotate_around r4 (q6, q5) a;

draw r4;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(39 + offset);

for i = 0 upto 7:
   draw r[i];
endfor;

for i = 9 upto 11:
   draw r[i];
endfor;


rotate_around r8 (q21, q22) a;

draw r8;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(40 + offset);


for i = 0 upto 8:
   draw r[i];
endfor;

for i = 10 upto 11:
   draw r[i];
endfor;

%for i = 0 upto 11:
%   label(i, get_center r[i]) with_text_color blue;
%endfor;

%for i = 20 upto 24:
%   dotlabel.top(i, q[i]);
%endfor;

rotate_around r9 (q22, q23) a;

draw r9;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(41 + offset);


for i = 0 upto 9:
   draw r[i];
endfor;

draw r11;


% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

% for i = 20 upto 24:
%    dotlabel.top(i, q[i]);
% endfor;

rotate_around r10 (q23, q24) a;

draw r10;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(42 + offset);


for i = 0 upto 10:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

% for i = 20 upto 24:
%    dotlabel.top(i, q[i]);
% endfor;

rotate_around r11 (q20, q24) a;

draw r11;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) Start rotating top "cup".  

beginfig(43 + offset);


for i = 0 upto 6:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

% for i = 20 upto 24:
%    dotlabel.top(i, q[i]);
% endfor;

for i = 7 upto 11:
   rotate_around r[i] (q21, q20) a;
   draw r[i];
endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) Cut.  Change focus.
%%          LDF 2005.05.07.


set f with_position (-3, 8, -10) with_direction (-3, 8, 10) 
   with_distance 15;


beginfig(44 + offset);


for i = 0 upto 5:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

% for i = 10 upto 14:
%    dotlabel.top(i, q[i]);
% endfor;

for i = 6 upto 11:
   rotate_around r[i] (q13, q14) a;
   draw r[i];
endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(45 + offset);


for i = 0 upto 4:
   draw r[i];
endfor;

for i = 5 upto 11:
   rotate_around r[i] (q12, q11) a;
   draw r[i];
endfor;

%for i = 0 upto 11:
%   label(i, get_center r[i]) with_text_color blue;
%endfor;

% for i = 10 upto 14:
%    dotlabel.top(i, q[i]);
% endfor;



output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) Cut.  Change focus.

set f with_position (0, 7, -10) with_direction (0, 7, 10) 
   with_distance 15;

%% **** (4) 

beginfig(46 + offset);

filldraw r1 with_fill_color violet with_draw_color black;

draw r0;

for i = 2 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

% for i = 10 upto 14:
%    dotlabel.top(i, q[i]);
% endfor;


output current_picture with_focus f no_sort;
clear current_picture;
shift frame (-5, 0, 3);
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(47 + offset);



draw r0;

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;

for i = 3 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color blue;
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(48 + offset);



draw r0;

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;

for i = 4 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]) with_text_color green;
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(49 + offset);



draw r0;

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;

for i = 5 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(50 + offset);



draw r0;

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;

for i = 6 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(51 + offset);





filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;

for i = 6 upto 11:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(52 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;

for i = 6 upto 10:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(53 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;

for i = 6 upto 9:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(54 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;
filldraw r9 with_fill_color yellow with_draw_color black;

for i = 6 upto 8:
   draw r[i];
endfor;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;


%% **** (4) 

beginfig(55 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;
filldraw r9 with_fill_color yellow with_draw_color black;
filldraw r8 with_fill_color green with_draw_color black;

draw r[6];
draw r[7];

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

beginfig(56 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;
filldraw r9 with_fill_color yellow with_draw_color black;
filldraw r8 with_fill_color green with_draw_color black;
filldraw r6 with_fill_color blue with_draw_color black;

draw r[7];

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;



%% **** (4) 

beginfig(57 + offset);

filldraw r1 with_fill_color violet with_draw_color black;
filldraw r3 with_fill_color blue with_draw_color black;
filldraw r2 with_fill_color red with_draw_color black;
filldraw r4 with_fill_color green with_draw_color black;
filldraw r5 with_fill_color yellow with_draw_color black;
filldraw r0 with_fill_color orange with_draw_color black;
filldraw r11 with_fill_color red with_draw_color black;
filldraw r10 with_fill_color orange with_draw_color black;
filldraw r9 with_fill_color yellow with_draw_color black;
filldraw r8 with_fill_color green with_draw_color black;
filldraw r6 with_fill_color blue with_draw_color black;
filldraw r7 with_fill_color violet with_draw_color black;

% for i = 0 upto 11:
%    label(i, get_center r[i]);
% endfor;

output current_picture with_focus f no_sort;
clear current_picture;
draw frame;
endfig with_projection parallel_x_z;



beginfig(58 + offset); 

p5 := mediate(get_point 0 frame, get_point 2 frame);

label("{\large The End}", p5);
draw frame;
endfig with_projection parallel_x_z;

end;

%% ** (2) Found maximum x and y values for images to be used 
%%        for MPEG animations.  The resulting PostScript files
%%        should have `geometry' values as close to 640x480 
%%        as possible.  The closest I could get was 639x479, 
%%        641x481 or 641x479.
%%
%%        LDF 2005.05.03.

    verbatim_metapost "verbatimtex \font\large=cmbx12 scaled \magstep3 etex";

    %verbatim_metapost "verbatimtex \\magnification=\\magstep3 etex";

    point p[];


   %% p0 := (182.05pt, 210pt);
   %% p1 := (412.05pt ,210pt);
   %% p2 := (412.05pt, 382.05002pt);
   %% p3 := (182.05pt, 382.05002pt);

   %% (- 412  182.05)    == 229.95  delta x
   %% (- 382.05002  210) == 172.05  delta y

   %% These values result in "geometry" of 261x196.

   %% Calculate new values.

   %% 229.95 / 261 == x / 640

   %% 172.05 / 196 == y / 480

   %% (setq x (* (/ 229.95 261) 640)) x == 563.8620689655172

   %% (setq y (* (/ 172.05 196) 480)) y == 421.3469387755102 

   %% These result in "geometry" of 635x474

   %%    p0 := (0, 0);
   %%    p1 := (563.8620689655172pt, 0);
   %%    p2 := (563.8620689655172pt, 421.3469387755102pt);
   %%    p3 := (0, 421.3469387755102pt);

   %% Rounding upwards:
   %% Didn't have any effect: -g635x474 (from `display -verbose')
   %% x == 564
   %% y == 422

   %% p0 := (0,     0);
   %% p1 := (564pt, 0);
   %% p2 := (564pt, 422pt);
   %% p3 := (0,     422pt);

   %% Raising values by trial and error.

   %% 569, 426     --> -g641x479 

   %% 568.999, 426.4 --> -g639x479
   
   %% 569, 427 --> -g639x481

   %% 570, 426.5 --> -g641x479

   %% 569.5,    426.75    --> -g641x481
   %% 569.25,   426.625   --> -g641x481
   %% 569.125,  426.5625  --> -g639x479
   %% 569.1875, 426.59375 --> -g641x481

   %% 569.15625, 426.578125 --> -g641x479

   %% Going back to 
   %% 569.1875, 426.59375 --> -g641x481

   %% I wasn't able to get them to be 640x480 exactly, so 
   %% this will have to do.

   p0 := (0,     0);
   p1 := (569.1875pt, 0);
   p2 := (569.1875pt, 426.59375pt);
   p3 := (0,          426.59375pt);

   p4 := mediate(p0, p2);

   path q;

   q := p0 -- p1 -- p2 -- p3 -- cycle;

   circle c;

   set c with_point_count 32;

   scale c (2.5, 2.5, 2.5);  

   circle d;

    beginfig(1);
   
    draw q with_color red with_pen penspeck;
    label("{\large Rotating Disk}", p4);
    endfig with_projection parallel_x_y;    
 

    beginfig(2);
       draw q with_color red with_pen penspeck;
       rotate c by 45; 
       d := c;
       shift d (xpart p4, ypart p4);
       filldraw d with_pen pencircle scaled (3, 3, 3)
          with_draw_color green with_fill_color blue;
      endfig with_projection parallel_x_y;

    end;





%% ** (2) Generate images for the MPEG animation `disk_1.mpg' in 
%%        `~/3DLDF/ANIMATNS/TTEST_0/'.
%%        LDF 2005.05.03.

    verbatim_metapost "verbatimtex \font\large=cmbx12 scaled \magstep3 etex";


    %verbatim_metapost "verbatimtex \\magnification=\\magstep3 etex";

    point p[];

    p0 := (182.05pt, 210pt);
    p1 := (412.05pt ,210pt);
    p2 := (412.05pt, 382.05002pt);
    p3 := (182.05pt, 382.05002pt);

    p4 := mediate(p0, p2);


    path q;

    q := p0 -- p1 -- p2 -- p3 -- cycle;

    transform t;
    t := identity shifted (-182pt, -210pt);

    q *= t;

    p4 *= t; 

    circle c;

    set c with_point_count 32;

    scale c (2.5, 2.5, 2.5);  

    circle d;

    for i = 1 upto 4:
       beginfig(i);
          draw q with_color red;
          label("{\large Rotating Disk}", p4);
       endfig with_projection parallel_x_y;    
    endfor;


    k := 4;

    for i = 1 upto 48:

       for j = 0 upto 3:    
         k += 1;
         beginfig(k);
           draw q with_color red;
           d := c;
           shift d (xpart p4, ypart p4);
           filldraw d with_pen pencircle scaled (3, 3, 3)
             with_draw_color green with_fill_color blue;
         endfig with_projection parallel_x_y;
       endfor;

    rotate c by 15; 
    endfor;

    end;




%% *** (3) 

reg_polygon r;
r := unit_pentagon scaled 3;

for i = 1 upto 5:
beginfig(i);
rotate r by 30;
filldraw r with_pen pencircle scaled 2 with_draw_color red
   with_fill_color blue;
endfig;
endfor;
end;

%% *** (3) Sphere.  LDF 2005.04.30.

% verbatim_metapost "verbatimtex \\magnification=\\magstep3 etex";
% verbatim_metapost "input boxes;";
% verbatim_metapost "input boxes;";
% verbatim_metapost "pickup pencircle scaled .25mm;";
% verbatim_metapost "defaultdx:=.75cm;";
% verbatim_metapost "defaultdy:=.75cm;";

circle c[];

division_value := 64;
one_quarter_division_value := 1/4division_value;
three_quarters_division_value := 3/4division_value;

set c0 with_point_count division_value;
scale c0 (8, 0, 8);
rotate c0 by 90;

point p;
path q[];


p := get_point 0 c0;


q[division_value] += p;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

pickup thick_pen;



step_value := 360 / division_value;
j := 1;
for i = 0 step step_value until 360 - step_value:
   rotate c0 (0, step_value);
   if (is_even j):
      draw c0;
   fi;
   for k = 2 step 2 until one_quarter_division_value - 2:
      q[k] += get_point (k) c0;
      q[three_quarters_division_value + k] 
         += get_point (three_quarters_division_value + k) c0;
   endfor; 
   q[division_value] += get_point 0 c0;
   j += 1;
endfor;

q[division_value] += cycle;
q[division_value] += ..;
draw q[division_value];

for i = 2 step 2 until one_quarter_division_value - 2:
      q[i] += ..;
      q[i] += cycle;
      q[three_quarters_division_value + i] += ..;
      q[three_quarters_division_value + i] += cycle;
      draw q[i];
      draw q[three_quarters_division_value + i];
endfor;

rotate current_picture by -25;

picture save_picture;

save_picture := current_picture;
clear current_picture;

message "Starting figures.";


for i = 1 upto 35:
   rotate save_picture (0, 10);
   beginfig(i);
      output save_picture;
   endfig;
   message "Finished figure:";
   show i;
endfor;


end;






%% *** (3) Trying to get surface hiding to work for three objects.
%%         LDF 2005.04.20.


pickup pencircle scaled 3;

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;

rectangle rp[];

picture save_picture;

rp0 := unit_rectangle scaled 5 rotated 90;

rp1 := unit_rectangle scaled 5 shifted (0, -1);
rp2 := unit_rectangle scaled 5 shifted (0, 1);


beginfig(1); 

draw rp0 with_draw_color blue;
draw rp1 with_draw_color red;
draw rp2 with_draw_color yellow;

save_picture := current_picture;

clear current_picture;

filldraw rp0 with_draw_color blue with_fill_color orange;
filldraw rp1 with_draw_color red with_fill_color green;
filldraw rp2 with_draw_color yellow with_fill_color violet;

dotlabel.top("origin", origin);
endfig with_focus f with_surface_hiding;

beginfig(2); 
output save_picture with_projection parallel_x_y; 
label("Parallel x-y", (0, -3)); 
endfig with_projection parallel_x_y; 

beginfig(3); 
output save_picture with_projection parallel_x_z;
label("Parallel x-z", (0, 0, -3)); 
endfig with_projection parallel_x_z;

beginfig(4); 
output save_picture with_projection parallel_z_y;
drawarrow origin -- (0, 0, 2);
dotlabel.lft("Origin", origin);
label.bot("z", (0, 0, 2));
drawarrow origin -- (0, 2);
label.lft("y", (0, 2));
label("Parallel z-y", (0, -3)); 
endfig with_projection parallel_z_y;

end;





%% *** (3) Added the option `with_z' to the rules for projecting
%%         `paths' and `polygons'.
%%         LDF 2005.04.19.

beginfig(1); 
focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;
point A;
A := (1, 2, 3);

point B;

B := A projected f;

message "point B:";
show B;

point C;

C := A projected f with_z;

message "point C:";
show C;


path D;
path E;

D := (1, 2, 3) -- (4, 5, 6);
E := D projected f with_z;

message "path E:";
show E;

polygon F;
polygon G;

F := unit_pentagon scaled 3 rotated 15 shifted (3, 1, 2);

G := F projected f;

message "polygon G:";
show G;

polygon H;

H := F projected f with_z;

message "polygon H:";
show H;

endfig; 
end;


%% *** (3) Working on surface hiding.
%%         LDF 2005.04.18.

pickup pencircle scaled 3;

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;

reg_polygon rp[];

polygon_vector pv;

picture save_picture;

rp0 := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, -5);

rp1 := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1, 5);

shift rp0 (0, 0, 6);

pv := rp0 / rp1;

beginfig(1); 

filldraw rp0 with_draw_color blue with_fill_color green;
filldraw rp1 with_draw_color red with_fill_color yellow;

save_picture := current_picture;

endfig with_focus f with_surface_hiding;

beginfig(2); 

draw pv0 with_color green;
draw pv1 with_color yellow;

draw pv2 with_color cyan;
draw pv3 with_color magenta;

endfig with_focus f;

beginfig(3); 
output save_picture with_projection parallel_x_y;
label.bot("Parallel X-Y", origin shifted (0, -.5));
endfig with_projection parallel_x_y;;


beginfig(4); 
output save_picture with_projection parallel_x_z;
label.bot("Parallel X-Y", origin shifted (0, 0, -.5));
endfig with_projection parallel_x_z;;

end;



%% *** (3) Working on projecting objects.
%%         Added functions and parser rules for getting 
%%         the `transform' data member from a `focus'
%%         and transforming a `transform'.
%%         LDF 2005.04.16.

pickup pencircle scaled 3;

reg_polygon p;
reg_polygon q;

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;

%% Working on this.
%% LDF 2005.04.15.

color_vector cv;
cv += blue;
cv += orange;
cv += yellow;
cv += violet;
cv += green;

polygon_vector pv;

picture save_picture;

p := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, -5);

q := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1, 5);

reg_polygon A;

A := unit_pentagon rotated (30, 30, 30) shifted (1, 2, 13);

polygon B;


B := projected A with_focus f;

rectangle C;
polygon D;

C := unit_rectangle rotated 90 scaled 5;

D := projected C with_focus f;

transform t;

t := get_transform f;

message "t:";
show t;
%pause;


transform u;

u := inverse t;

message "u:";
show u;
%pause;


shift p (0, 0, 6);

beginfig(1); 

draw A with_color violet;
draw B with_color orange;
draw D;

%% It's necessary to output and clear `current_picture',
%% because I need to output `A' and `B' without using surface 
%% hiding.  Trying to output them with surface hiding, together
%% with the other objects, causes an error.
%% I haven't yet worked on the surface hiding algorithm
%% using more than two original objects.  
%% LDF 2005.04.15.

output current_picture with_focus f;  
      
clear current_picture;


pv := p / q;

draw p with_draw_color blue with_fill_color green;
draw q with_draw_color red with_fill_color yellow;

save_picture := current_picture;

endfig with_focus f with_surface_hiding mean_z_sort;

beginfig(2); 

draw A with_color violet;
draw B with_color orange;
draw D;

output save_picture with_projection parallel_x_z;
endfig; 

beginfig(3); 

draw A with_color violet;
draw B with_color orange;
draw D;

output save_picture with_projection parallel_x_y;
endfig; 



end;


%% *** (3) Self-decomposition of `polygons'.
%%         LDF 2005.04.13.

beginfig(1);

triangle t;
reg_polygon r;

r := unit_pentagon scaled 3 shifted 7 rotated 90;

set t with_points ((-3, 0), (3, 0), (0, 3));

polygon_vector pv;
polygon_vector qv;

pv := t decompose 1;
qv := r decompose 1;

pickup pencircle scaled 1.3;

draw pv;
draw qv;

shift t (0, -5);
shift r (0, -7);


pv := t decompose 2;
qv := r decompose 2;

draw pv;
draw qv;


shift t (0, -5);
shift r (0, -7);


pv := t decompose 3;
qv := r decompose 3;

draw pv;
draw qv;


endfig with_projection parallel_x_y; 


%% *** (3) Self-decomposition of `rectangles'.
%%         LDF 2005.04.13.


beginfig(2);

color_vector cv;

cv += red;
cv += green;
cv += blue;
cv += yellow;
cv += magenta;
cv += cyan;
cv += orange;
cv += violet;
cv += blue_violet;
cv += yellow_green;

rectangle r;
%polygon_vector pv;

r := unit_rectangle rotated 90 scaled (3, 4);

pickup pencircle scaled 1.5;

pv := r decompose 1;

draw pv;

shift r by 7;
draw r;

pv := r decompose 1 with_rectangles;

draw pv;

%% **** (4) ***********


shift r (-7, -4.5);

pv := r decompose 2;

draw pv;

shift r by 7;
draw r;

pv := r decompose 2 with_rectangles;

draw pv;

%% **** (4) ***********

shift r (-7, -4.5);

pv := r decompose 3;

draw pv;

shift r by 7;
draw r;

pv := r decompose 3 with_rectangles;

draw pv;

%% **** (4) ***********

shift r (-7, -4.5);

pv := r decompose 4;

draw pv;

shift r by 7;
draw r;

pv := r decompose 4 with_rectangles;

draw pv;

%% **** (4) ***********

endfig with_projection parallel_x_y; 
end;



%% ** (2) Self-decomposition of a `polygon'.
%%        After much difficulty, I've managed to get a single level of 
%%        decomposition to work.
%%        LDF 2005.04.13.

beginfig(1); 

color_vector cv;

cv += red;
cv += green;
cv += blue;
cv += yellow;
cv += magenta;
cv += cyan;
cv += orange;
cv += violet;

reg_polygon r;
r := unit_pentagon scaled 2 rotated 90;

polygon_vector pv;

pv := r decompose 1;

fill pv with_fill_color_vector cv;


transform t;
t := identity shifted (0, -5);

r *= t;

pv := r decompose 1;

fill pv with_fill_color_vector cv;

r *= t;

pv := r decompose 1;

fill pv with_fill_color_vector cv;

endfig with_projection parallel_x_y; 
end;





%% *** (3) Working on `colors'.  I want to be able to use both 
%% "RGB" (red-green-blue) and "CMY" (cyan-magenta-yellow) `colors'.
%% This will need more work.  Currently, all `colors' are RGB.
%% LDF 2005.04.11.

verbatim_metapost "verbatimtex \font\large=cmr12 \font\largebf=cmbx12 etex";

beginfig(1);

circle c[];

c0 := unit_circle scaled 2 rotated 90 shifted (0, 5);
c2 := c0 shifted 3;
c1 := c0 shifted 6;


def m {color A, color B, string S, string T, string U} :=
transform t;
t := identity shifted (0, -5);
c0 *= c1 *= c2 *= t;
color C;
C := A;
C += B;
pickup pencircle scaled 2;
filldraw c0 with_draw_color black with_color A;
filldraw c1 with_draw_color black with_color B;
filldraw c2 with_draw_color black with_color C;

S := "{\largebf " & S & "}";
T := "{\largebf " & T & "}";
U := "{\largebf " & U & "}";

label(S, get_center c0); 
label(T, get_center c1); 
label(U, get_center c2); 
enddef;


string s[];
s0 := "q0";
s1 := "q1";
s2 := "q2";

color q[];
set q0 (.5, .0, .5);
set q1 (.3, .0, .3);


m {q0, q1, s0, s1, s2};

endfig with_projection parallel_x_y; 
end; 


%% *** (3) Working on surface hiding.
%%         LDF 2005.04.08.

pickup pencircle scaled 3;

reg_polygon p;
reg_polygon q;

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;


color_vector cv;
cv += blue;
cv += orange;
cv += yellow;
cv += violet;
cv += green;

polygon_vector pv;

picture save_picture;


p := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, -5);

q := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1, 5);


for i = 1 upto 10:

beginfig(i); 

message "Starting figure:";
show i;

shift p (0, 0, 3);

pv := p / q;

dotlabel.top(0, pv0);
dotlabel.bot(10, pv1);
dotlabel.lft(20, p);

filldraw p with_draw_color blue with_fill_color green;
filldraw q with_draw_color red with_fill_color yellow;

save_picture := current_picture;

endfig with_focus f with_surface_hiding mean_z_sort;

beginfig(20 + i); 
message "Starting figure:";
show 20 + i;
output save_picture with_projection parallel_x_z;
endfig; 

endfor;

end;

%% *** (3) BUG FIX:  The various combinations now seem to work
%%         properly.
%%         LDF 2005.04.08.

bool b[];

b0 := true;  % false
b1 := true;  % false
b2 := false; % true
b3 := false; % true

if b0:

   message "b0 is true;";

   if b1:
      message "A: b1 is true;";

      if b2:
         message "C: b2 is true;";
         if b3:
             message "E: b3 is true.";
         else:
             message "E: b3 is false.";
         fi;
      else:
         message "C: b2 is false;";
         if b3:
             message "F: b3 is true.";
         else:
             message "F: b3 is false.";
         fi;

      fi;

   else: 
      message "A: b1 is false;";
      if b2:
         message "D: b2 is true;";
      else:
         message "D: b2 is false;";
      fi;
   fi;

   if b2:
      message "A: b2 is true;";
   else: 
      message "A: b2 is false;";
   fi;

else:
   message "b0 is false;";

   if b1:
      message "B: b1 is true;";
   else: 
      message "B: b1 is false;";
   fi;

   if b2:
      message "B: b2 is true;";
   else: 
      message "B: b2 is false;";
   fi;

   

fi;

end;




%% *** (3) Now suppressing output from drawing 
%%         commands for non-polygonal `paths' when the type of 
%%         the current `Pen' is `Pen::NULL_PEN'.
%%         LDF 2005.04.05.

beginfig(1); 

focus f;
set f with_position (-5, 10, -10) with_direction (-5, 10, 10) 
   with_distance 10;


pickup pencircle scaled 3;

ellipse e;

e := unit_ellipse scaled 2;

draw e with_color blue;

shift e (0, 0, 2);

draw e with_pen null_pen;

endfig with_focus f; 

end;

%% *** (3) For polygonal types:  Now suppressing output from drawing 
%%         commands when the type of 
%%         the current `Pen' is `Pen::NULL_PEN'.
%%         LDF 2005.04.04.


beginfig(1); 

pickup pencircle scaled 3;

reg_polygon p;
reg_polygon q;

focus f;
set f with_position (-5, 10, -10) with_direction (-5, 10, 10) 
   with_distance 10;

p := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, 2);

q := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1);

pen_vector pv;
pv += pencircle scaled 3;
pv += null_pen;
pv += pensquare scaled 2;
pv += null_pen;
pv += pensquare scaled 2;


color_vector cv;

cv += blue;
cv += green;
cv += red;
cv += yellow;
cv += purple;

filldraw p with_draw_color_vector cv with_pen_vector pv;

endfig with_focus f;

end;


%% *** (3) Working on implementing surface hiding 
%%         LDF 2005.04.04.


beginfig(1); 

pickup pencircle scaled 3;

reg_polygon p;
reg_polygon q;

focus f;
set f with_position (-5, 10, -10) with_direction (-5, 10, 10) 
   with_distance 10;

p := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, 2);

q := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1);

filldraw p with_draw_color red with_fill_color green;
filldraw q with_draw_color blue with_fill_color yellow;;

endfig with_focus f with_surface_hiding;

end;



%% *** (3) Working on implementing surface hiding 
%%         in `Picture::output()' in `points.web'.
%%         The default behavior of `Picture::output()' is now _not_ to perform 
%%         surface hiding.  If you want surface hiding, you must use the
%%         `with_surface_hiding' option to `endfig' or `output'.
%%
%%         I've got surface hiding to work with two `polygon-like' objects.
%%         It still needs work, though.
%%         LDF 2005.04.04.

beginfig(1); 

pickup pencircle scaled 3;

reg_polygon p;
reg_polygon q;

focus f;
set f with_position (-5, 10, -10) with_direction (-5, 10, 10) 
   with_distance 10;

p := unit_pentagon scaled 5 rotated (0, 20) shifted (0, 0, 2);

q := unit_hexagon scaled 5 rotated (90, 20) shifted (0, 1);

draw p with_color red;
draw q with_color blue;

endfig with_focus f;

beginfig(2);

filldraw p with_draw_color red with_fill_color green;
filldraw q with_draw_color blue with_fill_color yellow;;

picture save_picture;

save_picture := current_picture;

endfig with_focus f with_surface_hiding;

beginfig(3); 

polygon_vector pv;
pv := p / q;

pickup pencircle scaled 2;

color_vector cv;

cv += red;
cv += blue;
cv += green;
cv += yellow;

draw pv with_color_vector cv;

if false:
   draw p with_color red;
   draw q with_color blue;
fi;

endfig with_focus f without_surface_hiding; 

beginfig(4); 
output save_picture with_projection parallel_x_y with_surface_hiding;
endfig; 

beginfig(5); 
output save_picture with_projection parallel_x_z with_surface_hiding;
endfig; 

end;

%% *** (3) Started working on `ellipse_slices', `circle_slices', and
%%         `polyhedron_slices'.  These types will be needed for 
%%         surface hiding.  They are not yet functional.
%%         LDF 2005.03.29.

beginfig(1); 

ellipse_slice e;
show e;

circle_slice c;
show c;

polyhedron_slice p;
show p;

endfig;
end;










%% *** (3) Multiple `pens' and/or `dash_patterns' can now be used for
%%         drawing objects of `polygon-like' types.
%%         LDF 2005.03.18.

beginfig(1); 

%pickup pencircle scaled 2;

polygon p;

p := unit_pentagon scaled 5 rotated 90;

color_vector cv;
cv += blue;
cv += red;

pen_vector pv;

pv += pencircle scaled 2;
pv += pencircle scaled 3;
pv += pencircle scaled 6;

dash_pattern_vector dpv;

dpv += evenly scaled 3;
dpv += with_dots scaled 3;
dpv += with_dots scaled 10;

draw p with_draw_color_vector cv with_dash_pattern_vector dpv
 with_pen_vector pv
;


circle c;

c := unit_circle scaled 7 rotated 90;

draw c with_draw_color_vector cv with_dash_pattern_vector dpv
 with_pen_vector pv
;



endfig with_projection parallel_x_y; 
end;







%% *** (3) Removed `Color* Path::fill_color'.  Now using
%%         `Pointer_Vector<Color>* fill_color_vector->v[0]'
%%         instead.  `fill_color_vector' is a member 
%%         of `class Shape'.  This causes no user-visible 
%%         changes.  
%%         LDF 2005.03.18.

beginfig(1); 

reg_polygon c;

c := unit_pentagon scaled 2 rotated 90;

fill c with_color red;

shift c by 5;

color_vector cv;
cv += blue;
cv += red;

filldraw c with_draw_color yellow with_pen pencircle scaled 3 with_fill_color_vector cv;


endfig with_projection parallel_x_y; 
end;

%% *** (3) Removed `Pen* Point::pen'.  Now using
%%         `Pointer_Vector<Pen>* pen_vector->v[0]'
%%         instead.  `pen_vector' is a member 
%%         of `class Shape'.  This causes no user-visible 
%%         changes.  
%%         LDF 2005.03.17.

beginfig(1); 

pen q;

q := pencircle scaled 6;

drawdot origin with_pen q;

point p;
p := (0, 1);



drawdot p with_color blue with_pen q;

shift p (0, 1);
drawdot p with_color blue with_pen q;

endfig with_projection parallel_x_y; 
end;


%% *** (3) Drawing and filling `solid-like' 
%%         objects now works again.  I had to account for 
%%         changes I've made to `class Shape' and `class Path'.
%%         They still don't work exactly as I'd like them to,
%%         but this was the case before, too.
%%         LDF 2005.03.17. 


%% PLEASE NOTE!
%% I've replaced the individual polyhedral types with the single type 
%% `polyhedron'.  I've changed the code below accordingly, but I 
%% haven't tested it.
%% LDF 2005.10.24.  

beginfig(1);
pickup pencircle scaled 3;
polyhedron d;
d := unit_dodecahedron scaled 2;
draw d with_color red;

color_vector cv;

cv += red;
cv += blue;
cv += red;
cv += blue;
cv += red;
cv += blue;
cv += red;
cv += blue;
cv += red;
cv += blue;
cv += red;
cv += blue;

shift d (0, 4);
rotate d (15, 15, 15);
filldraw d with_fill_color_vector cv;

endfig;  

end;
%% *** (3) Drawing `path_vector-like' objects.
%%         Debugged `Scan_Parse::drawing_command_path()'
%%         in `scanprsf.web'.  It seems to work now.
%%         LDF 2005.03.16.



beginfig(1); 

polygon_vector pv;

pv += unit_pentagon scaled 3;  

pv += unit_hexagon scaled 3 rotated 90;

pv += unit_heptagon scaled 3 rotated 90 shifted 5;


color_vector cv;

cv += red;
cv += green;
cv += blue;
cv += yellow;
cv += violet;
cv += orange;
cv += blue_violet;

color_vector dv;

dv += blue_violet;
dv += orange;


pickup pencircle scaled (2, 2, 2);

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;


%draw pv0;

%draw pv0 with_draw_color green;

%draw pv0 with_color blue;

%draw pv0 with_draw_color_vector cv;


%fill pv0;

%fill pv0 with_fill_color green;

%fill pv0 with_color blue;

%fill pv0 with_fill_color_vector cv;


%filldraw pv0;

%filldraw pv0 with_fill_color green;

%filldraw pv0 with_color blue;

%filldraw pv0 with_draw_color_vector cv;

%rotate pv0 by 90;

%draw pv0 with_pen pencircle scaled 6;

%undraw pv0;

%undraw pv0 with_fill_color green;

%undraw pv0 with_color blue;

%undraw pv0 with_draw_color_vector cv;

%unfilldraw pv0;

%unfilldraw pv0 with_draw_color green;

%unfilldraw pv0 with_color blue;

%unfilldraw pv0 with_draw_color_vector cv;

%filldraw pv0 with_draw_color_vector cv with_fill_color black;


%filldraw pv0 with_fill_color yellow with_color black
%   with_draw_color_vector cv with_fill_color_vector dv;

%filldraw pv0 with_fill_color_vector cv with_color_vector dv;

% filldraw pv0 
%     with_draw_color_vector cv
%      with_draw_color black 
%      with_fill_color yellow
%     with_fill_color_vector cv
%     with_color orange 
%     with_color_vector dv
% ;
    

%filldraw pv0 with_draw_color black with_fill_color yellow with_color black 
%   with_draw_color_vector cv with_fill_color_vector dv;

filldraw pv0 with_draw_color black with_fill_color yellow;



endfig with_focus f; 

end;





%% *** (3) Removed the parser rules for appending `colors' to `path-like' variables.
%% 	   Changed the `Path' drawing and filling functions (in `paths.web')
%% 	   and `Scan_Parse::drawing_command_path()' (in `scanprsf.web') so that they
%% 	   can handle `color_vectors' passed to the drawing and filling commands 
%% 	   using the `with_color_vector' and `with_draw_color_vector' options 
%% 	   instead.
%%
%% 	   Unfortunately, these changes have caused `Scan_Parse::drawing_command_path_vector()'
%% 	   to no longer work properly.  I have made a note to myself to fix this.
%%
%% 	   LDF 2005.03.15.

reg_polygon p;  
reg_polygon q;  
reg_polygon r;  

p := unit_pentagon scaled 3;  

q := unit_hexagon scaled 3 rotated 90;

r := unit_heptagon scaled 3 rotated 90 shifted 5;

color_vector cv;

cv += red;
cv += green;
cv += blue;
cv += yellow;
cv += violet;
cv += orange;
cv += blue_violet;

pickup pencircle scaled (2, 2, 2);

focus f;
set f with_position (-5, 5, -10) with_direction (-5, 5, 10) 
   with_distance 10;

beginfig(1);


draw p with_draw_color_vector cv;

draw q with_color green;

draw r with_color_vector cv;

endfig with_focus f with_surface_hiding; 

end;


%% *** (3) Drawing and filling (and undrawing and unfilling) 
%%         `path_like_vectors'.
%%         LDF 2005.03.10.


rectangle r;
r := unit_rectangle scaled 4;
rotate r by 90;
shift r (0, 1.5);

% triangle t;
% set t with_points ((-3, -1), (3, -1), (0, 3));

reg_polygon t;
t := unit_pentagon scaled 3 rotated 90;

polygon_vector pv;

point p[];

pv := t / r;

color_vector cv;
cv += blue;
cv += red;
cv += green;
cv += yellow;
cv += purple;
cv += orange;

color_vector dv;

dv += pink;
dv += cyan;
dv += magenta;
dv += yellow_green;
dv += blue_violet;
dv += gray;

polygon_vector pv_a;

pv_a += unit_rectangle;
pv_a += unit_pentagon shifted 3;

%% **** (4) Using `drawdblarrow' on a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 

drawdblarrow pv with_color_vector cv;
endfig with_projection parallel_x_y; 

end; 

%% **** (4) Using `drawarrow' on a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 

drawarrow pv;
endfig with_projection parallel_x_y; 

end; 

%% **** (4) Unfilldrawing a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 

fill unit_rectangle scaled (2, 2, 2) with_color green;
fill unit_pentagon scaled (2, 2, 2) shifted 3 with_color yellow;

pickup pencircle scaled 3;

unfilldraw pv_a with_color_vector cv;

endfig with_projection parallel_x_z; 

end; 


%% **** (4) Unfilling a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 

fill unit_rectangle scaled (2, 2, 2) with_color red;
fill unit_pentagon scaled (2, 2, 2) shifted 3 with_color blue;

unfill pv_a;

endfig with_projection parallel_x_z; 

end; 

%% **** (4) Undrawing a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 

draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 

pickup pencircle scaled (3, 3, 3);

draw pv with_color_vector cv;

pickup pencircle scaled (1, 1, 1);

undraw pv;

endfig with_projection parallel_x_y; 

end; 



%% **** (4) Filldrawing a `path_like_vector'.
%%          LDF 2005.03.10.

beginfig(1); 


draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 

pickup pencircle scaled (2, 2, 2);

filldraw pv with_draw_color_vector cv with_fill_color_vector dv;

endfig with_projection parallel_x_y; 

end; 

%% *** (3) Working on decomposing polygonal objects.
%%         Dividing a `polygon_like_expression' by
%%         another `polygon_like_expression'.
%%         I thought example of dividing two coplanar `polygons'
%%         wasn't working correctly, but it is.
%%         LDF 2005.03.10.

rectangle r;
r := unit_rectangle scaled 4;
rotate r by 90;
shift r (0, 1.5);

% triangle t;
% set t with_points ((-3, -1), (3, -1), (0, 3));

reg_polygon t;
t := unit_pentagon scaled 3 rotated 90;

polygon_vector pv;

point p[];

%% **** (4) 

beginfig(1); 

pv := t / r;

message "size pv:";
show size pv;
pause;


draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 

if size pv > 0:
   fill pv0 with_color red;
fi

if size pv > 1:
      fill pv1 with_color blue;
fi;

if size pv > 2:
   fill pv2 with_color yellow;
fi;

if size pv > 3:
   fill pv3 with_color green;
fi;
 
if size pv > 4:
   fill pv4 with_color purple;
fi;

if size pv > 5:
   fill pv5 with_color orange;
fi;

if size pv > 6:
   fill pv6 with_color brown;
fi;


endfig with_projection parallel_x_y; 


%% **** (4) 

beginfig(2); 

pv := r / t;

message "size pv:";
show size pv;
pause;

draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 

if size pv > 0:
   fill pv0 with_color red;
   if size pv > 1:
      fill pv1 with_color blue;
   fi;
      if size pv > 2:
         fill pv2 with_color yellow;
      fi;
         if size pv > 3:
            fill pv3 with_color green;
         fi;
fi;

endfig with_projection parallel_x_y; 

%% **** (4) 

beginfig(3); 

shift t (0, -4);

pv := t / r; 
             
message "size pv:";
show size pv;
pause;

draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 

endfig with_projection parallel_x_y; 


%% **** (4) 

beginfig(4); 

shift t (0, 7);

pv := t / r; 
             
message "size pv:";
show size pv;
pause;

draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 


if size pv > 0:
   fill pv0 with_color red;
fi

if size pv > 1:
      fill pv1 with_color blue;
fi;

if size pv > 2:
   fill pv2 with_color yellow;
fi;

if size pv > 3:
   fill pv3 with_color green;
fi;
 
if size pv > 4:
   fill pv4 with_color purple;
fi;

if size pv > 5:
   fill pv5 with_color orange;
fi;

if size pv > 6:
   fill pv6 with_color brown;
fi;

endfig with_projection parallel_x_y; 

%% **** (4) 

beginfig(5); 

shift t (0, 1);



pv := r / t; 
             
message "size pv:";
show size pv;
pause;

draw t;
dotlabel.bot(0, t);

draw r;
dotlabel.top(0, r); 


if size pv > 0:
   fill pv0 with_color red;
fi

if size pv > 1:
      fill pv1 with_color blue;
fi;

if size pv > 2:
   fill pv2 with_color yellow;
fi;

if size pv > 3:
   fill pv3 with_color green;
fi;
 
if size pv > 4:
   fill pv4 with_color purple;
fi;

if size pv > 5:
   fill pv5 with_color orange;
fi;

if size pv > 6:
   fill pv6 with_color brown;
fi;

endfig with_projection parallel_x_y; 

end;

%% *** (3) Working on decomposing polygonal objects.
%%         Dividing a `polygon_like_expression' by
%%         another `polygon_like_expression'.
%%         The non-coplanar case now works.
%%         The non-coplanar case now works.
%%         LDF 2005.02.25.

rectangle r;
r := unit_rectangle scaled 4;

triangle t;
set t with_points ((-3, -1), (3, -1), (0, 3));

polygon_vector pv;

point p[];

pv := r / t;

message "pv:";
show pv;

beginfig(1); 
draw r;
draw t;
dotlabel.bot(0, t);
p0 := mediate(get_point 0 t, get_point 1 t);
shift p0 (0, -.25);
label.bot("x-y", p0);

fill pv0 with_color red;
fill pv1 with_color green;

fill pv2 with_color blue;
fill pv3 with_color yellow;

endfig with_projection parallel_x_y;

beginfig(2); 
draw r;
draw t;
dotlabel.bot(0, r);
p0 := mediate(get_point 0 r, get_point 1 r);
shift p0 (0, 0, -.25);
label.bot("x-z", p0);

fill pv0 with_color red;
fill pv1 with_color green;

fill pv2 with_color blue;
fill pv3 with_color yellow;

endfig with_projection parallel_x_z;


beginfig(3); 

focus f;

set f with_position (-8, 3, -10) with_direction (-8, 3, 10) 
   with_distance 10;

draw r;
draw t;
dotlabel.bot(0, t);
p0 := mediate(get_point 0 t, get_point 1 t);
shift p0 (0, -.25);
label.bot("perspective", p0);

fill pv1 with_color green;
fill pv2 with_color blue;
fill pv3 with_color yellow;
fill pv0 with_color red;


dotlabel.top(0, r);
message "r:";
show r; 

endfig with_focus f max_z_sort;

end;



%% *** (3) Working on decomposing polygonal objects.
%%         Decomposing a `polygon-like' object using two `points'.
%%         This works now.
%%         LDF 2005.02.24.

beginfig(1); 

point p[];
p0 := (0, 0);
p1 := (2, 2);

dotlabel.top("$p_0$", p0);
dotlabel.top("$p_1$", p1);

draw p0 -- p1;

reg_polygon r;
r := unit_pentagon scaled 3 rotated 90;

draw r;

polygon_vector pv;

pv := r decompose (p0, p1);

show pv;

fill pv0 with_color red;
fill pv1 with_color green;

endfig with_projection parallel_x_y;
end;




%% *** (3) Working on decomposing polygonal objects.
%%         Decomposing a `polygon-like' object using two `points'.
%%         LDF 2005.02.22.

beginfig(1); 

point p[];
p0 := (-2, -2);
p1 := (2, 2);

draw p0 -- p1;

reg_polygon r;
r := unit_pentagon scaled 3 rotated 90;

draw r;

polygon_vector pv;

pv := r decompose (p0, p1);

show pv;

fill pv[0] with_color red;
fill pv[1] with_color green;

endfig with_projection parallel_x_y;
end;


%% *** (3) Decomposing a `polygon-like' using two `points'.
%%         LDF 2005.02.21.

beginfig(2);
point q[];
q0 := (-2, -2);
q1 := (2, 2);
shift q0 (0, .25);
shift q1 (0, .25);
draw q0 -- q1;

draw r;

polygon_vector qv;

qv := r decompose (q0, q1);

show qv;

fill qv0 with_color red;
fill qv1 with_color green;

endfig with_projection parallel_x_y;

end;


%% *** (3) Working on decomposing polygonal objects.
%% 	   Added the parser rule
%% 	   `polygon_vector_primary: rectangle_expression DECOMPOSE
%% 	   LEFT_PARENTHESIS point_expression COMMA point_expression
%% 	   RIGHT_PARENTHESIS' in `ppgvexpr.w'.
%%         LDF 2005.02.21.

point p[];
p0 := (-3, -3);
p1 := (3, 3);

transform t;
t := identity shifted (0, .25);

rectangle r;
r := unit_rectangle scaled 3 rotated 90;

polygon_vector pv;

beginfig(1); 
draw r;
draw p0 -- p1;
pv := r decompose (p0, p1);
show pv;
fill pv0 with_color red;
fill pv1 with_color green;

dotlabel.lft(0, pv0);
dotlabel.rt(10, pv1);

endfig with_projection parallel_x_y;

beginfig(2); 
p0 *= p1 *= t;
draw r;
draw p0 -- p1;
pv := r decompose (p0, p1);
show pv;
fill pv0 with_color red;
fill pv1 with_color green;

dotlabel.lft(0, pv0);
dotlabel.rt(10, pv1);

endfig with_projection parallel_x_y;

beginfig(3); 
p0 *= p1 *= t;
draw r;
draw p0 -- p1;
pv := r decompose (p0, p1);
show pv;
fill pv0 with_color red;
fill pv1 with_color green;

dotlabel.lft(0, pv0);
dotlabel.rt(10, pv1);

endfig with_projection parallel_x_y;

end;

%% *** (3) `polygons'.  LDF 2005.02.21.

beginfig(1);

polygon p;


p += cycle;

p += origin;

p += (1, 0);

p += (.5, 1);

message "p before minus_assign cycle:";
show p;

p -= cycle;

message "p after minus_assign cycle:";
show p;

p += cycle;

message "p after plus_assign cycle:";
show p;

draw p;

endfig;
end;


%% *** (3) BUG FIX:  This works now.

beginfig(1);

point p[];

p0 := p1 := p2 := p3 := (1, 2, 3);

p4 := (p0 + p1 + p2 + p3) / 4;

message "p4:";
show p4;

endfig;
end;


%% *** (3) `is_convex_polygonal'.  
%%         LDF 2005.02.11.

beginfig(1);

path p;

p := (0, 0) -- (3, 0) -- (0, 3) -- (3, 3) -- cycle;

draw p;
dotlabel.lft(0, get_point 0 p);
dotlabel.rt(1, get_point 1 p);
dotlabel.lft(2, get_point 2 p);
dotlabel.rt(3, get_point 3 p);

message "is_convex_polygonal p:";
show is_convex_polygonal p;

reg_polygon r;

r := unit_pentagon scaled 2 rotated 90 shifted (0, -3);
draw r;

message "is_convex_polygonal r:";
show is_convex_polygonal r;

path s;

%% `points' that lie on the sides of a polygonal path 
%% are not used for determining whether the `path' is convex.
%% LDF 2005.02.11.

s := origin -- (1, 0) -- (2, 0) -- (3, 1) -- (2, 2) -- (1.5, 2) 
            -- (1, 2) -- (-1, 1) -- cycle;

shift s (0, -8);

draw s;

dotlabel.top(0, s);

message "is_convex_polygonal s:";
show is_convex_polygonal s;

endfig with_projection parallel_x_y; 

end;





%% *** (3) Working on decomposing polygonal objects.
%% 	   It now works to divide a `rectangle' by a linear `path',
%%         using the division operator `/'.  The result is a `path_vector'
%%         with two elements.
%%         LDF 2005.02.07.

beginfig(1); 

path p;
p := (-2, -2) -- (2, 2);
shift p (0, .25);
draw p;

rectangle r;
r := unit_rectangle scaled 3 rotated 90;

dotlabel.bot(0, get_point 0 r);
dotlabel.bot(1, get_point 1 r);
dotlabel.urt(2, get_point 2 r);
dotlabel.top(3, get_point 3 r);


dotlabel.lrt(0, get_point 2 r) with_text_color blue;
dotlabel.llft(1, get_point 3 r) with_text_color blue;
dotlabel.ulft(2, get_point 0 r) with_text_color blue;
dotlabel.urt(3, get_point 1 r) with_text_color blue;

draw r;

path_vector pv;

pv := r / p;

show pv;

fill pv[0] with_color red;
fill pv[1] with_color green;

endfig with_projection parallel_x_y;

end;


%% *** (3) Started working on `origami_figures'.  They can't be 
%%         used for anything yet.
%%         LDF 2005.02.04.

beginfig(1);

origami_figure o;
show o;

point p;
show is_origami_figure o;
show is_origami_figure p;


endfig;
end;
 

%% *** (3) Started working on decomposing `rectangles'.
%% 	   Working on the function 
%% 	   `Rectangle::decompose(Path* p, Scanner_Node scanner_node = 0)'
%% 	   in `rectangs.web'.
%% 	   Added the rule
%% 	   `path_vector_primary --> DECOMPOSE rectangle_expression 
%% 	   BY path_expression' in `pphvexpr.w'. 
%%         LDF 2005.02.01.

beginfig(1); 

path p;
p := (-2, -2) -- (2, 2);
draw p;

rectangle r;
r := unit_rectangle scaled 1.5 rotated 90;

draw r;

path_vector pv;

pv := r / p;

show pv;

endfig with_projection parallel_x_y;

end;



%% *** (3) Bug fix:  `clear current_picture' no longer causes a 
%%         segmentation fault when using labels.
%%         LDF 2005.02.01.

beginfig(1); 

bool_point bp[];

bp0 := (true, origin);

dotlabel_if.top(0, bp0) with_text_color blue with_dot_color red;
label_if.bot(1, bp0) with_text_color green;

output current_picture;

clear current_picture;

draw origin .. (1, 1);

endfig;

end;





%% *** (3) `label_if', `label_unless', `dotlabel_if', and 
%%         `dotlabel_unless' for `bool_points' with a 
%%         `string_expression' or a 
%%         `numeric_expression' argument for the text, and 
%%         optional `with_text_color' and `with_dot_color' 
%%         arguments.
%%         LDF 2005.01.31.

beginfig(1); 

bool_point bp[];

bp0 := (true, origin);

dotlabel_if.top(0, bp0) with_text_color blue with_dot_color red;
label_if.bot(1, bp0) with_text_color green;


bp1 := (false, (0, 2));

dotlabel_unless.top(0, bp1) with_text_color purple with_dot_color yellow;
label_unless.bot(1, bp1) with_text_color orange;

endfig;

end;





%% *** (3) `label' and `dotlabel' for `bool_points' with a 
%%         `string' argument for the text and 
%%         optional `with_text_color' and `with_dot_color' 
%%         arguments.
%%         LDF 2005.01.31.

beginfig(1); 

bool_point bp;

bp := (true, origin);

dotlabel.top("bp", bp) with_text_color blue with_dot_color red;
label.bot("bp", bp) with_text_color green;

endfig;

end;


%% *** (3) `label' and `dotlabel' for `paths' with 
%%         a `numerical_expression' argument for the text and 
%%         optional `with_text_color' and `with_dot_color' 
%%         arguments.
%%         LDF 2005.01.31.

beginfig(1); 

circle c;

c := unit_circle scaled 2 rotated 90;
draw c;

dotlabel.top(10, c) with_text_color red with_dot_color green;
label.bot("p", 0, c) with_text_color blue;

endfig;

end;



%% *** (3) `label' and `dotlabel' for `points' with 
%%         a `numerical_expression' argument for the text and 
%%         optional `with_text_color' and `with_dot_color' 
%%         arguments.
%%         LDF 2005.01.31.

beginfig(1); 


label.lft(-1.2, origin) with_text_color blue;
dotlabel.rt(1, origin) with_text_color red with_dot_color green;

endfig;

end;



%% *** (3) It's now possible to generate a `path' from a `nurb'.  
%%         Now generating a NURB.
%% 	   I'm not sure it works right, though.  
%% 	   I don't understand why changing the weights has the 
%% 	   effect it does. 
%%         LDF 2005.01.28.

beginfig(1); 

nurb n;
path a;

n += origin;  %% 0
a += origin;

n += (1, 1);  %% 1
a += (1, 1);

n += (2, 1);  %% 2
a += (2, 1);

n += (3, 0);  %% 3
a += (3, 0);

n += (4, 1);  %% 4
a += (4, 1);

n += (5, .751);  %% 5
a += (5, .75);

n += (4.5, .25);  %% 6
a += (4.5, .25);


draw a;

dotlabel.top(0, a);

n += knot 0;  
n += knot 0;  
n += knot 0;  
n += knot 0;  
n += knot .25;  
n += knot .5;  
n += knot .75;  
n += knot 1;  
n += knot 1;  
n += knot 1;  
n += knot 1;  

n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  

path q;

q := generate n with_power 3 with_time_parameter .01;

draw q with_color red;

%dotlabel.bot(0, q); 

endfig; 

beginfig(2); 

nurb n;
path a;

n += origin;  %% 0
a += origin;

n += (1, 1);  %% 1
a += (1, 1);

n += (2, 1);  %% 2
a += (2, 1);

n += (3, 0);  %% 3
a += (3, 0);

n += (4, 1);  %% 4
a += (4, 1);

n += (5, .751);  %% 5
a += (5, .75);

n += (4.5, .25);  %% 6
a += (4.5, .25);


draw a;

dotlabel.top(0, a);

n += knot 0;  
n += knot 0;  
n += knot 0;  
n += knot 0;  
n += knot .25;  
n += knot .5;  
n += knot .75;  
n += knot 1;  
n += knot 1;  
n += knot 1;  
n += knot 1;  

n += weight 2;  
n += weight 2;  
n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  
n += weight 1;  

path q;

q := generate n with_power 3 with_time_parameter .01;

draw q with_color red;

%dotlabel.bot(0, q); 

endfig; 
end;





%% *** (3) Appending `knots' and `weights' to `nurbs'.  
%%         LDF 2005.01.27.

beginfig(1);

point p;
p := (1, 2, 3);

nurb n;

n += p;

n += knot 1.5;  

n += weight 31.5;  

message "n:";
show n;

endfig; 
end;



%% *** (3) `let'.  LDF 2005.01.26.

beginfig(1);
message "`$' before declaration:";
show $;

numeric $;
$ := 3;
message "`$' after declaration and assignment:";
show $;

message "`a' before `let' and declaration:";
show a;

let $ := point;
$ a;

message "`a' after `let' and before assignment:";
show a;

a := (0, 1, 2);
message "`a' after assignment:";
show a;


endfig; 
end;

%% *** (3) `is_quadrilateral'.  LDF 2005.01.25.

beginfig(1); 
rectangle r[];
r0 := unit_rectangle scaled 2;
draw r0;
dotlabel.top(0, r0);

r1 := r0 shifted 3;

shear r1 (2, 2, 2, 2, 2, 2);
draw r1 with_color blue;
dotlabel.top(0, r1);

message "is_planar r1:";
show is_planar r1;

message "is_quadrilateral r0:";
show is_quadrilateral r0;

message "is_quadrilateral r1:";
show is_quadrilateral r1;


r2 += origin;
r2 += (1, 0);
r2 += (0, 0, 1);
r2 += (1, 1, 1);

message "is_quadrilateral r2:";
show is_quadrilateral r2;


endfig with_projection parallel_x_z; 
end;



%% *** (3) `triangle_vectors'.
%%         LDF 2005.01.25.

beginfig(1);

%% **** (4) Declaration.

triangle_vector tpv;  


%% **** (4) Type predicate.

if is_triangle_vector tpv:                    
   message "`tpv' is a `triangle_vector'.";
else:
   message "`tpv' is not a `triangle_vector'.";
fi

if is_triangle_vector a:
   message "`a' is a `triangle_vector'.";
else:
   message "`a' is not a `triangle_vector'.";
fi

%% **** (4) Addition with assignment.

   triangle t;
   set t with_points (origin, (1, 0), (0, 1));

%% TO DO:  Applying a transformation to a `triangle' does not yet 
%%         cause the values for `a', `b', `c', `alpha', `beta', 
%%         and `gamma' to be recalculated!  LDF 2005.01.25.

   tpv += t;
   tpv += t rotated (15, 30, 60);
   tpv += t scaled (1, 2, 3);
   tpv += t sheared (1, 2, 3);;
   tpv += t scaled (4, 5, 6) shifted (7, 8, 9);
   tpv += t scaled (4, 5, 6) sheared (7, 8, 9);

   message "`tpv' before the loop:";
   show tpv;

%% **** (4) Assignment from a `triangle_vector_expression'.

triangle_vector btpv;

btpv := tpv;

message "`btpv':";
show btpv;

message "`size tpv':";
show size tpv;




%% **** (4) pop_back.

for i = 1 upto size tpv / 2:
message "`i' == ";
show i;
pop_back tpv;
message "`size tpv' after pop_back:";
show size tpv;
endfor;

message "`tpv' after the loop:";
show tpv;

message "`tpv[1]':";
show tpv1;

message "`last tpv':";
show last tpv;

clear tpv;
message "`tpv' after clearing:";
show tpv;

%triangle_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;


%% *** (3) Started working on surface hiding.  
%%         Added |unsigned short shape_type| to |class Shape|.
%%         It will be necessary to store information about
%%         the type of |Shapes| in the |Shape| objects themselves,
%%         i.e.,  |Points|, |Paths|, |Triangles|, etc.
%%         LDF 2005.01.24.

beginfig(1);
point p;
p := (1, 2, 3);
show p;
endfig; 
end;


%% *** (3) `is_triangular <path_like_expression>'.
%%         LDF 2005.01.24.

beginfig(1); 
path p;
message "is_triangular p:";
show is_triangular p;

p += origin;

message "is_triangular p after appending origin:";
show is_triangular p;


p += (1, 0);
p += (0, 1);

message "p after appending two more points:";
show p;

message "is_triangular p after appending two more points:";
show is_triangular p;

endfig with_projection parallel_x_y; 
end;


%% *** (3) Setting `triangles' using three points, 
%%         `is_triangle', and `is_triangular'.
%%         LDF 2005.01.24.

beginfig(1); 
point A;
point B;
point C;

A := origin;
B := (3, 5, 12);
C := (0, 4, 1);

triangle t[];

set t0 with_points (A, B, C);

message "t0:";
show t0; 

message "is_triangle t0:";
show is_triangle t0;

message "is_triangular t0:";
show is_triangular t0;


set t1 with_points (origin, (1, 0), (2, 0));

message "t1:";
show t1; 

message "is_triangle t1:";
show is_triangle t1;

message "is_triangular t1:";
show is_triangular t1;

draw t0;

dotlabel.ulft("$A$", A);
dotlabel.rt("$B$", B);
dotlabel.top("$C$",C);

label.rt("$a$", mediate(B, C));
label.ulft("$b$", mediate(A, C));
label.bot("$c$", mediate(A, B));

endfig with_projection parallel_x_y; 
end;


%% *** (3) `forsuffixes' now works. 
%%         LDF 2005.01.20.

numeric m[];
numeric n[];

beginfig(1); 
forsuffixes a = 3, 4, 5, 6:
m.a := a * 3;
message "(Outer loop):  `a' == ";
show a;
message "`m.a' == ";
show m.a;
   forsuffixes b = 7, 8, 9:
      n.b := b * 4;
      message "   (Inner loop):  `b' == ";
      show b;
      message "   `n.b' == ";
      show n.b;
   endfor;
endfor;

message "After the loop.";
endfig;
end;







%% *** (3) `focus_vectors'.
%%         LDF 2005.01.18.

beginfig(1);

%% **** (4) Declaration.

focus_vector fv;  

%% **** (4) Type predicate.

if is_focus_vector fv:                    
   message "`fv' is a `focus_vector'.";
else:
   message "`fv' is not a `focus_vector'.";
fi

if is_focus_vector a:
   message "`a' is a `focus_vector'.";
else:
   message "`a' is not a `focus_vector'.";
fi;


%% **** (4) Addition with assignment.

fv += with_position (0, 10, -10) with_direction (0, 10, 10) 
      with_distance 20;

fv += with_position (0, 20, -20) with_direction (0, 20, 20) 
      with_distance 20;

fv += with_position (0, 30, -30) with_direction (0, 30, 30) 
      with_distance 20;


message "fv after plus-assigns:";
show fv;

%% **** (4) Assignment from a `focus_vector_expression'.

focus_vector bfv;

bfv := fv;

message "`bfv':";
show bfv;

%% **** (4) Size.

message "`size fv':";
show size fv;


%% **** (4) Accessing an array element.

message "`fv[1]':";
show fv1;

%% **** (4) Last.

message "`last fv':";
show last fv;

%% **** (4) pop_back.


pop_back fv;
pop_back fv;


message "`fv' after popping twice:";
show fv;


clear fv;
message "`fv' after clearing:";
show fv;

%focus_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;





%% *** (3) `picture_vectors'.  LDF 2005.01.17. 

beginfig(1); 
picture_vector pv;
message "pv before incrementing:";
show pv;

%% **** (4) Incrementing.  Drawing on a `picture' causes memory to 
%%          be allocated for a `Picture' if it hasn't been already.  
%%          However, this doesn't cause the counter of `pv' to be 
%%          incremented, so the user must do this explicitly.
%%          LDF 2005.01.17.

pv++;
pv++;

message "pv after incrementing:";
show pv;

%% **** (4) Drawing on an element of the `picture' array referenced 
%% by the `picture_vector' variable.  LDF 2005.01.17.

draw origin .. (1, 1) on_picture pv[0];

message "pv after draw command:";
show pv;

%% **** (4) Size.

message "size pv:";
show size pv;

%% **** (4) last.

message "last pv:";
show last pv;

%% **** (4) pop_back.

pop_back pv;

message "size pv after popping:";
show size pv;

message "pv after popping:";
show pv;

%% **** (4) Clearing.

clear pv;

message "pv after clearing:";
show pv;

endfig; 

end;

%% *** (3) `cuboid_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

cuboid_vector epv;  


%% **** (4) Type predicate.

if is_cuboid_vector epv:                    
   message "`epv' is a `cuboid_vector'.";
else:
   message "`epv' is not a `cuboid_vector'.";
fi

if is_cuboid_vector a:
   message "`a' is a `cuboid_vector'.";
else:
   message "`a' is not a `cuboid_vector'.";
fi


%% **** (4) Addition with assignment.

   epv += unit_cuboid;
   epv += unit_cuboid rotated (15, 30, 60);
   epv += unit_cuboid scaled (1, 2, 3);
   epv += unit_cuboid sheared (1, 2, 3);
   epv += unit_cuboid scaled (4, 5, 6) shifted (7, 8, 9);
   epv += unit_cuboid scaled (4, 5, 6) sheared (7, 8, 9);

   message "`epv' before the loop:";
   show epv;



%% **** (4) Assignment from a `cuboid_vector_expression'.

cuboid_vector bepv;

bepv := epv;

message "`bepv':";
show bepv;



message "`size epv':";
show size epv;




%% **** (4) pop_back.

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "`epv' after the loop:";
show epv;


message "`epv[1]':";
show epv1;

message "`last epv':";
show last epv;

clear epv;
message "`epv' after clearing:";
show epv;

%cuboid_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;








%% *** (3) `reg_polygon_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

reg_polygon_vector epv;  


%% **** (4) Type predicate.

if is_reg_polygon_vector epv:                    
   message "`epv' is a `reg_polygon_vector'.";
else:
   message "`epv' is not a `reg_polygon_vector'.";
fi

if is_reg_polygon_vector a:
   message "`a' is a `reg_polygon_vector'.";
else:
   message "`a' is not a `reg_polygon_vector'.";
fi


%% **** (4) Addition with assignment.

   epv += unit_triangle;
   epv += unit_triangle rotated (15, 30, 60);
   epv += unit_triangle scaled (1, 2, 3);
   epv += unit_pentagon;
   epv += unit_pentagon scaled (4, 5, 6) shifted (7, 8, 9);
   epv += unit_pentagon scaled (4, 5, 6) sheared (7, 8, 9);

   message "`epv' before the loop:";
   show epv;



%% **** (4) Assignment from a `reg_polygon_vector_expression'.

reg_polygon_vector bepv;

bepv := epv;

message "`bepv':";
show bepv;



message "`size epv':";
show size epv;




%% **** (4) pop_back.

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "`epv' after the loop:";
show epv;


message "`epv[1]':";
show epv1;

message "`last epv':";
show last epv;

clear epv;
message "`epv' after clearing:";
show epv;

%reg_polygon_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;

%% *** (3) `rectangle_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

rectangle_vector epv;  


%% **** (4) Type predicate.

if is_rectangle_vector epv:                    
   message "`epv' is a `rectangle_vector'.";
else:
   message "`epv' is not a `rectangle_vector'.";
fi

if is_rectangle_vector a:
   message "`a' is a `rectangle_vector'.";
else:
   message "`a' is not a `rectangle_vector'.";
fi


%% **** (4) Addition with assignment.

   epv += unit_rectangle;
   epv += unit_rectangle rotated (15, 30, 60);
   epv += unit_rectangle scaled (1, 2, 3);
   epv += unit_rectangle sheared (1, 2, 3);;
   epv += unit_rectangle scaled (4, 5, 6) shifted (7, 8, 9);
   epv += unit_rectangle scaled (4, 5, 6) sheared (7, 8, 9);


   message "`epv' before the loop:";
   show epv;



%% **** (4) Assignment from a `rectangle_vector_expression'.

rectangle_vector bepv;

bepv := epv;

message "`bepv':";
show bepv;



message "`size epv':";
show size epv;




%% **** (4) pop_back.

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "`epv' after the loop:";
show epv;


message "`epv[1]':";
show epv1;

message "`last epv':";
show last epv;

clear epv;
message "`epv' after clearing:";
show epv;

%rectangle_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;


%% *** (3) `circle_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

circle_vector epv;  


%% **** (4) Type predicate.

if is_circle_vector epv:                    
   message "`epv' is a `circle_vector'.";
else:
   message "`epv' is not a `circle_vector'.";
fi

if is_circle_vector a:
   message "`a' is a `circle_vector'.";
else:
   message "`a' is not a `circle_vector'.";
fi


%% **** (4) Addition with assignment.

   epv += unit_circle;
   epv += unit_circle rotated (15, 30, 60);
   epv += unit_circle scaled (1, 2, 3);
   epv += unit_circle sheared (1, 2, 3);;
   epv += unit_circle scaled (4, 5, 6) shifted (7, 8, 9);
   epv += unit_circle scaled (4, 5, 6) sheared (7, 8, 9);


   message "`epv' before the loop:";
   show epv;



%% **** (4) Assignment from a `circle_vector_expression'.

circle_vector bepv;

bepv := epv;

message "`bepv':";
show bepv;



message "`size epv':";
show size epv;




%% **** (4) pop_back.

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "`epv' after the loop:";
show epv;


message "`epv[1]':";
show epv1;

message "`last epv':";
show last epv;

clear epv;
message "`epv' after clearing:";
show epv;

%circle_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;


%% *** (3) `ellipse_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

ellipse_vector epv;  


%% **** (4) Type predicate.

if is_ellipse_vector epv:                    
   message "`epv' is a `ellipse_vector'.";
else:
   message "`epv' is not a `ellipse_vector'.";
fi

if is_ellipse_vector a:
   message "`a' is a `ellipse_vector'.";
else:
   message "`a' is not a `ellipse_vector'.";
fi


%% **** (4) Addition with assignment.

   epv += unit_ellipse;
   epv += unit_ellipse rotated (15, 30, 60);
   epv += unit_ellipse scaled (1, 2, 3);
   epv += unit_ellipse sheared (1, 2, 3);;
   epv += unit_ellipse scaled (4, 5, 6) shifted (7, 8, 9);
   epv += unit_ellipse scaled (4, 5, 6) sheared (7, 8, 9);


   message "`epv' before the loop:";
   show epv;



%% **** (4) Assignment from a `ellipse_vector_expression'.

ellipse_vector bepv;

bepv := epv;

message "`bepv':";
show bepv;



message "`size epv':";
show size epv;




%% **** (4) pop_back.

for i = 1 upto size epv / 2:
message "`i' == ";
show i;
pop_back epv;
message "`size epv' after pop_back:";
show size epv;
endfor;

message "`epv' after the loop:";
show epv;


message "`epv[1]':";
show epv1;


message "`last epv':";
show last epv;

clear epv;
message "`epv' after clearing:";
show epv;

%ellipse_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;


%% *** (3) `path_vectors'.
%%         LDF 2005.01.14.

beginfig(1);

%% **** (4) Declaration.

path_vector tpv;  


%% **** (4) Type predicate.

if is_path_vector tpv:                    
   message "`tpv' is a `path_vector'.";
else:
   message "`tpv' is not a `path_vector'.";
fi

if is_path_vector a:
   message "`a' is a `path_vector'.";
else:
   message "`a' is not a `path_vector'.";
fi


%% **** (4) Addition with assignment.

   tpv += origin .. (1, 1, 1);
   tpv += origin .. (1, 1, 1) rotated (15, 30, 60);
   tpv += origin .. (1, 1, 1) scaled (1, 2, 3);
   tpv += origin .. (1, 1, 1) sheared (1, 2, 3);;
   tpv += origin .. (1, 1, 1) scaled (4, 5, 6) shifted (7, 8, 9);
   tpv += origin .. (1, 1, 1) scaled (4, 5, 6) sheared (7, 8, 9);


   message "`tpv' before the loop:";
   show tpv;

%% **** (4) Assignment from a `path_vector_expression'.

path_vector btpv;

btpv := tpv;

message "`btpv':";
show btpv;

message "`size tpv':";
show size tpv;

%% **** (4) pop_back.

for i = 1 upto size tpv / 2:
message "`i' == ";
show i;
pop_back tpv;
message "`size tpv' after pop_back:";
show size tpv;
endfor;

message "`tpv' after the loop:";
show tpv;

message "`tpv[1]':";
show tpv1;

message "`last tpv':";
show last tpv;

clear tpv;
message "`tpv' after clearing:";
show tpv;

%path_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;





%% *** (3) `transform_vectors'.
%%         LDF 2005.01.13.

beginfig(1);

%% **** (4) Declaration.

transform_vector tpv;  


%% **** (4) Type predicate.

if is_transform_vector tpv:                    
   message "`tpv' is a `transform_vector'.";
else:
   message "`tpv' is not a `transform_vector'.";
fi

if is_transform_vector a:
   message "`a' is a `transform_vector'.";
else:
   message "`a' is not a `transform_vector'.";
fi


%% **** (4) Addition with assignment.

   tpv += identity;
   tpv += identity rotated (15, 30, 60);
   tpv += identity scaled (1, 2, 3);
   tpv += identity sheared (1, 2, 3);;
   tpv += identity scaled (4, 5, 6) shifted (7, 8, 9);
   tpv += identity scaled (4, 5, 6) sheared (7, 8, 9);


   message "`tpv' before the loop:";
   show tpv;

%% **** (4) Assignment from a `transform_vector_expression'.

transform_vector btpv;

btpv := tpv;

message "`btpv':";
show btpv;

message "`size tpv':";
show size tpv;

%% **** (4) pop_back.

for i = 1 upto size tpv / 2:
message "`i' == ";
show i;
pop_back tpv;
message "`size tpv' after pop_back:";
show size tpv;
endfor;

message "`tpv' after the loop:";
show tpv;

message "`tpv[1]':";
show tpv1;

message "`last tpv':";
show last tpv;

clear tpv;
message "`tpv' after clearing:";
show tpv;

%transform_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;



%% *** (3) `dash_pattern_vectors'.
%%         LDF 2005.01.13.

beginfig(1);

%% **** (4) Declaration.

dash_pattern_vector dpv;  


%% **** (4) Type predicate.

if is_dash_pattern_vector dpv:                    
   message "`dpv' is a `dash_pattern_vector'.";
else:
   message "`dpv' is not a `dash_pattern_vector'.";
fi

if is_dash_pattern_vector a:
   message "`a' is a `dash_pattern_vector'.";
else:
   message "`a' is not a `dash_pattern_vector'.";
fi


%% **** (4) Addition with assignment.

   dpv += evenly;
   dpv += withdots;
   dpv += evenly scaled (1, 2, 3);
   dpv += withdots scaled (1, 2, 3);;
   dpv += evenly scaled (4, 5, 6) shifted (7, 8, 9);
   dpv += withdots scaled (4, 5, 6) shifted (7, 8, 9);

   message "`dpv' before the loop:";
   show dpv;



%% **** (4) Assignment from a `dash_pattern_vector_expression'.

dash_pattern_vector bdpv;

bdpv := dpv;

message "`bdpv':";
show bdpv;

message "`size dpv':";
show size dpv;

%% **** (4) pop_back.

for i = 1 upto size dpv / 2:
message "`i' == ";
show i;
pop_back dpv;
message "`size dpv' after pop_back:";
show size dpv;
endfor;

message "`dpv' after the loop:";
show dpv;

message "`dpv[1]':";
show dpv1;

message "`last dpv':";
show last dpv;

clear dpv;
message "`dpv' after clearing:";
show dpv;

%dash_pattern_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;

endfig;
end;

%% *** (3) `pen_vectors'.
%%         LDF 2005.01.13.

beginfig(1);

%% **** (4) Declaration.

pen_vector sv;  


%% **** (4) Type predicate.

if is_pen_vector sv:                    
   message "`sv' is a `pen_vector'.";
else:
   message "`sv' is not a `pen_vector'.";
fi

if is_pen_vector a:
   message "`a' is a `pen_vector'.";
else:
   message "`a' is not a `pen_vector'.";
fi


%% **** (4) Addition with assignment.

   sv += pencircle;
   sv += pensquare;
   sv += penspeck;
   sv += pencircle scaled (1, 2, 3);
   sv += pensquare shifted (1, 2, 3);
   sv += pencircle scaled (2, 3, 4) rotated (1, 2, 3);

   message "`sv' before the loop:";
   show sv;


%% **** (4) Assignment from a `pen_vector_expression'.

pen_vector bsv;

bsv := sv;

message "`bsv':";
show bsv;

message "`size sv':";
show size sv;

%% **** (4) pop_back.

for i = 1 upto size sv / 2:
message "`i' == ";
show i;
pop_back sv;
message "`size sv' after pop_back:";
show size sv;
endfor;

message "`sv' after the loop:";
show sv;

message "`sv[1]':";
show sv1;

message "`last sv':";
show last sv;

clear sv;
message "`sv' after clearing:";
show sv;

%pen_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;


endfig;

end;

%% *** (3) Globe font.  
%% Improved version with less repetition and more drastic 
%% rotations.  LDF 2005.01.11.

circle c[];

division_value := 32;
one_quarter_division_value := 1/4division_value;
three_quarters_division_value := 3/4division_value;

set c0 with_point_count division_value;
scale c0 (8cm, 0, 8cm);
rotate c0 by 90;

point p;
path q[];

q[division_value] += get_point 0 c0;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

pickup thick_pen;


step_value := 360 / division_value;
j := 1;
for i = 0 step step_value until 360 - step_value:
   rotate c0 (0, step_value);
   if (is_even j):
      draw c0;
   fi;
   for k = 2 step 2 until one_quarter_division_value - 2:
      q[k] += get_point (k) c0;
      q[three_quarters_division_value + k] 
         += get_point (three_quarters_division_value + k) c0;
   endfor; 
   q[division_value] += get_point 0 c0;
   j += 1;
endfor;

q[division_value] += cycle;
q[division_value] += ..;
draw q[division_value];

for i = 2 step 2 until one_quarter_division_value - 2:
      q[i] += ..;
      q[i] += cycle;
      q[three_quarters_division_value + i] += ..;
      q[three_quarters_division_value + i] += cycle;
      draw q[i];
      draw q[three_quarters_division_value + i];
endfor;

picture p;
picture q;

q := p := current_picture;

n := 0;


for i = 0 step 1 until 4:
   p := q;
   if i > 0:
      rotate p (45i, 0);
   fi;
   for j = 0 step 1 until 5:
      if j > 0:
         rotate p (0, 30);
      fi
      beginfig(n); 
         output p;
      endfig; 
      n += 1;
   endfor;
endfor;
end;

%% *** (3) `string_vectors'.
%%         LDF 2005.01.07.

beginfig(1);

%% **** (4) Declaration.

string_vector sv;  

%% **** (4) Type predicate.

if is_string_vector sv:                    
   message "`sv' is a `string_vector'.";
else:
   message "`sv' is not a `string_vector'.";
fi

if is_string_vector a:
   message "`a' is a `string_vector'.";
else:
   message "`a' is not a `string_vector'.";
fi

%% **** (4) Addition with assignment.

   sv += "aaa";
   sv += "bbb";
   sv += "ccc";
   sv += "ddd";
   sv += "eee";
   sv += "fff";

   message "`sv' before the loop:";
   show sv;


%% **** (4) Assignment from a `string_vector_expression'.

string_vector bsv;

bsv := sv;

message "`bsv':";
show bsv;

message "`size sv':";
show size sv;

%% **** (4) pop_back.

for i = 1 upto size sv / 2:
message "`i' == ";
show i;
pop_back sv;
message "`size sv' after pop_back:";
show size sv;
endfor;

message "`sv' after the loop:";
show sv;

message "`sv[1]':";
show sv1;

message "`last sv':";
show last sv;

clear sv;
message "`sv' after clearing:";
show sv;

%string_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;


endfig;

end;

%% *** (3) `last macro_vector_variable' with arguments.
%%         LDF 2005.01.10.

beginfig(1); 
macro_vector mv;

def mv (a) {point p} += 
message "This is mv0.";
message "`a' in mv0:";
show a;
message "`p' in mv0:";
show p;
enddef;

def mv (a) {point p} += 
message "This is mv1.";
message "`a' in mv1:";
show a;
message "`p' in mv1:";
show p;
enddef;

def mv (a) {point p} += 
message "This is mv2.";
message "`a' in mv2:";
show a;
message "`p' in mv2:";
show p;
enddef;

for i = 2 downto 0:
last mv (i) {(i, i, i)};
pop mv;
endfor;

message "`mv' after loop:";
show mv;

endfig;;
end;




%% *** (3) Sphere.  Put on the GNU 3DLDF home page.
%%         LDF 2005.01.10.

beginfig(1);
circle c[];

division_value := 64;
one_quarter_division_value := 1/4division_value;
three_quarters_division_value := 3/4division_value;


set c0 with_point_count division_value;
scale c0 (8, 0, 8);
rotate c0 by 90;

point p;
path q[];

q[division_value] += get_point 0 c0;

pen thick_pen;

thick_pen := pencircle scaled (2.5, 2.5, 2.5);

pickup thick_pen;


step_value := 360 / division_value;
j := 1;
for i = 0 step step_value until 360 - step_value:
   rotate c0 (0, step_value);
   if (is_even j):
      draw c0;
   fi;
   for k = 2 step 2 until one_quarter_division_value - 2:
      q[k] += get_point (k) c0;
      q[three_quarters_division_value + k] 
         += get_point (three_quarters_division_value + k) c0;
   endfor; 
   q[division_value] += get_point 0 c0;
   j += 1;
endfor;

q[division_value] += cycle;
q[division_value] += ..;
draw q[division_value];

for i = 2 step 2 until one_quarter_division_value - 2:
      q[i] += ..;
      q[i] += cycle;
      q[three_quarters_division_value + i] += ..;
      q[three_quarters_division_value + i] += cycle;
      draw q[i];
      draw q[three_quarters_division_value + i];
endfor;

rotate current_picture (-45, -15);

endfig;
end;


%% *** (3) `last macro_vector_variable'.
%%         LDF 2005.01.08.

beginfig(1); 
macro_vector mv;

def mv += 
message "This is mv0.";
enddef;

def mv += 
message "This is mv1.";
enddef;

def mv += 
message "This is mv2.";
enddef;

for i = 2 downto 0:
last mv;
pop mv;
endfor;

message "`mv' after loop:";
show mv;

endfig;;
end;





%% *** (3) `last bool_point_vector_expression'.
%%         LDF 2005.01.08.

beginfig(1); 
bool_point_vector bpv;

bpv += (true, origin);
bpv += (false, (1, 1, 1));
bpv += (true, (2, 2, 2));

message "last bpv:";
show last bpv;

endfig;;
end;


%% *** (3) `last point_vector_expression'.
%%         LDF 2005.01.08.

beginfig(1); 
point_vector pv;

pv += origin;
pv += (1, 1, 1);
pv += (2, 2, 2);

message "last pv:";
show last pv;

endfig;;
end;

%% *** (3) `last color_vector_expression'.
%%         LDF 2005.01.07.

beginfig(1); 
color_vector cv;

cv += blue;
cv += red;
cv += green;

message "last cv:";
show last cv;

endfig;;
end;



%% *** (3) `boolean_vectors'.
%%         LDF 2005.01.07.

beginfig(1);

%% **** (4) Declaration.

boolean_vector bv;  

%% **** (4) Type predicate.

if is_boolean_vector bv:                    
   message "`bv' is a `boolean_vector'.";
else:
   message "`bv' is not a `boolean_vector'.";
fi

if is_boolean_vector a:
   message "`a' is a `boolean_vector'.";
else:
   message "`a' is not a `boolean_vector'.";
fi


%% **** (4) Addition with assignment.

   bv += true;
   bv += false;
   bv += true;
   bv += false;
   bv += true;
   bv += false;



   message "`bv' before the loop:";
   show bv;


%% **** (4) Assignment from a `boolean_vector_expression'.

boolean_vector bbv;

bbv := bv;

message "`bbv':";
show bbv;

message "`size bv':";
show size bv;

%% **** (4) pop_back.

for i = 1 upto size bv / 2:
message "`i' == ";
show i;
pop_back bv;
message "`size bv' after pop_back:";
show size bv;
endfor;

message "`bv' after the loop:";
show bv;

message "`bv[1]':";
show bv1;

message "`last bv':";
show last bv;

clear bv;
message "`bv' after clearing:";
show bv;

%boolean_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;


endfig;

end;



%% *** (3) `numeric_vectors'.
%%         LDF 2005.01.07.

beginfig(1);

%% **** (4) Declaration.

numeric_vector nv;  

%% **** (4) Type predicate.

if is_numeric_vector nv:                    
   message "`nv' is a `numeric_vector'.";
else:
   message "`nv' is not a `numeric_vector'.";
fi

if is_numeric_vector a:
   message "`a' is a `numeric_vector'.";
else:
   message "`a' is not a `numeric_vector'.";
fi


%% **** (4) Addition with assignment.

for i = 0 upto 5:
   nv += i;
endfor;

show nv;

message "`nv' before the loop:";
show nv;

%% **** (4) Assignment from a `numeric_vector_expression'.

numeric_vector nnv;

nnv := nv;

message "`nnv':";
show nnv;

%% **** (4) pop_back.

for i = 1 upto size nv / 2:
message "`i' == ";
show i;
pop_back nv;
message "`size nv' after pop_back:";
show size nv;
endfor;

message "`nv' after the loop:";
show nv;

message "`nv[1]':";
show nv1;

message "`last nv':";
show last nv;

clear nv;
message "`nv' after clearing:";
show nv;

%numeric_vector q;   %% Causes error, but 3dldf can recover.
% message "last q:";  
% show last q;


endfig;

end;





%% *** (3) Assignment to a `color_vector_variable'
%%         from a `color_vector_expression' 
%%         LDF 2005.01.07.

beginfig(1);
color_vector a, b;

a += blue;
a += red;

b := a;

message "a:";
show a;

message "b:";
show b;

endfig; 

end;

%% *** (3) Popping `ellipses' off of `ellipse_vectors'.
%%         LDF 2005.01.06.

beginfig(1);

ellipse_vector ev;

ellipse e;

set e with_point_count 4;

for i = 1 upto 6:
ev += e scaled (i, i, i);
endfor;

message "`ev' before the loop:";
show ev;

for i = 1 upto size ev / 2:
message "i == ";
show i;
pop ev;
message "`size ev' after pop:";
show size ev;
endfor;

message "`ev' after the loop:";
show ev;

endfig;

end;

%% *** (3) Popping `paths' off of `path_vectors'.
%%         LDF 2005.01.06.

beginfig(1);

path_vector pv;

pv += origin .. (1, 1, 1);
pv += (2, 2, 2) .. (3, 3, 3);
pv += (3, 3, 3) .. (4, 4, 4);
pv += (5, 5, 5) .. (6, 6, 6);
pv += (7, 7, 7) .. (8, 8, 8);
pv += (7, 7, 7) .. (8, 8, 8);

message "`pv' before the loop:";
show pv;

for i = 1 upto size pv / 2:
message "i == ";
show i;
pop pv;
message "`size pv' after pop:";
show size pv;
endfor;

message "`pv' after the loop:";
show pv;


endfig;

end;




%% *** (3) Popping `macros' off of a `macro_vector'.
%%         LDF 2005.01.06.

beginfig(1);

macro_vector m;

def m += 
message "This is m0.";
enddef;

def m += 
message "This is m1.";
enddef;

def m += 
message "This is m2.";
enddef;

def m += 
message "This is m3.";
enddef;

def m += 
message "This is m4.";
enddef;

def m += 
message "This is m5.";
enddef;

def m += 
message "This is m6.";
enddef;

message "`size m' before popping:";
show size m;

for i = 1 upto size m / 2:
message "i == ";
show i;
pop m;
message "`size m' after pop:";
show size m;
endfor;

for i = 0 upto size m - 1:
m[i];
endfor;

endfig;

end;



%% *** (3) It's now possible to specify dimensions for `numeric' 
%%         values!  Internally, 3DLDF converts these values to 
%%         centimeters, and the values it writes to the output files
%%         are always suffixed with "cm".
%%         LDF 2005.01.06.

beginfig(1);

message "pt (printer's point):";
show pt;

message "pc (pica):";
show pc;

message "in (inch):";
show in;

message "bp (big point):";
show bp;

message "cm (centimeter):";
show cm;

message "mm (millimeter):";
show mm;

message "dd (didot point):";
show dd;

message "cc (cicero):";
show cc;


message "72.27pt / in:";
show 72.27pt / in;

message "pc / pt:";
show pc / pt;

message "in:";
show in;

message "in / bp:";
show in / bp;

message "cm:";
show cm;

message "mm:";
show mm;

message "(1157dd) / (1238pt):";
show (1157dd) / (1238pt);

message "cc / dd:";
show cc / dd;

point p;

p := (1cm, 2in, 3cc);

message "p:";
show p;




endfig;

end;


%% *** (3) Debugged parser rules involving unary plus and minus.
%%         I'm sorry to say that they can no longer be used with
%%         `points'.  However, `points' can be multiplied by 
%%         integers.  See below for examples.
%%         LDF 2005.01.06.

beginfig(1);

a := -1;

message "a:";
show a;

b := 2 + 3;

message "b:";
show b;

c := -2 + 3;

message "c:";
show c;

d := +2;

message "d:";
show d;

e := 15 - 7;
message "e:";
show e;

point p, q, r, s;

p := (1, 2, 3);

%% q := -p; %% Invalid!

q := -1*p;  %% This works.

message "q:";
show q;

%r := +p;  %% Invalid!

r := 1p;  %% This works.

message "r:";
show r;

s := 2p;  %% This works, too.

message "s:";
show s;

endfig;

end;



%% *** (3) Popping `bool_points' off of a `bool_point_vector'.

beginfig(1);

bool_point_vector p;

p += (true, (1, 1, 1));
p += (false, (2, 2, 2));
p += (true, (3, 3, 3));
p += (false, (4, 4, 4));
p += (true, (5, 5, 5));
p += (false, (6, 6, 6));

message "p:";
show p;

message "size p:";
show size p;

for i = 1 upto size p / 2:
message "i == ";
show i;
pop p;
message "size of `p' after pop:";
show size p;
endfor;

message "p after loop:";
show p;

endfig;

end;



%% *** (3) Popping `points' off of a `point_vector'.

beginfig(1);

point_vector p;

p += (1, 1, 1);
p += (2, 2, 2);
p += (3, 3, 3);
p += (4, 4, 4);
p += (5, 5, 5);
p += (6, 6, 6);

message "p:";
show p;

message "size p:";
show size p;

for i = 1 upto size p / 2:
message "i == ";
show i;
pop p;
message "size of `p' after pop:";
show size p;
endfor;

message "p after loop:";
show p;

endfig;

end;



%% *** (3) Popping `colors' off of a `color_vector'.

beginfig(1);

color_vector c;
c += blue;
c += red;
c += green;
c += orange;
c += black;
c += white;

message "c:";
show c;

message "size c:";
show size c;

for i = 1 upto size c / 2:
message "i == ";
show i;
pop c;
message "size of `c' after pop:";
show size c;
endfor;

message "c after loop:";
show c;

endfig;

end;



%% *** (3) Examples of how to use `macro_vectors'.  LDF 2005.01.03.
%%         It's now possible to clear them;  see below.

beginfig(1); 

macro_vector m;

def m (a) +=
message "In `m0':  a:";
show a;
enddef;

string b;
b := "bbb";

m0 (b);

def m (c, d, e) {point p, path q, transform t} +=
message "In `m1':  c:";
show c;
message "In `m1':  d:";
show d;
message "In `m1':  e:";
show e;
message "In `m1':  p:";
show p;
message "In `m1':  q:";
show q;
message "In `m1':  t:";
show t;
enddef;


numeric f;
f := 1.45;

string g;
g := "ggg";

picture h;

m1 (f, g, h) {(1, 2, 3), origin .. (10, 10, 10), 
              identity scaled (1, 2, 3) shifted (4, 5, 6)};


message "`m' before clearing:";
show m;

clear m;

message "`m' after clearing:";
show m;

endfig;
end;



%% *** (3) Examples of using macros.  LDF 2005.01.03.

beginfig(1); 

macro a, b, d;  %% Some are declared, others are not.

%% Macro with no arguments.  
def a :=  
message "This is `a'.";
enddef;

a;

%% Redefining a macro.
def a := 
message "This is `a' after being redefined.";
enddef;

a;

%% A macro with no untyped arguments and a single typed argument.
def b {point c} := 
message "In `b':  `c' == ";
show c;
enddef;

b {(0, 1, 2)};

%% A macro with no typed arguments and a single untyped argument.
def d (e) :=
message "In`d':  `e' == ";
show e;
enddef;

string f;
f := "fff";

d (f);

%% A macro with one typed argument and one untyped argument.
def g (h) {path i} :=
message "In `g':  `h' == ";
show h;
message "In `g':  `i' == ";
show i;
enddef;

point j;

j := (0, 1, 2);

g (j) {origin -- (3, 3, 3)};


%% A nested macro definition.
def k :=
def l :=
message "This is `l' in `k'.";
enddef;
message "This is `k'.";
l;
enddef;

k;

%% A macro with two typed arguments and two untyped arguments.
def m (n, o) {path p, transform q} :=
message "In `m':  `n' == ";
show n;
message "In `m':  `o' == ";
show o;
message "In `m':  `p' == ";
show p;
message "In `m':  `q' == ";
show q;
enddef;

point r;
string s;

r := (0, 1, 2);
s := "sss";

m (r, s) {origin -- (3, 3, 3), identity scaled (1, 2, 3)};

endfig;
end;


%% *** (3) Debugged parser rules and functions for macros.
%%         LDF 2005.01.03.

beginfig(1); 

def m (a, b, c) {point p, ellipse q} :=  

message "m before n.";

def n (d) := 
message "d in n.";
show d;
pause;
enddef;

message "p in m before shift:";
show p;
pause;

shift p (1, 2, 3);

message "p in m after shift:";
show p;
pause;

a := 2;
message "a: (untyped:  numeric)";
show a;
pause;

b := "abc";
message "b: (untyped:  string)";
show b;
pause;

c := unit_circle scaled (2, 3, 4);
message "c: (untyped:  circle)";
show c;
pause;

message "q: (typed:  ellipse)";
show q;
pause;

n(b);

message "m after n.";

enddef;

numeric A;
string B;
circle C;

m (A, B, C) {(0, 1, 2), unit_ellipse};

message "m:";
show m;
pause;

endfig; 

end;


%m (B, C);  %% Error:  Argument mismatch.  Can recover.  LDF 2005.01.02.



%% *** (3) Working on the parser rules for `macros'.  
%%         It's now possible to use undeclared variables or declared macro 
%%         variables in macro definitions.  
%%         LDF 2004.12.30.


beginfig(1); 


def m :=  %% `m' is an undeclared variable (`variable UNDECLARED'):
          %% LDF 2004.12.30.
a:= 2;
show a;
string b;
b := "abc";
show b;
enddef;

m;

message "m:";
show m;

macro n[];

def n0 :=   %% `n0' is a member of an array of macros.
            %% LDF 2004.12.30.
a := 2;
show a;
string b;
b := "abc";
show b;
enddef;

n0;

message "n0:";
show n0;

endfig; 

end;


%% *** (3) BUG FIX:  Variables with multiple subscripts separated by `tags' work
%%                   now.  The rule `suffix: suffix tag' in `pvariabl.w' was 
%%                   not being included in the CWEB section `@<Define rules@>'.

beginfig(1); 

point a[][];

a0[1] := (1, 2, 3);

show a0[1];

point n[]a[];            %% This works now.
n[0]a[0] := (4, 5, 6);  
show n[0]a[0];          

n[0]a[0] := (1, 2, 3);

show n[0]a[0];

show n1a2;

endfig; 

end;



%% *** (3) A `defun' with a loop.  LDF 2004.12.23.

beginfig(1); 


defun a (c) =
for i = 0 upto c:
   message "`i':";
   show i;
endfor;
enddef;

numeric b;

b := 3;

a (b);


endfig; 

end;





%% *** (3) A `defun' with a conditional.  LDF 2004.12.23.

beginfig(1); 


defun a (c) =
bool d; %% `d' is local to the replacement text of `a'.
d := c;
if d:
message "d is true";
else:
message "d is false";
fi;
enddef;

bool b;

b := true;

a (b);

b := false;

a(b);

show d;

%a; %% ERROR:  Wrong number of arguments.  Can recover.

%a (); %% ERROR:  Wrong number of arguments.  Can recover.

%a (b, b); %% ERROR:  Wrong number of arguments.  Can recover.

endfig; 

end;





%% *** (3) `defuns'.  LDF 2004.12.22.

beginfig(1); 

defun a (b, c, d, e) =
b := "abc";
c := false;
d := unit_square;
e := (1, 2, 3);

defun f (g, h, i) = 
g := "ggg";
h := true;
i := unit_square scaled (4, 5, 6);

message "g:";
show g;

message "h";
show h;

message "i:";
show i;

enddef;

message "b:";
show b;

message "c:";
show c;

message "d:";
show d;

message "e:";
show e;

f (b, c, d);

enddef;


string A;
bool B;
rectangle C;
point D;


a (A, B, C, D);

defun j =
message "This is `j'.";
defun k = 
message "This is `k'.";
enddef;
k;
enddef;

j;

endfig; 
end;



%% *** (3) Setting `color' parts.  LDF 2004.12.20.

beginfig(1); 
color c;
c := white;
set red_part .1 c;
message "c:";
show c;

set green_part .2 c;
message "c:";
show c;

set blue_part .3 c;
message "c:";
show c;

endfig; 
end;


%% *** (3) Multiplying `points' by `numerics' with the `numeric' first, 
%%         with and without the `*' symbol.
%%         LDF 2004.12.20.


beginfig(1);
point p, q;
p := (.125, .05, .075);

q := 3 * p;

message "q:";
show q;

q :=  2p;

message "q:";
show q;


endfig; 
end;




%% *** (3) Multiplying and dividing `points' by `numerics' with assignment.


beginfig(1);
point p;

p := (1, 2, 3);

p *= 4;

message "p:";
show p;

p /= 3;

message "p:";
show p;



endfig; 
end;



%% *** (3) Multiplying `colors' by `numerics' with the `numeric' first. 


beginfig(1);
color c, d, e, f;
set c (.125, .05, .075);

d :=  2 * c;

message "d:";
show d;

endfig; 
end;


%% *** (3) Multiplying and dividing `colors' by `numerics' 
%%         with assignment.
%%         LDF 2004.12.18.

beginfig(1);
color c, d, e, f;
set c (.125, .05, .075);


c *=  2;

message "c:";
show c;


c /= 3;

message "c:";
show c;

c /= 0;

message "c:";
show c;

endfig; 
end;

%% *** (3) Adding and subtracting `colors' with assignment.
%%         LDF 2004.12.18.

beginfig(1);
color c, d, e, f;
set c (.25, .5, .75);
set d (.71, .82, .93);

d += c;

message "d:";
show d;

d -= c;

message "d:";
show d;


e += c;  %% `e' is unknown.  Error can be handled.

message "e:";
show e;

e -= c;  %% `e' is unknown.  Error can be handled.

message "e:";
show e;

endfig; 
end;


%% *** (3) Adding and subtracting `colors'.
%%         LDF 2004.12.17.

beginfig(1);
color c, d, e, f;
set c (.25, .5, .75);
set d (.1, .2, .3);

e := c + d;

message "e:";
show e;

f := c - d;

message "f:";
show f;

endfig; 
end;



%% *** (3) Multiplying `color' variables by `numerics' with
%%         no multiplication sign.
%%         LDF 2004.12.17.

beginfig(1);
color c, d;
set c (.25, .5, .75);
d := .5white;
message "d:";
show d; 
endfig; 
end;




%% *** (3) Multiplying `color' variables by `numerics' with
%%         no multiplication sign.
%%   dfn2004.12.17.

beginfig(1);
color c, d;
set c (.25, .5, .75);
d := .5white;
message "d:";
show d; 
endfig; 
end;

%% *** (3) Multiplying and dividing `colors' by `numerics'.
%%         LDF 2004.12.17.

beginfig(1); 

color c, d;
set c (.25, .5, .75);

message "c:";
show c; 

d := c * 2;

message "d:";
show d; 

d := c/3;

message "d:";
show d; 


n := 2;

d := c * n;

message "d:";
show d; 

d := c/0; %% Causes errors, but `3dldf' can handle them.

message "d:";
show d; 


endfig; 

end;




%% *** (3) Multiplying and dividing `colors' by `numerics'.
%%         LDF 2004.12.17.

beginfig(1); 

color c, d;
set c (.25, .5, .75);

message "c:";
show c; 

d := c * 2;

message "d:";
show d; 

d := c/3;

message "d:";
show d; 


n := 2;

d := c * n;

message "d:";
show d; 

d := c/0; %% Causes errors, but `3dldf' can handle them.

message "d:";
show d; 


endfig; 

end;

%% *** (3) Color parts.
%%         LDF 2004.12.17.

beginfig(1); 

color c;
set c (.25, .5, .75);

message "c:";
show c; 

message "red_part c:";
show red_part c;

message "green_part c:";
show green_part c;

message "blue_part c:";
show blue_part c;

endfig; 

end;





%% *** (3) It is now possible to use plain `color' arguments 
%%         in drawing and filling commands for `solids'.
%%         LDF 2004.12.16.

beginfig(1); 
cuboid c;
c := unit_cuboid rotated (15, 15, 15) shifted (1, 2, 3);

pen p;

p := pencircle scaled (2, 2);

filldraw c with_draw_color red with_fill_color blue with_pen p;
endfig; 

end;




%% *** (3) `rectangle_vector_secondary: rectangle_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `prcvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

rectangle e;

e := unit_rectangle;

label("$e$", get_center e);

rectangle q[];

q0 := e scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

draw q1;

p2 := get_center q1;

label.top("$q_1$", p2);


p3 := (p1 -- p0) intersection_point e;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;

%endfig with_focus f; 

picture r;
r := current_picture;
endfig with_projection parallel_x_z;

beginfig(2);
output r with_focus f;
endfig;


end;





%% *** (3) `cuboid_vector_secondary: cuboid_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `pcbvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

ellipse e;

set e with_point_count 32;

label("$e$", get_center e);

cuboid q[];

q0 := unit_cuboid shifted (2, 2);

draw q0;

rectangle r[];

r0 := get_rectangle 0 q0;
draw r0 with_color blue with_pen pencircle scaled (2, 2, 2);


scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

message "q0:";
show q0;

message "q1:";
show q1;

color_vector cv;
cv += red;

draw q1 with_color_vector cv with_pen pencircle scaled (2, 2, 2);

%p2 := get_center q1;

%label.top("$q_1$", p2);


% p3 := (p1 -- p0) intersection_point e;

% dotlabel.lft("$i$", p3);

% draw p1 -- p3 dashed evenly;

% drawarrow p3 -- p0 dashed with_dots;

% drawarrow p3 -- p2 dashed evenly;

endfig with_focus f; 
%endfig with_projection parallel_x_y;
end;

%% *** (3) Clearing `pictures'.
%%         LDF 2004.12.13.

beginfig(1);

draw origin .. (1, 1, 1);

output current_picture;

clear current_picture;

string s;
s := "pair p, q, r[];";
s := s & new_line & "p = (1cm, 2cm);" & newline 
     & "message " & ditto & "p:" & ditto & ";"
     & new_line & "show p;";

verbatim_metapost s;

fill unit_circle scaled (2, 0, 2);

endfig;  

end;

%% *** (3) `reg_polygon_vector_secondary: reg_polygon_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `prpvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

reg_polygon e;

e := unit_pentagon;

label("$e$", get_center e);

reg_polygon q[];

q0 := e scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

draw q1;

p2 := get_center q1;

label.top("$q_1$", p2);


p3 := (p1 -- p0) intersection_point e;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;

endfig with_focus f; 
end;

%% *** (3) `rectangle_vector_secondary: rectangle_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `prcvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

rectangle e;

e := unit_rectangle;

label("$e$", get_center e);

rectangle q[];

q0 := e scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

draw q1;

p2 := get_center q1;

label.top("$q_1$", p2);


p3 := (p1 -- p0) intersection_point e;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;

endfig with_focus f; 
end;








%% *** (3) `circle_vector_secondary: circle_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `pcrvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

circle e;

set e with_point_count 32;

label("$e$", get_center e);

circle q[];

q0 := e scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

draw q1;

p2 := get_center q1;

label.top("$q_1$", p2);


p3 := (p1 -- p0) intersection_point e;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;

endfig with_focus f; 
end;


%% *** (3) `ellipse_vector_secondary: ellipse_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `pelvexpr.w'.
%%         LDF 2004.12.14.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);

label.ulft("$p_0$", p0);

ellipse e;

set e with_point_count 32;

label("$e$", get_center e);

ellipse q[];

q0 := e scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale e (3, 3, 3);

draw e;

p1 := get_center q0;

label("$q_0$", p1);

q1 := q0 reflected_off e with_direction p0;

draw q1;

p2 := get_center q1;

label.top("$q_1$", p2);


p3 := (p1 -- p0) intersection_point e;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;

endfig with_focus f; 
end;

%% *** (3) `path_assignment: path_variable ASSIGN 
%%         path_vector_expression'.  LDF 2004.12.13.

beginfig(1); 

path p[];
p0 := origin .. (1, 1, 1);
p1 := (2, 2, 2) .. (3, 3, 3);
p2 := (4, 4, 4) .. (5, 5, 5);

path_vector pv;

pv += p0;
pv += p1;
pv += p2;

message "pv:";
show pv;

path q;

q := pv;

message "q:";
show q;

endfig;
end;

%% *** (3) `path_vector_secondary: path_secondary REFLECTED_OFF 
%%         path_like_expression WITH_DIRECTION point_expression' 
%%         in `pphvexpr.w'.
%%         LDF 2004.12.13.

beginfig(1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];
p0 := (-1, -1, 0);


label.ulft("$p_0$", p0);

circle c;

set c with_point_count 32;


label("$c$", get_center c);

path q[];

q0 := c scaled (2, 0, 4) rotated (15, 15, 15)  shifted (2, 3, 4);

draw q0;

scale c (3, 3, 3);

draw c;

p1 := get_point 0 q0;

dotlabel.top("$q_0$", p1);

path_vector pv;

pv := q0 reflected_off c with_direction p0;

p2 := get_point 0 pv0;

label.top("$q_1$", p2);
draw pv0;

p3 := (p1 -- p0) intersection_point c;

dotlabel.lft("$i$", p3);

draw p1 -- p3 dashed evenly;

drawarrow p3 -- p0 dashed with_dots;

drawarrow p3 -- p2 dashed evenly;


endfig with_focus f; 
end;

%% *** (3) `path_vectors'.  LDF 2004.12.13.

beginfig(1); 

path p[];
p0 := origin .. (1, 1, 1);
p1 := (2, 2, 2) .. (3, 3, 3);
p2 := (4, 4, 4) .. (5, 5, 5);

path_vector pv;

pv += p0;
pv += p1;
pv += p2;

message "pv:";
show pv;

endfig;
end;

%% *** (3) Added the parser rule
%%         `numeric_primary: SIZE color_vector_primary'
%%         in `pnumexpr.w'.

beginfig(1); 
color_vector cv;
cv += red;
cv += blue;
cv += green;

show size cv;

endfig;
end;


%% *** (3) Added the parser rule
%%         `numeric_secondary --> numeric_secondary numeric_variable'
%%         in `pnumexpr.w' for multiplication without `TIMES'.

beginfig(1); 
a := 2;

message "a2:";
show a2;

message "a 2:";
show a 2;

numeric n[];

message "n2:";
show n2;

point p[];

message "p2:";
show p2;

message "2a";
show 2a;

message "2 a:";
show 2 a;

message "2*a:";
show 2*a;

message "2 * a:";
show 2 * a;

message "a*2:";
show a*2;

message "a * 2:";
show a * 2;

endfig;
end;





%% *** (3) Reflecting a `point' off of a planar `path'.
%% `reflected_off' now returns a `point_vector' rather than a 
%% single `point'.  See below for an explanation of what's returned.

point_vector q;  %% BUG!  It doesn't work to put this after 
                 %% `beginfig'.  The problem seems to be in 
                 %% the `Pointer_Vector' destructor.
                 %% Will work on fixing this soon.
                 %% LDF 2004.12.09.



for i = 0 upto 8:
beginfig(i + 1); 

focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];

circle c;

set c with_point_count 32;

transform t;

t := identity scaled 2 rotated ((i * 7.5), (i * 15), (i * 45)) 
   shifted .25;

c *= t;

point center, n;

center := get_center c;
n := normal c;

n += center;

label("$c$", center);
label.lft("normal", n);

drawarrow center -- n;

draw c;

p0 := (1, 2, 0) rotated (0, 45);

dotlabel.top("$p_0$", p0);

p1 := -p0;

label.bot("direction", p1);

drawarrow p0 -- p1 dashed with_dots;


q := p0 reflected_off c with_direction p1;

message "q:";
show q;


%% q0:  The point representing the reflection. 
%% q2:  The intersection `point' of the ray from p0 in the direction
%%      of p1.
%% q1:  A `point' on the line from q2 to q0 such that q1 - q2 is 
%%      a unit vector.
%% q3:  The unit vector corresponding to q0 - q2.

label.top("$q_0$", q0);

dotlabel.top("origin", origin);

dotlabel.top("$q_1$", q1);
dotlabel.top("$q_2$", q2);
label.top("$q_3$", q3);


drawarrow p0 -- q2 -- q0 dashed evenly;

drawarrow origin -- q3 dashed evenly;


%endfig with_projection parallel_x_y;
endfig with_focus f; 
endfor;

end;





%% *** (3)  LDF 2004.12.09.
%% BUG.

beginfig(1); 

point_vector pv;  %% BUG!  If `pv' is declared inside the loop,
                  %% `3dldf' gets into an endless loop.
                  %% It looks like this may be difficult to fix.
                  %% This problem doesn't seem to affect non-vector
                  %% types, so I may not try to fix it until after the 
                  %% next release.  
                  %% In addition, redeclaring variables inside loops is
                  %% not really a sensible thing to do, anyway.
                  %% LDF 2004.12.09.
for i = 0 upto 3:
point p;
p := (i, i, i);
pv += (i + 1, i + 1, i + 1);
show pv;
endfor;
endfig; 
end;


%% *** (3) Reflecting a `point' off of a planar `path'.
%% `reflected_off' now returns a `point_vector' rather than a 
%% single `point'.  See below for an explanation of what's returned.

point_vector q;  %% BUG!  It doesn't work to put this after 
                 %% `beginfig'.  The problem seems to be in 
                 %% the `Pointer_Vector' destructor.
                 %% Will work on fixing this soon.
                 %% LDF 2004.12.09.

for i = 0 upto 8:
beginfig(i + 1); 



focus f;

set f with_position (0, 3, -10) with_direction (0, 3, 10) 
   with_distance 20;

point p[];

circle c;

set c with_point_count 32;

transform t;

t := identity scaled 2 rotated (0, 0, (i * 45)) shifted .25;

c *= t;

point center, n;

center := get_center c;
n := normal c;

n += center;

label("$c$", center);
label.lft("normal", n);

drawarrow center -- n;

draw c;

p0 := (1, 2, 0) rotated (0, 45);

dotlabel.top("$p_0$", p0);

p1 := -p0;

label.bot("direction", p1);

drawarrow p0 -- p1 dashed with_dots;


q := p0 reflected_off c with_direction p1;

message "q:";
show q;


%% q0:  The point representing the reflection. 
%% q2:  The intersection `point' of the ray from p0 in the direction
%%      of p1.
%% q1:  A `point' on the line from q2 to q0 such that q1 - q2 is 
%%      a unit vector.
%% q3:  The unit vector corresponding to q0 - q2.

label.top("$q_0$", q0);

dotlabel.top("origin", origin);

dotlabel.top("$q_1$", q1);
dotlabel.top("$q_2$", q2);
label.top("$q_3$", q3);


drawarrow p0 -- q2 -- q0 dashed evenly;

drawarrow origin -- q3 dashed evenly;


%endfig with_projection parallel_x_y;
endfig with_focus f; 
endfor;

end;



%% *** (3) Assigning to `booleans' from `bool_point_vectors'.
%% LDF 2004.12.09.

beginfig(1); 

bool_point_vector bpv;

bpv += (true,  (1, 2, 3)); 
bpv += (false, (4, 5, 6));
bpv += (true,  (7, 8, 9));

message "bpv:";
show bpv;

boolean b;

b := bpv;

message "b:";
show b;

endfig;
end;

%% *** (3) Assigning to `bool_points' from `bool_point_vectors' and
%% showing `bool_point_vectors'.
%% LDF 2004.12.09.

beginfig(1); 

bool_point_vector bpv;

bpv += (true,  (1, 2, 3)); 
bpv += (false, (4, 5, 6));
bpv += (true,  (7, 8, 9));

message "bpv:";
show bpv;

bool_point bp;

bp := bpv;

message "bp:";
show bp;

endfig;
end;

%% *** (3) Assigning to `colors' from `color_vectors' and
%% showing `color_vectors'.
%% LDF 2004.12.09.

beginfig(1); 

color_vector cv;
cv += blue;
cv += green;
cv += red;

message "cv before:";
show cv;

color c;


c := cv;

message "c:";
show c;

message "cv after:";
show cv;

endfig;
end;

%% *** (3) Assigning to `points' from `point_vectors' and
%% showing `point_vectors'.
%% LDF 2004.12.09.

beginfig(1); 

point_vector pv;
pv += (1, 1, 1);
pv += (2, 2, 2);
pv += (3, 3, 3);

message "pv before:";
show pv;

point p;


p := pv;

message "p:";
show p;

message "pv after:";
show pv;

endfig;
end;



%% *** (3) Multiplying `numerics' and `points' by `numeric' variables
%% containing non-integral values works, too.
%% LDF 2004.12.07.

beginfig(1); 

a := 2;

b := 2.5 * a;

message "b:";
show b;

c := a * 2.5;

message "c:";
show c;

point p;

p := (1, 2, 3);

point q;

q := 2.5 * p;

message "q:";
show q;

point r;

r := p * 2.5;

message "r:";
show r;

endfig;

end;


%% *** (3) Bug fix:  Added the parser rule
%% `numeric_secondary: numeric_token OVER numeric_variable'.
%% LDF 2004.12.07.

beginfig(1); 

a := 5;

b := 2.5 / a;

message "b:";
show b;

c := a / 2.5;

message "c:";
show c;

point p;

p := (1, 2, 3);

point r;

r := p / 2.5;

message "r:";
show r;

endfig;

end;

%% *** (3) Bug fix:  Added the parser rule
%% `numeric_secondary: numeric_secondary TIMES numeric_variable'.
%% LDF 2004.12.07.

beginfig(1); 

a := 2;

b := 2 * a;

message "b:";
show b;

c := a * 2;

message "c:";
show c;

point p;

p := (1, 2, 3);

point q;

q := 2 * p;

message "q:";
show q;

point r;

r := p * 2;

message "r:";
show r;

endfig;

end;

%% *** (3) LDF 2004.11.23.
%% Showing `cuboid_expressions'.

%beginfig(1);


show unit_cuboid;

cuboid c[];

c0 := unit_cuboid;

show c0;

show c1;

%end;





%% *** (3) LDF 2004.11.23.
%% Showing `reg_polygon_expressions'.

%beginfig(1);


show unit_pentagon;

reg_polygon r;

show r;

r := unit_pentagon;

show r;

%end;






%% *** (3) LDF 2004.11.23.
%% Showing `rectangle_expressions'.

%beginfig(1);


show unit_rectangle;

rectangle r;

show r;

r := unit_rectangle;

show r;

%end;


%% *** (3) LDF 2004.11.23.
%% Showing `ellipse_expressions'.

%beginfig(1);


show unit_ellipse;

ellipse e;

show e;

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `circle_expressions'.

%beginfig(1);

circle c;

show c;

c := unit_circle;

show c;  

%end;





%% *** (3) LDF 2004.11.22.
%% Showing `path_expressions'.

%beginfig(1);

path p;

show p;

p := origin .. (1, 2, 3);

show p;  

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `focus_expressions'.

%beginfig(1);

focus f;

show f;

set f with_position (-5, 1.5, -3) with_direction (0, 0, 0) 
   with_distance 20;

show f;  

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `picture_expressions'.

%beginfig(1);

picture p;

show p;

draw unit_circle on_picture p;

show p;  

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `transform_expressions'.

%beginfig(1);

transform t;

show t;

t  := identity scaled (2, 3, 4);

show t;  

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `color_expressions'.

%beginfig(1);

color c;

show c;

c  := red;

show c;  

%end;

%% *** (3) LDF 2004.11.22.
%% Showing `dash_pattern_expressions'.

%beginfig(1);

dash_pattern d;

show d;

d  := evenly;

show d;  



%end;

%% *** (3) LDF 2004.11.22.
%% Showing `pen_expressions'.

%beginfig(1);

pen p;

show p;

p  := pencircle;

show p;  

%end;


%% *** (3) LDF 2004.11.22.
%% Showing `point_expressions'.

%beginfig(1);

point p;

show p;  

p  := (3.5, 1, 2);

show p;


%end;

%% *** (3) LDF 2004.11.22.
%% Showing `numeric_expressions'.

beginfig(1);

numeric n;

show n;  %% It's not possible to distinguish unknown numeric variables 
         %% from `numeric_expressions' that are equal to 0.  I may change 
         %% this in the future.  LDF 2004.11.21.


n := 3.5;

show n;

show b;  %% Undeclared and unknown.

c := 2;

show c;
endfig;

end;


%% *** (3) LDF 2004.11.22.
%% Showing `string_expressions'.

beginfig(1);

string s;

show s;  

s  := "abc";

show s;

endfig;

end;


%% *** (3) LDF 2004.11.21.
%% Showing `boolean_expressions'.

%beginfig(1);

bool b;

show b;

b := true;

show b;

show false;

show true;

endfig;

end;



%% *** (3) LDF 2004.12.06.
%% Operation assignments on `numerics' and `points'.

beginfig(1); 

a := 0;
a += 3;
show a;
a -= 2;
show a;
a *= 2;
show a;
a /= 3;
show a;
a /= 0;
show a;

point p;
p := (1, 1, 1);
p += (2, 2, 2);
show p;

p -= (4, 4, 4);
show p;
 
endfig; 
end;






%% *** (3) Moved rules for `operation_assignments' to
%% `popassgn.w' from `passign.w'.
%% LDF 2004.12.06.

beginfig(1); 

path p;

p += (1, 1, 1);  %% This still works.

show p;

x := 3;
y := x * 2;  
             
show y;

z := 2 * x;  %% !! BUG.  This doesn't work.  Will try to fix soon!
             %% LDF 2004.12.06.

show z;

 
endfig; 
end;

%% ** (2) Changed `reflected in' to `reflected_in'.
%% ** (2) LDF 2004.12.03.

%% *** (3) LDF 2004.12.03.

beginfig(1);  %% Reflection of a `reg_polygon in the plane of a `circle'.
              %% LDF 2004.12.03.
reg_polygon p, q;   
p := unit_pentagon shifted (0, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;

%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of an `cuboid' in the plane of a `circle'.
              %% LDF 2004.12.03.
cuboid p, q;   
p := unit_cuboid shifted (0, 10);
q := p reflected_in unit_circle;
show p;
show q;
%endfig;
%end;


%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of an `circle' in the plane of another `circle'.
              %% LDF 2004.12.03.
circle p, q;   
p := unit_circle shifted (0, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;

%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of an `ellipse' in the plane of a `circle'.
              %% LDF 2004.12.03.
ellipse p, q;   
p := unit_circle shifted (0, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;


%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of a `rectangle in the plane of a `circle'.
              %% LDF 2004.12.03.
rectangle p, q;   
p := unit_square shifted (0, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;


%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of a `reg_polygon in the plane of a `circle'.
              %% LDF 2004.12.03.
reg_polygon p, q;   
p := unit_pentagon shifted (0, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;



%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of a `path' in the plane of a `circle'.
              %% LDF 2004.12.03.
path p, q;   
p := (0, 1) .. (1, 1);
q := p reflected_in unit_circle;
show q;
%endfig;
%end;

%% *** (3) LDF 2004.12.03.

%beginfig(1);  %% Reflection of a `point' in the plane of a `circle'.
point p, q;   %% LDF 2004.12.03.
p := (0, 1);
circle c;
c := unit_circle;
transform t;
t := identity rotated (0, 0, 45);
p *= c *= t;
q := p reflected_in c;
show p;
show q;

endfig;
end;







%% *** (3) LDF 2004.12.02.
%% Transforming `pictures'.  They cannot be transformed using 
%% `transformers' because `pictures' are persistent, i.e., 
%% temporaries are not created for them.  
%% `transformation commands' should be used instead.

beginfig(1);

path p;

p := (1, 1, 1) -- (2, 2, 2);

dotlabel.top(1, (1, 1, 1));
dotlabel.top(2, (2, 2, 2));

draw p;

picture q;
show q;

q := current_picture;

rotate q by 180;

show q;

show current_picture;

output q;

q := current_picture shifted 2; %% Causes a warning to be issued.

endfig;

end;





%% *** (3) LDF 2004.12.01.
%% `scantokens string_expression'.

beginfig(1);

point p;

p := (1, 2, 3);

string s;

scantokens s; %% `s' is unknown.  This causes a warning to be
              %% issued, but `3dldf' can continue.

s := "show p";

scantokens s;

endfig;

end;




%% *** (3) LDF 2004.12.01.
%% boolean expressions.
%% Now using |bool| instead of |int| for the type of the object 
%% referenced by |boolean_variables|, |boolean_primaries|,
%% |secondaries|, |tertiaries|, and |expressions|.

beginfig(1);

boolean b[];

show b0;

b1 := true;

show b1;

b2 := false;

show b2;

point p[];

p0 := (3, 3, 3);

b3 := p0 is_on_segment (0, 0, 0) -- (2, 2, 2);
show b3;

b4 := p0 is_on_line (0, 0, 0) -- (2, 2, 2);
show b4;

b5 := b1 and b2;

show b5;

b6 := b1 and b4;
show b6;

b7 := b1 or b2;

show b7;

b8 := 3 > 2;

show b8;

endfig;

end;





%% *** (3) LDF 2004.11.30.
%% path connectors.

beginfig(1);

path p, q;

p := (1, 1, 1)..(2, 2, 2);  %% Bug fix:  This now works.

q := (1, 1, 1) .. (2, 2, 2);   


show p;  
show q;

endfig;

end;





%% *** (3) LDF 2004.11.30.
%% numerical suffixes.

beginfig(1);

numeric t[];

t[.5] := 3;

show t[1/2];  %% Bug fix:  This now works when reading from 
              %% standard input.


endfig;

end;

%% *** (3) LDF 2004.11.27.
%% `for' loops with `upto' and `downto'.

beginfig(1);

for i = 2 upto 10:
show i;
endfor;

for i = 10 downto 2:
show i;
endfor;

endfig;

end;



%% *** (3) LDF 2004.11.26.
%% Quarters of `circles'.

beginfig(1);

circle c;

c := unit_circle scaled 3;

draw c;

label.top("", 0, c);

path p[];


p0 := quarter c with_closed with_angle 45 with_start 15;

%with_angle 30;


pen q;

q := pencircle scaled (1.5, 1.5);

drawarrow p0 with_pen q with_color blue;


%p1 := quarter c with_closed with_start 3;

%drawarrow p1 with_pen q with_color red;

endfig with_projection parallel_x_z;

end;


%% Halves of `circles'.

beginfig(1);

circle c;

c := unit_circle scaled 3;

draw c;

label.top("", 0, c);

path p[];


p0 := half c with_closed with_angle 90 with_start 12;


pen q;

q := pencircle scaled (1.5, 1.5);

drawarrow p0 with_pen q with_color blue;


p1 := half c with_closed with_start 3;

%drawarrow p1 with_pen q with_color red;

endfig with_projection parallel_x_z;

end;





%% *** (3) LDF 2004.11.26.
%% `path' segments.

beginfig(1);

path p[];

pen q;

q := pencircle scaled (1.5, 1.5);

ellipse e;

e := unit_ellipse scaled (2, 0, 3);

draw e;
label.top("", 0, e);

p0 := segment e with_start 1 with_end 3 with_angle 180;
draw p0 with_color blue with_pen q;

p1 := segment e with_start 1 with_end 5 with_closed;

draw p1 with_color red with_pen q;


endfig with_projection parallel_x_z;

end;





%% *** (3) LDF 2004.11.26.
%% Cyclical `paths' can now be reversed.

beginfig(1);

path p[];

p0 := (1, 1, 1) .. (2, 2, 2) -- (3, 3, 3) ... (4, 4, 4) --- (5, 5, 5);

p2 := reverse p0;

show p2;

p1 := p0;

p1 += ..;

p1 += cycle;

p3 := reverse p1;

show p3;

endfig;

end;

%% *** (3) LDF 2004.11.23.
%% Showing `cuboid_expressions'.

beginfig(1);


show unit_cuboid;

cuboid c[];

c0 := unit_cuboid;

show c0;

show c1;

end;





%% *** (3) LDF 2004.11.23.
%% Showing `reg_polygon_expressions'.

beginfig(1);


show unit_pentagon;

reg_polygon r;

show r;

r := unit_pentagon;

show r;

end;






%% *** (3) LDF 2004.11.23.
%% Showing `rectangle_expressions'.

beginfig(1);


show unit_rectangle;

rectangle r;

show r;

r := unit_rectangle;

show r;

end;


%% *** (3) LDF 2004.11.23.
%% Showing `ellipse_expressions'.

beginfig(1);


show unit_ellipse;

ellipse e;

show e;

end;

%% *** (3) LDF 2004.11.22.
%% Showing `circle_expressions'.

beginfig(1);

circle c;

show c;

c := unit_circle;

show c;  

end;





%% *** (3) LDF 2004.11.22.
%% Showing `path_expressions'.

beginfig(1);

path p;

show p;

p := origin .. (1, 2, 3);

show p;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `focus_expressions'.

beginfig(1);

focus f;

show f;

set f with_position (-5, 1.5, -3) with_direction (0, 0, 0) 
   with_distance 20;

show f;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `picture_expressions'.

beginfig(1);

picture p;

show p;

draw unit_circle on_picture p;

show p;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `transform_expressions'.

beginfig(1);

transform t;

show t;

t  := identity scaled (2, 3, 4);

show t;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `color_expressions'.

beginfig(1);

color c;

show c;

c  := red;

show c;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `dash_pattern_expressions'.

beginfig(1);

dash_pattern d;

show d;

d  := evenly;

show d;  



end;

%% *** (3) LDF 2004.11.22.
%% Showing `pen_expressions'.

beginfig(1);

pen p;

show p;

p  := pencircle;

show p;  

end;

%% *** (3) LDF 2004.11.22.
%% Showing `string_expressions'.

beginfig(1);

string s;

show s;  

s  := "abc";

show s;


end;

%% *** (3) LDF 2004.11.22.
%% Showing `point_expressions'.

beginfig(1);

point p;

show p;  

p  := (3.5, 1, 2);

show p;


end;

%% *** (3) LDF 2004.11.22.
%% Showing `numeric_expressions'.

beginfig(1);

numeric n;

show n;  %% It's not possible to distinguish unknown numeric variables 
         %% from `numeric_expressions' that are equal to 0.  I may change 
         %% this in the future.  LDF 2004.11.21.


n := 3.5;

show n;

show b;  %% Undeclared and unknown.

c := 2;

show c;

end;



%% *** (3) LDF 2004.11.21.
%% Showing `boolean_expressions'.

beginfig(1);

bool b;

show b;

b := true;

show b;

show false;

show true;

end;

%% *** (3) LDF 2004.11.20.
%% `in_ellipse' and `out_ellipse'.

beginfig(1);

rectangle r;

r := unit_rectangle scaled (2, 0, 3);

draw r;

ellipse e;

e := in_ellipse r;

draw e;

e := out_ellipse r;

draw e;


endfig with_projection parallel_x_z; 

end;



%% *** (3) LDF 2004.11.15.
%% `in_circle' and `out_circle'.

beginfig(1);

reg_polygon r;

r := unit_pentagon;

draw r;

circle c;

c := in_circle r;

draw c;

c := out_circle r;

draw c;


endfig with_projection parallel_x_z; 

end;


%% *** (3) LDF 2004.11.15.
%% `is_big_endian' and `is_little_endian'.
%% It's not possible to show `is_big_endian' or 
%% `is_little_endian' directly, because `show' currently
%% only takes `variable' arguments, not `expressions'.
%% I plan to change this.

beginfig(1);
bool b;
b := is_big_endian; 
show b;
b := is_little_endian; 
show b;
endfig; 

end;

%% *** (3) LDF 2004.11.13.
%% `pickup <color expression>' and `pickup_fill_color <color expression>'.

beginfig(1); 

pickup red;

pickup_fill_color blue;

circle c;
c := unit_circle scaled (3, 4) rotated 90;
fill c;

drop_fill_color;

fill c shifted (0, 1);

drop_color;

fill c shifted (0, 2);


endfig;

end;



%% *** (3) LDF 2004.11.13.
%% `pickup <color expression>' and `pickup_fill_color <color expression>'.

beginfig(1); 

pickup red;

pickup_fill_color blue;

circle c;
c := unit_circle scaled (3, 4) rotated 90;
fill c;

drop_fill_color;

fill c shifted (0, 1);

drop_color;

fill c shifted (0, 2);


endfig;

end;




%% *** (3) LDF 2004.11.13.
%% `pickup <color expression>' and `pickup_draw_color <color expression>'.

beginfig(1); 

pickup red;

pickup_draw_color blue;

circle c;
c := unit_circle scaled (3, 4) rotated 90;
draw c;

drop_draw_color;

draw c shifted (0, 1);

drop_color;

draw c shifted (0, 2);


endfig;

end;


%% *** (3) LDF 2004.11.13.
%% Implemented the commands
%% `pickup <dash_pattern>', and `drop_dash_pattern'.

beginfig(1); 

dash_pattern d;

d := evenly scaled (2, 3);

pickup d;

show current_dash_pattern;

circle c;
c := unit_circle scaled (3, 4) rotated 90;
filldraw c with_fill_color white;

drop_dash_pattern;

filldraw c shifted (0, 1) with_fill_color white;

endfig;

end;




%% *** (3) LDF 2004.11.12.
%% Implemented the commands
%% `pickup <color expression>', `pickup_draw_color <color expression>', 
%% `pickup_fill_color <color expression>', `drop_color', `drop_draw_color', 
%% and `drop_fill_color'.

beginfig(1); 

pickup blue;

show current_color;

pickup_draw_color red;

show current_draw_color;

pickup_fill_color green;

show current_fill_color;


circle c;
c := unit_circle scaled (3, 4) rotated 90;
filldraw c with_pen pencircle scaled (2, 3) dashed evenly scaled (2, 3);

point p;
p := (0, 5);

drawdot p withpen pencircle scaled (5, 5, 5);

endfig;

end;

%% *** (3) LDF 2004.11.12.
%% If `default_pen' is known, `beginfig' causes a `pickup'
%% command to be written to the MetaPost output file, that 
%% picks it up.  This implies that assigning to `default_pen' 
%% only has an effect following the next `beginfig' command.
%% To assign to `default_pen' and use the new value within the
%% same figure, call `pickup default_pen' or use 
%% `with_pen default_pen'.

default_pen := pensquare scaled (2, 3) rotated (0, 0, 45);

circle c;
c := unit_circle rotated 90;

beginfig(1); 
draw c;
clear default_pen;
endfig;

beginfig(2);
draw c;
default_pen := pencircle scaled (1, 4);
pickup default_pen;
draw c shifted (0, 1);
drop_pen;
draw c shifted (0, 2);
draw c shifted (0, 3) with_pen default_pen;
endfig; 

beginfig(3);
draw c;
endfig; 
 
end;

%% *** (3) LDF 2004.11.12.
%% Picking up and dropping `pens' and drawing `solids'.

beginfig(1); 

cuboid c;

c := unit_cuboid shifted 2;

draw c;


pen p;

p := pensquare scaled (3, 5) rotated (0, 0, 30);

pickup p;

shift c (0, 1);

draw c;

drop_pen;

undraw c;

shift c (0, 1);

draw c;

endfig;
end;

%% *** (3) LDF 2004.11.12.
%% Picking up and dropping `pens' and drawing `points' using
%% `drawdot'.


beginfig(1); 

point q;

q := origin;

drawdot q;


pen p;

p := pensquare scaled (3, 5) rotated (0, 0, 30);

pickup p;

shift q (0, 1);

drawdot q;

drop_pen;

shift q (0, 1);

drawdot q;

endfig with_projection parallel_x_y; 
end;


%% *** (3) LDF 2004.11.12.
%% Picking up and dropping `pens' and drawing `paths'.


beginfig(1); 

circle c;

c := unit_circle rotated 90;

draw c;

pen p;

p := penrazor scaled (3, 5) rotated (0, 0, 30);

pickup p;

shift c (0, 1);

draw c;

drop_pen;

shift c (0, 1);

draw c;

endfig with_projection parallel_x_y; 
end;







%% *** (3) LDF 2004.11.11.  
%% Assignments from `point_vectors' to `bool_point_vectors'
%% and vice versa.

beginfig(1);

circle c[];

c0 := unit_circle scaled 2;
c1 := c0 shifted 1;

draw c0;
draw c1 with_color red;

bool_point_vector bpv_a, bpv_b;

bpv_a := c0 intersection_points c1;

show bpv_a;

bpv_b := bpv_a;

show bpv_b;

rectangle r;
reg_polygon p;
 
p := unit_pentagon scaled (4, 4, 4) rotated (90, 0);

r := unit_square scaled (3, 3, 3) rotated (90, 0) shifted 2.5;

draw p;
draw r;

point_vector pv_a, pv_b;

pv_a := p intersection_points r;
show pv_a;

pv_b := pv_a;

show pv_b;

bpv_a := pv_a;

show bpv_a;

pv_b := bpv_b;
show pv_b;

endfig with_projection parallel_x_z;
end;



%% *** (3) LDF 2004.11.10.  
%% Added the rule 
%% `point_vector_assignment: point_vector_variable
%% ASSIGN bool_point_vector_expression'.
%% This makes it possible to assign the result of 
%% `c0 intersection_points c1', where `c0' and `c1' are `circles',
%% to a `point_vector', although the result of this `expression' is
%% a `bool_point_vector'.


beginfig(1);

circle c[];

c0 := unit_circle scaled 2;
c1 := c0 shifted 1;

draw c0;
draw c1 with_color red;


point_vector pv;


pv := c0 intersection_points c1;

show pv;


dotlabel.top(0, pv0);
dotlabel.top(1, pv1);

endfig with_projection parallel_x_z;
end;


%% *** (3) LDF 2004.11.10.
%% Intersection points of a `reg_polygon'  and a `rectangle':
%% Added the rule 
%% `bool_point_vector_assignment: bool_point_vector_variable
%% ASSIGN point_vector_expression'.  This means that the result of 
%% `p intersection_points r', where `p' and `r' are
%% `polygon_like' objects, can be assigned to `bool_point_vector',
%% even though the result of the `expression' is a 
%% `point_vector_tertiary'.

beginfig(1);
bool_point_vector bpv;
point_vector pv;

rectangle r;
reg_polygon p;
 
p := unit_pentagon scaled (4, 4, 4) rotated (90, 0);

r := unit_square scaled (3, 3, 3) rotated (90, 0) shifted 2.5;

draw p;
draw r;

bpv := p intersection_points r;

show bpv;

a := size bpv - 1;

show a;

for i = 0 step 1 until a:
dotlabel.top(i, bpv[i]);
endfor;

endfig with_projection parallel_x_y; 
end;




%% *** (3) LDF 2004.11.10.
%% Intersection points of a `reg_polygon'  and a `rectangle'.
%% The result is now a `point_vector_tertiary' rather than
%% a `bool_point_vector_tertiary'.

beginfig(1);
point_vector pv;

rectangle r;
reg_polygon p;
 
p := unit_pentagon scaled (4, 4, 4) rotated (90, 0);

r := unit_square scaled (3, 3, 3) rotated (90, 0) shifted 2.5;

draw p;
draw r;

pv := p intersection_points r;

show pv;

a := size pv - 1;

show a;

for i = 0 step 1 until a:
dotlabel.top(i, pv[i]);
endfor;

endfig with_projection parallel_x_y; 
end;

%% *** (3) LDF 2004.11.10.  
%% Now only actual intersection points are stored in the `bool_point_vector'
%% for `circle' intersections.

beginfig(1);

circle c[];

c0 := unit_circle scaled 2;
c1 := c0 shifted 1;

draw c0;
draw c1 with_color red;


bool_point_vector bvp;

bvp := c0 intersection_points c1;

show bvp;

endfig with_projection parallel_x_z;
end;




%% *** (3) LDF 2004.11.09.  
%% Fixed the `unit_' variables.  These are all of the right size.  
%% I haven't checked the other "unit_polygons" yet, though.

beginfig(1);

reg_polygon p;
rectangle r;
 
p := unit_pentagon;
show p;

r := unit_square;

show r;
circle c;
c := unit_circle;

show c;

draw r;
draw p;
draw c;

dotlabel.top("$(1, 0, 0)$", (1, 0, 0));
dotlabel.top("$(0, 0, 1)$", (0, 0, 1));

endfig with_projection parallel_x_z;
end;



%% *** (3) LDF 2004.11.09.  
%% Transformations and transformation commands:
%% `numeric_primary' arguments are now allowed.  
%% When a single number is used with `scale' or `scaled', 
%% the object is scaled by that amount in all three dimensions. 
%% For all other transformations and transformation commands,
%% the object is transformed by that amount in the x-dimension only.

beginfig(1);

reg_polygon p;
rectangle r;
 
p := unit_pentagon rotated 90;

r := unit_square rotated 90;

scale p by 2;  %% `by' is needed, because otherwise the parser doesn't 
               %% resolve the "2" to `numeric_primary'.  LDF 2004.11.09.

transform t;

t := identity scaled 3;  %% `by' isn't needed with `transformers', 
                         %% only with `transformation_commands'.
                         %% LDF 2004.11.09.

r *= t;

show p;
show r;


draw p;
draw r;

circle c;
c := unit_circle scaled 2 rotated 90;

shift c by 1;
show c;
draw c;


endfig;
end;


%% *** (3) LDF 2004.11.09.  
%% Intersection points of a linear `path'  and a `rectangle' (in that order).

%% !! This case now works.
%% LDF 2004.11.09.


beginfig(1);
bool_point_vector bpv;

path p;
rectangle r;

p := (-2, -2) -- (2, 2);

r := unit_square scaled (3, 3, 3) rotated (90, 0) shifted (.5, 0);

draw p;
draw r;

show p;
show r;

bpv := p intersection_points r;

a := size bpv - 1;

show a;

show bpv;

for i = 0 step 1 until a:
show i;
dotlabel_if.top(i, bpv[i]);
endfor;

endfig with_projection parallel_x_y; 
end;

%% *** (3) LDF 2004.11.09.  
%% Intersection points of a `rectangle' and a linear `path' (in that order).

%% !! This case now works.
%% LDF 2004.11.09.


beginfig(1);
bool_point_vector bpv;

path p;
rectangle r;

p := (-2, -2) -- (2, 2);

r := unit_square scaled (3, 3, 3) rotated (90, 0) shifted (.5, 0);

draw p;
draw r;

show p;
show r;

bpv := r intersection_points p;

a := size bpv - 1;

show a;

show bpv;

for i = 0 step 1 until a:
show i;
dotlabel_if.top(i, bpv[i]);
endfor;

endfig with_projection parallel_x_y; 
end;



%% *** (3) LDF 2004.11.09.  
%% Intersection points of a `reg_polygon' and a linear `path' (in that order).

%% !! This case works.
%% LDF 2004.11.09.


beginfig(1);
bool_point_vector bpv;

path p;
reg_polygon r;

p := (-1, -1) -- (2, 2);

r := unit_pentagon scaled (3, 3, 3) rotated (90, 0) shifted (.5, 0);

draw p;
draw r;

show p;
show r;

bpv := r intersection_points p;

a := size bpv - 1;

show a;

show bpv;

for i = 0 step 1 until a:
show i;
dotlabel_if.top(i, bpv[i]);
endfor;


endfig with_projection parallel_x_y; 
end;


%% *** (3) LDF 2004.11.09.  
%% Intersection points of a linear `path' and a `reg_polygon' (in that order).

%% !! This case works.
%% LDF 2004.11.09.

beginfig(1);
bool_point_vector bpv;

path p;
reg_polygon r;

p := (-1, -1) -- (2, 2);

r := unit_pentagon scaled (3, 3, 3) rotated (90, 0) shifted (.5, 0);

draw p;
draw r;

show p;
show r;

bpv := p intersection_points r;

a := size bpv - 1;

show a;

show bpv;

for i = 0 step 1 until a:
show i;
dotlabel_if.top(i, bpv[i]);
endfor;


endfig with_projection parallel_x_y; 
end;




%% *** (3) LDF 2004.11.08. `drawarrow' and `drawdlbarrow'.

beginfig(1);

path p[];

p0 := origin .. (1, 1);
drawarrow p0;

p1 := (2, 1) -- (2, 5);

drawdblarrow p1;

endfig with_projection parallel_x_y;  
end;


%% *** (3) LDF 2004.11.08. `internal_quantities' are now 
%% normal `numerics', except that their `category' is 
%% `Id_Map_Entry_Type::INTERNAL' rather than 
%% `Id_Map_Entry_Type::REGULAR'.

beginfig(1);
show tracingtitles;
tracingtitles := 1;
show tracingtitles;
endfig;  
end;


%% *** (3) LDF 2004.11.08.  
%% Intersection points of a `reg_polygon' and a linear `path' (in that order).
%% This case works:  `reg_polygon' and `path' are non-coplanar.

beginfig(1);
bool_point_vector bpv;

focus f;

set f with_position (-5, 1.5, -3) with_direction (0, 0, 0) with_distance 20;

path p;
reg_polygon r;

p := (0, 1, -1) -- (0, 1, 1);

r := unit_pentagon scaled (2, 0, 3)  rotated (90, 0);

show p;
show r;

draw p;
draw r;

bpv := p intersection_points r;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
%dotlabel_if.top(2, bpv2);
%dotlabel_if.top(3, bpv3);

endfig with_focus f;
end;




%% *** (3) LDF 2004.11.08.  
%% Intersection points of a `reg_polygon' and a linear `path' (in that order).
%% This case works:  `reg_polygon' and `path' are non-coplanar.

beginfig(1);
bool_point_vector bpv;

focus f;

set f with_position (-5, 1.5, -3) with_direction (0, 0, 0) with_distance 20;

path p;
reg_polygon r;

p := (0, 1, -1) -- (0, 1, 1);

r := unit_pentagon scaled (2, 0, 3)  rotated (90, 0);

show p;
show r;

draw p;
draw r;

bpv := p intersection_points r;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
%dotlabel_if.top(2, bpv2);
%dotlabel_if.top(3, bpv3);

endfig with_focus f;
end;


%% *** (3) LDF 2004.11.08.  
%% Intersection points of a `rectangle' and a linear `path' (in that order).
%% This case works:  `rectangle' and `path' are non-coplanar.

beginfig(1);
bool_point_vector bpv;

focus f;

set f with_position (-5, 1.5, -3) with_direction (0, 0, 0) with_distance 20;

path p;
rectangle r;

p := (0, 1, -1) -- (0, 1, 1);

r := unit_rectangle scaled (2, 0, 3)  rotated (90, 0);

show p;
show r;

draw p;
draw r;

bpv := p intersection_points r;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
%dotlabel_if.top(2, bpv2);
%dotlabel_if.top(3, bpv3);

endfig with_focus f;
end;


%% *** (3) LDF 2004.11.08.  
%% Intersection points of an `ellipse' and a `circle' (in that order).

beginfig(1);
bool_point_vector bpv;

circle c;
ellipse e;

c := unit_circle scaled (2, 0, 2);
draw c;

e := unit_ellipse scaled (2, 0, 1) shifted (1, 0); 

label("$c$", get_center c);
label("$e$", get_center e);

draw e with_color red;


bpv := e intersection_points c;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

endfig with_projection parallel_x_z; 
end;

%% *** (3) LDF 2004.11.08.  
%% Intersection points of a `circle' and an `ellipse' (in that order).

beginfig(1);
bool_point_vector bpv;

circle c;
ellipse e;

c := unit_circle scaled (2, 0, 2);
draw c;

e := unit_ellipse scaled (2, 0, 1) shifted (1, 0); 

label("$c$", get_center c);
label("$e$", get_center e);

draw e with_color red;


bpv := c intersection_points e;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

endfig with_projection parallel_x_z; 
end;



%% *** (3) LDF 2004.11.08.  
%% Intersection points of two `circles'.

beginfig(1);
bool_point_vector bpv;

circle c[];

c0 := unit_circle scaled (2, 2, 2);
draw c0;

c1 := c0 shifted (1, 0);

label("$c_0$", get_center c0);
label("$c_1$", get_center c1);

draw c1 with_color red;

bpv := c0 intersection_points c1;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

endfig with_projection parallel_x_z; 
end;


%% *** (3) LDF 2004.11.06.  
%% Intersection of a linear `path' and an `ellipse', parser 
%% rule 
%% `bool_point_vector_tertiary: path_tertiary INTERSECTION_POINTS 
%% ellipse_like_secondary'.


beginfig(1);
bool_point_vector bpv;
path q;
ellipse e;

q := (-2, -2) .. (2, 2);
draw q;
dotlabel.top("$q$", get_point 1 q);

e := unit_ellipse rotated (90, 0);

draw e;

bpv := q intersection_points e;

show bpv;

point p[];

p0 := bpv0;
p1 := bpv1;

dotlabel.top("$p_0$", p0);  
dotlabel.top("$p_1$", p1);  

endfig with_projection parallel_x_y; 
end;



%% *** (3) LDF 2004.11.06.  
%% Intersection points of two `ellipses'.

beginfig(1);
bool_point_vector bpv;

ellipse e[];

e0 := unit_ellipse scaled (2, 2, 2);
draw e0;

e1 := e0 shifted (1, 0);

label("$e_0$", get_center e0);
label("$e_1$", get_center e1);

draw e1 with_color red;

bpv := e0 intersection_points e1;

show bpv;

dotlabel_if.top(0, bpv0);
dotlabel_if.top(1, bpv1);
dotlabel_if.top(2, bpv2);
dotlabel_if.top(3, bpv3);

endfig with_projection parallel_x_z; 
end;


%% *** (3) LDF 2004.11.06.  
%% Conditional labelling of `bool_points' with `numeric_expression' argument.


beginfig(1);
bool_point_vector bpv;
path q;
ellipse e;

q := (-2, -2) .. (2, 2);
draw q;
dotlabel.top("$q$", get_point 1 q);

e := unit_ellipse rotated (90, 0);

draw e;

bpv := q intersection_points e;

%show bpv;

point p;

p := bpv1;

dotlabel_if.top(0, bpv0);  
dotlabel_unless.top(1, bpv1);  

bpv0 := false;
bpv1 := false;

dotlabel_if.bot(0, bpv0);  
dotlabel_unless.bot(1, bpv1);  

endfig with_projection parallel_x_y; 
end;

%% *** (3) LDF 2004.11.06.  
%% Conditional labelling of `bool_points' with `string_expression' argument.


beginfig(1);
bool_point_vector bpv;
path q;
ellipse e;

q := (-2, -2) .. (2, 2);
draw q;
dotlabel.top("$q$", get_point 1 q);

e := unit_ellipse rotated (90, 0);

draw e;

bpv := q intersection_points e;

%show bpv;

point p;

p := bpv1;

dotlabel_if.top("$p_0$", bpv0);  
dotlabel_unless.top("$p_1$", bpv1);  

bpv0 := false;
bpv1 := false;

dotlabel_if.bot("$p_0$", bpv0);  
dotlabel_unless.bot("$p_1$", bpv1);  

endfig with_projection parallel_x_y; 
end;



%% *** (3) LDF 2004.11.06.  
%% Intersection of a linear `path' and an `ellipse', parser 
%% rule 
%% `bool_point_vector_tertiary: path_tertiary INTERSECTION_POINTS 
%% ellipse_like_secondary'.


beginfig(1);
bool_point_vector bpv;
path q;
ellipse e;

q := (-2, -2) .. (2, 2);
draw q;
dotlabel.top("$q$", get_point 1 q);

e := unit_ellipse rotated (90, 0);

draw e;

bpv := q intersection_points e;

show bpv;

point p[];

p0 := bpv0;
p1 := bpv1;


dotlabel.top("$p_0$", p0);  
dotlabel.top("$p_1$", p1);  

endfig with_projection parallel_x_y; 
end;



%% *** (3) LDF 2004.11.05.  
%% Intersection of two linear `paths':
%% `bool_point_tertiary --> path_tertiary INTERSECTION_POINT 
%% path_secondary'.

beginfig(1);
point p;
path q[];

q0 := (-1, -1) .. (1, 1);
q1 := (-1, 1) .. (1, -1);

transform t;

t := identity shifted (1, 1);

q0 *= q1 *= t;

draw q0;
draw q1;

dotlabel.top("$q_0$", get_point 1 q0);
dotlabel.bot("$q_1$", get_point 1 q1);

bool_point b;

b := q0 intersection_point q1;

show b;

p := b;

dotlabel.top("$p$", p);  %% !! LDF 2004.11.05.  Add `dotlabel_if', etc.

endfig with_projection parallel_x_y; 
end;

%% *** (3) LDF 2004.11.05.  
%% Intersection of two linear `paths':
%% `bool_point_tertiary --> path_tertiary INTERSECTION_POINT 
%% path_secondary'.

beginfig(1);
point p;
path q[];

q0 := (-1, -1) .. (1, 1);
q1 := (-1, 1) .. (1, -1);

transform t;

t := identity shifted (1, 1);

q0 *= q1 *= t;

draw q0;
draw q1;

dotlabel.top("$q_0$", get_point 1 q0);
dotlabel.bot("$q_1$", get_point 1 q1);

bool_point b;

b := q0 intersection_point q1;

show b;

p := b;

dotlabel.top("$p$", p);  %% !! LDF 2004.11.05.  Add `dotlabel_if', etc.

endfig with_projection parallel_x_y; 
end;



%% *** (3) LDF 2004.11.05.  Scaling `pens' works after all.

beginfig(1);
pen p;
point q[];
q0 := origin;
q1 := (0, 3);

for i = .25 step .25 until 3:
p := pencircle scaled (i, i, i);
draw q0 -- q1 with_pen p;
dotlabel.top(i, q1);
shift q0 (1, 0);
shift q1 (1, 0);
endfor;
endfig with_projection parallel_x_y; 
end;

%% *** (3) LDF 2004.11.05.  Assignment from a `point_expression'
%%         to a `bool_point_variable'.

beginfig(1);
bool_point bp;
point p;

p := (1, 1, 1);

bp := p;

show bp;

p := (2, 2, 2);

bp := p;

bp := true;

show bp;

endfig; 
end;



%% *** (3) LDF 2004.11.05.  Assignment from a `boolean_expression'
%%         to a `bool_point_variable'.

beginfig(1);
bool_point bp;
boolean b;

b := true;

bp := b;

show bp;

b := false;

bp := b;

show bp;

endfig; 
end;


%% *** (3) LDF 2004.11.05.  `drawdot_if', `drawdot_unless', 
%%         `undrawdot_if', and `undrawdot_unless'. 

beginfig(1);
bool_point a, b, c, d;
a := (true, (0, 0, 0));
b := (false, (1, 1, 1));
c := (true, (2, 2, 2));
d := (false, (3, 3, 3));

drawdot_if a;
drawdot_unless b;

drawdot_if d;
drawdot_unless c;


undrawdot_if a;
undrawdot_unless b;

undrawdot_if d;
undrawdot_unless c;

endfig with_projection parallel_x_y;
end;

%% *** (3) LDF 2004.11.05.  
%% Assignments to a `point' from a `bool_point' can be chained.

beginfig(1);
point p[];
bool_point bp;
bp := (false, (1, 2, 3));
p0 := p1 := bp;  
show p0;
show p1;
endfig; 
end;


%% *** (3) LDF 2004.11.05.  
%% Assignment from a `bool_point' to a `point'.       

beginfig(1);
point p;
bp := (false, (1, 2, 3));


show p;
show bp;

p := bp;

show p;

bp := (true, (4, 5, 6));
show bp;

p := bp;
show p;

endfig;  
end;



%% *** (3) LDF 2004.11.05.  
%% Assignment from a `bool_point' to a `boolean'.       

beginfig(1);
boolean b;
bool_point bp;
bp := (false, (1, 2, 3));


show b;
show bp;

b := bp;

show b;

bp := (true, (4, 5, 6));
show bp;

b := bp;
show b;

endfig;  
end;



%% *** (3) LDF 2004.11.05.  Assignments using `+=' and `-=' are no longer 
%%         chainable.  They fail with parse errors, as they should,
%%         rather than causing segmentation faults.             

beginfig(1);
path p, q, r;
p += (1, 1, 1);
show p;
p += (2, 2, 2);

r := q := p;
show p;
show q;
show r;

p += cycle;
p += ..;

show p;

p -= cycle;
show p;

q := p += (2, 2, 2);  %% This now fails with a parse error, as it should,
                      %% rather than with a segmentation fault.
                      %% LDF 2004.11.05.
show p;
show q;


endfig;  
end;

beginfig(1);
bool_point b;
b := (true, origin);
show b;
endfig;  
end;




%% *** (3) LDF 2004.11.02.  `set reg_polygon'.

beginfig(1); 
reg_polygon r;
set r with_sides 13 with_diameter 6;
draw r;
dotlabel.top(0, r);
endfig with_projection parallel_x_z;
end; 


%% *** (3) LDF 2004.11.02.  `set circle_variable'.
%%                          In this drawing, 64 points are enough 
%%                          to solve the problem of distorted 
%%                          foreshortened `circles'.

beginfig(1); 

circle c[];

set c0 with_center origin with_diameter 3 with_point_count 64;

c1 := c0 rotated 90;

draw c0;
draw c1;

for i = 11.25 step 11.25 until 360:
rotate c0 (i, 0, 0);
draw c0;
rotate c1 (0, i, 0);
draw c1;
endfor;

picture p;
p := current_picture;
endfig; 


beginfig(2);
output p with_projection parallel_x_y; 
endfig; 

beginfig(3); 
output p with_projection parallel_x_z; 
endfig; 

beginfig(4);
focus f;
set f with_position (5, 5, -10) with_direction (5, 5, 10) with_distance 15;
output p with_focus f;
endfig; 


end; 




%% *** (3) LDF 2004.11.02.  `set ellipse_variable'.
%%                          The arguments are now optional, but
%%                          they must appear in order.
%%                          If a `point n' is passed as the `normal'
%%                          argument, the `ellipse' is rotated such that
%%                          its normal is equal to `n'.

beginfig(1); 

ellipse e;

point n;

n := unit_vector (1, 1, 1);  %% `n' needn't be a unit vector.

show n;

set e with_center origin with_axis_h 3 with_axis_v 2 with_point_count 16
 with_normal n;

show e;

point p;

p := normal e;

show p;

endfig; 
end; 




%% *** (3) LDF 2004.11.01.  Replacing the connector `..' with `--' 
%%                          in a `circle' to avoid problems with 
%%                          foreshortening.

beginfig(1); 

circle c[];

c0 := unit_circle scaled (2, 2, 2);
c1 := unit_circle scaled (2, 2, 2) rotated (90);

clear_connectors c0;
clear_connectors c1;

c0 += --;
c1 += --;

draw c0;
draw c1;

for i = 15 step 15 until 360:
rotate c0 (i, 0, 0);
rotate c1 (0, i, 0);
draw c0;
draw c1;
endfor;

picture p;

p := current_picture;

endfig; 

beginfig(2); 
output p with_projection parallel_x_z;
endfig; 

beginfig(3); 
output p with_projection parallel_x_y;
endfig; 

end; 


%% *** (3) LDF 2004.11.01. `clear_connectors path_like_variable'.

beginfig(1);
point p[];
path q[];

q0 := (1, 1, 1) -- (2, 2,2) .. (3, 3, 3) --- (4, 4, 4) ... (5, 5, 5);

show q0;

clear_connectors q0;

show q0;

q0 += ..;

q0 += ...;

show q0;

circle c;

c := unit_circle scaled (2, 2, 2);

clear_connectors c;

show c;

endfig; 
end; 


%% *** (3) LDF 2004.11.01.

beginfig(1);
point p[];
path q[];


q0 := (1, 1, 1) -- (2, 2,2);

q0 += cycle;



%% q2 := q1 := q0 += p5;     %% Invalid.  These constructions cause 
%% q2 := q1 := q0 += cycle;  %% segmentation faults.  I don't want     
%% q2 := q1 := q0 -= cycle;  %% to allow them, but I would like to be  
                             %% be able to catch and handle the error. 
                             %% I don't plan to try fixing this until  
                             %% after the forthcoming release, though. 
                             %% LDF 2004.11.01.                        

q2 := q1 := q0 += ..;        %% On the other hand, this construction
                             %% is valid.  LDF 2004.11.01.

show q2;                             

endfig; 
end; 



%% *** (3) LDF 2004.11.01.

beginfig(1);
point p[];
path q[];


%% LDF 2004.11.01.  This now works properly.

q0 := (5, 5, 5) ... (4, 4, 4) ... cycle;
q1 := q0 .. cycle;
q2 := q0 -- (1, 1, 1) -- (2, 2,2);
show q0;
show q1;
show q2;
q3 := (1, 1, 1) --- (2, 2, 2) --- q0 --- cycle;
show q3;
endfig; 
end; 


%% *** (3) LDF 2004.10.28.

beginfig(1);
point p[];
path q[];

%% LDF 2004.10.28.  Fixed bug:  
%% Now if the value of the variable in the loop header, 
%% here `i', is changed within a loop, 
%% it no longer loses this value when the loop iterates again.
%% This bug didn't affect `forever' loops, because they 
%% have no header.

message "for loop:";
pause;

for i = 0 step 1 until 4:
message "Beginning of loop:";
show i;
p[i] := (i, i, i);
q[i] := p[i] .. p[i];
if is_odd i:
   q[i] += --;
fi;
q[i] += (i, i, i);
q[i] += p[i];
show q[i];
i := i + 1; 
message "End of loop:";
show i;
endfor;

message "forever loop:";
pause;

i := 0;
forever:
exit_if i >= 4;
p[i] := (i, i, i);
q[i] := p[i] .. p[i];
if is_odd i:
   q[i] += --;
fi;
q[i] += (i, i, i);
q[i] += p[i];
show q[i];
i := i + 1;
endfor;

endfig; 
end; 


%% *** (3) LDF 2004.10.27.  Bug fix:  `forever' loops work again.

numeric i;
i := 0;
forever:
i := i + 1;
show i;
exit_if i >= 3;
endfor;
end;

%% *** (3) LDF 2004.10.27.

beginfig(1);
point p[];
path q[];

%% LDF 2004.10.27.  Bug fix:  This works now.

for i = 0 step 1 until 4:
p[i] := (i, i, i);
q[i] := p[i] .. p[i];
if is_odd i:
   q[i] += --;
fi;
q[i] += (i, i, i);
q[i] += p[i];
show q[i];
endfor;

endfig; 
end; 



%% *** (3) LDF 2004.10.27.


beginfig(1);
path p[], r;
point q;

i := 1;
q := (i, i, i);

bool b;

%r := p0 := p1 := p2 := (1, 1, 1);  %% LDF 2004.10.27.  This worked before.  
r := p0 := p1 := p2 := q;           %% Bug fix:  This works now.

show r;

endfig;  

end;



%% *** (3) LDF 2004.10.27.

beginfig(1);  %% LDF 2004.10.27.  Appending `points' and connectors
              %% to a `path' using the `+=' operator.
path p;
show p;
p += (1, 1, 1); 
show p;

p += ..;

p += (2, 2, 2);
point q;
q := (3, 3, 3);
p += --;
p += q;
show p;
endfig; 
end;





%% *** (3) LDF 2004.10.27.  Bug fix:  It's now possible to chain 
%%                          `point' assignments.

beginfig(1); 

point p[], q, r;

q := r := p0 := p1 := (1, 1, 1);


show q;
show r;

show p0;
show p1;
show p2;

path p[], q, r;  %% It's now possible to chain `path' assignments, too.

q := r := p0 := p1 := (1, 1, 1) .. (2, 2, 2);


show q;
show r;

show p0;
show p1;
show p2;



endfig;  


end;



%% *** (3) LDF 2004.10.27.  Fixed bug:  This works again.

beginfig(1); 
a := 1;
show a;
a := 2;
show a;
string s;
s := "abc";
show s;
s := "def";
show s;
point p;
p := (1, 1, 1);
show p;
p := (2, 2, 2);
show p;
endfig;  

end;



%% *** (3) LDF 2004.10.26.  Bug involving `path' connectors.

beginfig(1); 
point p[];
path q;
p0 := (1, 1, 1);
p1 := (21, 21, 21);
q := p0 .. p1;

% q := p0.. p1; %% LDF 2004.10.26.  BUG:  
                %% Connectors must be surrounded by whitespace,
                %% so this won't work.  Will try to fix this.
                %% Actually, the behavior differs depending on
                %% what connectors are being used, but surrounding
                %% them with spaces will work for all of them.

endfig;
end;


%% *** (3)  LDF 2004.10.26.


beginfig(1);  %% LDF 2004.10.26.  `is_colinear'
bool b[];
point p[];
path q[];


q0 := origin -- (1, 1, 1);
q1 := (3, 3, 3) -- (4, 4, 4);

b0 := q0 is_colinear q1;
show b0;

q2:= origin -- (0, 1);

b1 := q0 is_colinear q2;
show b1;

endfig; 
end;


beginfig(1);  %% `is_coplanar'

circle c[];
bool b[];

c0 := unit_circle;
c1 := unit_circle shifted (1, 0);

b1 := c0 is_coplanar c1;
show b1;

c2 := unit_circle shifted (0, 1);
b2 := c0 is_coplanar c2;
show b2;

c3 := c2;
c4 := c2 shifted (0, 0, 2);

transform t;
t := identity rotated (45, 45, 45);

c3 *= c4 *= t;

b3 := c3 is_coplanar c4;
show b3;

c4 := unit_circle shifted (0, -1);
b4 := c2 is_coplanar c4;
show b4;

endfig; 
end;

%% LDF 2004.10.25.  Working on rules and functions for
%% finding intersection points.  Some at least don't work 
%% quite right.

beginfig(1);  
rectangle c[];
point p[];

c0 := unit_square;
c1 := unit_square shifted (.25, 0);

draw c0;
draw c1;

point_vector pv;

pv := c0 intersection_points c1;

show pv;

endfig; 
end;



%% LDF 2004.10.25.  Chained assignment to `points'.

beginfig(1);  
point p[];

p0 := p1 := p2 := (2, 2, 2);  

show p0;
show p1;
show p2;

endfig; 
end;


%% *** (3) LDF 2004.10.25. `is_linear' and `is_planar'.

beginfig(1);
point p[];

p1 := (1, 1, 1);
p2 := (2, 2, 2);

path q[];

q0 := origin -- p2;

bool b[];

b0 := is_linear q0;
show b0;

ellipse e;

e := unit_ellipse;

b1 := is_linear e;
show b1;

b2 := is_planar (origin .. (1, 1, 1) .. (-1, 2, 3) -- (4, -5, 3) -- cycle);
show b2;

b3 := is_planar e;
show b3;


endfig; 

%end;




%% *** (3) LDF 2004.10.25.

beginfig(1);  %% `distance_along_line'.
point p[];

p1 := (1, 1, 1);
p2 := (2, 2, 2);

path q[];

q0 := origin -- p2;

e := origin distance_along_line (origin -- p2);  %% 0.  `point' is the 
                                                 %% first `point' on the `path'.

show e;

f := p2 distance_along_line (origin -- p2);  %% 1.  `point' is the 
                                             %% last `point' on the `path'.

show f;


a := p1 distance_along_line (origin -- p2);  %% .5 == halfway.
show a; 

b := p1 distance_along_line q0;  %% The same as `a'.
show b; 

q1 := origin -- p1 shifted (1, 1, 2) -- p2 -- cycle;  

c := p1 distance_along_line q1;  %% Error:  `path' isn't linear.  
                                 %% Can recover.  `c' is set to 
                                 %% `INVALID_NUMERIC'.

show c;

if c == INVALID_NUMERIC:
message "c == INVALID_NUMERIC.";
else:
message "c !== INVALID_NUMERIC.";
fi;
pause;

d := (-1, -1, -1) distance_along_line q0; %% -.5 == 1.5 of the way from 
                                          %% `p2' to the origin.
          

show d;

endfig;

end; 

%% *** (3) LDF 2004.10.25.  Transformation commands.  They seem to work now. 
%%                          Fixed bugs that affected `scale' and `shear'.

beginfig(1);  
point p[];
cuboid e;

e := unit_cuboid;

color_vector c;

c += blue;

draw e with_color_vector c;

scale e (1.5, 1.5, 1.5);

clear c;

c += green;

draw e with_color_vector c;

shift e (1, 0);    

shear e (2, 3, 4); %% LDF 2004.10.25.  `shear' now works.

clear c;

c += red;

draw e with_color_vector c;

endfig;
end;

%% *** (3) LDF 2004.10.23.  `distance_to_plane':  Distance of a `point' to the 
%%                          plane of a planar `path'.

beginfig(1);  
point p[];
ellipse e;
bool b[];
numeric n[];
path q[];

e := unit_circle;

n0 := origin distance_to_plane e;
show n0;

p0 := (0, 1);

q0 := (-1, -1, -1) -- (-1, -3, 0) -- (0, 3, 0) -- (1, -2, 3) -- (3, 3, 3);


n1 := p0 distance_to_plane e;
show n1;

if n1 == INVALID_NUMERIC:
   message "n1 == INVALID_NUMERIC.";
else:
   message "n1 != INVALID_NUMERIC.";
fi;
pause;

p1 := (0, -1);
n2 := p1 distance_to_plane e;
show n2;

n3 := p0 distance_to_plane q0;
show n3;

if n3 == INVALID_NUMERIC:
   message "n3 == INVALID_NUMERIC.";
else:
   message "n3 != INVALID_NUMERIC.";
fi;
pause;



endfig;
end;

%% *** (3) LDF 2004.10.23.  `is_parallel':  Parallelity of linear `paths'.

beginfig(1);  
point p[];
ellipse e;
e := unit_circle;

bool b[];

path p[];

p0 := origin -- (1, 0);
p1 := (0, 1) -- (1, 1);
p2 := origin -- (1, 1, 1);

b0 := p0 is_parallel p1;
show b0; 

b1 := p0 is_parallel p2;
show b1;

b2 := p0 is_parallel e;
show b2;



endfig;
end;



%% *** (3) LDF 2004.10.23.  `location'.

beginfig(1);  
point p[];
ellipse e;
e := unit_circle;
a := origin location e;
show a;

p0 := (0, 1);
b := p0 location e;
show b;

c := (1, 0, 0) location e;
show c;

d := (1.5, 0) location e;

endfig;
end;


%% *** (3) LDF 2004.10.22.  `is_in_triangle'.

beginfig(1);  
bool b[];
point p[];
point q[];

p0 := (1, .5);

dotlabel.top("$p_0$", p0);

q0 := origin;
q1 := 2;
q2 := (2, 2);

draw q0 -- q1 -- q2 -- cycle;

dotlabel.top("$q_0$", q0);
dotlabel.top("$q_1$", q1);
dotlabel.top("$q_2$", q2);


b0 := p0 is_in_triangle (q0, q1, q2);
show b0;


p1 := (1, 1);

dotlabel.top("$p_1$", p1);


b1 := p1 is_in_triangle (q0, q1, q2);
show b1;

p2 := (1, 2);

dotlabel.top("$p_2$", p2);


b2 := p2 is_in_triangle (q0, q1, q2);
show b2;


endfig with_projection parallel_x_y;
end;

%% *** (3) LDF 2004.10.22.  `is_on_segment' and `is_on_line'.

beginfig(1);  
bool b[];
point p[];

p0 := (3, 3, 3);

b0 := p0 is_on_segment (0, 0, 0) -- (2, 2, 2);
show b0;

b1 := p0 is_on_line (0, 0, 0) -- (2, 2, 2);
show b1;

b2 := p0 is_on_segment (0, 0, 0) -- (1, 2, 3) -- (12, -4, -10);
show b2;

endfig;
end;

%% *** (3) LDF 2004.10.18.

beginfig(1);  %% `is_circular.
              %% LDF 2004.10.18.

circle c;
c := unit_circle;
bool b[];     %% `bool' is now a synonym of `boolean'.
b0 := is_circular c;
show b0;

reg_polygon r;
r := unit_pentagon;

b1 := is_circular r;
show b1;

path p;
p := origin -- (1, 1, 1);

b2 := is_circular p;
show b2;

circle d;
d := c sheared (2, 3, 4, 5, 6, 7);

b3 := is_circular d;
show b3;

ellipse e;
e := unit_circle;
b4 := is_circular e;
show b4;

endfig;
end;




%% *** (3) LDF 2004.10.18.

beginfig(1);  %% `is_elliptical'.
              %% LDF 2004.10.18.
ellipse e;
e := unit_circle;

bool b[];     %% `bool' is now a synonym of `boolean'.
b0 := is_elliptical e;
show b0;

reg_polygon r;
r := unit_pentagon;

b1 := is_elliptical r;
show b1;

path p;
p := origin -- (1, 1, 1);

b2 := is_elliptical p;
show b2;

ellipse f;
f := e sheared (2, 3, 4, 5, 6, 7);

b3 := is_elliptical f;
show b3;


endfig;
end;

%% *** (3) LDF 2004.10.14.  Working on this.  
%%         Must make `is_elliptical()' and `is_circle()'
%%         member functions of |Path|. 

beginfig(1);  %% `is_elliptical'.
ellipse e;
boolean b;

e := unit_ellipse;
b := is_elliptical e;
show b;

rectangle r;
r := unit_square;


b := is_rectangular r;
show b;

endfig;
end;

%% *** (3) LDF 2004.10.14.

beginfig(1);  %% `is_square'.
rectangle r;
boolean b;

r := unit_square;
b := is_square r;
show b;

scale r (2, 0, 3);
b := is_square r;
show b;

b := is_rectangular r;
show b;

endfig;
end;



%% *** (3) LDF 2004.10.14.

beginfig(1);  %% `is_rectangular'.
rectangle r;
r := unit_square;

boolean b[];
b0 := is_rectangle r;
show b0;

circle c;
c := unit_circle;
b1 := is_rectangle c;
show b1;
endfig;
end;


%% *** (3) LDF 2004.10.13.

beginfig(1);  %% `get_rectangle'.  LDF 2004.10.13.
point p[];
rectangle r[];
cuboid c;
c := unit_cuboid rotated (0, 45);
draw c;
r0 := get_rectangle 0 c;
draw r0 with_color red with_pen pencircle scaled (2, 2);
p0 := get_center r0;
dotlabel.top("$p_0$", p0);
r1 := get_rectangle 1 c;
draw r1 with_color blue with_pen pencircle scaled (2, 2);
p1 := get_center r1;
dotlabel.top("$p_1$", p1);
endfig;
end;



%% *** (3) LDF 2004.10.09.

beginfig(1); %% `dotlabel point' with an integer argument rather than a `string'.
             %% This works for `label', too.  LDF 2004.10.09.
rectangle r;
r := unit_square scaled (1.2, 2.3) rotated 90 shifted (1, 2);
draw r;
label (3, r);
endfig with_projection parallel_x_y;
end;

%% *** (3) LDF 2004.10.09.

beginfig(1); %% `dotlabel point' with an integer argument rather than a `string'.
             %% This works for `label', too.  LDF 2004.10.09.
rectangle r;
r := unit_square scaled (1.2, 2.3) rotated 90 shifted (1, 2);
draw r;
point p, q;
p := get_center r;
show p;
dotlabel.top(12, p);
endfig with_projection parallel_x_y;
end;



%% *** (3) LDF 2004.10.09.

beginfig(1); %% `get_center' with an `ellipse' argument and a `circle' 
             %% argument.  LDF 2004.10.09.
ellipse e;
e := unit_circle scaled (2.3, 1.2) rotated 90 shifted (1, 2);
point p, q;
p := get_center e;
show p;
circle c;
c := unit_circle rotated 90 scaled (3, 3) shifted (-1, 2, 3);
q := get_center c;
draw c;
show q;
endfig with_projection parallel_x_y;
end;



%% *** (3) LDF 2004.10.06.

beginfig(1);  %% Unit vector of a `point'.
              %% LDF 2004.10.06.
point p, q;
p := (12, 13.5, 19);

q := unit_vector p;
show q;

m := magnitude p;
show m;

n := magnitude q;
show n;

a := length p;
show a;

b := length q;
show b;

endfig;
end;

%% *** (3) LDF 2004.10.06.

beginfig(1);  %% Normal of a planar `path'.
              %% LDF 2004.10.06.
point p;
circle q;

q := unit_circle;

p := normal q;
show p;

path r;

r := origin .. (1, -1) .. (1, 1) .. (2, 2, 5); %% Not planar!

point s;

s := normal r;  %% These statements 
show s;         %% will fail, but `3dldf' will be able to recover.

endfig;
end;



%% *** (3) LDF 2004.10.06.


beginfig(1);  %% Cross product of two `points' 
              %% (actually vectors, in the mathematical sense).
              %% LDF 2004.10.06.
point p, q, r, s, t;   
p := (1, 0);
q := (2, 0);

s := p cross_product q;  %% Vectors are parallel, cross product == `origin'.
show s;

r := (0, 1);
t := p cross_product r; %% Vectors are not parallel, cross product is 
                        %% perpendicular to both `p' and `r'.
show t;
endfig;
end;


%% *** (3) LDF 2004.10.06.

beginfig(1);  %% Dot product of two `points' 
              %% (actually vectors, in the mathematical sense).
              %% LDF 2004.10.06.
point p, q, r;   
p := (1, 0);
q := (0, 1);
r := p rotated (0, 0, 45);
a := p dot_product q;  %% Vectors are perpendicular, dot product == 0.
show a;
b := p dot_product r; %% Vectors are not perpendicular, dot product != 0.
show b;
endfig;
end;

%% *** (3) LDF 2004.10.04.

beginfig(1);  %% `is_even numeric_primary' and 
              %% `is_odd numeric_primary'.

if is_even 4:
      message "4 is even.";
   else:
      message "4 isn't even.";
fi;
pause;


if is_even 5:
      message "5 is even.";
   else:
      message "5 isn't even.";
fi;
pause;


if is_odd 4:
      message "4 is odd.";
   else:
      message "4 isn't odd.";
fi;
pause;

if is_odd 5:
      message "5 is odd.";
   else:
      message "5 isn't odd.";
fi;
pause;

end;

%% *** (3) LDF 2004.10.04.

beginfig(1);  %% `is_cycle path_like_expression'.

boolean b;
path p, q;
circle c, d; 

p := (1, 1) .. (2, 2) .. (3, 3);

q := (1, 1) .. (2, 2) .. (3, 3) .. cycle;

d := unit_circle;


if is_cycle p:
      message "`p' is a cycle.";
   else:
      message "`p' isn't a cycle.";
fi;
pause;

if (is_cycle q):
      message "`q' is a cycle.";
   else:
      message "`q' isn't a cycle.";
fi;
pause;


show c; %% Even `circles' with no points are cycles.

if (is_cycle c):
      message "`c' is a cycle.";
   else:
      message "`c' isn't a cycle.";
fi;
pause;


if (is_cycle d):
      message "`d' is a cycle.";
   else:
      message "`d' isn't a cycle.";
fi;
pause;


end;




%% *** (3) LDF 2004.10.04.

beginfig(1);      %% `type_predicates'.
point p;
path q;

if is_point p:
      message "`p' is a `point'.";
   else:
      message "`p' isn't a `point'.";
fi;
pause;

if is_point q:
      message "`q' is a `point'.";
   else:
      message "`q' isn't a `point'.";
fi;
pause;
end;



%% *** (3) LDF 2004.10.04.

beginfig(1);      %% `not <boolean_primary>'.
boolean b, c, d;
b := true;
c := not b;
show c;
d := not c;
show d;
end_input;
%end;


%% *** (3) LDF 2004.10.04.

beginfig(1);      %% `is_known' and `is_unknown'.
rectangle r;
reg_polygon p;
r := unit_square;
boolean b;
if (is_known p):
      message "p is known.";
      pause;
   else:
      message "p is unknown.";
fi;

if (is_known r):
      message "r is known.";
      pause;
   else:
      message "r is unknown.";
fi;
end;



%% *** (3) LDF 2004.10.01.

beginfig(1);      
rectangle r;
reg_polygon p;
r := unit_square;
p := unit_decagon;
point_vector b;
b := r intersection_points p;  %% LDF 2004.10.01.  This works.
show b;
end_input;
%end;

%% *** (3) LDF 2004.10.01.

beginfig(1);      
point p, q; 
p := (1, 0, 0);
transform t, u, v;
t := identity shifted 1;
u := identity;
v := identity;
v *= u *= t;  %% LDF 2004.10.01.  This works.  
              %% It's now possible to chain 
              %% `transformation_assignment_commands' of this type 
              %% (the only type, so far).
              %% 
p *= v *= t;  %% The objects in the chain needn't all be of the 
              %% same type, though.
show p;
endfig;
end_input;
%end;


%% *** (3) LDF 2004.10.01.

beginfig(1);      
point p, q; 
p := (1, 0, 0);
transform t;
t := identity shifted 1;
p *= t;  %% LDF 2004.10.01.  This works. 
         %% It's not possible to write, e.g., `transform p by t'.
         %% It might be possible to implement this, but that would make 
         %% `transform' ambiguous, i.e., it would sometimes be 
         %% a declarator, and sometimes a command.
show p;
endfig;
end_input;
%end;

%% *** (3) LDF 2004.10.01.


beginfig(1);      
point p, q; 
                  
p := (1, 0, 0);
q := (0, 1, 0);
a := p angle q; %% This works.  LDF 2004.10.01.  		 
		%% I'd forgotten that I'd implemented the rule 
		%% `numeric_secondary: point_secondary ANGLE point_primary'.
                %% I've revised it slightly, but the only user-visible
                %% change is that the debugging and error output is
                %% now thread-safe.
show a;
endfig;
end;


%% *** (3) LDF 2004.10.01.

beginfig(1);  
point p, q, r, s;
p := (1, 0, 0);
q := (0, 1, 0);
a := p angle q;
show a;
endfig;
endinput;  %% LDF 2004.10.01.
           %% This works, but it only makes sense under the following
           %% conditions: 
           %%
           %% 1.  single-threaded input and inclusion are being used, 
           %% and
           %% 2.  There was a single filename argument or a file 
           %%     was input by calling `input' while running 
           %%     `3dldf' interactively.
           %%
           %% Otherwise, it causes warnings to be issued.
end;



%% *** (3) LDF 2004.09.22.  This works.

beginfig(1);  
point p;
p := (0, 0, 0);
drawdot p;

message "Hello.";
pause;
errmessage "Hello again";

endfig with_projection parallel_x_y;


%% *** (3) LDF 2004.09.22.  This works.

beginfig(1);
i := 1;
forever:  
show i;
i := i + 1;
exitif i > 3;
endfor;
endfig;

%% *** (3) LDF 2004.09.22.
%% It may not be possible to implement `for_suffixes' with
%% Metafont-like behavior.  LDF 2004.09.22.

beginfig(1);
for_suffixes i = 1, 2, 3:  %% This causes an error to be signalled.
show i;
endfor;
endfig;


%% *** (3) LDF 2004.09.22.  If multithreaded inclusion is being used,
%% any given file should only be included once.  Included files should
%% contain an `end' command.  If single-threaded inclusion is being
%% used, they should not, unless the user really wants to terminate
%% the run at that point. 

%input "sample1";  %% This works.

beginfig(1);
point p;
p := (2, 2, 2);
drawdot p;
%input "sample1";  %% This works, but is potentially confusing if
                   %% multithreaded inclusion is being used.  Including
                   %% a file within a figure in this case is no
                   %% different from including it outside of any
                   %% figures.  LDF 2004.09.20.

endfig with_projection parallel_x_y;

input "sample1";  %% This works.

end;

%% *****************





point p; %% This works.  LDF 2004.09.13.
for i = 6 step -3 until 0:
   for j = 10 step -1 until 8:
      p := (i, j);
      show p;
   endfor;
endfor;


point p; %% This works.  LDF 2004.09.13.
for i = 6 step 3 until 12:
   for j = 10 step 1 until 12:
      p := (i, j);
      show p;
   endfor;
endfor;


%% *** (3) for loop. 

point p; %% This works.  LDF 2004.09.13.
for i = 2 step 2 until 6:
show i;
p := (i, i, i);
show p;
endfor;

%% ****************

point p; %% This works.  However, unlike MF/MP, all declarations
         %% within a group are local to the group.
         %% LDF 2004.09.13.
p := (1, 2, 3);
begingroup; 
point a;
a := (2, 3, 4);
show a;
endgroup;
show a;




begingroup; 

endgroup;


for a = 1 step 3 until 7: %% Working on this.  Must implement groups before loops.
                          %% LDF 2004.09.12.
show a;
show b;
point p; 
p := 12;
endfor;



%% *** This works.  The `boolean_expressions' can be changed.  
%%     LDF 2004.09.10.


a := 0;

if false:
if true:
a := 1;
fi
else: 
a:= 2;
fi

show a;



a := 0;

if true:
if false:
a := 1;
else: 
a:= 2;
fi
fi

show a;



a := 0;

if false:
a := 1;
elseif false:
a := 2;
else:
a := 3;
fi

show a;

a := 0;

if false:
a := 1;
elseif false:
a := 2;
fi
 
show a;


%% *** This works.  LDF 2004.09.09.

circle c[];

c0 := unit_circle rotated 90;
c1 := unit_circle rotated 90 scaled (2, 3) shifted (1.5);


draw c0;
draw c1;

bool_point_vector bpv;

bpv := c0 intersection_points c1;

show bpv;

drawdot bpv0 with_pen pencircle scaled 3;
drawdot bpv1 with_pen pencircle scaled 3;

drawdot bpv2 with_pen pencircle scaled 3;  % Causes an error and a
                                           % warning to be signalled,
                                           % but `3dldf' can recover
                                           % from the error and continue.

%% *** This works.  LDF 2004.09.08.

ellipse c[];

c0 := unit_circle scaled (2, 4) rotated 90;
c1 := unit_circle scaled (4, 2) rotated 90 shifted (1);


draw c0;
draw c1;

bool_point_vector bpv;

bpv := c0 intersection_points c1;

show bpv;



%% *** This works.  LDF 2004.09.08.

circle c[];

c0 := unit_circle scaled 2 rotated 90;
c1 := unit_circle scaled 2 rotated 90 shifted (1);


draw c0;
draw c1;


bool_point_vector bpv;

bpv := c0 intersection_points c1;

show bpv;



%% *** This works.  LDF 2004.09.08.

dash_pattern d;
d := evenly scaled (3);

path p;

p := origin .. (3, 3);

draw p dashed d;

circle c;
c := unit_circle scaled 3;

draw c with_pen pensquare scaled (2, 3) rotated (0, 0, 45);




%% *** This works.  LDF 2004.09.07.


path p, q;

p :=  ((-1, -1, 0) -- (1, 1, 0)) shifted (1, 1);
q := ((-1, 1, 0) -- (1, -1, 0)) shifted (1, 1);

circle c;

c := unit_circle scaled 2 rotated 90;


draw c;
draw p;

bool_point_vector bpv;

bpv := c intersection_points p;

show bpv;




%% *** This works.  LDF 2004.09.05.

path p, q;

p :=  ((-1, -1, 0) -- (1, 1, 0)) shifted (1, 1);
q := ((-1, 1, 0) -- (1, -1, 0)) shifted (1, 1);

point A;
A := p intersection_point q;
show A;

bool_point B;
B := p intersection_point q;
show B;



bool_point_vector bpv;
bool_point bp, bpa;

bp := (true, (1,1,1));
bpa := (false, (2,2,2));

bpv += bp;
bpv += bpa;

show bpv;
show bpv[0];
show bpv[1];
show bpv[2];


%% ** (2) End of 3DLDF code.


%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metafont
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% End:
