%% glyph_test.ldf
%% Created by Laurence D. Finston (LDF) Wed 06 Apr 2022 10:50:52 PM CEST

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2022 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de


% * (1) Beginning of 3DLDF code.

input "plain.lmc";

verbatim_metapost "prologues := 3; outputtemplate := \"%j%3c.eps\";";

glyph g;
glyph h;
glyph t;

%% * (1)

numeric frame_wd;
numeric frame_ht;
frame_wd := 18cm;
frame_ht := 20cm;

path frame;

frame :=    (-.5frame_wd, -.5frame_ht) -- (.5frame_wd, -.5frame_ht) -- (.5frame_wd, .5frame_ht)
         -- (-.5frame_wd, .5frame_ht) -- cycle;


focus f;
set f with_position (0, 15, -10) with_direction (0, 15, 10) with_distance 10;

path_vector pv;
point p[][];
path q[];
transform t[];
string s;
pen big_pen;
big_pen := pencircle scaled (2mm, 2mm, 2mm);

pen medium_pen;
medium_pen := pencircle scaled (1mm, 1mm, 1mm);

%% * (1) Fig. 0.
  
beginfig(0);

%% ** (2)
  
  draw frame shifted (5cm, 5cm);
  
  dotlabel.bot("origin", origin);
  
  g := get_glyph 65 from "cmssbx10";

  scale g by .5; 
  
  % message "g:";
  % show g;

  %draw g;
  
  pv := get_paths from g;

  n := (length pv0) - 1;

  draw pv0;
  draw pv1;
  
  for i = 0 upto n:
    p[0][i] := get_point (i) pv0;
    s := decimal i;
    dotlabel.top(s, p[0][i]);
  endfor;
  
  for i = 0 upto n:
    p[1][i] := get_point (i) pv1;
    s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;

  q0 := pv0;
  q1 := pv1;

  resolve q0 (0, 1) to 10 with_no_transform;

  resolve q0 (11, 12) to 6 with_no_transform;

  resolve q0 (18, 19) to 10 with_no_transform;

  resolve q0 (29, 30) to 30 with_no_transform;

  resolve q0 (61, 64) to 15 with_no_transform;

  resolve q0 (76, 77) to 5 with_no_transform;

  resolve q0 (82, 83) to 10 with_no_transform;

  resolve q0 (93, 94) to 5 with_no_transform;

  resolve q0 (99, 100) to 10 with_no_transform;

  resolve q0 (109, 110) to 3 with_no_transform;

  resolve q0 (113, 115) to 10 with_no_transform;

  q0 += get_point 0 q0;

  %dotlabel.rt("125", get_point 125 q0) with_text_color red;  


  resolve q0 (124, 125) to 20 with_no_transform;

  replace connectors q0 with "..";
  
  draw q0 with_color blue with_pen medium_pen;

  %draw subpath (96, 98) of q0 with_color green with_pen medium_pen;

  message "length q0:";
  show length q0;
  %pause;
  
  n := length q0;
  
  for i = 0 upto n:
    p[2][i] := get_point (i) q0;
    s := decimal i;
    %dotlabel.bot(s, p[2][i]) with_text_color blue;
  endfor;


  
endfig with_projection parallel_x_y;


%% * (1) Fig. 1.

beginfig(1);

%% ** (2)

  draw frame shifted (5cm, -10cm);

  output current_picture with_projection parallel_x_y;
  clear current_picture;
  
  dotlabel.bot("origin", origin);

  q2 := q0 rotated (-90, 0);
  q3 := q1 rotated (-90, 0);

  draw q2;
  draw q3;

  t0 := identity shifted (0, 2cm);

  q4 := q2 transformed t0;
  q5 := q3 transformed t0;
  
  draw q4;
  draw q5;

  % n := (length q2) - 1;
  
  % for i = 0 upto n:
  %   p[2][i] := get_point (i) q2;
  %   %s := decimal i;
  %   %dotlabel.top(s, p[1][i]);
  % endfor;

  % n := (length q3) - 1;
  
  % for i = 0 upto n:
  %   p[3][i] := get_point (i) q3;
  %   %s := decimal i;
  %   %dotlabel.top(s, p[1][i]);
  % endfor;

  % draw p[0][0] -- p[2][0];
  % draw p[0][7] -- p[2][7];
  % draw p[0][8] -- p[2][8];
  % draw p[0][15] -- p[2][15];
  % draw p[0][16] -- p[2][16];
  % draw p[0][23] -- p[2][23];
  % draw p[0][24] -- p[2][24];
  % draw p[0][31] -- p[2][31];
  % draw p[0][32] -- p[2][32];
  % draw p[0][33] -- p[2][33];
  % draw p[0][40] -- p[2][40];
  % draw p[0][41] -- p[2][41];
  % draw p[0][49] -- p[2][49];

  % % draw get_point (32) pv0 -- get_point (32) q2;
  % % draw get_point (33) pv0 -- get_point (33) q2;
  % % draw get_point (40) pv0 -- get_point (40) q2;
  
  % unfilldraw p[0][32] -- p[0][33] -- p[2][33] -- p[2][32] -- cycle;
  % unfill q2;

  % draw q3;

  


  % draw q2;
  % draw q3; %withcolor blue withpen big_pen;
  
  % % draw get_point (0) pv0 .. get_point (1) pv0 .. get_point (2) pv0 .. get_point (3) pv0
  % %   with_color blue with_pen pencircle scaled (1mm, 1mm); %  rotated (-45, 0)
  
%% ** (2) End of fig. 1

%endfig with_projection parallel_x_y;
endfig with_focus f no_sort;

%% * (1)

bye;



%% Local Variables:
%% mode: MetaPost
%% eval:(outline-minor-mode t)
%% outline-regexp:"%% [*\f]+"
%% End:
