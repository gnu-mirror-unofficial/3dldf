%% glyph_test.ldf
%% Created by Laurence D. Finston (LDF) Wed 06 Apr 2022 10:50:52 PM CEST

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2022 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de


% * (1) Beginning of 3DLDF code.

input "plain.lmc";

verbatim_metapost "prologues := 3; outputtemplate := \"%j%3c.eps\";";

glyph g;
glyph h;
glyph t;

%% * (1)

numeric frame_wd;
numeric frame_ht;
frame_wd := 18cm;
frame_ht := 20cm;

path frame;

frame :=    (-.5frame_wd, -.5frame_ht) -- (.5frame_wd, -.5frame_ht) -- (.5frame_wd, .5frame_ht)
         -- (-.5frame_wd, .5frame_ht) -- cycle;


focus f;
set f with_position (0, 15, -10) with_direction (0, 15, 10) with_distance 10;

path_vector pv;
point p[][];
path q[];
transform t[];
string s;
pen big_pen;
big_pen := pencircle scaled (2mm, 2mm, 2mm);

pen medium_pen;
medium_pen := pencircle scaled (1mm, 1mm, 1mm);

%% * (1) Fig. 0.
  
beginfig(0);

%% ** (2)
  
  draw frame shifted (5cm, 5cm);
  
  dotlabel.bot("origin", origin);
  
  g := get_glyph 65 from "cmssbx10";

  scale g by .5; 
  
  % message "g:";
  % show g;

  %draw g;
  
  pv := get_paths from g;

  n := (length pv0) - 1;

  draw pv0;
  draw pv1;
  
  for i = 0 upto n:
    p[0][i] := get_point (i) pv0;
    s := decimal i;
    dotlabel.top(s, p[0][i]);
  endfor;
  
  for i = 0 upto n:
    p[1][i] := get_point (i) pv1;
    s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;

  q0 := pv0;
  q1 := pv1;

%% !! START HERE:  LDF 2022.04.07.  Add "resolved" and put the result of it in a path.
%% Make it an assignment.

  
  resolve q0 (0, 1) to 10;

  n :=   := (length pv0) - 1;
  
  for i = 0 upto n:
    p[1][i] := get_point (i) pv1;
    s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;
  

  
endfig with_projection parallel_x_y;

bye;

%% * (1) Fig. 1.

beginfig(1);

%% ** (2)

  draw frame shifted (5cm, -10cm);

  output current_picture with_projection parallel_x_y;
  clear current_picture;
  
  dotlabel.bot("origin", origin);
  
  q0 := pv0 rotated (-90, 0);
  q1 := pv1 rotated (-90, 0);

  n := (length q0) - 1;

  string s;
  
  for i = 0 upto n:
    p[0][i] := get_point (i) q0;
    %s := decimal i;
    %dotlabel.top(s, p[0][i]);
  endfor;
  
  n := (length pv1) - 1;
  
  for i = 0 upto n:
    p[1][i] := get_point (i) pv1;
    %s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;


  dotlabel.top("7", p[0][7]);
  dotlabel.top("8", p[0][8]);

  dotlabel.lft("15", p[0][15]);
  dotlabel.lft("16", p[0][16]);

  dotlabel.bot("23", p[0][23]);
  dotlabel.lrt("24", p[0][24]);

  dotlabel.rt("31", p[0][31]);
  dotlabel.lrt("32", p[0][32]);
  dotlabel.llft("33", p[0][33]);
  %dotlabel.lft("34", p[0][34]);
  %dotlabel.lft("35", p[0][35]);
  dotlabel.lft("36", p[0][36]);
  %dotlabel.lft("37", p[0][37]);

  dotlabel.bot("40", p[0][40]);
  dotlabel.bot("41", p[0][41]); 

  dotlabel.rt("49", p[0][49]); 
  dotlabel.top("0", p[0][0]);

  % dotlabel.lrt("$p_0^{20}$", p[0][20]);
  % dotlabel.lrt("$p_0^{30}$", p[0][30]);
  % dotlabel.lrt("$p_0^{40}$", p[0][40]);
  % dotlabel.lrt("$p_0^{45}$", p[0][45]);
  % dotlabel.rt("$p_0^{49}$", p[0][49]);

  % dotlabel.urt("$p_0^1$", p[0][1]);
  % dotlabel.top("$p_0^2$", p[0][2]);
  % dotlabel.lft("$p_0^3$", p[0][3]);
  % dotlabel.ulft("$p_0^4$", p[0][4]);
  % dotlabel.lft("$p_0^5$", p[0][5]);
  % dotlabel.bot("$p_0^6$", p[0][6]);
  % dotlabel.bot("$p_0^7$", p[0][7]);
  % dotlabel.bot("$p_0^8$", p[0][8]);
  % dotlabel.lrt("$p_0^9$", p[0][9]);
  % dotlabel.llft("$p_0^{10}$", p[0][10]);
  % dotlabel.lft("$p_0^{11}$", p[0][11]);
  % dotlabel.bot("$p_0^{12}$", p[0][12]);
  % dotlabel.bot("$p_0^{13}$", p[0][13]);
  % dotlabel.rt("$p_0^{14}$", p[0][14]);
  % dotlabel.urt("$p_0^{15}$", p[0][15]);
  % dotlabel.urt("$p_0^{16}$", p[0][16]);
  % dotlabel.urt("$p_0^{17}$", p[0][17]);
  % dotlabel.urt("$p_0^{18}$", p[0][18]);
  % dotlabel.urt("$p_0^{19}$", p[0][19]);
  %dotlabel.top("$p_0^{20}$", p[0][20]);
  % dotlabel.top("$p_0^{21}$", p[0][21]);
  
  
  % dotlabel.lft("$p_1^0$", p[1][0]);
  % dotlabel.lft("$p_1^1$", p[1][1]);
  % dotlabel.rt("$p_1^2$", p[1][2]);
  % dotlabel.rt("$p_1^3$", p[1][3]);
  % dotlabel.rt("$p_1^4$", p[1][4]);
  % dotlabel.lft("$p_1^5$", p[1][5]);

  %% !! START HERE: LDF 2022.04.06.  Make this work.  The function
  %% exists, I just need the parser rule.
  
  %message "connectors (34, 40) q0:";
  %show connectors (34, 40) q0;
  %pause;

  %replace connectors q0 with "..";

  draw q0;
  draw q1;

  t0 := identity shifted (0, 2cm);

  q2 := q0 transformed t0;
  q3 := q1 transformed t0;
  
  draw q2;
  draw q3;

  n := (length q2) - 1;
  
  for i = 0 upto n:
    p[2][i] := get_point (i) q2;
    %s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;

  n := (length q3) - 1;
  
  for i = 0 upto n:
    p[3][i] := get_point (i) q3;
    %s := decimal i;
    %dotlabel.top(s, p[1][i]);
  endfor;

  draw p[0][0] -- p[2][0];
  draw p[0][7] -- p[2][7];
  draw p[0][8] -- p[2][8];
  draw p[0][15] -- p[2][15];
  draw p[0][16] -- p[2][16];
  draw p[0][23] -- p[2][23];
  draw p[0][24] -- p[2][24];
  draw p[0][31] -- p[2][31];
  draw p[0][32] -- p[2][32];
  draw p[0][33] -- p[2][33];
  draw p[0][40] -- p[2][40];
  draw p[0][41] -- p[2][41];
  draw p[0][49] -- p[2][49];

  % draw get_point (32) pv0 -- get_point (32) q2;
  % draw get_point (33) pv0 -- get_point (33) q2;
  % draw get_point (40) pv0 -- get_point (40) q2;
  
  unfilldraw p[0][32] -- p[0][33] -- p[2][33] -- p[2][32] -- cycle;
  unfill q2;

  draw q3;

  


  draw q2;
  draw q3; %withcolor blue withpen big_pen;
  
  % draw get_point (0) pv0 .. get_point (1) pv0 .. get_point (2) pv0 .. get_point (3) pv0
  %   with_color blue with_pen pencircle scaled (1mm, 1mm); %  rotated (-45, 0)
  
%% ** (2) End of fig. 1

%endfig with_projection parallel_x_y;
endfig with_focus f no_sort;

%% * (1)

end_mp;
end;


%% Local Variables:
%% mode: MetaPost
%% eval:(outline-minor-mode t)
%% outline-regexp:"%% [*\f]+"
%% End:
