def get_spherical_biangle (pp) {numeric rad, boolean ddo_labels, numeric ra_divisions,
                                numeric decl_divisions, boolean draw_biangle,
                                numeric draw_portion,
			   	boolean draw_lines, boolean draw_vertical} = 

  circle c[];
  numeric a;
  numeric radius[];
  numeric circum[];
  numeric n[];
  point ra_decl_zero_pt;
  numeric tab_wd;

  point r[];

  boolean testing;

  testing := false; % true; % 
  ddo_labels := true;
  
  tab_wd := .25cm;
  
  radius0 := rad;

  ra_decl_zero_pt := (rad, 0);

  c0 := unit_circle scaled (radius0, 0, radius0) rotated (90, 0);
  a := circumference c0;   %% a == Circumference of horizontal great circle.

  
  if testing:
    draw c0 with_color red on_picture bi_ang_pict[0];
  fi;

% (% 100 32)
% (/ 100 32)
% (/ 100 32.0)

% (* 3 32)

  message "decl_divisions:";
  show decl_divisions;
  message "draw_portion:";
  show draw_portion;

  r0 := (-radius0, 0);
  r1 := (radius0, 0);

  %message "magnitude (r1 - r0) (diameter of c0):";
  %show magnitude (r1 - r0);

  if testing:
    draw r0 -- r1 on_picture bi_ang_pict[0];  %% Horizontal line through origin.
  fi;

  if ddo_labels and testing:
    dotlabel.lft("$r_0$", r0) on_picture bi_ang_pict[0];
    dotlabel.rt("$r_1$", r1) on_picture bi_ang_pict[0];
  fi;

  r2 := (0, -radius0);
  r3 := (0, radius0);

  if testing:
    draw r2 -- r3 on_picture bi_ang_pict[0];  %% Vertical line through origin.
  fi;

  if ddo_labels and testing:
    dotlabel.bot("$r_2$", r2) on_picture bi_ang_pict[0];
    dotlabel.top("$r_3$", r3) on_picture bi_ang_pict[0];
  fi;

  
  k := 2 * decl_divisions;
  decl_increment := 360 / k;
  n := 90 - decl_increment;

  message "k == ";
  show k;

  message "decl_increment == ";
  show decl_increment;

  message "n == ";
  show n;

  j := 4;
  for i = decl_increment step decl_increment until n:
    r[j] := r1 rotated (0, 0, i);
    r[j+1] := (0, ypart r[j]);
    if testing:
      draw r[j + 1] -- r[j] on_picture bi_ang_pict[0];
    fi;
    if ddo_labels and testing:
      dotlabel.rt("$r_{" & decimal j & "}$", r[j]) on_picture bi_ang_pict[0];
    fi;
    radius[j] := magnitude(r[j] - r[j + 1]);
    c[j] := unit_circle scaled (radius[j], 0, radius[j]);
    circum[j] := circumference c[j];
    biangle_width[i] := circum[j] / ra_divisions;
    message "biangle_width[" & decimal i & "]:";
    show biangle_width[i];
    j += 2;
  endfor;


  
% %% **** (4)

  edge0 := null_path; 
  edge1 := null_path; 
  edge2 := null_path;  
  edge3 := null_path;  

  edge0 += ..;
  edge1 += ..;
  edge2 += ..;
  edge3 += ..;

  n0 := a / ra_divisions;          %% 1/ra_divisions of circumference of c0 == width of spherical biangles 
                                   %% at 0 deg. declination. 

  n1 := a / (2 * decl_divisions);  %% Distance between the declination lines in increments of (360 / decl_divisions)
                                   %% deg.

  
  pp[0][0] := (-.5n0, 0);
  pp[1][0] := (.5n0, 0);

  message "draw_lines:";
  show draw_lines;
  message "line_color:";
  show line_color;

  message "ddo_labels:";
  show ddo_labels;
    
  if true or draw_lines:
    draw pp[0][0] -- pp[1][0] with_color line_color on_picture bi_ang_pict[0];
  fi;
  
  if true or do_labels_ra_decl:
    label.rt("$0^\circ$", pp[1][0] shifted (2.5cm, 0)) on_picture bi_ang_pict[0];
  fi;
  
  if ddo_labels:
    dotlabel.lft("$pp_0^0$", pp[0][0]) on_picture bi_ang_pict[0];
    dotlabel.rt("$pp_1^0$", pp[1][0]) on_picture bi_ang_pict[0];
  fi;
  
  edge0 += pp[0][0];
  edge1 += pp[1][0];
  edge2 += pp[0][0];
  edge3 += pp[1][0];

  pp[0][90]  := pp[1][90]  := (0, .25a);
  pp[0][-90] := pp[1][-90] := (0, -.25a);


  if draw_vertical:
    draw pp[0][90] -- pp[0][-90] with_color black on_picture bi_ang_pict[0];
  fi;
  
  if ddo_labels:
    dotlabel.top("$pp_0^{90}$", pp[0][90]) on_picture bi_ang_pict[0];
    dotlabel.bot("$pp_0^{-90}$", pp[0][-90]) on_picture bi_ang_pict[0];
  fi;

  if do_labels_ra_decl:
    label.rt("$90^\circ$", pp[0][90] shifted (.25cm, 0)) on_picture bi_ang_pict[0];
    label.rt("$-90^\circ$", pp[0][-90] shifted (.25cm, 0)) on_picture bi_ang_pict[0];
  fi;

  message "decl_increment == ";
  show decl_increment;

  message "n == ";
  show n;

  j := 1;
  for i = decl_increment step decl_increment until n:

    message "i == ";
    show i;

    pp[0][i] := (-.5biangle_width[i], (j * n1));
    pp[1][i] := (.5biangle_width[i], (j * n1));

    pp[0][-i] := pp[0][i] rotated 180; 
    pp[1][-i] := pp[1][i] rotated 180; 

    edge0 += pp[0][i];
    edge1 += pp[1][i];
    edge2 += pp[0][-i];
    edge3 += pp[1][-i];
    
    if draw_lines:
      draw pp[0][i] -- pp[1][i] with_color line_color on_picture bi_ang_pict[0];
      draw pp[0][-i] -- pp[1][-i] with_color line_color on_picture bi_ang_pict[0];
    fi;

    if ddo_labels:
      dotlabel.lft("$pp_0^{" & decimal i & "}$", pp[0][i]) on_picture bi_ang_pict[0];
      dotlabel.rt("$pp_1^{" & decimal i & "}$", pp[1][i]) on_picture bi_ang_pict[0];
      dotlabel.lft("$pp_0^{-" & decimal i & "}$", pp[0][-i]) on_picture bi_ang_pict[0];
      dotlabel.rt("$pp_1^{-" & decimal i & "}$", pp[1][-i]) on_picture bi_ang_pict[0];
    fi;

    if not do_labels_ra_decl:
      ;
    else:
      label("$" & decimal (decl_increment * j) & "^\circ$", pp[1][i] shifted (2.5cm, 0))
	on_picture bi_ang_pict[0];
    fi;
    j += 1;
  endfor;

%% *** (3)



  
  edge0 += pp[0][90];
  edge1 += pp[1][90];

  edge2 += pp[0][-90];
  edge3 += pp[1][-90];

  draw edge0 on_picture bi_ang_pict[0]; % with_color dark_gray;
  draw edge1 on_picture bi_ang_pict[0]; % with_color dark_gray;

  if draw_portion >= 1:
    draw edge2 on_picture bi_ang_pict[0]; % with_color dark_gray;
    draw edge3 on_picture bi_ang_pict[0]; % with_color dark_gray;
  fi;
  
  if draw_portion == .5:
    draw pp[0][0] -- pp[1][0] with_color black on_picture bi_ang_pict[0];
  fi;


  
%% *** (3)
  
enddef;

endinput;


%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%       GNU Emacs editor.  The local variable list is not evaluated when an 
%%       indirect buffer is visited, so it's necessary to evaluate the       
%%       following s-expression in order to use the facilities normally      
%%       accessed via the local variables list.                              
%%       \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metapost
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% abbrev-mode:t
%% outline-regexp:"%% [*\f]+"
%% End:

