@q sprellps.web @>
    
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2022 The Free Software Foundation, Inc.                    @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * Superellipse.@>
@** Superellipse\quad ({\tt sprellps\PERIOD web}).\hfil

\LOG
\initials{LDF 2022.04.26.}
Created this file.
\ENDLOG 

@f Superellipse Path

@q * Include files.@>

@ Include files.
\initials{LDF 2022.04.26.}

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
  
@q * (1) |class Superellipse|.  @>

@ |class Superellipse|.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this class declaration.
\ENDLOG 

@<Declare |class Superellipse|@>=

class Superellipse : public Ellipse
{
   friend int yyparse(yyscan_t);

   protected:

      real beta; 
      real gamma; 

      real superness_beta; 
      real superness_gamma; 

      int resolution; 
  
      real x_semiaxis_length; 
      real z_semiaxis_length;

      real arc_begin;
      real arc_end;

    public:

       @<Declare |Superellipse| functions@>@;

};

@q ** (2) |Superellipse| functions.  @>
@ |Superellipse| functions.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this section.
\ENDLOG 


@q *** (3) Default constructor.  @>

@ Default constructor.
\initials{LDF 2022.04.26.}

The values for |beta|, |gamma|, |superness_beta| and |superness_gamma| are negative
in order to be able to test whether they've been set by a parser rule.
As of 2022.04.26, the only parser rule that creates a |Superellipse| is 
\§path primary> $\longrightarrow$ \.{SUPERELLIPSE} \§superellipse option list>.
\par
If one of these data members is not set by an option, then it's reset to its absolute value, 
which is therefore it's default value.  The values chosen correspond to the superellipse
popularized by by Piet Hein and used, among other things, for his ``superegg'' toy.
See {\it The METAFONTbook}, p.~126 and Gardner, Martin, {\it Mathematical Carnival\/} 
(New York: Knopf, 1975), pp.~240--254.

The following is Emacs-Lisp code for calculating $\beta$ and |superness_beta|
when the other quantity is known.  The same applies to $\gamma$ and 
|superness_gamma|
\initials{LDF 2022.04.26.}

\begingroup
\obeylines
\obeyspaces
\tt 
;; set beta with superness known.
(progn
   ;; (setq superness 0.0)
   ;; (setq superness 2.5)
   ;; (setq superness 0.5)
    (setq superness 0.75)
   ;; (setq superness 0.757858283255199) ;; --> beta == 2.5, Piet Hein's value for the superegg.
   ;; (setq superness 1.0)               ;; --> beta == infinity (rectangle)
   (setq beta (/ -1 (/ (log superness) (log 2))))
)

;; set superness with beta known.
(progn
   (setq beta 0.757858283255199)
   (setq superness (/ -1 (/ (log beta) (log 2))))
)
\endgroup

!!START HERE:  LDF 2022.04.26.  Add explanation of result of different values for $\beta$
and $\gamma$.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare |Superellipse| functions@>=
Superellipse(void) 
{
   shape_type = SUPERELLIPSE_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   line_switch = false;
   cycle_switch = true;
   pen_vector = 0; 
   dash_pattern_vector = 0;

   beta              = -0.757858283255199; 
   gamma             = -0.757858283255199;
   superness_beta    = -2.5;
   superness_gamma   = -2.5;
   x_semiaxis_length = 1;
   z_semiaxis_length = 1;

   resolution        = 32;

   arc_begin = -PI;
   arc_end   = PI;

   return;
}

@q ** (2) Copy constructor.  @>
@
@<Declare |Superellipse| functions@>=
Superellipse(const Superellipse &s) 
{
   operator=(s);
   return;
   
}  /* End of |Superellipse| copy constructor definition  */


@q ** (2) Destructor.  @>
@
@<Declare |Superellipse| functions@>=
~Superellipse(void);


@
@<Define |Superellipse| functions@>=
Superellipse::~Superellipse(void)
{
   return;
}

@q * (1) Assignment. @>
@* Assignment.
@^\cofunc{Superellipse}{=}@>

\LOG
\initials{LDF 2022.04.28.}
Added this funtion.
\ENDLOG 

@q ** (2) Declaration  @>

@<Declare |Superellipse| functions@>=

Superellipse&
operator=(const Superellipse& e);

@q ** (2) Definition  @>
@
@<Define |Superellipse| functions@>= 

Superellipse&
Superellipse::operator=(const Superellipse& s)
{
  if (this == &s)  /* \initials{LDF 2022.04.28.}  Make sure it's not
                      self-assignment.  */
    return *this;

  Path::operator=(s);

  beta              = s.beta;   /* |Superellipse| members. */
  gamma             = s.gamma; 
  superness_beta    = s.superness_beta;
  superness_gamma   = s.superness_gamma;
  resolution        = s.resolution;
  x_semiaxis_length = s.x_semiaxis_length;
  z_semiaxis_length = s.z_semiaxis_length;
  arc_begin         = s.arc_begin;
  arc_end           = s.arc_end;

  center = s.center;  /* |Ellipse| members. */
  axis_h = s.axis_h;
  axis_v = s.axis_v;
  focus_0 = s.focus_0;
  focus_1 = s.focus_1;

  number_of_points = s.number_of_points; /* |Reg_Cl_Plane_Curve| members. */

  return *this;

} /* End of |Superellipse::operator=| definition  */

@q *** (3) Is |Superellipse|.@> 
@  Is {\bf Superellipse}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) @>

@q **** (4) @>

@<Declare |Superellipse| functions@>=
virtual
bool
is_superellipse(void) const;

@q **** (4) @>
@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_superellipse(void) const
{
   cerr << "In Superellipse::is_superellipse." << endl;

   return true;
}

@q ** (2) Is |Superelliptical|.@> 
@  Is {\bf Superelliptical}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) @>

@<Declare |Superellipse| functions@>=
virtual
bool
is_superelliptical(real x_val = 0.0, 
                   real y_val = 0.0,
                   real beta  = 0.0,
                   real gamma = 0.0) const;

@q *** (3) @>
@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_superelliptical(real x_val, 
                                 real y_val,
                                 real beta,
                                 real gamma) const
{
@q **** (4) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::is_superelliptical'." 
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   if (!is_superellipse() && (x_val <= 0.0 || y_val <= 0.0))
   {
       cerr << "WARNING!  In `Superellipse::is_superelliptical':"
            << endl 
            << "Path (`*this') is not a `Superellipse' and `x_val' and `y_val'"
            << endl 
            << "are both <= 0." << endl 
            << "Can't test.  Exiting function with return value `false'."
            << endl;

       return false;
   }

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   else if (!is_superellipse())
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "In `Superellipse::is_superelliptical':"
               << endl 
               << "Path (`*this') is not a `Superellipse' but `x_val' and `y_val'"
               << endl 
               << "are both > 0:" << endl 
               << "`x_val' == " << x_val << endl 
               << "`y_val' == " << y_val << endl
               << "Will test `Path' (`*this')." << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      /* !! START HERE  LDF 2022.04.26.  */ 

      cerr << "In `Superellipse::is_superelliptical':  Haven't programmed this yet."
           << endl;

   }  /* |else if (!is_superellipse())|  */
 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   else /* |*this| is a |Superellipse|  */
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "In `Superellipse::is_superellistical':"
               << endl 
               << "Path (`*this') is a `Superellipse'.  Will test."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      /* !! START HERE  LDF 2022.04.26.  */ 

      cerr << "In `Superellipse::is_superelliptical':  Haven't programmed this yet."
           << endl;

   } /* |else| (|*this| is a |Superellipse|)  */

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::is_superelliptical' successfully "
           << "with return value `false'." 
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return false;

} /* End of |Superellipse::is_superelliptical| definition  */

@q ** (2) Pseudo-constructor for dynamic allocation.@>
@*1 Pseudo-constructor for dynamic allocation.
\initials{LDF 2022.04.26.}

@q *** (3) Pointer argument.@>
@*2 Pointer argument.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare non-member template functions for |Superellipse|@>=

Superellipse* 
create_new(const Superellipse* s, Scanner_Node scanner_node);

@q *** (3) Reference argument.@>
@*2 Reference argument.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare non-member template functions for |Superellipse|@>=
Superellipse* 
create_new(const Superellipse& e, Scanner_Node scanner_node);

@q ** (2) Generate path.  @>

@ Generate path.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Superellipse| functions@>=
int
generate_path(Scanner_Node scanner_node = 0);

@q **** (4) Definition @>
@
@<Define |Superellipse| functions@>=
int
Superellipse::generate_path(Scanner_Node scanner_node)
{
@q ***** (5) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::generate_path'."
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   int status = 0;
   int status1 = 0;

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if LDF_REAL_DOUBLE
    if (beta < 0)
       beta = fabs(beta);

    if (gamma < 0)
       gamma = fabs(gamma);

    if (superness_beta < 0)
       superness_beta = fabs(superness_beta);

    if (superness_gamma < 0)
       superness_gamma = fabs(superness_gamma);
#else 
    if (beta < 0)
       beta = fabsf(beta);

    if (gamma < 0)
       gamma = fabsf(gamma);

    if (superness_beta < 0)
       superness_beta = fabsf(superness_beta);

    if (superness_gamma < 0)
       superness_gamma = fabsf(superness_gamma);
#endif

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

    Point p0;

    real step = (arc_end - arc_begin) / resolution;

    real two_over_beta = (2.0F / beta);
    real two_over_gamma = (2.0F / gamma);

    real x;
    real z;

    real a = x_semiaxis_length; 
    real b = z_semiaxis_length;

#if DEBUG_COMPILE
    if (DEBUG)
    { 
        cerr << "a               == " << a << endl
             << "b               == " << b << endl 
             << "beta            == " << beta << endl 
             << "gamma           == " << gamma << endl 
             << "two_over_beta   == " << two_over_beta << endl
             << "two_over_gamma  == " << two_over_gamma << endl
             << "superness_beta  == " << superness_beta << endl 
             << "superness_gamma == " << superness_gamma << endl 
             << "resolution      == " << resolution << endl 
             << "step            == " << step << endl
             << "arc_begin       == " << arc_begin << endl 
             << "arc_end         == " << arc_end << endl 
             << endl;

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 

    }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

    Path::clear();

    bool first_time = true;

    int sign_x =  1;
    int sign_z = -1;
  
    real cos_t;
    real sin_t;

    operator+=("..");

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

    for (real t = arc_begin; t <= arc_end; t += step)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "t == " << t << endl
                << "cosf(t) == " << cosf(t) << endl
                << "sinf(t) == " << sinf(t) << endl
                << "(powf(cosf(t), two_over_beta)) == " 
                << (powf(cosf(t), two_over_beta)) 
                << endl
                << "powf(sinf(t), two_over_gamma) == " 
                << powf(sinf(t), two_over_gamma) 
                << endl
                << "two_over_beta == " << two_over_beta << endl
                << "two_over_gamma == " << two_over_gamma << endl;

       }  
#endif /* |DEBUG_COMPILE|  */@; 

       cos_t = cosf(t);
    
       if (cos_t < 0)
       {
          sign_x = -1;
          cos_t *= -1;
       }
       else
          sign_x = 1;

       sin_t = sinf(t);
    
       if (sin_t < 0)
       {
          sign_z = -1;
          sin_t *= -1;
       }
       else
          sign_z = 1;
#if LDF_REAL_DOUBLE
       x = sign_x * a * sgn(cos_t) * pow(fabs(cos_t), two_over_beta);
       z = sign_z * b * sgn(sin_t) * pow(fabs(sin_t), two_over_gamma);
#else
       x = sign_x * a * sgn(cos_t) * powf(fabsf(cos_t), two_over_beta);
       z = sign_z * b * sgn(sin_t) * powf(fabsf(sin_t), two_over_gamma);
#endif 

#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "x == " << x << endl
               << "z == " << z << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@; 
  
       status = fpclassify(x);
       status1 = fpclassify(z);

       if (   (status  == FP_NORMAL || status  == FP_ZERO) 
           && (status1 == FP_NORMAL || status1 == FP_ZERO))
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "x and z are both normal or zero." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
       }
       else if ((status == FP_NORMAL || status == FP_ZERO) && status1 == FP_SUBNORMAL)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "x is normal or zero but z is subnormal.  Setting z to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          z = 0.0;
       }
       else if (status == FP_SUBNORMAL && (status1 == FP_NORMAL || status1 == FP_ZERO))
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "z is normal or zero but x is subnormal.  Setting x-coordinate to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          x = 0.0;
       }
       else if (status == FP_SUBNORMAL || status == FP_SUBNORMAL)
       {
#if DEBUG_COMPILE
          if (DEBUG) 
          { 
             cerr << "x and z are subnormal.  Setting x- and z-coordinates to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          x = z = 0.0;
       }
       else if (status == FP_NAN && (1 - sinf(t)) < .1)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "status == FP_NAN but (1 - sinf(t)) < .1.  Setting x to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          x = 0.0;
       }
       else if (status1 == FP_NAN && (1 - cosf(t)) < .1)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "status1 == FP_NAN but (1 - cost(t)) < .1.  Setting z to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          z = 0.0;
       }
       else if (fabs(x) < .00001 || fabs(z) < .00001)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "Absolute value of x and/or z is < .00001."
                  << "Setting the small cooordinate or coordinatess to 0.0." 
                  << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          if (fabs(x) < .00001)
             x = 0.0;

          if (fabs(z) < .00001)
             z = 0.0;
       }
       else
       {
           cerr << "WARNING!  In `Superellipse::generate_path':" << endl 
                << "x- and/or z-coordinate is not normal, subnormal or zero:" << endl;

           if (status == FP_NAN)
              cerr << "x is not a number." << endl;
           else if (status == FP_INFINITE)
              cerr << "x is positive or negative infinity." << endl;

           cerr << "Skipping and continuing." << endl << endl; 

           continue;
       }

       p0.set(x, 0, z);
       operator+=(p0); 

       if (arc_begin == -PI && arc_end == PI)
          set_cycle(true);
       else 
          set_cycle(false);

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@;   

@q ****** (6) @>

    } /* |for| */


@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if 0 
   show("*this:");
#endif 

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::generate_path' successfully "
           << "with return value 0."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

} /* End of |Superellipse::generate_path| definition  */

@q ** (2) Sgn.  @>

@ Sgn.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Superellipse| functions@>=
static
int 
sgn(real r);

@q **** (4) Definition @>
@
@<Define |Superellipse| functions@>=
int 
Superellipse::sgn(real r)
{
   if (r < 0)
      return -1;
   else if (r == 0)
      return 0;
   else
      return 1;
}


@q ** (2) Show.  @>

@ Show.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Superellipse| functions@>=
virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1,
     int show_connectors = 0) const;

@q **** (4) Definition @>
@
@<Define |Superellipse| functions@>=
void 
Superellipse::show(string text, char coords,
                   const bool do_persp, const bool do_apply,
                   Focus* f, const unsigned short proj,
                   const real factor,
                   int show_connectors) const
{
@q ***** (5) @>

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::show'."
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

   cerr << "beta               == " << beta << endl
        << "gamma              == " << gamma << endl
        << "superness_beta     == " << superness_beta << endl
        << "superness_gamma    == " << superness_gamma << endl
        << "x_semiaxis_length  == " << x_semiaxis_length  << endl
        << "z_semiaxis_length  == " << z_semiaxis_length  << endl
        << "resolution         == " << resolution << endl
        << "x_semiaxis_length  == " << x_semiaxis_length << endl
        << "z_semiaxis_length  == " << z_semiaxis_length << endl
        << "arc_begin          == " << arc_begin << endl 
        << "arc_end            == " << arc_end << endl;


   Path::show("Path:");

   cerr << endl;

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::show' successfully "
           << "with return value 0."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return;

} /* End of |Superellipse::show| definition  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2022.04.26.}

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Superellipse| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return SUPERELLIPSE_TYPE;
}

@q ** Is cubic.@>
@ Is cubic.
@^\cfunc{Superellipse}{is\_cubic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Superellipse| functions@>=
virtual
bool
is_cubic() const;

@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_cubic() const
{
  return false;
}

@q ** Is quartic.@>
@ Is quartic.
@^\cfunc{Superellipse}{is\_quartic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Superellipse| functions@>=
virtual
bool
is_quartic() const;

@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_quartic() const
{
  return false;
}


@q ** (2) Is |Ellipse|.@> 
@*1 Is {\bf Ellipse}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@<Declare |Superellipse| functions@>=
virtual
inline
bool
is_ellipse(void) const 
{
   return true;
}

@q ** (2) Is elliptical.@>
@*1 Is elliptical.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@<Declare |Superellipse| functions@>=
virtual
bool
is_elliptical(Scanner_Node scanner_node) const;

@q **** (4) Definition.@> 
  
@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_elliptical(Scanner_Node scanner_node) const
{
   return false;

} /* End of |Superellipse::is_elliptical| definition.  */

@q ** (2) Get rectangle.  @>
@ Get rectangle.
\initials{LDF 2022.04.27.}

\LOG
\initials{LDF 2022.04.27.}
Added this function.
\ENDLOG 

@q *** (3) Declaration @>

@<Declare |Superellipse| functions@>=
int
get_rectangle(Rectangle *r, Scanner_Node scanner_node = 0);

@q *** (3) Definition @>
@
@<Define |Superellipse| functions@>=
int
Superellipse::get_rectangle(Rectangle *r, Scanner_Node scanner_node)
{
@q **** (4) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::get_rectangle'." << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   int s = points.size();

   if (s < 4)
   {
       cerr << "ERROR!  In `Superellipse::get_rectangle':" << endl 
            << "`points.size()' < 4:  `points.size()' == " << s
            << endl 
            << "Can't get `Rectangle'." << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;
   }

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr << "`points.size()' == " << s << " (>= 4)" 
            << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 


@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   if (arc_begin > -PI || arc_end < PI)
   {
       /* !! TODO:  LDF 2022.04.28.  Program this case.  */

       cerr << "ERROR!  In `Superellipse::get_rectangle':" << endl 
            << "`arc_begin' > -pi and/or `arc_end' < pi:"
            << endl 
            << "`arc_begin' == " << arc_begin << ", "
            << "`arc_end' == " << arc_end << endl
            << "Haven't programmed this case yet." << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;
   }

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   Point p0 = *points[0];
   Point p1 = *points[s/4];
   Point p2 = *points[s/2];
   Point p3 = *points[3*s/4];

   Point p4 = (p0 - center);
   p4.shift(p1);

   Point p5 = (p1 - center);
   p5.shift(p2);

   Point p6 = p5;
   p6.rotate(p0, p2, 180);

   Point p7 = p6;
   p7.rotate(p1, p3, 180);

   r->set(p4, p5, p6, p7);

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::get_rectangle' successfully with return value 0." 
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

} /* End of |Superellipse::get_rectangle| definition */

@q ** (2) Reset arc.  @>
@ Reset arc.
\initials{LDF 2022.04.28.}

\LOG
\initials{LDF 2022.04.28.}
Added this funtion.
\ENDLOG 

@q *** (3) Declaration @>

@<Declare |Superellipse| functions@>=
int
reset_arc(real begin = -1, 
          real end = -1, 
          real resolution = -1, 
          Scanner_Node scanner_node = 0);


@q *** (3) Definition @>
@
@<Define |Superellipse| functions@>=
int
Superellipse::reset_arc(real begin, 
                        real end, 
                        real resolution, 
                        Scanner_Node scanner_node)
{
@q **** (4) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::reset_arc'." << endl
           << "`begin' == " << begin << endl 
           << "`end' == " << end << endl 
           << "`resolution' == " << resolution << endl;

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::reset_arc' successfully with return value 0." 
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

} /* End of |Superellipse::reset_arc| definition */



@q * (1) Putting Superellipse together.@>
@* Putting {\bf Superellipse} together.
\initials{LDF 2022.04.26.}

This is what's compiled.
\initials{LDF 2022.04.26.}

@c
@<Include files@>@;
@<Declare |class Superellipse|@>@;
@<Define |Superellipse| functions@>@;
@<Declare non-member template functions for |Superellipse|@>@;

@ This is what's written to \filename{ellipses.h}.
\initials{LDF 2022.04.26.}

@(sprellps.h@>=
@<Declare |class Superellipse|@>@;
@<Declare non-member template functions for |Superellipse|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
