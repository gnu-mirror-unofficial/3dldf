@q sprellps.web @>
    
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2022 The Free Software Foundation, Inc.                    @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * Superellipse.@>
@** Superellipse\quad ({\tt sprellps\PERIOD web}).\hfil

\LOG
\initials{LDF 2022.04.26.}
Created this file.
\ENDLOG 

@f Superellipse Path

@q * Include files.@>

@ Include files.
\initials{LDF 2022.04.26.}

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
  
@q * (1) |class Superellipse|.  @>

@ |class Superellipse|.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this class declaration.
\ENDLOG 

@<Declare |class Superellipse|@>=

class Superellipse : public Ellipse
{
   friend int yyparse(yyscan_t);

   protected:

      real beta; 
      real gamma; 

      real superness_beta; 
      real superness_gamma; 

      int resolution; 
  
      real x_semiaxis_length; 
      real z_semiaxis_length;

      Path *bounding_path;

    public:

       @<Declare |Superellipse| functions@>@;

};

@q ** (2) |Superellipse| functions.  @>
@ |Superellipse| functions.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this section.
\ENDLOG 


@q *** (3) Default constructor.  @>

@ Default constructor.
\initials{LDF 2022.04.26.}

The values for |beta|, |gamma|, |superness_beta| and |superness_gamma| are negative
in order to be able to test whether they've been set by a parser rule.
As of 2022.04.26, the only parser rule that creates a |Superellipse| is 
\§path primary> $\longrightarrow$ \.{SUPERELLIPSE} \§superellipse option list>.
\par
If one of these data members is not set by an option, then it's reset to its absolute value, 
which is therefore it's default value.  The values chosen correspond to the superellipse
popularized by by Piet Hein and used, among other things, for his ``superegg'' toy.
See {\it The METAFONTbook}, p.~126 and Gardner, Martin, {\it Mathematical Carnival\/} 
(New York: Knopf, 1975), pp.~240--254.

The following is Emacs-Lisp code for calculating $\beta$ and $\superness$ 
when the other quantity is known.
\initials{LDF 2022.04.26.}

\begingroup
\obeylines
\obeyspaces
\tt 
;; set beta with superness known.
(progn
   ;; (setq superness 0.0)
   ;; (setq superness 2.5)
   ;; (setq superness 0.5)
    (setq superness 0.75)
   ;; (setq superness 0.757858283255199) ;; --> beta == 2.5, Piet Hein's value for the superegg.
   ;; (setq superness 1.0)               ;; --> beta == infinity (rectangle)
   (setq beta (/ -1 (/ (log superness) (log 2))))
)

;; set superness with beta known.
(progn
   (setq beta 0.757858283255199)
   (setq superness (/ -1 (/ (log beta) (log 2))))
)
\endgroup

!!START HERE:  LDF 2022.04.26.  Add explanation of result of different values for $\beta$.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare |Superellipse| functions@>=
Superellipse(void) 
{
   shape_type = SUPERELLIPSE_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   line_switch = false;
   cycle_switch = true;
   pen_vector = 0; 
   dash_pattern_vector = 0;

   beta              = -0.757858283255199; 
   gamma             = -0.757858283255199;
   superness_beta    = -2.5;
   superness_gamma   = -2.5;
   x_semiaxis_length = 1;
   z_semiaxis_length = 1;

   resolution        = 32;

   bounding_path = static_cast<Path*>(0);
   
   return;
}

@q *** (3) Is |Superellipse|.@> 
@  Is {\bf Superellipse}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) @>

@<Declare |Superellipse| functions@>=
virtual
inline
bool
is_superellipse(void) const {return true;}

@q ** (2) Is |Superelliptical|.@> 
@  Is {\bf Superelliptical}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) @>

@<Declare |Superellipse| functions@>=
virtual
bool
is_superelliptical(real x_val = 0.0, 
                   real y_val = 0.0,
                   real beta  = 0.0,
                   real gamma = 0.0) const;

@q *** (3) @>
@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_superelliptical(real x_val, 
                                 real y_val,
                                 real beta,
                                 real gamma) const
{
@q **** (4) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::is_superelliptical'." 
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   if (!is_superellipse() && (x_val <= 0.0 || y_val <= 0.0))
   {
       cerr << "WARNING!  In `Superellipse::is_superelliptical':"
            << endl 
            << "Path (`*this') is not a `Superellipse' and `x_val' and `y_val'"
            << endl 
            << "are both <= 0." << endl 
            << "Can't test.  Exiting function with return value `false'."
            << endl;

       return false;
   }

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   else if (!is_superellipse())
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "In `Superellipse::is_superelliptical':"
               << endl 
               << "Path (`*this') is not a `Superellipse' but `x_val' and `y_val'"
               << endl 
               << "are both > 0:" << endl 
               << "`x_val' == " << x_val << endl 
               << "`y_val' == " << y_val << endl
               << "Will test `Path' (`*this')." << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      /* !! START HERE  LDF 2022.04.26.  */ 

      cerr << "In `Superellipse::is_superelliptical':  Haven't programmed this yet."
           << endl;

   }  /* |else if (!is_superellipse())|  */
 

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

   else /* |*this| is a |Superellipse|  */
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "In `Superellipse::is_superellistical':"
               << endl 
               << "Path (`*this') is a `Superellipse'.  Will test."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      /* !! START HERE  LDF 2022.04.26.  */ 

      cerr << "In `Superellipse::is_superelliptical':  Haven't programmed this yet."
           << endl;

   } /* |else| (|*this| is a |Superellipse|)  */

@q **** (4) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::is_superelliptical' successfully "
           << "with return value `false'." 
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return false;

} /* End of |Superellipse::is_superelliptical| definition  */

@q ** (2) Pseudo-constructor for dynamic allocation.@>
@*1 Pseudo-constructor for dynamic allocation.
\initials{LDF 2022.04.26.}

@q *** (3) Pointer argument.@>
@*2 Pointer argument.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare non-member template functions for |Superellipse|@>=

Superellipse* 
create_new(const Superellipse* s, Scanner_Node scanner_node);

@q *** (3) Reference argument.@>
@*2 Reference argument.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG 

@<Declare non-member template functions for |Superellipse|@>=
Superellipse* 
create_new(const Superellipse& e, Scanner_Node scanner_node);

@q ** (2) Generate path.  @>

@ Generate path.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Superellipse| functions@>=
int
generate_path(Scanner_Node scanner_node = 0);

@q **** (4) Definition @>
@
@<Define |Superellipse| functions@>=
int
Superellipse::generate_path(Scanner_Node scanner_node)
{
@q ***** (5) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::generate_path'."
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   int status = 0;
   int status1 = 0;

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if LDF_REAL_DOUBLE
    if (beta < 0)
       beta = fabs(beta);

    if (gamma < 0)
       gamma = fabs(gamma);

    if (superness_beta < 0)
       superness_beta = fabs(superness_beta);

    if (superness_gamma < 0)
       superness_gamma = fabs(superness_gamma);
#else 
    if (beta < 0)
       beta = fabsf(beta);

    if (gamma < 0)
       gamma = fabsf(gamma);

    if (superness_beta < 0)
       superness_beta = fabsf(superness_beta);

    if (superness_gamma < 0)
       superness_gamma = fabsf(superness_gamma);
#endif

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

    Point p0;

    real step = 2 * PI / resolution;

    float two_over_beta = (2.0F / beta);

    real x;
    real z;

    real a = x_semiaxis_length; 
    real b = z_semiaxis_length;

#if DEBUG_COMPILE
    if (DEBUG)
    { 
        cerr << "a              == " << a << endl
             << "b              == " << b << endl 
             << "beta           == " << beta << endl 
             << "two_over_beta  == " << two_over_beta << endl
             << "superness_beta == " << superness_beta << endl 
             << "resolution     == " << resolution << endl 
             << "step           == " << step << endl
             << endl;
    }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

    Path::clear();

    bool first_time = true;

    int sign_x =  1;
    int sign_z = -1;
  
    real cos_f;
    real sin_f;

    operator+=("..");

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

    for (float f = -PI; f <= PI; f += step)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "f == " << f << endl
                << "cosf(f) == " << cosf(f) << endl
                << "sinf(f) == " << sinf(f) << endl
                << "(powf(cosf(f), two_over_beta)) == " << (powf(cosf(f), two_over_beta)) << endl
                << "powf(sinf(f), two_over_beta) == " << powf(sinf(f), two_over_beta) << endl
                << "two_over_beta == " << two_over_beta << endl;

       }  
#endif /* |DEBUG_COMPILE|  */@; 

       cos_f = cosf(f);
    
       if (cos_f < 0)
       {
          sign_x = -1;
          cos_f *= -1;
       }
       else
          sign_x = 1;

       sin_f = sinf(f);
    
       if (sin_f < 0)
       {
          sign_z = -1;
          sin_f *= -1;
       }
       else
          sign_z = 1;

       x = sign_x * a * powf(cos_f, two_over_beta);
       z = sign_z * b * powf(sin_f, two_over_beta);

#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "x == " << x << endl
               << "z == " << z << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@; 

  
       status = fpclassify(static_cast<float>(x));
       status1 = fpclassify(static_cast<float>(z));

       if (   (status  == FP_NORMAL || status  == FP_ZERO) 
           && (status1 == FP_NORMAL || status1 == FP_ZERO))
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "x and z are both normal or zero." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
       }
       else if ((status == FP_NORMAL || status == FP_ZERO) && status1 == FP_SUBNORMAL)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "x is normal or zero but z is subnormal.  Setting z to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          z = 0.0;
       }
       else if (status == FP_SUBNORMAL && (status1 == FP_NORMAL || status1 == FP_ZERO))
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "z is normal or zero but x is subnormal.  Setting x-coordinate to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          x = 0.0;
       }
       else if (status == FP_SUBNORMAL || status == FP_SUBNORMAL)
       {
#if DEBUG_COMPILE
          if (DEBUG) 
          { 
             cerr << "x and z are subnormal.  Setting x- and z-coordinates to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          x = z = 0.0;
       }
       else if (status == FP_NAN && (1 - sinf(f)) < .1)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "status == FP_NAN but (1 - sinf(f)) < .1.  Setting x to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          x = 0.0;
       }
       else if (status1 == FP_NAN && (1 - cosf(f)) < .1)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "status1 == FP_NAN but (1 - cost(f)) < .1.  Setting z to 0.0." << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
          z = 0.0;
       }
       else if (fabs(x) < .00001 || fabs(z) < .00001)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "Absolute value of x and/or z is < .00001."
                  << "Setting the small cooordinate or coordinatess to 0.0." 
                  << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 

          if (fabs(x) < .00001)
             x = 0.0;

          if (fabs(z) < .00001)
             z = 0.0;
       }
       else
       {
           cerr << "WARNING!  In `Superellipse::generate_path':" << endl 
                << "x- and/or z-coordinate is not normal, subnormal or zero:" << endl;

           if (status == FP_NAN)
              cerr << "x is not a number." << endl;
           else if (status == FP_INFINITE)
              cerr << "x is positive or negative infinity." << endl;

           cerr << "Skipping and continuing." << endl << endl; 

           continue;
       }

       p0.set(x, 0, z);
       operator+=(p0); 
       set_cycle();

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@;   

@q ****** (6) @>

    } /* |for| */


@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if 0 
   show("*this:");
#endif 

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::generate_path' successfully "
           << "with return value 0."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

} /* End of |Superellipse::generate_path| definition  */

@q ** (2) Show.  @>

@ Show.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Superellipse| functions@>=
virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1,
     int show_connectors = 0) const;

@q **** (4) Definition @>
@
@<Define |Superellipse| functions@>=
void 
Superellipse::show(string text, char coords,
                   const bool do_persp, const bool do_apply,
                   Focus* f, const unsigned short proj,
                   const real factor,
                   int show_connectors) const
{
@q ***** (5) @>

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ 
   if (DEBUG)
   { 
      cerr << "Entering `Superellipse::show'."
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

   cerr << "beta               == " << beta << endl
        << "gamma              == " << gamma << endl
        << "superness_beta     == " << superness_beta << endl
        << "superness_gamma    == " << superness_gamma << endl
        << "x_semiaxis_length  == " << x_semiaxis_length  << endl
        << "z_semiaxis_length  == " << z_semiaxis_length  << endl
        << "resolution         == " << resolution << endl
        << "x_semiaxis_length  == " << x_semiaxis_length << endl
        << "z_semiaxis_length  == " << z_semiaxis_length << endl;

   Path::show("Path:");

   if (bounding_path == 0)
      cerr << "bounding_path is NULL." << endl;
   else 
   {
      cerr << "bounding_path is non-NULL:" << endl;
      bounding_path->show("bounding_path:");
   }
  
   cerr << endl;

@q ***** (5) @>
@
@<Define |Superellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Superellipse::show' successfully "
           << "with return value 0."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return;

} /* End of |Superellipse::show| definition  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2022.04.26.}

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Superellipse| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return SUPERELLIPSE_TYPE;
}

@q ** Is cubic.@>
@ Is cubic.
@^\cfunc{Superellipse}{is\_cubic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Superellipse| functions@>=
virtual
bool
is_cubic() const;

@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_cubic() const
{
  return false;
}

@q ** Is quartic.@>
@ Is quartic.
@^\cfunc{Superellipse}{is\_quartic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Superellipse| functions@>=
virtual
bool
is_quartic() const;

@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_quartic() const
{
  return false;
}


@q ** (2) Is |Ellipse|.@> 
@*1 Is {\bf Ellipse}.
\initials{LDF 2022.04.26.}

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@<Declare |Superellipse| functions@>=
virtual
inline
bool
is_ellipse(void) const 
{
   return true;
}

@q ** (2) Is elliptical.@>
@*1 Is elliptical.

\LOG
\initials{LDF 2022.04.26.}
Added this function.
\ENDLOG

@<Declare |Superellipse| functions@>=
virtual
bool
is_elliptical(Scanner_Node scanner_node) const;

@q **** (4) Definition.@> 
  
@
@<Define |Superellipse| functions@>=
bool
Superellipse::is_elliptical(Scanner_Node scanner_node) const
{
   return false;

} /* End of |Superellipse::is_elliptical| definition.  */


@q * (1) Putting Superellipse together.@>
@* Putting {\bf Superellipse} together.
\initials{LDF 2022.04.26.}

This is what's compiled.
\initials{LDF 2022.04.26.}

@c
@<Include files@>@;
@<Declare |class Superellipse|@>@;
@<Define |Superellipse| functions@>@;
@<Declare non-member template functions for |Superellipse|@>@;

@ This is what's written to \filename{ellipses.h}.
\initials{LDF 2022.04.26.}

@(sprellps.h@>=
@<Declare |class Superellipse|@>@;
@<Declare non-member template functions for |Superellipse|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
