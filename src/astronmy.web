@q astronmy.web  @>
@q Created by Laurence Finston (LDF) Fri 28 May 2021 12:36:22 AM CEST @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2021 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Astronomy.@>
@** Astronomy\quad ({\tt astronmy\PERIOD web}).\hfil

\LOG
\initials{LDF 2021.05.28.}
Created this file.
\ENDLOG 

\immediate\write\functexifile{File:  astronmy.web^^J}

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"
#include "imetfncs.h++"
#include "deftfncs.h++"
#include "sctpcrt.h++"  
#include "sctpfncs.h++"  
#include "prrfnc0.h++"

@q * (1) Star class definition.@>
@* {\bf Star} class definition.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this |class| definition.
\ENDLOG

@q ** (2) Code.@> 

@<Declare |class Star|@>=

class Star
{

   friend Scanner_Type;
   friend bool compare_star_constant_name(Star *, Star *);
   friend bool compare_common_name(Star *s, Star *);
   friend bool compare_flamsteed_designation_number(Star *s, Star *);
   friend bool compare_bayer_designation_greek_letter(Star *s, Star *);
   friend bool compare_bayer_designation_greek_letter_tex(Star *s, Star *);
   friend bool compare_bs_hr_number(Star *s, Star *);
   friend bool compare_bs_number(Star *s, Star *);
   friend bool compare_hr_number(Star *s, Star *);
   friend bool compare_approx_rank_apparent_magnitude(Star *s, Star *);
   friend bool compare_apparent_magnitude(Star *s, Star *); 
   friend bool compare_absolute_magnitude(Star *s, Star *);     
   friend bool compare_constellation_abbreviation(Star *s, Star *);
   friend bool compare_constellation_full_name(Star *s, Star *);
   friend bool compare_constellation_name_genitive(Star *s, Star *);
   friend bool compare_constellation_number(Star *s, Star *);
   friend bool compare_right_ascension_hours(Star *s, Star *t);
   friend bool compare_right_ascension_minutes(Star *s, Star *t);
   friend bool compare_right_ascension_seconds(Star *s, Star *t);
   friend bool compare_right_ascension_decimal_hours(Star *s, Star *t);
   friend bool compare_right_ascension_decimal_degrees(Star *s, Star *t);
   friend bool compare_declination_degrees(Star *s, Star *t);
   friend bool compare_declination_minutes(Star *s, Star *t);
   friend bool compare_declination_seconds(Star *s, Star *t);
   friend bool compare_declination_decimal_degrees(Star *s, Star *t);
   friend bool compare_is_binary(Star *s, Star *t);
   friend int plot_star_func(Star *s, Point* p, real radius, Scanner_Node scanner_node);

   friend int yyparse(yyscan_t);

   friend int Scan_Parse::get_stars_func(Scanner_Node, vector<Star*>&);
   friend int Scan_Parse::plot_stars_func(Scanner_Node);
   friend int Scan_Parse::show_stars_func(Scanner_Node);

   protected:

      string star_constant_name;

      string common_name;                                   
      string greek_name;                                    
      string latin_name;                                    
      string arabic_name;                                   
      int flamsteed_designation_number;                     
      string bayer_designation_greek_letter;                
      string bayer_designation_greek_letter_tex;            
      string bayer_designation_extension;
      int bs_hr_number;                                     
      int approx_rank_apparent_magnitude;                   
      real apparent_magnitude;                              
      real absolute_magnitude;                              
      bool apparent_magnitude_varies;                       
      bool absolute_magnitude_varies;                       
      string constellation_abbreviation;                    
      string constellation_full_name;                       
      string constellation_name_genitive;                   
      int constellation_number;                             
      int right_ascension_hours;                            
      int right_ascension_minutes;                          
      real right_ascension_seconds;                         
      real right_ascension_decimal_hours;                   
      real right_ascension_decimal_degrees;                 
      int declination_degrees;                              
      int declination_minutes;                              
      real declination_seconds;                             
      real declination_decimal_degrees;                     
      int is_binary;                                        
      int is_multiple;
      int is_binary_component;
      int is_eclipsing_binary; 
      string notes;                                                              

   public:

      @<Declare |static| |class Star| data members@>@;

      @<Declare |Star| functions@>@;
};

@q ** (2) Static member variable declarations and initializations.@>
@*1 Static member variable declarations and initializations.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@<Declare |static| |class Star| data members@>=

@q *** (3) Code.@> 
@
@<Initialize |static| |class Star| data members@>=

@q ** (2) |struct Stars_Where_Option_Struct| declaration.@>
@*1 |struct Stars_Where_Option_Struct| declaration.
\initials{LDF 2021.06.21.}

\LOG
\initials{LDF 2021.06.21.}
Added this section.
\ENDLOG

@<Declare |struct Stars_Where_Option_Struct|@>=

struct Stars_Where_Option_Struct
{
   int  conjunction;
   int  field;
   int  relation;
   int  int_value;
   real real_value;
   bool bool_value;
   string comparison_string;

   Stars_Where_Option_Struct(void)
   {
      conjunction       = 0;  
      field             = 0;
      relation          = 0;
      int_value         = 0;
      real_value        = 0.0;
      bool_value        = false;
      comparison_string = "";
   }
   ~Stars_Where_Option_Struct(void)
   {
      return;
   }

   void show(string s = "");

   void
   operator=(const Stars_Where_Option_Struct &w)
   {
      conjunction       = w.conjunction;
      field             = w.field;            
      relation          = w.relation;         
      int_value         = w.int_value;            
      real_value        = w.real_value;            
      bool_value        = w.bool_value;            
      comparison_string = w.comparison_string;
      return;
   }

};

@q *** (3) Show.@>
@ Show.

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@<Define |struct Stars_Where_Option_Struct| functions@>=

void
Stars_Where_Option_Struct::show(string s)
{
   using namespace Scan_Parse;

   if (s == "")
      cerr << "Stars_Where_Option_Struct:" << endl;
   else
      cerr << s << endl;

   cerr << "conjunction       == " << conjunction;
 
   if (conjunction > 0)
      cerr << " == " << name_map[conjunction];

   cerr << endl
        << "field             == " << field;

   if (field == STARS_STAR_CONSTANT_NAME)
      cerr << " == STARS_STAR_CONSTANT_NAME" << endl;

   if (field == STARS_COMMON_NAME)
      cerr << " == STARS_COMMON_NAME" << endl;

   else if (field == STARS_GREEK_NAME)
      cerr << " == STARS_GREEK_NAME" << endl;

   else if (field == STARS_LATIN_NAME)
      cerr << " == STARS_LATIN_NAME" << endl;

   else if (field == STARS_ARABIC_NAME)
      cerr << " == STARS_ARABIC_NAME" << endl;
   
   else if (field == STARS_FLAMSTEED_DESIGNATION_NUMBER)
      cerr << " == STARS_FLAMSTEED_DESIGNATION_NUMBER" << endl;

   else if (field == STARS_BAYER_DESIGNATION_GREEK_LETTER)
      cerr << " == STARS_BAYER_DESIGNATION_GREEK_LETTER" << endl;

   else if (field == STARS_BAYER_DESIGNATION_GREEK_LETTER_TEX)
      cerr << " == STARS_BAYER_DESIGNATION_GREEK_LETTER_TEX" << endl;

   else if (field == STARS_BS_HR_NUMBER)
      cerr << " == STARS_BS_HR_NUMBER" << endl;

   else if (field == STARS_BS_NUMBER)
      cerr << " == STARS_BS_NUMBER" << endl;

   else if (field == STARS_HR_NUMBER)
      cerr << " == STARS_HR_NUMBER" << endl;

   else if (field == STARS_APPROX_RANK_APPARENT_MAGNITUDE)
      cerr << " == STARS_APPROX_RANK_APPARENT_MAGNITUDE" << endl;

   else if (field == STARS_APPARENT_MAGNITUDE)
      cerr << " == STARS_APPARENT_MAGNITUDE" << endl;

   else if (field == STARS_ABSOLUTE_MAGNITUDE)
      cerr << " == STARS_ABSOLUTE_MAGNITUDE" << endl;

   else if (field == STARS_APPARENT_MAGNITUDE_VARIES)
      cerr << " == STARS_APPARENT_MAGNITUDE_VARIES" << endl;

   else if (field == STARS_ABSOLUTE_MAGNITUDE_VARIES)
      cerr << " == STARS_ABSOLUTE_MAGNITUDE_VARIES" << endl;

   else if (field == STARS_CONSTELLATION_ABBREVIATION)
      cerr << " == STARS_CONSTELLATION_ABBREVIATION" << endl;

   else if (field == STARS_CONSTELLATION_FULL_NAME)
      cerr << " == STARS_CONSTELLATION_FULL_NAME" << endl;

   else if (field == STARS_CONSTELLATION_NAME_GENITIVE)
      cerr << " == STARS_CONSTELLATION_NAME_GENITIVE" << endl;

   else if (field == STARS_CONSTELLATION_NUMBER)
      cerr << " == STARS_CONSTELLATION_NUMBER" << endl;

   else if (field == STARS_RIGHT_ASCENSION_HOURS)
      cerr << " == STARS_RIGHT_ASCENSION_HOURS" << endl;

   else if (field == STARS_RIGHT_ASCENSION_MINUTES)
      cerr << " == STARS_RIGHT_ASCENSION_MINUTES" << endl;

   else if (field == STARS_RIGHT_ASCENSION_SECONDS)
      cerr << " == STARS_RIGHT_ASCENSION_SECONDS" << endl;

   else if (field == STARS_RIGHT_ASCENSION_DECIMAL_HOURS)
      cerr << " == STARS_RIGHT_ASCENSION_DECIMAL_HOURS" << endl;

   else if (field == STARS_RIGHT_ASCENSION_DECIMAL_DEGREES)
      cerr << " == STARS_RIGHT_ASCENSION_DECIMAL_DEGREES" << endl;

   else if (field == STARS_DECLINATION_DEGREES)
      cerr << " == STARS_DECLINATION_DEGREES" << endl;

   else if (field == STARS_DECLINATION_MINUTES)
      cerr << " == STARS_DECLINATION_MINUTES" << endl;

   else if (field == STARS_DECLINATION_SECONDS)
      cerr << " == STARS_DECLINATION_SECONDS" << endl;

   else if (field == STARS_DECLINATION_DECIMAL_DEGREES)
      cerr << " == STARS_DECLINATION_DECIMAL_DEGREES" << endl;

   else if (field == STARS_RIGHT_ASCENSION)
      cerr << " == STARS_RIGHT_ASCENSION" << endl;

   else if (field == STARS_DECLINATION)
      cerr << " == STARS_DECLINATION" << endl;

   else if (field == STARS_IS_BINARY)
      cerr << " == STARS_IS_BINARY" << endl;

   else 
      cerr << " WARNING!  Unknown field." << endl;

   cerr << "relation          == "   << relation << " == " << name_map[relation] << endl
        << "int_value         == "   << int_value << endl
        << "real_value        == "   << real_value << endl
        << "bool_value        == "   << bool_value << endl
        << "comparison_string == \"" << comparison_string << "\""
        << endl;

} /* End of |Stars_Where_Option_Struct::show| definition */

@q ** (2) |struct Stars_Get_Option_Struct| declaration.@>
@*1 |struct Stars_Get_Option_Struct| declaration.
\initials{LDF 2021.06.21.}

\LOG
\initials{LDF 2021.06.21.}
Added this section.
\ENDLOG

@<Declare |struct Stars_Get_Option_Struct|@>=

struct Stars_Get_Option_Struct
{

   bool         ascending_descending;
   unsigned int fields;
   unsigned int limit;
   unsigned int offset;
   
   vector<unsigned int> order_by_options;
   vector<Stars_Where_Option_Struct> where_options;

   Stars_Get_Option_Struct(void)
   {
      ascending_descending = 0;  /* 0:  ascending. 1:  descending. */
      fields = 0U;
      limit  = 0U;
      offset = 0U;;

      return;
   }  

   ~Stars_Get_Option_Struct(void)
   {
      order_by_options.clear();
      where_options.clear();
      return;
   }   

};

@q ** (2) Global constants.@>
@*1 Global constants.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@<Global constants@>=

@q *** (3)@>
@
@<Declarations for the header file@>=

@q ** (2) |Star| functions.@> 
@*1 {\bf Star} functions.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q *** (3) Constructors and Setting Functions.@>
@*2 Constructors and Setting Functions.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Default Constructor.@> 
@*3 Default Constructor.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Star| functions@>=
Star(void);

@q ***** (5) Definition.  @>

@
@<Define |Star| functions@>= 
Star::Star(void)
{
      star_constant_name = "";
      common_name = "";
      greek_name = "";
      latin_name = "";
      arabic_name = "";
      flamsteed_designation_number = 0;
      bayer_designation_greek_letter = "";
      bayer_designation_greek_letter_tex = "";
      bs_hr_number = 0;
      approx_rank_apparent_magnitude = 0;
      apparent_magnitude = 0.0;       
      absolute_magnitude = 0.0;
      apparent_magnitude_varies = false;
      absolute_magnitude_varies = false;
      constellation_abbreviation = "";
      constellation_full_name = "";
      constellation_name_genitive = "";
      constellation_number = 0;
      right_ascension_hours = 0;
      right_ascension_minutes = 0;
      right_ascension_seconds = 0.0;
      right_ascension_decimal_hours = 0.0;
      right_ascension_decimal_degrees = 0.0;
      declination_degrees = 0;
      declination_minutes = 0;
      declination_seconds = 0.0;
      declination_decimal_degrees = 0.0;
      is_binary = 0;

   return;
}

@q **** (4) Copy constructor.@> 
@*3 Copy constructor.
\initials{LDF 2021.06.07.}

\LOG
\initials{LDF 2021.06.07.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Star| functions@>=
Star(const Star &s);

@q ***** (5) Definition.  @>

@
@<Define |Star| functions@>= 
Star::Star(const Star &s)
{
      star_constant_name = s.star_constant_name;
      common_name = s.common_name;
      greek_name = s.greek_name;
      latin_name = s.latin_name;
      arabic_name = s.arabic_name;
      flamsteed_designation_number = s.flamsteed_designation_number;
      bayer_designation_greek_letter = s.bayer_designation_greek_letter;
      bayer_designation_greek_letter_tex = s.bayer_designation_greek_letter_tex;
      bs_hr_number = s.bs_hr_number;
      approx_rank_apparent_magnitude = s.approx_rank_apparent_magnitude;
      apparent_magnitude = s.apparent_magnitude;        
      absolute_magnitude = s.absolute_magnitude;
      apparent_magnitude_varies = s.apparent_magnitude_varies;        
      absolute_magnitude_varies = s.absolute_magnitude_varies;
      constellation_abbreviation = s.constellation_abbreviation;
      constellation_full_name = s.constellation_full_name;
      constellation_name_genitive = s.constellation_name_genitive;
      constellation_number = s.constellation_number;
      right_ascension_hours = s.right_ascension_hours;
      right_ascension_minutes = s.right_ascension_minutes;
      right_ascension_seconds = s.right_ascension_seconds;
      right_ascension_decimal_hours = s.right_ascension_decimal_hours;
      right_ascension_decimal_degrees = s.right_ascension_decimal_degrees;
      declination_degrees = s.declination_degrees;
      declination_minutes = s.declination_minutes;
      declination_seconds = s.declination_seconds;
      declination_decimal_degrees = s.declination_decimal_degrees;
      is_binary = s.is_binary;

   return;
}

@q **** (4) Setting function with individual arguments.@> 
@*2 Setting function with individual arguments.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
int
set(real ra, real dcl, Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Star| functions@>= 
int
Star::set(real ra, real dcl, Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Star::set'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@>

   return 0;

@q ***** (5)@>

}  /* End of |Star::set| definition.  */

@q **** (4) Setting function with |Scanner_Node| argument.@> 
@*2 Setting function with |Scanner_Node| argument.@> 
\initials{LDF 2021.06.07.}

\LOG
\initials{LDF 2021.06.07.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
int
set(Scanner_Node scanner_node);

@q **** (4) Definition.  @>

@
@<Define |Star| functions@>=
int
Star::set(Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Star::set' with `Scanner_Node' argument.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Star| functions@>=

   if (scanner_node->curr_row == 0)
   {
       cerr_strm << thread_name << "ERROR!  In `Star::set' with `Scanner_Node' argument:"
                 << endl
                 << "`scanner_node->curr_row' is NULL.  Can't set `Star'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
   
       return 1;

   }

@q ***** (5) @>
@
@<Define |Star| functions@>=

      int i = 0;

      common_name = scanner_node->curr_row[i++];
      greek_name = scanner_node->curr_row[i++];
      latin_name = scanner_node->curr_row[i++];
      arabic_name = scanner_node->curr_row[i++];
      flamsteed_designation_number = atoi(scanner_node->curr_row[i++]);
      bayer_designation_greek_letter = scanner_node->curr_row[i++];
      bayer_designation_greek_letter_tex = scanner_node->curr_row[i++];
      bayer_designation_extension = scanner_node->curr_row[i++];
      bs_hr_number = atoi(scanner_node->curr_row[i++]);
      approx_rank_apparent_magnitude = atoi(scanner_node->curr_row[i++]);
      apparent_magnitude = atof(scanner_node->curr_row[i++]);
      absolute_magnitude = atof(scanner_node->curr_row[i++]);
      apparent_magnitude_varies = static_cast<bool>(atoi(scanner_node->curr_row[i++]));
      absolute_magnitude_varies = static_cast<bool>(atoi(scanner_node->curr_row[i++]));
      constellation_abbreviation = scanner_node->curr_row[i++];
      constellation_full_name = scanner_node->curr_row[i++];
      constellation_name_genitive = scanner_node->curr_row[i++];
      constellation_number = atoi(scanner_node->curr_row[i++]);
      right_ascension_hours = atoi(scanner_node->curr_row[i++]);
      right_ascension_minutes = atoi(scanner_node->curr_row[i++]);
      right_ascension_seconds = atof(scanner_node->curr_row[i++]);
      right_ascension_decimal_hours = atof(scanner_node->curr_row[i++]);
      right_ascension_decimal_degrees = atof(scanner_node->curr_row[i++]);
      declination_degrees = atoi(scanner_node->curr_row[i++]);
      declination_minutes = atoi(scanner_node->curr_row[i++]);
      declination_seconds = atof(scanner_node->curr_row[i++]);
      declination_decimal_degrees = atof(scanner_node->curr_row[i++]);
      is_binary = atoi(scanner_node->curr_row[i++]);
      is_multiple = atoi(scanner_node->curr_row[i++]);
      is_binary_component = atoi(scanner_node->curr_row[i++]);
      is_eclipsing_binary = atoi(scanner_node->curr_row[i++]);
      notes = scanner_node->curr_row[i++];

      size_t pos;

      do
      {
         pos = constellation_full_name.find("รถ");
         if (pos != string::npos)
           constellation_full_name.replace(pos, 2, "@@{o}");

      } while (pos != string::npos);

@q ***** (5)@>
@
@<Define |Star| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name 
                 << "Exiting `Star::set' with `Scanner_Node' argument successfully with return value 0."
                 << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

@q ***** (5)@>

}  /* End of |Star::set| definition.  */

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
virtual
~Star(void);

@q **** (4) Definition.  @>

@
@<Define |Star| functions@>= 
Star::~Star(void)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

}  /* End of |~Star| definition.  */

@q *** (3) Pseudo-constructor for dynamic allocation.@>
@*2 Pseudo-constructor for dynamic allocation.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Pointer argument.@>
@*3 Pointer argument.@>
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Star|@>=

Star* 
create_new(const Star* p, Scanner_Node scanner_node = 0);

@q **** (4) Reference argument.@>
@*3 Referece argument.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Star|@>=
Star* 
create_new(const Star& p, Scanner_Node scanner_node = 0);

@q *** (3) Assignment.@> 
@*2 Assignment.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Assignment from a |Star|.@> 
@*3 Assignment from a |Star|.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Star| functions@>=
virtual
Star&
operator=(const Star& c);

@q ***** (5) Definition.@> 
@
@<Define |Star| functions@>=

Star&
Star::operator=(const Star& s)
{

@q ****** (6) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

    if (this == &s) /* Make sure it's not self-assignment. */
       return *this;

@q ****** (6)@>

      star_constant_name = s.star_constant_name;
      common_name                        = s.common_name;
      greek_name                         = s.greek_name;     
      latin_name                         = s.latin_name;
      arabic_name                        = s.arabic_name;
      flamsteed_designation_number       = s.flamsteed_designation_number;
      bayer_designation_greek_letter     = s.bayer_designation_greek_letter;
      bayer_designation_greek_letter_tex = s.bayer_designation_greek_letter_tex;
      bs_hr_number                       = s.bs_hr_number;
      approx_rank_apparent_magnitude     = s.approx_rank_apparent_magnitude;
      apparent_magnitude                 = s.apparent_magnitude;        
      absolute_magnitude                 = s.absolute_magnitude;
      apparent_magnitude_varies          = s.apparent_magnitude_varies;        
      absolute_magnitude_varies          = s.absolute_magnitude_varies;
      constellation_abbreviation         = s.constellation_abbreviation;
      constellation_full_name            = s.constellation_full_name;
      constellation_name_genitive        = s.constellation_name_genitive;
      constellation_number               = s.constellation_number;
      right_ascension_hours              = s.right_ascension_hours;
      right_ascension_minutes            = s.right_ascension_minutes;
      right_ascension_seconds            = s.right_ascension_seconds;
      right_ascension_decimal_hours      = s.right_ascension_decimal_hours;
      right_ascension_decimal_degrees    = s.right_ascension_decimal_degrees;
      declination_degrees                = s.declination_degrees;
      declination_minutes                = s.declination_minutes;
      declination_seconds                = s.declination_seconds;
      declination_decimal_degrees        = s.declination_decimal_degrees;
      is_binary                          = s.is_binary;
 
      return *this;

}  /* End of |Star::operator=(const Star& s)| definition.  */

@q **** (4) @>

@q *** (3) operator==@>
@ Equality operator (|operator==|).
\initials{LDF 2021.06.24.}

\LOG
\initials{LDF 2021.06.24.}
Added this function.
\ENDLOG

@q **** (4) Declaration  @>

@<Declare |Star| functions@>=
bool
operator==(const Star &s);

@q **** (4) Definition.  @>
@
@<Define |Star| functions@>= 
bool
Star::operator==(const Star &s)
{
   if (bs_hr_number > 0 && s.bs_hr_number > 0 && bs_hr_number == s.bs_hr_number)
   {
      return true;
   }

   if (common_name != "" && s.common_name != "" && common_name == s.common_name)
   {
      return true;
   }

   if (   bayer_designation_greek_letter     != "" && bayer_designation_greek_letter ==  s.bayer_designation_greek_letter
       && bayer_designation_greek_letter_tex != "" && bayer_designation_greek_letter_tex ==  s.bayer_designation_greek_letter_tex
       && constellation_name_genitive        != "" && s.constellation_name_genitive != ""
       && constellation_name_genitive        == s.constellation_name_genitive)
   {
     return true;
   }   

   return false;
}

@q *** (3) Clear.@> 
@*2 Clear.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
int
clear(Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Star| functions@>= 
int 
Star::clear(Scanner_Node scanner_node)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>


   return 0;

}  /* End of |Star::clear| definition.  */

@q *** (3) Show.@> 
@*2 Show.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
void 
show(string text = "", unsigned int fields = 0U) const;

@q **** (4) Definition.@> 
@
@<Define |Star| functions@>=
void 
Star::show(string text, unsigned int fields) const
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   using namespace Scan_Parse;

    string s;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Entering `Star::show'." << endl 
           << "`fields' == " << hex << fields << " (hex)" << dec
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@>
@
@<Define |Star| functions@>=

    if (fields == 0U)
       fields = ~0U;

@q ***** (5)@>
@
@<Define |Star| functions@>=

    if (fields == ~0U)
    {
        cerr << "star_constant_name:                  " << star_constant_name << endl
             << "common_name:                         " << common_name << endl
             << "greek_name:                          " << greek_name << endl 
             << "latin_name:                          " << latin_name << endl 
             << "arabic_name:                         " << arabic_name << endl 
             << "flamsteed_designation_number:        " << flamsteed_designation_number << endl 
             << "bayer_designation_greek_letter:      " << bayer_designation_greek_letter << endl 
             << "bayer_designation_greek_letter_tex:  " << bayer_designation_greek_letter_tex << endl 
             << "bayer_designation_extension:         " << bayer_designation_extension << endl 
             << "bs_hr_number:                        " << bs_hr_number << endl 
             << "approx_rank_apparent_magnitude:      " << approx_rank_apparent_magnitude << endl 
             << "apparent_magnitude:                  " << apparent_magnitude << endl 
             << "absolute_magnitude:                  " << absolute_magnitude << endl 
             << "apparent_magnitude_varies:           " << apparent_magnitude_varies << endl 
             << "absolute_magnitude_varies:           " << absolute_magnitude_varies << endl 
             << "constellation_abbreviation:          " << constellation_abbreviation << endl 
             << "constellation_full_name:             " << constellation_full_name << endl 
             << "constellation_name_genitive:         " << constellation_name_genitive << endl 
             << "constellation_number:                " << constellation_number << endl 
             << "right_ascension_hours:               " << right_ascension_hours << endl 
             << "right_ascension_minutes:             " << right_ascension_minutes << endl 
             << "right_ascension_seconds:             " << right_ascension_seconds << endl 
             << "right_ascension_decimal_hours:       " << right_ascension_decimal_hours << endl 
             << "right_ascension_decimal_degrees:     " << right_ascension_decimal_degrees << endl 
             << "declination_degrees:                 " << declination_degrees << endl 
             << "declination_minutes:                 " << declination_minutes << endl 
             << "declination_seconds:                 " << declination_seconds << endl 
             << "declination_decimal_degrees:         " << declination_decimal_degrees << endl 
             << "is_binary:                           " << is_binary << endl
             << "is_multiple:                         " << is_multiple << endl 
             << "is_binary_component:                 " << is_binary_component << endl 
             << "is_eclipsing_binary:                 " << is_eclipsing_binary << endl 
             << "notes:                               " << notes << endl 
             << endl; 

        return;    

    }  /* |if|  */

@q ***** (5)@>
@
@<Define |Star| functions@>=

    if (fields & STARS_RIGHT_ASCENSION)
    {
       fields |=   STARS_RIGHT_ASCENSION_HOURS | STARS_RIGHT_ASCENSION_MINUTES | STARS_RIGHT_ASCENSION_SECONDS
                 | STARS_RIGHT_ASCENSION_DECIMAL_HOURS | STARS_RIGHT_ASCENSION_DECIMAL_DEGREES;
    }

    if (fields & STARS_DECLINATION)
    {
       fields |=   STARS_DECLINATION_DEGREES | STARS_DECLINATION_MINUTES | STARS_DECLINATION_SECONDS 
                 | STARS_DECLINATION_DECIMAL_DEGREES;
    }

    if (text == "")
       text = "Star:";

    cerr << text << endl;

    if (star_constant_name != "")
    {
        cerr << "star_constant_name              == " << star_constant_name << endl;  

        s = star_constant_name;

        for (int i = 0; i < s.length(); ++i)
            s[i] = tolower(s[i]);

        if (s != star_constant_name)
           cerr << "alternative star_constant_name  == " << s << endl;

        s = "";

    }

    if (fields & STARS_COMMON_NAME)
       cerr << "common_name                         == " << common_name << endl;

    if (fields & STARS_GREEK_NAME)
       cerr << "greek_name                          == " << greek_name << endl;

    if (fields & STARS_LATIN_NAME)
       cerr << "latin_name                          == " << latin_name << endl;

    if (fields & STARS_ARABIC_NAME)
       cerr << "arabic_name                         == " << arabic_name << endl;

    if (fields & STARS_FLAMSTEED_DESIGNATION_NUMBER)
       cerr << "flamsteed_designation_number        == " << flamsteed_designation_number << endl;

    if (fields & STARS_BAYER_DESIGNATION_GREEK_LETTER)
       cerr << "bayer_designation_greek_letter      == " << bayer_designation_greek_letter << endl;

    if (fields & STARS_BAYER_DESIGNATION_GREEK_LETTER_TEX)
       cerr << "bayer_designation_greek_letter_tex  == " << bayer_designation_greek_letter_tex << endl;


    if (fields & (STARS_BS_HR_NUMBER | STARS_BS_NUMBER | STARS_HR_NUMBER))
       cerr << "bs_hr_number                        == " << bs_hr_number << endl;

    if (fields & STARS_APPROX_RANK_APPARENT_MAGNITUDE)
       cerr << "approx_rank_apparent_magnitude      == " << approx_rank_apparent_magnitude << endl;

    if (fields & STARS_APPARENT_MAGNITUDE)
       cerr << "apparent_magnitude                  == " << apparent_magnitude << endl;

    if (fields & STARS_ABSOLUTE_MAGNITUDE)
       cerr << "absolute_magnitude                  == " << absolute_magnitude << endl;

    if (fields & STARS_APPARENT_MAGNITUDE_VARIES)
       cerr << "apparent_magnitude_varies           == " << apparent_magnitude_varies << endl;

    if (fields & STARS_ABSOLUTE_MAGNITUDE_VARIES)
       cerr << "absolute_magnitude_varies           == " << absolute_magnitude_varies << endl;

    if (fields & STARS_CONSTELLATION_ABBREVIATION)
       cerr << "constellation_abbreviation          == " << constellation_abbreviation << endl;

    if (fields & STARS_CONSTELLATION_FULL_NAME)
       cerr << "constellation_full_name             == " << constellation_full_name << endl;

    if (fields & STARS_CONSTELLATION_NAME_GENITIVE)
       cerr << "constellation_name_genitive         == " << constellation_name_genitive << endl;

    if (fields & STARS_CONSTELLATION_NUMBER)
       cerr << "constellation_number                == " << constellation_number << endl;

    if (fields & STARS_RIGHT_ASCENSION_HOURS)
       cerr << "right_ascension_hours               == " << right_ascension_hours << endl;

    if (fields & STARS_RIGHT_ASCENSION_MINUTES)
       cerr << "right_ascension_minutes             == " << right_ascension_minutes << endl;

    if (fields & STARS_RIGHT_ASCENSION_SECONDS)
       cerr << "right_ascension_seconds             == " << right_ascension_seconds << endl;

    if (fields & STARS_RIGHT_ASCENSION_DECIMAL_HOURS)
       cerr << "right_ascension_decimal_hours       == " << right_ascension_decimal_hours << endl;

    if (fields & STARS_RIGHT_ASCENSION_DECIMAL_DEGREES)
       cerr << "right_ascension_decimal_degrees     == " << right_ascension_decimal_degrees << endl;

    if (fields & STARS_DECLINATION_DEGREES)
       cerr << "declination_degrees                 == " << declination_degrees << endl;

    if (fields & STARS_DECLINATION_MINUTES)
       cerr << "declination_minutes                 == " << declination_minutes << endl;

    if (fields & STARS_DECLINATION_SECONDS)
       cerr << "declination_seconds                 == " << declination_seconds << endl;

    if (fields & STARS_DECLINATION_DECIMAL_DEGREES)
       cerr << "declination_decimal_degrees         == " << declination_decimal_degrees << endl;

    if (fields & STARS_IS_BINARY)
       cerr << "is_binary                           == " << is_binary << endl;

    cerr << endl;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Star::show' successfully with `void' return value." << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

    return;

} /* End of |Star::show| definition.  */

@q *** (3) process_where_option.@> 
@*2 process_where_option.
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Star| functions@>=
int
process_where_option(Stars_Where_Option_Struct &where_option,
                     vector<Star*> &a_star_ptr_vector,
                     vector<Star*> &b_star_ptr_vector,
		     Scanner_Node scanner_node = 0);

@q **** (4) Definition.@> 
@ 
@<Define |Star| functions@>= 
int
Star::process_where_option(Stars_Where_Option_Struct &where_option, 
                           vector<Star*> &a_star_ptr_vector, 
                           vector<Star*> &b_star_ptr_vector,
                           Scanner_Node scanner_node) 
{ 
@q ***** (5) @>

   using namespace Scan_Parse;

   bool DEBUG = false; /* |true|  */ 

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Entering `Star::process_where_option'." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@;    

@q ***** (5) @>
@
@<Define |Star| functions@>=
   
   string Star::*star_str_ptr  = 0;
   int    Star::*star_int_ptr  = 0;
   real   Star::*star_real_ptr = 0;
   bool   Star::*star_bool_ptr = 0;

   int status = 0;

   bool (*fp_str) (const string&, const string&);
   fp_str = 0;

   bool (*fp_int) (const int&, const int&);
   fp_int = 0;

   bool (*fp_real) (const real&, const real&);
   fp_real = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "where_option.field == " << where_option.field << " == " 
           << star_field_name_map[where_option.field] << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Star| functions@>=

@q ****** (6) @>

   if (where_option.field == STARS_STAR_CONSTANT_NAME)
   {
      star_str_ptr  = &Star::star_constant_name;
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;
   }

@q ****** (6) @>

   else if (where_option.field == STARS_COMMON_NAME)
   {
      star_str_ptr  = &Star::common_name;
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;
   }

@q ****** (6) @>

   else if (where_option.field == STARS_GREEK_NAME)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_GREEK_NAME." << endl
               << "Setting `star_str_ptr' to `&Star::greek_name'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::greek_name; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_LATIN_NAME)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_LATIN_NAME." << endl
               << "Setting `star_str_ptr' to `&Star::latin_name'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::latin_name; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_ARABIC_NAME)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_ARABIC_NAME." << endl
               << "Setting `star_str_ptr' to `&Star::arabic_name'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::arabic_name; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_FLAMSTEED_DESIGNATION_NUMBER)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_FLAMSTEED_DESIGNATION_NUMBER." << endl
               << "Setting `star_int_ptr' to `&Star::flamsteed_designation_number'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::flamsteed_designation_number;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_BAYER_DESIGNATION_GREEK_LETTER)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_BAYER_DESIGNATION_GREEK_LETTER." << endl
               << "Setting `star_str_ptr' to `&Star::bayer_designation_greek_letter'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::bayer_designation_greek_letter; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_BAYER_DESIGNATION_GREEK_LETTER_TEX)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_BAYER_DESIGNATION_GREEK_LETTER_TEX." << endl
               << "Setting `star_str_ptr' to `&Star::bayer_designation_greek_letter_tex'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::bayer_designation_greek_letter_tex; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (   where_option.field == STARS_BS_HR_NUMBER 
            || where_option.field == STARS_BS_NUMBER 
            || where_option.field == STARS_HR_NUMBER)   
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_BS_HR_NUMBER or STARS_BS_NUMBER or STARS_HR_NUMBER." 
               << endl
               << "Setting `star_int_ptr' to `&Star::bs_hr_number'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0;
      star_int_ptr  = &Star::bs_hr_number; 
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }

   }

@q ****** (6) @>

   else if (where_option.field == STARS_APPROX_RANK_APPARENT_MAGNITUDE)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_APPROX_RANK_APPARENT_MAGNITUDE." << endl
               << "Setting `star_int_ptr' to `&Star::approx_rank_apparent_magnitude'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::approx_rank_apparent_magnitude;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_APPARENT_MAGNITUDE)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_APPARENT_MAGNITUDE." << endl
               << "Setting `star_real_ptr' to `&Star::apparent_magnitude'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::apparent_magnitude;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_ABSOLUTE_MAGNITUDE)
   {  
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_ABSOLUTE_MAGNITUDE." << endl
               << "Setting `star_real_ptr' to `&Star::absolute_magnitude'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::absolute_magnitude;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_APPARENT_MAGNITUDE_VARIES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_APPARENT_MAGNITUDE_VARIES." << endl
               << "Setting `star_int_ptr' to `&Star::apparent_magnitude_varies'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = &Star::apparent_magnitude_varies;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `bool' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.real_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.bool_value  = static_cast<bool>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }

   }


@q ****** (6) @>

   else if (where_option.field == STARS_ABSOLUTE_MAGNITUDE_VARIES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_ABSOLUTE_MAGNITUDE_VARIES." << endl
               << "Setting `star_int_ptr' to `&Star::absolute_magnitude_varies'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = &Star::absolute_magnitude_varies;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.real_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.bool_value  = static_cast<bool>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }

   }

@q ****** (6) @>

   else if (where_option.field == STARS_CONSTELLATION_ABBREVIATION)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_CONSTELLATION_ABBREVIATION." << endl
               << "Setting `star_str_ptr' to `&Star::constellation_abbreviation'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::constellation_abbreviation; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_CONSTELLATION_FULL_NAME)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_CONSTELLATION_FULL_NAME." << endl
               << "Setting `star_str_ptr' to `&Star::constellation_full_name'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::constellation_full_name; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_CONSTELLATION_NAME_GENITIVE)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_CONSTELLATION_NAME_GENITIVE." << endl
               << "Setting `star_str_ptr' to `&Star::constellation_name_genitive'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = &Star::constellation_name_genitive; 
      star_int_ptr  = 0;
      star_real_ptr = 0;
      star_bool_ptr = 0;

   }

@q ****** (6) @>

   else if (where_option.field == STARS_CONSTELLATION_NUMBER)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_CONSTELLATION_NUMBER." << endl
               << "Setting `star_int_ptr' to `&Star::constellation_number'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::constellation_number;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_RIGHT_ASCENSION_HOURS)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_RIGHT_ASCENSION_HOURS." << endl
               << "Setting `star_int_ptr' to `&Star::right_ascension_hours'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::right_ascension_hours;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }

   }

@q ****** (6) @>

   else if (where_option.field == STARS_RIGHT_ASCENSION_MINUTES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_RIGHT_ASCENSION_MINUTES." << endl
               << "Setting `star_int_ptr' to `&Star::right_ascension_minutes'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::right_ascension_minutes;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_RIGHT_ASCENSION_SECONDS)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_RIGHT_ASCENSION_SECONDS." << endl
               << "Setting `star_real_ptr' to `&Star::right_ascension_seconds'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::right_ascension_seconds;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (   where_option.field == STARS_RIGHT_ASCENSION_DECIMAL_HOURS
            || where_option.field == STARS_RIGHT_ASCENSION)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_RIGHT_ASCENSION or STARS_RIGHT_ASCENSION." << endl
               << "Setting `star_real_ptr' to `&Star::right_ascension_decimal_hours'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::right_ascension_decimal_hours;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_RIGHT_ASCENSION_DECIMAL_DEGREES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_RIGHT_ASCENSION_DECIMAL_DEGREES." << endl
               << "Setting `star_real_ptr' to `&Star::right_ascension_decimal_degrees'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::right_ascension_decimal_degrees;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_DECLINATION_DEGREES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_DECLINATION_DEGREES." << endl
               << "Setting `star_int_ptr' to `&Star::declination_degrees'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::declination_degrees;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_DECLINATION_MINUTES)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_DECLINATION_MINUTES." << endl
               << "Setting `star_int_ptr' to `&Star::declination_minutes'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::declination_minutes;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_DECLINATION_SECONDS)
   {
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_DECLINATION_SECONDS." << endl
               << "Setting `star_real_ptr' to `&Star::declination_seconds'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::declination_seconds;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (   where_option.field == STARS_DECLINATION_DECIMAL_DEGREES
            || where_option.field == STARS_DECLINATION)
   {  
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_DECLINATION_DECIMAL_DEGREES or STARS_DECLINATION." 
               << endl
               << "Setting `star_real_ptr' to `&Star::declination_decimal_degrees'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = 0;
      star_real_ptr = &Star::declination_decimal_degrees;
      star_bool_ptr = 0;

      if (where_option.int_value != 0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.int_value' == " <<  where_option.int_value << " (!= 0)" 
                  << endl
                  << "Casting `where_option.int_value' to `real' and assigning it to" 
                  << endl 
                  << "`where_option.real_value' and setting `where_option.int_value' to 0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.real_value  = static_cast<real>(where_option.int_value);
         where_option.int_value = 0;
      }
   }

@q ****** (6) @>

   else if (where_option.field == STARS_IS_BINARY)
   {  
#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "where_option.field == STARS_IS_BINARY." << endl
               << "Setting `star_int_ptr' to `&Star::is_binary'."
               << endl;
      }  
#endif /* |DEBUG_COMPILE|  */@; 

      star_str_ptr  = 0; 
      star_int_ptr  = &Star::is_binary;
      star_real_ptr = 0;
      star_bool_ptr = 0;

      if (where_option.real_value != 0.0)
      {
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << "`where_option.real_value' == " <<  where_option.real_value << " (!= 0.0)" 
                  << endl
                  << "Casting `floor(where_option.real_value)' to `int' and assigning it to" 
                  << endl 
                  << "`where_option.int_value' and setting `where_option.int_value' to 0.0."
                  << endl;
         }       
#endif /* |DEBUG_COMPILE|  */@;  
 
         where_option.int_value  = static_cast<int>(floor(where_option.real_value));
         where_option.real_value = 0.0;
      }
   }


@q ****** (6) @>

   else
   {
       cerr << "ERROR!  In `Star::process_where_option':"
            << "`where_option.field' has an invalid value:  " 
            << where_option.field << "." << endl
            << "Can't process \"where option\"." << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;
   }

@q ****** (6) @>

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      if (star_str_ptr != 0 && this->*star_str_ptr != "")
         cerr << "`this->*star_str_ptr'  == \"" << this->*star_str_ptr << "\"" << endl
              << "`where_option.comparison_string' == " << where_option.comparison_string
              << endl;
      else 
         cerr << "`this->*star_str_ptr' == NULL or this->*star_str_ptr == \"\"." << endl;

      if (star_int_ptr != 0)
         cerr << "`this->*star_int_ptr'  == " << this->*star_int_ptr << endl
              << "`where_option.int_value' == " << where_option.int_value << endl;
      else 
         cerr << "`this->*star_int_ptr'  == NULL." << endl;

      if (star_real_ptr != 0)
         cerr << "`this->*star_real_ptr' == " << this->*star_real_ptr << endl
              << "`where_option.real_value' == " << where_option.real_value << endl;
      else 
         cerr << "`this->*star_real_ptr' == NULL." << endl;

      if (star_bool_ptr != 0)
         cerr << "`this->*star_bool_ptr'  == " << this->*star_bool_ptr << endl
              << "`where_option.bool_value' == " << where_option.bool_value << endl;
      else 
         cerr << "`this->*star_bool_ptr'  == NULL." << endl;

      }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Star| functions@>=

      if (where_option.relation == EQUAL)
      {
@q ****** (6) @>

#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == EQUAL" << endl
                   << "Setting `fp_str' = `equal_str', `fp_int' = `equal_int' and `fp_real' = `equal_real'."
                   << endl;
           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = equal_str;
           fp_int  = equal_int;
           fp_real = equal_real;


      } /* |if (where_option.relation == EQUAL)| */

@q ****** (6) @>

      else if (where_option.relation == NOT_EQUAL)
      {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == NOT_EQUAL" << endl
                   << "Setting `fp_str' = `not_equal_str', `fp_int' = `not_equal_int' and `fp_real' = `not_equal_real'."
                   << endl;
           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = not_equal_str;
           fp_int  = not_equal_int;
           fp_real = not_equal_real;
      }

@q ****** (6) @>

      else if (where_option.relation == LESS)
      {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == LESS" << endl
                   << "Setting `fp_str' = `less_str', `fp_int' = `less_int' and `fp_real' = `less_real'."
                   << endl;

           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = less_str;
           fp_int  = less_int;
           fp_real = less_real;

      }

@q ****** (6) @>

      else if (where_option.relation == LESS_OR_EQUAL)
      {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == LESS_OR_EQUAL" << endl
                   << "Setting `fp_str' = `less_or_equal_str', `fp_int' = `less_or_equal_int' and `fp_real' = `less_or_equal_real'."
                   << endl;

           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = less_or_equal_str;
           fp_int  = less_or_equal_int;
           fp_real = less_or_equal_real;

      }

@q ****** (6) @>

      else if (where_option.relation == GREATER)
      {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == GREATER" << endl
                   << "Setting `fp_str' = `greater_str', `fp_int' = `greater_int' and `fp_real' = `greater_real'."
                   << endl;

           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = greater_str;
           fp_int  = greater_int;
           fp_real = greater_real;

      }

@q ****** (6) @>

      else if (where_option.relation == GREATER_OR_EQUAL)
      {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "`where_option.relation' == GREATER_OR_EQUAL" << endl
                   << "Setting `fp_str' = `greater_or_equal_str', `fp_int' = `greater_or_equal_int' and "
                   << "`fp_real' = `greater_or_equal_real'."
                   << endl;

           }     
#endif /* |DEBUG_COMPILE|  */@;         

           fp_str  = greater_or_equal_str;
           fp_int  = greater_or_equal_int;
           fp_real = greater_or_equal_real;

      }

@q ***** (5) @>
@
@<Define |Star| functions@>=

    if (star_str_ptr != 0)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "`star_str_ptr' != 0" << endl
               << "Calling `fp_str(this->*star_str_ptr, where_option.comparison_string)'."
               << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@;         

       status = fp_str(this->*star_str_ptr, where_option.comparison_string);

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "In `Star::process_where_option':" << endl 
                << "`fp_str' returned " << status << "." << endl;

           if (status == 1)
           {
              cerr << "Will push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }
           else
           {
              cerr << "Won't push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }   
       }   
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |if (star_str_ptr != 0)| */ 

@q ***** (5) @>
@
@<Define |Star| functions@>=

    else if (star_int_ptr != 0)
    {
#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "`star_int_ptr' != 0" << endl
               << "Calling `fp_int(this->*star_int_ptr, where_option.int_value)'."
               << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@;         

       status = fp_int(this->*star_int_ptr, where_option.int_value);

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "In `Star::process_where_option':" << endl 
                << "`fp_int' returned " << status << "." << endl;

           if (status == 1)
           {
              cerr << "Will push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }
           else
           {
              cerr << "Won't push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }   
       }   
#endif /* |DEBUG_COMPILE|  */@; 

    }  /* |else if (star_int_ptr != 0)|  */

@q ***** (5) @>
@
@<Define |Star| functions@>=

    else if (star_real_ptr != 0)
    {

#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "`star_real_ptr' != 0" << endl
               << "Calling `fp_real(this->*star_real_ptr, where_option.real_value)'."
               << endl;
       }  
#endif /* |DEBUG_COMPILE|  */@;         

       status = fp_real(this->*star_real_ptr, where_option.real_value);

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "In `Star::process_where_option':" << endl 
                << "`fp_real' returned " << status << "." << endl;

           if (status == 1)
           {
              cerr << "Will push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }
           else
           {
              cerr << "Won't push `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                   << endl;
           }   
       }   
#endif /* |DEBUG_COMPILE|  */@; 

    }  /* |else if (star_real_ptr != 0)|  */

@q ***** (5) @>
@
@<Define |Star| functions@>=

    else
    {
        cerr << "WARNING!  In `Star::process_where_option':" << endl 
             << "`star_str_ptr', `star_int_ptr' and `star_real_ptr'"
             << endl 
             << "are all NULL.  This shouldn't be possible."
             << endl
             << "Exiting function unsuccessfully with return value 2."
             << endl;

        return 2;
    }    

@q ***** (5) @>
@
@<Define |Star| functions@>=

    if (status == 1)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       { 
           cerr << "`status' == 1 (`true')." << endl;
       }      
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) @>

       if (where_option.conjunction == 0 || where_option.conjunction == AND)
       {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "where_option.conjunction == 0 || where_option.conjunction == AND" << endl
                   << "Pushing `this' onto `a_star_ptr_vector'."
                   << endl;

           }            
#endif /* |DEBUG_COMPILE|  */@; 

           a_star_ptr_vector.push_back(this);
        }

@q ****** (6) @>

        else if (where_option.conjunction == OR)
        {
#if DEBUG_COMPILE
           if (DEBUG)
           { 
              cerr << "where_option.conjunction == OR" << endl
                   << "Pushing `this' onto `b_star_ptr_vector'."
                   << endl;
           }            
#endif /* |DEBUG_COMPILE|  */@; 

           b_star_ptr_vector.push_back(this);
        }

@q ****** (6) @>
@
@<Define |Star| functions@>=

        else
        {
            cerr << "WARNING!  In `Star::process_where_option':"
                 << endl 
                 << "`where_option.conjunction' has invalid value:  "
                 << where_option.conjunction << endl 
                 << "`name_map[where_option.conjunction]' == \"" 
                 << name_map[where_option.conjunction] << "\""
                 << endl 
                 << "This case is either invalid or hasn't been accounted for."
                 << endl
                 << "Not pushing `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'."
                 << endl
                 << "Exiting function with return value 2."
                 << endl;

            return 2;

        }
@q ****** (6) @>

    }  /* |if (status == true)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
    else if (DEBUG)
    { 
           cerr << "`status' == 0 (`false').  Not pushing `this' onto `a_star_ptr_vector' or `b_star_ptr_vector'." 
                << endl;
    }     
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Star| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Star::process_where_option' successfully with return value 0." 
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@;    

   return 0;
  
} /* End of |Star::process_where_option| definition  */


@q *** (3) Plot.  @>
@*2 Plot.
\initials{LDF 2021.06.25.}

\LOG
\initials{LDF 2021.06.25.}
Added this function.
\ENDLOG 

@q **** (4) @>

@<Declare |Star| functions@>=
int
plot(Scanner_Node scanner_node = 0);

@q **** (4) @>
@
@<Define |Star| functions@>=
int
Star::plot(Scanner_Node scanner_node)
{
@q ***** (5) @>

   bool DEBUG = true;  /* |false|  */

   int status = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   {  
       cerr << "Entering `Star::plot'." << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@;     

@q ***** (5) @>


@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {  
       cerr << "Exiting `Star::plot' successfully with return value 0." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@;     

   return 0;

@q ***** (5) @>

}  /* End of |Star::plot| definition  */

@q *** (3) @>

@q ** (2) @>

@q * (1) Constellation class definition.@>
@* {\bf Constellation} class definition.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this |class| definition.
\ENDLOG

@q ** (2) Code.@> 

@<Declare |class Constellation|@>=

class Constellation
{

   friend int yyparse(yyscan_t);

   friend int Scan_Parse::get_stars_func(Scanner_Node, vector<Star*>&);
   friend int Scan_Parse::plot_stars_func(Scanner_Node);
   friend int Scan_Parse::show_stars_func(Scanner_Node);

   protected:

   public:

      @<Declare |static| |class Constellation| data members@>@;

      @<Declare |Constellation| functions@>@;
};

@q ** (2) Static member variable declarations and initializations.@>
@*1 Static member variable declarations and initializations.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@<Declare |static| |class Constellation| data members@>=

@q *** (3) Code.@> 
@
@<Initialize |static| |class Constellation| data members@>=

@q ** (2) Global constants.@>
@*1 Global constants.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@<Global constants@>=

@q *** (3)@>
@
@<Declarations for the header file@>=

@q ** (2) |Constellation| functions.@> 
@*1 {\bf Constellation} functions.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q *** (3) Constructors and Setting Functions.@>
@*2 Constructors and Setting Functions.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Default Constructor.@> 
@*3 Default Constructor.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Constellation| functions@>=
Constellation(void);

@q ***** (5) Definition.  @>

@
@<Define |Constellation| functions@>= 
Constellation::Constellation(void)
{
   return;
}


@q **** (4) Setting function.@> 
@*2 Setting function.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Constellation| functions@>=
int
set(real real_part, real imaginary_part, Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Constellation| functions@>= 
int
Constellation::set(real real_part, real imaginary_part, Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Constellation::set'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@>

   return 0;

@q ***** (5)@>

}  /* End of |Constellation::set| definition.  */

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Constellation| functions@>=
virtual
~Constellation(void);

@q **** (4) Definition.  @>

@
@<Define |Constellation| functions@>= 
Constellation::~Constellation(void)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

}  /* End of |~Constellation| definition.  */

@q *** (3) Pseudo-constructor for dynamic allocation.@>
@*2 Pseudo-constructor for dynamic allocation.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Pointer argument.@>
@*3 Pointer argument.@>
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Constellation|@>=

Constellation* 
create_new(const Constellation* p, Scanner_Node scanner_node = 0);

@q **** (4) Reference argument.@>
@*3 Referece argument.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Constellation|@>=
Constellation* 
create_new(const Constellation& p, Scanner_Node scanner_node = 0);

@q *** (3) Assignment.@> 
@*2 Assignment.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this section.
\ENDLOG

@q **** (4) Assignment from a |Constellation|.@> 
@*3 Assignment from a |Constellation|.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Constellation| functions@>=
virtual
Constellation&
operator=(const Constellation& c);

@q ***** (5) Definition.@> 
@
@<Define |Constellation| functions@>=

Constellation&
Constellation::operator=(const Constellation& c)
{

@q ****** (6) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

    if (this == &c) /* Make sure it's not self-assignment. */
       return *this;

@q ****** (6)@>

    return *this;

}  /* End of 
      |Constellation::operator=(const Constellation& m)| definition.  */

@q *** (3) Clear.@> 
@*2 Clear.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Constellation| functions@>=
int
clear(Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Constellation| functions@>= 
int 
Constellation::clear(Scanner_Node scanner_node)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

   return 0;

}  /* End of |Constellation::clear| definition.  */

@q *** (3) Show.@> 
@*2 Show.
\initials{LDF 2021.05.28.}

\LOG
\initials{LDF 2021.05.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Constellation| functions@>=

void 
show(string text = "", Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 

@
@<Define |Constellation| functions@>=
void 
Constellation::show(string text, Scanner_Node scanner_node) const
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

    if (text == "")
       text = "Constellation:";

    cerr << text 
         << endl;

@q ***** (5)@>

    return;

} /* End of |Constellation::show| definition.  */

@q * (1) Planet class definition.@>
@* {\bf Planet} class definition.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this |class| definition.
\ENDLOG

@q ** (2) Code.@> 

@<Declare |class Planet|@>=

class Planet
{

   friend int yyparse(yyscan_t);

   friend int Scan_Parse::get_stars_func(Scanner_Node, vector<Star*>&);
   friend int Scan_Parse::plot_stars_func(Scanner_Node);
   friend int Scan_Parse::show_stars_func(Scanner_Node);


   protected:

   public:

      @<Declare |static| |class Planet| data members@>@;

      @<Declare |Planet| functions@>@;
};

@q ** (2) Static member variable declarations and initializations.@>
@*1 Static member variable declarations and initializations.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@<Declare |static| |class Planet| data members@>=

@q *** (3) Code.@> 
@
@<Initialize |static| |class Planet| data members@>=

@q ** (2) Global constants.@>
@*1 Global constants.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@<Global constants@>=

@q *** (3)@>
@
@<Declarations for the header file@>=

@q ** (2) |Planet| functions.@> 
@*1 {\bf Planet} functions.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@q *** (3) Constructors and Setting Functions.@>
@*2 Constructors and Setting Functions.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@q **** (4) Default Constructor.@> 
@*3 Default Constructor.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Planet| functions@>=
Planet(void);

@q ***** (5) Definition.  @>

@
@<Define |Planet| functions@>= 
Planet::Planet(void)
{
   return;
}


@q **** (4) Setting function.@> 
@*2 Setting function.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Planet| functions@>=
int
set(real real_part, real imaginary_part, Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Planet| functions@>= 
int
Planet::set(real real_part, real imaginary_part, Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Planet::set'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@>

   return 0;

@q ***** (5)@>

}  /* End of |Planet::set| definition.  */

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Planet| functions@>=
virtual
~Planet(void);

@q **** (4) Definition.  @>

@
@<Define |Planet| functions@>= 
Planet::~Planet(void)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

}  /* End of |~Planet| definition.  */

@q *** (3) Pseudo-constructor for dynamic allocation.@>
@*2 Pseudo-constructor for dynamic allocation.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@q **** (4) Pointer argument.@>
@*3 Pointer argument.@>
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Planet|@>=

Planet* 
create_new(const Planet* p, Scanner_Node scanner_node = 0);

@q **** (4) Reference argument.@>
@*3 Referece argument.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Planet|@>=
Planet* 
create_new(const Planet& p, Scanner_Node scanner_node = 0);

@q *** (3) Assignment.@> 
@*2 Assignment.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this section.
\ENDLOG

@q **** (4) Assignment from a |Planet|.@> 
@*3 Assignment from a |Planet|.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Planet| functions@>=
virtual
Planet&
operator=(const Planet& c);

@q ***** (5) Definition.@> 
@
@<Define |Planet| functions@>=

Planet&
Planet::operator=(const Planet& c)
{

@q ****** (6) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

    if (this == &c) /* Make sure it's not self-assignment. */
       return *this;

@q ****** (6)@>

    return *this;

}  /* End of 
      |Planet::operator=(const Planet& m)| definition.  */

@q *** (3) Clear.@> 
@*2 Clear.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Planet| functions@>=
int
clear(Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Planet| functions@>= 
int 
Planet::clear(Scanner_Node scanner_node)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

   return 0;

}  /* End of |Planet::clear| definition.  */

@q *** (3) Show.@> 
@*2 Show.
\initials{LDF 2021.05.29.}

\LOG
\initials{LDF 2021.05.29.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Planet| functions@>=

void 
show(string text = "", Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 

@
@<Define |Planet| functions@>=
void 
Planet::show(string text, Scanner_Node scanner_node) const
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

    if (text == "")
       text = "Planet:";

    cerr << text 
         << endl;

@q ***** (5)@>

    return;

} /* End of |Planet::show| definition.  */

@q ***** (5) Comparison functions for |class Star|.@>
@*6 Comparison functions for |class Star|.
\initials{LDF 2021.06.21.}

\LOG
\initials{LDF 2021.06.22.}
Added this section.
\ENDLOG

@q ****** (6) Compare |star_constant_name|.@>
@*7 Compare |star_constant_name|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_star_constant_name(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_star_constant_name(Star *s, Star *t)
{
   return s->star_constant_name < t->star_constant_name;
}

@q ****** (6) Compare |common_name|.@>
@*7 Compare |common_name|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_common_name(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_common_name(Star *s, Star *t)
{
   return s->common_name < t->common_name;
}

@q ****** (6) Compare |flamsteed_designation_number|.@>
@*7 Compare |flamsteed_designation_number|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_flamsteed_designation_number(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_flamsteed_designation_number(Star *s, Star *t)
{
   return s->flamsteed_designation_number < t->flamsteed_designation_number;
}

@q ****** (6) Compare |bayer_designation_greek_letter|.@>
@*7 Compare |bayer_designation_greek_letter|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_bayer_designation_greek_letter(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_bayer_designation_greek_letter(Star *s, Star *t)
{
   return s->bayer_designation_greek_letter < t->bayer_designation_greek_letter;
}


@q ****** (6) Compare |bayer_designation_greek_letter_tex|.@>
@*7 Compare |bayer_designation_greek_letter_tex|.
\initials{LDF 2021.09.08.}

\LOG
\initials{LDF 2021.09.08.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_bayer_designation_greek_letter_tex(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_bayer_designation_greek_letter_tex(Star *s, Star *t)
{
   return s->bayer_designation_greek_letter_tex < t->bayer_designation_greek_letter_tex;
}


@q ****** (6) Compare |bs_hr_number|.@>
@*7 Compare |bs_hr_number|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_bs_hr_number(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_bs_hr_number(Star *s, Star *t)
{
   return s->bs_hr_number < t->bs_hr_number;
}

@q ****** (6) Compare |bs_number|.@>
@*7 Compare |bs_number|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_bs_number(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_bs_number(Star *s, Star *t)
{
   return compare_bs_hr_number(s, t);
}

@q ****** (6) Compare |hr_number|.@>
@*7 Compare |hr_number|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_hr_number(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_hr_number(Star *s, Star *t)
{
   return compare_bs_hr_number(s, t);
}

@q ****** (6) Compare |approx_rank_apparent_magnitude|.@>
@*7 Compare |approx_rank_apparent_magnitude|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_approx_rank_apparent_magnitude(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_approx_rank_apparent_magnitude(Star *s, Star *t)
{
   return s->approx_rank_apparent_magnitude < t->approx_rank_apparent_magnitude;
}

@q ****** (6) Compare |apparent_magnitude|.@>
@*7 Compare |apparent_magnitude|.
\initials{LDF 2021.07.10.}

\LOG
\initials{LDF 2021.07.10.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_apparent_magnitude(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_apparent_magnitude(Star *s, Star *t)
{
   return s->apparent_magnitude < t->apparent_magnitude;
}

@q ****** (6) Compare |absolute_magnitude|.@>
@*7 Compare |absolute_magnitude|.
\initials{LDF 2021.09.06.}

\LOG
\initials{LDF 2021.09.06.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_absolute_magnitude(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_absolute_magnitude(Star *s, Star *t)
{
   return s->absolute_magnitude < t->absolute_magnitude;
}

@q ****** (6) Compare |constellation_abbreviation|.@>
@*7 Compare |constellation_abbreviation|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_constellation_abbreviation(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_constellation_abbreviation(Star *s, Star *t)
{
   return s->constellation_abbreviation < t->constellation_abbreviation;
}

@q ****** (6) Compare |constellation_full_name|.@>
@*7 Compare |constellation_full_name|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_constellation_full_name(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_constellation_full_name(Star *s, Star *t)
{
   return s->constellation_full_name < t->constellation_full_name;
}

@q ****** (6) Compare |constellation_name_genitive|.@>
@*7 Compare |constellation_name_genitive|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_constellation_name_genitive(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_constellation_name_genitive(Star *s, Star *t)
{
   return s->constellation_name_genitive < t->constellation_name_genitive;
}

@q ****** (6) Compare |constellation_number|.@>
@*7 Compare |constellation_number|.
\initials{LDF 2021.06.22.}

\LOG
\initials{LDF 2021.06.22.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_constellation_number(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_constellation_number(Star *s, Star *t)
{
   return s->constellation_number < t->constellation_number;
}

@q ****** (6) Compare |compare_right_ascension_hours|.@>
@*7 Compare |compare_right_ascension_hours|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_right_ascension_hours(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_right_ascension_hours(Star *s, Star *t)
{
   return s->right_ascension_hours < t->right_ascension_hours;
}

@q ****** (6) Compare |compare_right_ascension_minutes|.@>
@*7 Compare |compare_right_ascension_minutes|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_right_ascension_minutes(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_right_ascension_minutes(Star *s, Star *t)
{
   return s->right_ascension_minutes < t->right_ascension_minutes;
}

@q ****** (6) Compare |compare_right_ascension_seconds|.@>
@*7 Compare |compare_right_ascension_seconds|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_right_ascension_seconds(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_right_ascension_seconds(Star *s, Star *t)
{
   return s->right_ascension_seconds < t->right_ascension_seconds;
}

@q ****** (6) Compare |compare_right_ascension_decimal_hours|.@>
@*7 Compare |compare_right_ascension_decimal_hours|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_right_ascension_decimal_hours(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_right_ascension_decimal_hours(Star *s, Star *t)
{
   return s->right_ascension_decimal_hours < t->right_ascension_decimal_hours;
}

@q ****** (6) Compare |compare_right_ascension_decimal_degrees|.@>
@*7 Compare |compare_right_ascension_decimal_degrees|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_right_ascension_decimal_degrees(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_right_ascension_decimal_degrees(Star *s, Star *t)
{
   return s->right_ascension_decimal_degrees < t->right_ascension_decimal_degrees;
}

@q ****** (6) Compare |compare_declination_degrees|.@>
@*7 Compare |compare_declination_degrees|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_declination_degrees(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_declination_degrees(Star *s, Star *t)
{
   return s->declination_degrees < t->declination_degrees;
}

@q ****** (6) Compare |compare_declination_minutes|.@>
@*7 Compare |compare_declination_minutes|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_declination_minutes(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_declination_minutes(Star *s, Star *t)
{
   return s->declination_minutes < t->declination_minutes;
}

@q ****** (6) Compare |compare_declination_seconds|.@>
@*7 Compare |compare_declination_seconds|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_declination_seconds(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_declination_seconds(Star *s, Star *t)
{
   return s->declination_seconds < t->declination_seconds;
}

@q ****** (6) Compare |compare_declination_decimal_degrees|.@>
@*7 Compare |compare_declination_decimal_degrees|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_declination_decimal_degrees(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_declination_decimal_degrees(Star *s, Star *t)
{
   return s->declination_decimal_degrees < t->declination_decimal_degrees;
}

@q ****** (6) Compare |compare_is_binary|.@>
@*7 Compare |compare_is_binary|.
\initials{LDF 2021.6.27.}

\LOG
\initials{LDF 2021.6.27.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool
compare_is_binary(Star *s, Star *t);

@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_is_binary(Star *s, Star *t)
{
   return s->is_binary < t->is_binary;
}

@q ****** (6) Compare |Star| pointers.@>
@*7 Compare |Star| pointers.
\initials{LDF 2021.06.24.}

\LOG
\initials{LDF 2021.06.24.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.  @>
@
@<Declare non-member functions for |class Star|@>=
bool compare_star_pointers(Star *s, Star *t);


@q ******* (7) Definition.  @>
@
@<Define non-member functions for |class Star|@>=
bool
compare_star_pointers(Star *s, Star *t)
{
   if (s == 0 || t == 0)
      return false;

   return *s == *t;
}


@q * (1) Putting Astronomy together.@>
@* Putting {\bf Astronomy} together.

\immediate\write\functexifile{^^JEnd of file:  astronmy.web^^J}

@q ** (2) This is what's compiled.@> 

This is what's compiled.

@c
@<Include files@>@;
@<Declare |struct Stars_Where_Option_Struct|@>@;
@<Declare |struct Stars_Get_Option_Struct|@>@;
@<Declare |class Star|@>@;
@<Initialize |static| |class Star| data members@>@;
@<Declare non-member functions for |class Star|@>@;
@<Declare non-member template functions for |Star|@>@;
@<Define |Star| functions@>@;
@<Declare |class Constellation|@>@;
@<Initialize |static| |class Constellation| data members@>@;
@<Declare non-member template functions for |Constellation|@>@;
@<Define |Constellation| functions@>@;
@<Declare |class Planet|@>@;
@<Initialize |static| |class Planet| data members@>@;
@<Declare non-member template functions for |Planet|@>@;
@<Define non-member functions for |class Star|@>@;
@<Define |Planet| functions@>@;
@<Global constants@>@;
@<Define |struct Stars_Where_Option_Struct| functions@>@;

@q ** (2) This is what's written to "astronmy.h".@> 

@ This is what's written to \filename{astronmy.h}.

@(astronmy.h@>=
#ifndef LDF_ASTRONMY_KNOWN
#define LDF_ASTRONMY_KNOWN 1
@<Declare |struct Stars_Where_Option_Struct|@>@;
@<Declare |struct Stars_Get_Option_Struct|@>@;
@<Declare |class Star|@>@;
@<Declare |class Constellation|@>@;
@<Declare |class Planet|@>@;
@<Declare non-member template functions for |Star|@>@;
@<Declare non-member template functions for |Constellation|@>@;
@<Declare non-member template functions for |Planet|@>@;
@<Declarations for the header file@>@;
@<Declare non-member functions for |class Star|@>@;
#endif

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
