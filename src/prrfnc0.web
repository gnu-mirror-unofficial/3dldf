@q prrfnc0.web @>
 
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>



@q * (0) Parser rule functions.@>
@** Parser rule functions\quad ({\tt prrfnc0\PERIOD web}).\hfil
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this file.
\ENDLOG

@q * (1) Include files.@>
@ Include files.
\initials{LDF 2005.04.15.}

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"
#include "imetfncs.h++"
#include "deftfncs.h++"
#include "sctpcrt.h++"  
#include "sctpfncs.h++"  

@q * (1) Initialize |name_map| and |type_name_map|. @>
@* Initialize {\bf name\_map} and {\bf type\_name\_map}. 

\LOG
\initials{LDF Undated.}  
Added entry for |EQUALS|.

\initials{LDF 2004.05.17.}  
Added entries for |BOOLEAN|,
|BOOLEAN_DECLARATOR|, |OR|, |AND|, |EQUAL|, |NOT_EQUAL|, |LESS|,  
|LESS_OR_EQUAL|, |GREATER|, |GREATER_OR_EQUAL|, 
|NOT|, |TRUE|, |FALSE|, |IS_ODD|, |IS_EVEN|, |IS_CYCLE|, |IS_KNOWN|, 
|IS_UNKNOWN|, and |CHAREXISTS|.
Removed the entry for |EQUALS|.  

\initials{LDF 2004.05.19.}  
Added entry for |BOOLEAN_DECLARATOR|.

\initials{LDF 2004.11.07.}
Removed entries for the internal quantities.

\initials{LDF 2005.06.09.}
Moved this function definition from \filename{pbsndecl.w} to this
file (\filename{prrfnc0.web}).
\ENDLOG 

@q ** (2) Definition. @>

@<Define functions@>=
int
initialize_name_map(void)
{

  name_map[NULL_VALUE] = "NULL_VALUE";

@q *** (3) Predefined sparks. @>
@*2 Predefined sparks.

\LOG
\initials{LDF 2004.05.13.}  
Now adding entries in |name_map| for
|AMPERSAND|, |CYCLE|, |PERIOD_PAIR|, |PERIOD_TRIPLE|, |HYPHEN|, |HYPHEN_PAIR|, 
and |HYPHEN_TRIPLE|.

\initials{LDF 2004.05.13.}  
Now adding entries in |name_map| for
|REVERSE|, |SUBPATH|, and |OF|.

\initials{LDF 2004.09.10.}
Added |name_map| entry for |COLON|.

\initials{LDF 2004.09.30.}
Added |name_map| entry for |END_INPUT|.

\initials{LDF 2005.01.02.}
Replaced the entry for |CURLY_BRACES| with ones for |LEFT_BRACE| and 
|RIGHT_BRACE|.

\initials{LDF 2005.12.06.}
Added entry for |ULONG_LONG_TYPE|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=
  name_map[END] = "END";
  name_map[INPUT] = "INPUT";
  name_map[END_INPUT] = "END_INPUT";
  name_map[TERMINATE] = "TERMINATE";
  name_map[INVALID_CATCODE] = "INVALID_CATCODE";
  name_map[INVALID_CHAR] = "INVALID_CHAR";
  name_map[SPACE] = "SPACE";

  name_map[AMPERSAND] = "AMPERSAND";

  name_map[CYCLE] = "CYCLE";

  name_map[REVERSE] = "REVERSE";

  name_map[SUBPATH] = "SUBPATH";

  name_map[OF] = "OF";

  name_map[PERIOD] = "PERIOD";
  name_map[PERIOD_PAIR] = "PERIOD_PAIR";
  name_map[PERIOD_TRIPLE] = "PERIOD_TRIPLE";

  name_map[HYPHEN] = "HYPHEN";
  name_map[HYPHEN_PAIR] = "HYPHEN_PAIR";
  name_map[HYPHEN_TRIPLE] = "HYPHEN_TRIPLE";

  name_map[COMMA] = "COMMA";
  name_map[COLON] = "COLON";
  name_map[SEMI_COLON] = "SEMI_COLON";
  name_map[LEFT_PARENTHESIS] = "LEFT_PARENTHESIS";
  name_map[RIGHT_PARENTHESIS] = "RIGHT_PARENTHESIS";
  name_map[DOUBLE_QUOTE] = "DOUBLE_QUOTE";
  name_map[LEFT_BRACKET] = "LEFT_BRACKET";
  name_map[RIGHT_BRACKET] = "RIGHT_BRACKET";
  name_map[LEFT_BRACE]    = "LEFT_BRACE";
  name_map[RIGHT_BRACE]   = "RIGHT_BRACE";
  name_map[DIGIT] = "DIGIT";
  name_map[INTEGER] = "INTEGER";
  name_map[ULONG_LONG_TYPE] = "ULONG_LONG_TYPE";
  name_map[REAL] = "REAL";
  name_map[PERCENT] = "PERCENT";

@q *** (3) Basic symbolic tokens.  @>
@*2 Basic symbolic tokens.
@<Define functions@>=

  name_map[SYMBOL_0] = "SYMBOL_0";
  name_map[SYMBOL_1] = "SYMBOL_1";
  name_map[SYMBOL_2] = "SYMBOL_2";
  name_map[SYMBOL_3] = "SYMBOL_3";
  name_map[SYMBOL_4] = "SYMBOL_4";
  name_map[SYMBOL_5] = "SYMBOL_5";
  name_map[SYMBOL_6] = "SYMBOL_6";
  name_map[SYMBOL_7] = "SYMBOL_7";


@q *** (3) General-Purpose Words and ``Syntactic Sugar''.@>
@*2 General-Purpose Words and ``Syntactic Sugar''.
\initials{LDF 2004.09.24.}

\LOG
\initials{LDF 2004.09.24.}
Added this section with |name_map| entries for 
|IN|, |BY|, and |AROUND|.

\initials{LDF 2004.12.03.}
Added |name_map| entry for |OFF|.
\ENDLOG

@<Define functions@>=

  name_map[IN]     = "IN";
  name_map[OFF]    = "OFF";
  name_map[BY]     = "BY";
  name_map[AROUND] = "AROUND";

@q *** (3) Object types defined in 3DLDF (and |UNDECLARED|).  @>
@*2 Object types defined in 3DLDF (and |UNDECLARED|).

\LOG
\initials{LDF 2004.06.08.}  
Added entry for |FOCUS|.

\initials{LDF 2004.07.01.}
Added entry for |SYNONYM|.

\initials{LDF 2004.08.23.}
Added entry for |COLOR_VECTOR|.

\initials{LDF 2004.08.27.}
Added entry for |POINT_VECTOR|.

\initials{LDF 2004.09.01.}
Added entries for |BOOL_POINT| and |BOOL_POINT_VECTOR|.

\initials{LDF 2004.12.10.}
Added entries for |PATH_VECTOR|, 
|TRIANGLE_VECTOR|, |REG_POLYGON_VECTOR|, 
|RECTANGLE_VECTOR|, |SQUARE_VECTOR|, 
|ELLIPSE_VECTOR|, |CIRCLE_VECTOR|,  |CUBOID_VECTOR|, 
|TETRAHEDRON_VECTOR|, |OCTAHEDRON_VECTOR|, |DODECAHEDRON_VECTOR|, 
|ICOSAHEDRON_VECTOR|, and |TRUNC_OCTAHEDRON_VECTOR|.

\initials{LDF 2004.12.11.}
Added entries for 
|BOOLEAN_VECTOR_DECLARATOR|, 
|STRING_VECTOR_DECLARATOR|, 
|NUMERIC_VECTOR_DECLARATOR|, 
|TRANSFORM_VECTOR_DECLARATOR|, 
|PEN_VECTOR_DECLARATOR|, 
|DASH_PATTERN_VECTOR_DECLARATOR|, 
|FOCUS_VECTOR_DECLARATOR|, and
|PICTURE_VECTOR_DECLARATOR|.

\initials{LDF 2004.12.13.}
Added entries for 
|BOOLEAN_VECTOR|, 
|STRING_VECTOR|, 
|NUMERIC_VECTOR|, 
|PEN_VECTOR|, 
|DASH_PATTERN_VECTOR|, 
|PICTURE_VECTOR|, 
|TRANSFORM_VECTOR|, and
|FOCUS_VECTOR|.

\initials{LDF 2004.12.21.}
Added |type_name_map| entries for 
|BOOLEAN_VECTOR_DECLARATOR|,
|STRING_VECTOR_DECLARATOR|, 
|NUMERIC_VECTOR_DECLARATOR|,
|TRANSFORM_VECTOR_DECLARATOR|,
|PEN_VECTOR_DECLARATOR|, 
|DASH_PATTERN_VECTOR_DECLARATOR|,
|FOCUS_VECTOR_DECLARATOR|, 
and 
|PICTURE_VECTOR_DECLARATOR|.

\initials{LDF 2005.01.26.}
Added entries for |NURB| and |NURB_VECTOR|.

\initials{LDF 2005.02.03.}
Added entries for |ORIGAMI_FIGURE| and |ORIGAMI_FIGURE_VECTOR|.

\initials{LDF 2005.02.11.}
Added entries for |POLYGON| and |POLYGON_VECTOR|.

\initials{LDF 2005.05.18.}
Added entries for |HELIX| and |HELIX_VECTOR|.

\initials{LDF 2005.12.05.}
Added entries for |ULONG_LONG|, |ULONG_LONG_VECTOR|, and 
|ULONG_LONG_VECTOR_DECLARATOR|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=

   name_map[SYNONYM] = "SYNONYM";
   name_map[UNDECLARED] = "UNDECLARED";
   name_map[BOOLEAN] = "BOOLEAN";
   name_map[BOOL_POINT] = "BOOL_POINT";
   name_map[NUMERIC] = "NUMERIC";
   name_map[ULONG_LONG] = "ULONG_LONG";
   name_map[STRING] = "STRING";
   name_map[PEN] = "PEN";
   name_map[DASH_PATTERN] = "DASH_PATTERN";
   name_map[COLOR] = "COLOR";
   name_map[PICTURE] = "PICTURE";
   name_map[TRANSFORM] = "TRANSFORM";
   name_map[POINT] = "POINT";
   name_map[FOCUS] = "FOCUS";
   name_map[NURB] = "NURB";
   name_map[PATH] = "PATH";
   name_map[TRIANGLE] = "TRIANGLE";
   name_map[POLYGON] = "POLYGON";
   name_map[REG_POLYGON] = "REG_POLYGON";
   name_map[RECTANGLE] = "RECTANGLE";
   name_map[SQUARE] = "SQUARE";
   name_map[ELLIPSE] = "ELLIPSE";
   name_map[CIRCLE] = "CIRCLE";
   name_map[HELIX] = "HELIX";
   name_map[CUBOID] = "CUBOID";
   name_map[POLYHEDRON] = "POLYHEDRON";

   name_map[ORIGAMI_FIGURE]
     = "ORIGAMI_FIGURE";


   name_map[ELLIPSE_SLICE] = "ELLIPSE_SLICE";
   name_map[CIRCLE_SLICE] = "CIRCLE_SLICE";
   name_map[POLYHEDRON_SLICE] = "POLYHEDRON_SLICE";

   name_map[ELLIPSE_SLICE_VECTOR] = "ELLIPSE_SLICE_VECTOR";
   name_map[CIRCLE_SLICE_VECTOR] = "CIRCLE_SLICE_VECTOR";
   name_map[POLYHEDRON_SLICE_VECTOR] = "POLYHEDRON_SLICE_VECTOR";


   name_map[BOOLEAN_VECTOR] = "BOOLEAN_VECTOR";
   name_map[STRING_VECTOR] = "STRING_VECTOR";
   name_map[NUMERIC_VECTOR] = "NUMERIC_VECTOR";
   name_map[ULONG_LONG_VECTOR] = "ULONG_LONG_VECTOR";
   name_map[COLOR_VECTOR] = "COLOR_VECTOR";
   name_map[PEN_VECTOR] = "PEN_VECTOR";
   name_map[DASH_PATTERN_VECTOR] = "DASH_PATTERN_VECTOR";
   name_map[PICTURE_VECTOR] = "PICTURE_VECTOR";
   name_map[TRANSFORM_VECTOR] = "TRANSFORM_VECTOR";
   name_map[FOCUS_VECTOR] = "FOCUS_VECTOR";

   name_map[POINT_VECTOR] = "POINT_VECTOR";
   name_map[BOOL_POINT_VECTOR] = "BOOL_POINT_VECTOR";
   name_map[NURB_VECTOR] = "NURB_VECTOR";
   name_map[PATH_VECTOR] = "PATH_VECTOR";
   name_map[TRIANGLE_VECTOR] = "TRIANGLE_VECTOR";
   name_map[POLYGON_VECTOR] = "POLYGON_VECTOR";
   name_map[REG_POLYGON_VECTOR] = "REG_POLYGON_VECTOR";
   name_map[RECTANGLE_VECTOR] = "RECTANGLE_VECTOR";
   name_map[SQUARE_VECTOR] = "SQUARE_VECTOR";
   name_map[ELLIPSE_VECTOR] = "ELLIPSE_VECTOR";
   name_map[CIRCLE_VECTOR] = "CIRCLE_VECTOR";
   name_map[HELIX_VECTOR] = "HELIX_VECTOR";
   name_map[CUBOID_VECTOR] = "CUBOID_VECTOR";
   name_map[POLYHEDRON_VECTOR] = "POLYHEDRON_VECTOR";

   name_map[ORIGAMI_FIGURE_VECTOR] = "ORIGAMI_FIGURE_VECTOR";

   name_map[BOOLEAN_VECTOR_DECLARATOR] = "BOOLEAN_VECTOR_DECLARATOR";
   name_map[STRING_VECTOR_DECLARATOR] = "STRING_VECTOR_DECLARATOR";
   name_map[NUMERIC_VECTOR_DECLARATOR] = "NUMERIC_VECTOR_DECLARATOR";
   name_map[ULONG_LONG_VECTOR_DECLARATOR] = "ULONG_LONG_VECTOR_DECLARATOR";
   name_map[TRANSFORM_VECTOR_DECLARATOR] = "TRANSFORM_VECTOR_DECLARATOR";
   name_map[PEN_VECTOR_DECLARATOR] = "PEN_VECTOR_DECLARATOR";
   name_map[DASH_PATTERN_VECTOR_DECLARATOR] = "DASH_PATTERN_VECTOR_DECLARATOR";
   name_map[FOCUS_VECTOR_DECLARATOR] = "FOCUS_VECTOR_DECLARATOR";
   name_map[PICTURE_VECTOR_DECLARATOR] = "PICTURE_VECTOR_DECLARATOR";

   type_name_map[BOOLEAN_VECTOR_DECLARATOR] = "boolean_vector";
   type_name_map[STRING_VECTOR_DECLARATOR] = "string_vector";
   type_name_map[NUMERIC_VECTOR_DECLARATOR] = "numeric_vector";
   type_name_map[ULONG_LONG_VECTOR_DECLARATOR] = "ulong_long_vector";
   type_name_map[TRANSFORM_VECTOR_DECLARATOR] = "transform_vector";
   type_name_map[PEN_VECTOR_DECLARATOR] = "pen_vector";
   type_name_map[DASH_PATTERN_VECTOR_DECLARATOR] = "dash_pattern_vector";
   type_name_map[FOCUS_VECTOR_DECLARATOR] = "focus_vector";
   type_name_map[PICTURE_VECTOR_DECLARATOR] = "picture_vector";





@q *** (3) Declarators for object types defined in 3DLDF.  @>
@*2 Declarators for object types defined in 3DLDF.

\LOG
\initials{LDF 2004.08.23.}
Added entries for |COLOR_DECLARATOR| (which was missing) 
and |COLOR_VECTOR_DECLARATOR|.

\initials{LDF 2004.08.27.}
Added entry for |POINT_VECTOR_DECLARATOR|.

\initials{LDF 2004.09.01.}
Added entries for |BOOL_POINT_DECLARATOR| and 
|BOOL_POINT_VECTOR_DECLARATOR|.

\initials{LDF 2004.12.10.}
Added entries for |PATH_VECTOR_DECLARATOR|, 
|TRIANGLE_VECTOR_DECLARATOR|, |REG_POLYGON_VECTOR_DECLARATOR|, 
|RECTANGLE_VECTOR_DECLARATOR|, |SQUARE_VECTOR_DECLARATOR|, 
|ELLIPSE_VECTOR_DECLARATOR|, |CIRCLE_VECTOR_DECLARATOR|,  
|CUBOID_VECTOR_DECLARATOR|, |TETRAHEDRON_VECTOR_DECLARATOR|, 
|OCTAHEDRON_VECTOR_DECLARATOR|, |DODECAHEDRON_VECTOR_DECLARATOR|, 
|ICOSAHEDRON_VECTOR_DECLARATOR|, 
and |TRUNC_OCTAHEDRON_VECTOR_DECLARATOR|.

\initials{LDF 2005.01.26.}
Added entries in |name_map| and |type_name_map|
for |NURB_DECLARATOR| and |NURB_VECTOR_DECLARATOR|.

\initials{LDF 2005.02.03.}
Added entries in |name_map| and |type_name_map|
for |ORIGAMI_FIGURE_DECLARATOR| and |ORIGAMI_FIGURE_VECTOR_DECLARATOR|.

\initials{LDF 2005.02.11.}
Added entries in |name_map| and |type_name_map|
for |POLYGON_DECLARATOR| and |POLYGON_VECTOR_DECLARATOR|.

\initials{LDF 2005.05.18.}
Added entries in |name_map| and |type_name_map|
for |HELIX_DECLARATOR| and |HELIX_VECTOR_DECLARATOR|.  


\initials{LDF 2005.05.24.}
Added |type_name_map| entries for 
|HELIX_SLICE_DECLARATOR|, 
|HELIX_SLICE_VECTOR_DECLARATOR|, 
|CONE_DECLARATOR|, 
|CONE_VECTOR_DECLARATOR|, 
|CONE_SLICE_DECLARATOR|, 
|CONE_SLICE_VECTOR_DECLARATOR|, 
|CYLINDER_DECLARATOR|, 
|CYLINDER_VECTOR_DECLARATOR|, 
|CYLINDER_SLICE_DECLARATOR|, 
|CYLINDER_SLICE_VECTOR_DECLARATOR|, 
|ELLIPSOID_DECLARATOR|, 
|ELLIPSOID_VECTOR_DECLARATOR|, 
|ELLIPSOID_SLICE_DECLARATOR|, 
|ELLIPSOID_SLICE_VECTOR_DECLARATOR|, 
|SPHERE_DECLARATOR|, 
|SPHERE_VECTOR_DECLARATOR|, 
|SPHERE_SLICE_DECLARATOR|, 
and 
|SPHERE_SLICE_VECTOR_DECLARATOR|. 

\initials{LDF 2005.06.08.}
Added |type_name_map| entries for 
|GLYPH_DECLARATOR|, |GLYPH_VECTOR_DECLARATOR|, 
|GLYPH_SLICE_DECLARATOR|, and |GLYPH_SLICE_VECTOR_DECLARATOR|. 

\initials{LDF 2005.10.30.}
Added |type_name_map| entries for 
|PLANE_DECLARATOR| and |PLANE_VECTOR_DECLARATOR|, 

\initials{LDF 2005.12.05.}
Added entries for |ULONG_LONG_DECLARATOR|.
\ENDLOG 

@q **** (4) Code.@>

@<Define functions@>=

  name_map[BOOLEAN_DECLARATOR] = "BOOLEAN_DECLARATOR";

  name_map[STRING_DECLARATOR] = "STRING_DECLARATOR";
  name_map[COLOR_DECLARATOR] = "COLOR_DECLARATOR";
  name_map[NUMERIC_DECLARATOR] = "NUMERIC_DECLARATOR";
  name_map[ULONG_LONG_DECLARATOR] = "ULONG_LONG_DECLARATOR";
  name_map[TRANSFORM_DECLARATOR] = "TRANSFORM_DECLARATOR";
  name_map[POINT_DECLARATOR] = "POINT_DECLARATOR";
  name_map[BOOL_POINT_DECLARATOR] = "BOOL_POINT_DECLARATOR";
  name_map[FOCUS_DECLARATOR] = "FOCUS_DECLARATOR";
  name_map[NURB_DECLARATOR] = "NURB_DECLARATOR";
  name_map[PATH_DECLARATOR] = "PATH_DECLARATOR";
  name_map[TRIANGLE_DECLARATOR] = "TRIANGLE_DECLARATOR";
  name_map[POLYGON_DECLARATOR] = "POLYGON_DECLARATOR";
  name_map[REG_POLYGON_DECLARATOR] = "REG_POLYGON_DECLARATOR";
  name_map[RECTANGLE_DECLARATOR] = "RECTANGLE_DECLARATOR";
  name_map[SQUARE_DECLARATOR] = "SQUARE_DECLARATOR";
  name_map[ELLIPSE_DECLARATOR] = "ELLIPSE_DECLARATOR";
  name_map[CIRCLE_DECLARATOR] = "CIRCLE_DECLARATOR";
  name_map[HELIX_DECLARATOR] = "HELIX_DECLARATOR";
  name_map[CUBOID_DECLARATOR] = "CUBOID_DECLARATOR";
  name_map[POLYHEDRON_DECLARATOR] = "POLYHEDRON_DECLARATOR";

  name_map[ELLIPSE_SLICE_DECLARATOR] = "ELLIPSE_SLICE_DECLARATOR";
  name_map[CIRCLE_SLICE_DECLARATOR] = "CIRCLE_SLICE_DECLARATOR";
  name_map[POLYHEDRON_SLICE_DECLARATOR] = "POLYHEDRON_SLICE_DECLARATOR";

  name_map[ELLIPSE_SLICE_VECTOR_DECLARATOR] 
     = "ELLIPSE_SLICE_VECTOR_DECLARATOR";

  name_map[CIRCLE_SLICE_VECTOR_DECLARATOR] 
     = "CIRCLE_SLICE_VECTOR_DECLARATOR";

  name_map[POLYHEDRON_SLICE_VECTOR_DECLARATOR] 
     = "POLYHEDRON_SLICE_VECTOR_DECLARATOR";

  name_map[ORIGAMI_FIGURE_DECLARATOR]
    = "ORIGAMI_FIGURE_DECLARATOR";


  name_map[COLOR_VECTOR_DECLARATOR] = "COLOR_VECTOR_DECLARATOR";
  name_map[POINT_VECTOR_DECLARATOR] = "POINT_VECTOR_DECLARATOR";
  name_map[BOOL_POINT_VECTOR_DECLARATOR] = "BOOL_POINT_VECTOR_DECLARATOR";
  name_map[NURB_VECTOR_DECLARATOR] = "NURB_VECTOR_DECLARATOR";
  name_map[PATH_VECTOR_DECLARATOR] = "PATH_VECTOR_DECLARATOR";
  name_map[TRIANGLE_VECTOR_DECLARATOR] = "TRIANGLE_VECTOR_DECLARATOR";
  name_map[POLYGON_VECTOR_DECLARATOR] = "POLYGON_VECTOR_DECLARATOR";
  name_map[REG_POLYGON_VECTOR_DECLARATOR] = "REG_POLYGON_VECTOR_DECLARATOR";
  name_map[RECTANGLE_VECTOR_DECLARATOR] = "RECTANGLE_VECTOR_DECLARATOR";
  name_map[SQUARE_VECTOR_DECLARATOR] = "SQUARE_VECTOR_DECLARATOR";
  name_map[ELLIPSE_VECTOR_DECLARATOR] = "ELLIPSE_VECTOR_DECLARATOR";
  name_map[CIRCLE_VECTOR_DECLARATOR] = "CIRCLE_VECTOR_DECLARATOR";
  name_map[HELIX_VECTOR_DECLARATOR] = "HELIX_VECTOR_DECLARATOR";
  name_map[CUBOID_VECTOR_DECLARATOR] = "CUBOID_VECTOR_DECLARATOR";
  name_map[POLYHEDRON_VECTOR_DECLARATOR] = "POLYHEDRON_VECTOR_DECLARATOR";

  name_map[ORIGAMI_FIGURE_VECTOR_DECLARATOR]
     = "ORIGAMI_FIGURE_VECTOR_DECLARATOR";

  type_name_map[BOOLEAN_DECLARATOR] = "boolean";

  type_name_map[STRING_DECLARATOR] = "string";
  type_name_map[COLOR_DECLARATOR] = "color";
  type_name_map[NUMERIC_DECLARATOR] = "numeric";
  type_name_map[ULONG_LONG_DECLARATOR] = "ulong_long";
  type_name_map[TRANSFORM_DECLARATOR] = "transform";
  type_name_map[POINT_DECLARATOR] = "point";
  type_name_map[BOOL_POINT_DECLARATOR] = "bool_point";
  type_name_map[FOCUS_DECLARATOR] = "focus";
  type_name_map[NURB_DECLARATOR] = "nurb";
  type_name_map[PATH_DECLARATOR] = "path";
  type_name_map[TRIANGLE_DECLARATOR] = "triangle";
  type_name_map[POLYGON_DECLARATOR] = "polygon";
  type_name_map[REG_POLYGON_DECLARATOR] = "reg_polygon";
  type_name_map[RECTANGLE_DECLARATOR] = "rectangle";
  type_name_map[SQUARE_DECLARATOR] = "square";
  type_name_map[ELLIPSE_DECLARATOR] = "ellipse";
  type_name_map[CIRCLE_DECLARATOR] = "circle";
  type_name_map[HELIX_DECLARATOR] = "helix";
  type_name_map[CUBOID_DECLARATOR] = "cuboid";
  type_name_map[POLYHEDRON_DECLARATOR] = "polyhedron";

  type_name_map[ELLIPSE_SLICE_DECLARATOR] = "ellipse_slice";
  type_name_map[CIRCLE_SLICE_DECLARATOR] = "circle_slice";
  type_name_map[POLYHEDRON_SLICE_DECLARATOR] = "polyhedron_slice";

  type_name_map[ELLIPSE_SLICE_VECTOR_DECLARATOR] 
     = "ellipse_slice_vector";

  type_name_map[CIRCLE_SLICE_VECTOR_DECLARATOR] 
     = "circle_slice_vector";

  type_name_map[POLYHEDRON_SLICE_VECTOR_DECLARATOR] 
     = "polyhedron_slice_vector";

  type_name_map[ORIGAMI_FIGURE_DECLARATOR] = "origami_figure";


  type_name_map[COLOR_VECTOR_DECLARATOR] = "color_vector";
  type_name_map[POINT_VECTOR_DECLARATOR] = "point_vector";
  type_name_map[BOOL_POINT_VECTOR_DECLARATOR] = "bool_point_vector";
  type_name_map[NURB_VECTOR_DECLARATOR] = "nurb_vector";
  type_name_map[PATH_VECTOR_DECLARATOR] = "path_vector";
  type_name_map[TRIANGLE_VECTOR_DECLARATOR] = "triangle_vector";
  type_name_map[POLYGON_VECTOR_DECLARATOR] = "polygon_vector";
  type_name_map[REG_POLYGON_VECTOR_DECLARATOR] = "reg_polygon_vector";
  type_name_map[RECTANGLE_VECTOR_DECLARATOR] = "rectangle_vector";
  type_name_map[SQUARE_VECTOR_DECLARATOR] = "square_vector";
  type_name_map[ELLIPSE_VECTOR_DECLARATOR] = "ellipse_vector";
  type_name_map[CIRCLE_VECTOR_DECLARATOR] = "circle_vector";
  type_name_map[HELIX_VECTOR_DECLARATOR] = "helix_vector";
  type_name_map[CUBOID_VECTOR_DECLARATOR] = "cuboid_vector";
  type_name_map[POLYHEDRON_VECTOR_DECLARATOR] = "polyhedron_vector";

  type_name_map[ORIGAMI_FIGURE_VECTOR_DECLARATOR] = "origami_figure_vector";

  type_name_map[HELIX_SLICE_DECLARATOR] = "helix_slice";
  type_name_map[HELIX_SLICE_VECTOR_DECLARATOR] = "helix_slice_vector";
  type_name_map[CONE_DECLARATOR] = "cone";
  type_name_map[CONE_VECTOR_DECLARATOR] = "cone_vector";
  type_name_map[CONE_SLICE_DECLARATOR] = "cone_slice";
  type_name_map[CONE_SLICE_VECTOR_DECLARATOR] = "cone_slice_vector";
  type_name_map[CYLINDER_DECLARATOR] = "cylinder";
  type_name_map[CYLINDER_VECTOR_DECLARATOR] = "cylinder_vector";
  type_name_map[CYLINDER_SLICE_DECLARATOR] = "cylinder_slice";
  type_name_map[CYLINDER_SLICE_VECTOR_DECLARATOR] = "cylinder_slice_vector";
  type_name_map[ELLIPSOID_DECLARATOR] = "ellipsoid";
  type_name_map[ELLIPSOID_VECTOR_DECLARATOR] = "ellipsoid_vector";
  type_name_map[ELLIPSOID_SLICE_DECLARATOR] = "ellipsoid_slice";
  type_name_map[ELLIPSOID_SLICE_VECTOR_DECLARATOR] = "ellipsoid_slice_vector";

  type_name_map[SPHERE_DECLARATOR] = "sphere";
  type_name_map[SPHERE_VECTOR_DECLARATOR] = "sphere_vector";
  type_name_map[SPHERE_SLICE_DECLARATOR] = "sphere_slice";
  type_name_map[SPHERE_SLICE_VECTOR_DECLARATOR] = "sphere_slice_vector";

  type_name_map[GLYPH_DECLARATOR] = "glyph";
  type_name_map[GLYPH_VECTOR_DECLARATOR] = "glyph_vector";
  type_name_map[GLYPH_SLICE_DECLARATOR] = "glyph_slice";
  type_name_map[GLYPH_SLICE_VECTOR_DECLARATOR] = "glyph_slice_vector";

  type_name_map[PLANE_DECLARATOR] = "plane";
  type_name_map[PLANE_VECTOR_DECLARATOR] = "plane_vector";


@q **** (4) Types for conic sections, quadric surfaces, and related types.@> 
@*3 Types for conic sections, quadric surfaces, and related types.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section with entries for 
|PARABOLA_DECLARATOR|,           
|HYPERBOLA_DECLARATOR|,          
|PARABOLOID_DECLARATOR|,         
|HYPERBOLOID_DECLARATOR|,        
|PARABOLA_SLICE_DECLARATOR|,     
|HYPERBOLA_SLICE_DECLARATOR|,    
|PARABOLOID_SLICE_DECLARATOR|
and |HYPERBOLOID_SLICE_DECLARATOR|.

\initials{LDF 2007.07.29.}
Added |type_name_map| entries for |CONIC_SECTION_LATTICE_DECLARATOR| and
|CONIC_SECTION_LATTICE_VECTOR_DECLARATOR|.  Added |_DECLARATOR| in several 
places where it was missing.

\initials{LDF 2007.10.13.}
Added entries for |ARC_DECLARATOR| and |ARC_VECTOR_DECLARATOR|.
\ENDLOG

@q ***** (5) Code.@> 

@<Define functions@>=

   type_name_map[PARABOLA_DECLARATOR]                 = "parabola";
   type_name_map[HYPERBOLA_DECLARATOR]                = "hyperbola";

   type_name_map[ARC_DECLARATOR]                      = "arc";

   type_name_map[PARABOLOID_DECLARATOR]               = "paraboloid";
   type_name_map[HYPERBOLOID_DECLARATOR]              = "hyperboloid";
   type_name_map[PARABOLA_VECTOR_DECLARATOR]          = "parabola_vector";
   type_name_map[HYPERBOLA_VECTOR_DECLARATOR]         = "hyperbola_vector";

   type_name_map[ARC_VECTOR_DECLARATOR]               = "arc_vector";

   type_name_map[PARABOLOID_VECTOR_DECLARATOR]        = "paraboloid_vector";
   type_name_map[HYPERBOLOID_VECTOR_DECLARATOR]       = "hyperboloid_vector";
   type_name_map[PARABOLA_SLICE_DECLARATOR]           = "parabola_slice";
   type_name_map[HYPERBOLA_SLICE_DECLARATOR]          = "hyperbola_slice";
   type_name_map[PARABOLOID_SLICE_DECLARATOR]         = "paraboloid_slice";
   type_name_map[HYPERBOLOID_SLICE_DECLARATOR]        = "hyperboloid_slice";
   type_name_map[PARABOLA_SLICE_VECTOR_DECLARATOR]    = "parabola_slice_vector";
   type_name_map[HYPERBOLA_SLICE_VECTOR_DECLARATOR]   = "hyperbola_slice_vector";
   type_name_map[PARABOLOID_SLICE_VECTOR_DECLARATOR]  = "paraboloid_slice_vector"; 
   type_name_map[HYPERBOLOID_SLICE_VECTOR_DECLARATOR] = "hyperboloid_slice_vector";


@q *** (3) System information.@>
@*2 System information.
\initials{LDF 2004.11.15.}

\LOG
\initials{LDF 2004.11.15.}
Added this section with |name_map| entries for
|IS_BIG_ENDIAN| and |IS_LITTLE_ENDIAN|.
\ENDLOG

@<Define functions@>=


   name_map[IS_BIG_ENDIAN]    = "IS_BIG_ENDIAN";
   name_map[IS_LITTLE_ENDIAN] = "IS_LITTLE_ENDIAN"; 


@q *** (3) Transformers and Transform Commands.  @>
@*2 Transformers and Transform Commands.

\LOG
\initials{LDF 2004.05.09.}  
Added this section.

\initials{LDF 2004.09.24.}
Added |name_map| entries for the transform commands.

\initials{LDF 2004.10.04.}
Changed |REFLECTED_IN| to |REFLECTED|.

\initials{LDF 2004.10.13.}
Added |name_map| entry for |ROTATE_AROUND|.

\initials{LDF 2004.12.03.}
Replaced |REFLECTED| with |REFLECTED_IN| and |REFLECTED_OFF|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=

  name_map[REFLECTED_IN] = "REFLECTED_IN";
  name_map[REFLECTED_OFF] = "REFLECTED_OFF";
  name_map[ROTATED] = "ROTATED";
  name_map[ROTATED_AROUND] = "ROTATED_AROUND";
  name_map[SCALED] = "SCALED";
  name_map[SHEARED] = "SHEARED";
  name_map[SHIFTED] = "SHIFTED";
  name_map[TRANSFORMED] = "TRANSFORMED";
  name_map[XSCALED] = "XSCALED";
  name_map[YSCALED] = "YSCALED";
  name_map[ZSCALED] = "ZSCALED";

  name_map[REFLECT] = "REFLECT";
  name_map[ROTATE] = "ROTATE";
  name_map[ROTATE_AROUND] = "ROTATE_AROUND";
  name_map[SCALE] = "SCALE";
  name_map[SHEAR] = "SHEAR";
  name_map[SHIFT] = "SHIFT";
  name_map[TRANSFORM_BY] = "TRANSFORM_BY";
  name_map[XSCALE] = "XSCALE";
  name_map[YSCALE] = "YSCALE";
  name_map[ZSCALE] = "ZSCALE";


@q *** (3) Operators.  @>
@*2 Operators.

\LOG
\initials{LDF 2004.04.28.}  
Added |name_map| entries for |XPART|, |YPART|,
|ZPART|, and |WPART|. 

\initials{LDF 2004.04.28.}  
Added |name_map| entry for |MAGNITUDE|.

\initials{LDF 2004.04.28.}  
Added |name_map| entry for |ANGLE|.

\initials{LDF 2004.05.17.} 
Added |name_map| entries for |OR|, |AND|, |EQUAL|,
|NOT_EQUAL|, |LESS|, |LESS_OR_EQUAL|, |GREATER|, |GREATER_OR_EQUAL|, 
|NOT|, and |EQUATE|.  Removed the entry for |EQUALS|.

\initials{LDF 2004.05.17.}  
Added |name_map| entries for 
|TRUE|, |FALSE|, |IS_ODD|, |IS_EVEN|, |IS_CYCLE|, |IS_KNOWN|, 
|IS_UNKNOWN|, and |CHAREXISTS|.


\initials{LDF 2004.06.07.}
Removed the entry in |name_map| for |WITH_DOTS|.  
|with_dots| is now a predefined variable defined in |Scanner_Type::create| in 
\filename{scan.web}.

\initials{LDF 2004.08.25.}
Added |name_map| entries for |PLUS_ASSIGN|, |MINUS_ASSIGN|, |TIMES_ASSIGN|,  
and |DIVIDE_ASSIGN|.

\initials{LDF 2004.10.02.}
Added entries for the following type predicates:\hfil\break
|IS_SYNONYM|, |IS_UNDECLARED|,
|IS_BOOLEAN|, |IS_BOOL_POINT|, |IS_BOOL_POINT_VECTOR|, |IS_STRING|,
|IS_NUMERIC|, |IS_PEN|, |IS_DASH_PATTERN|, |IS_COLOR|, |IS_COLOR_VECTOR|,
|IS_PICTURE|, |IS_TRANSFORM|, |IS_POINT|, |IS_POINT_VECTOR|, |IS_FOCUS|,
|IS_PATH|, |IS_TRIANGLE|, |IS_REG_POLYGON|, |IS_RECTANGLE|, |IS_SQUARE|,
|IS_ELLIPSE|, |IS_CIRCLE|, |IS_CUBOID|, |IS_TETRAHEDRON|, |IS_OCTAHEDRON|,
|IS_DODECAHEDRON|, |IS_ICOSAHEDRON|, and |IS_TRUNC_OCTAHEDRON|.

\initials{LDF 2004.10.05.}
Added |name_map| entries for |DOT_PRODUCT| and |CROSS_PRODUCT|.

\initials{LDF 2004.10.06.}
Added |name_map| entries for |NORMAL| and |UNIT_VECTOR|.

\initials{LDF 2004.10.06.}
Added |name_map| entries for |XXPART|, |XYPART|, |XZPART|, 
|YXPART|, |YYPART|, |YZPART|, and |ZXPART|, |ZYPART|, 
and |ZZPART|.

\initials{LDF 2004.10.07.}
@:BUG FIX@> BUG FIX: 
Added |name_map| entries for |WXPART|, |WYPART|, and |WZPART|. 

\initials{LDF 2004.10.14.}
Added |name_map| entries for 
|IS_ELLIPTICAL|,
|IS_CIRCULAR|,
|IS_REG_POLYGONAL|,
|IS_TRIANGULAR|,
|IS_QUADRATICAL|,
|IS_PENTAGONAL|,
|IS_HEXAGONAL|,
|IS_HEPTAGONAL|,
|IS_OCTAGONAL|,
|IS_NONAGONAL|,
|IS_DECAGONAL|,
|IS_ONDECAGONAL|,
|IS_DODECAGONAL|,
|IS_RECTANGULAR|,
|IS_CONVEX|,
|IS_CONICAL|,
|IS_PARABOLIC|,
|IS_HYPERBOLIC|,
|IS_TRAPEZOIDAL|,
|IS_PRISMOIDAL|,
|IS_CUBOIDAL|,
|IS_ELLIPSOIDAL|,
|IS_SPHEROIDAL|, and
|IS_SPHERICAL|.         

\initials{LDF 2004.10.22.}
Added |name_map| entries for 
|IS_ON_SEGMENT|, |IS_ON_LINE|, 
|IS_IN_TRIANGLE|, |IS_IN_RECTANGLE|, and |LOCATION|.

\initials{LDF 2004.10.23.}
Added |name_map| entries for 
|IS_PARALLEL|, 
|IS_COPLANAR|, 
|IS_SKEW|, 
|IS_NON_PARALLEL|, 
|IS_NON_COPLANAR|, and 
|IS_NON_SKEW|.

\initials{LDF 2004.10.23.}
Added |name_map| entry for |DISTANCE|.

\initials{LDF 2004.10.23.}
Changed |DISTANCE| to |DISTANCE_TO_PLANE|.

\initials{LDF 2004.10.25.}
Added |name_map| entries for |IS_PLANAR| and |DISTANCE_ALONG_LINE|.

\initials{LDF 2004.10.25.}
Added |name_map| entry for |IS_LINEAR|.

\initials{LDF 2004.10.25.}
Removed the |name_map| entries for |IS_NON_PARALLEL|, 
|IS_NON_COPLANAR|, and |IS_NON_SKEW|.

\initials{LDF 2004.10.26.}
Added |name_map| entry for |IS_COLINEAR|.

\initials{LDF 2004.12.10.}
Added entries for |IS_PATH_VECTOR|, 
|IS_TRIANGLE_VECTOR|, |IS_REG_POLYGON_VECTOR|, 
|IS_RECTANGLE_VECTOR|, |IS_SQUARE_VECTOR|, 
|IS_ELLIPSE_VECTOR|, |IS_CIRCLE_VECTOR|,  |IS_CUBOID_VECTOR|, 
|IS_TETRAHEDRON_VECTOR|, |IS_OCTAHEDRON_VECTOR|, |IS_DODECAHEDRON_VECTOR|, 
|IS_ICOSAHEDRON_VECTOR|, and |IS_TRUNC_OCTAHEDRON_VECTOR|.

\initials{LDF 2004.12.11.}
Added entries for 
|IS_BOOLEAN_VECTOR|, 
|IS_STRING_VECTOR|, 
|IS_NUMERIC_VECTOR|, 
|IS_TRANSFORM_VECTOR|, 
|IS_PEN_VECTOR|, 
|IS_DASH_PATTERN_VECTOR|, 
|IS_FOCUS_VECTOR|, and
|IS_PICTURE_VECTOR|.

\initials{LDF 2004.12.16.}
Added |name_map| entries for |RED_PART|, 
|GREEN_PART|, |BLUE_PART|, |YELLOW_PART|, |MAGENTA_PART|,
|CYAN_PART|, |BLACK_PART|, |WHITE_PART|, |BLUE_VIOLET_PART|, and
|RED_ORANGE_PART|.

\initials{LDF 2005.01.25.}
Added |name_map| entry for |IS_QUADRILATERAL|.

\initials{LDF 2005.01.25.}
Added |name_map| entries for |IS_NURB| and |IS_NURB_VECTOR|.

\initials{LDF 2005.02.03.}
Added |name_map| entries for |IS_ORIGAMI_FIGURE| and 
|IS_ORIGAMI_FIGURE_VECTOR|.

\initials{LDF 2005.02.07.}
Added |name_map| entry for |IS_CONVEX_POLYGONAL|.

\initials{LDF 2005.02.11.}
Added |name_map| entries for |IS_POLYGON|, 
|IS_POLYGON_VECTOR|, and |IS_POLYGONAL|.

\initials{LDF 2005.05.18.}
Added |name_map| entries for |IS_HELIX| 
|IS_HELIX_VECTOR|, and |IS_HELICAL|.

\initials{LDF 2005.05.24.}
Added |name_map| entries for
|HELIX_SLICE|, |HELIX_SLICE_VECTOR|,
|CONE|, |CONE_VECTOR|, |CONE_SLICE|, |CONE_SLICE_VECTOR|,
|CYLINDER|, |CYLINDER_VECTOR|,
|CYLINDER_SLICE|, |CYLINDER_SLICE_VECTOR|,
|ELLIPSOID|, |ELLIPSOID_VECTOR|, |ELLIPSOID_SLICE|, 
|ELLIPSOID_SLICE_VECTOR|,
|SPHERE|, |SPHERE_VECTOR|, |SPHERE_SLICE|, 
|SPHERE_SLICE_VECTOR|, |HELIX_SLICE_DECLARATOR|, 
|HELIX_SLICE_VECTOR_DECLARATOR|, |CONE_DECLARATOR|, |CONE_VECTOR_DECLARATOR|, 
|CONE_SLICE_DECLARATOR|, 
|CONE_SLICE_VECTOR_DECLARATOR|,
|CYLINDER_DECLARATOR|, |CYLINDER_VECTOR_DECLARATOR|,
|CYLINDER_SLICE_DECLARATOR|, |CYLINDER_SLICE_VECTOR_DECLARATOR|,
|ELLIPSOID_DECLARATOR|, |ELLIPSOID_VECTOR_DECLARATOR|, 
|ELLIPSOID_SLICE_DECLARATOR|, |ELLIPSOID_SLICE_VECTOR_DECLARATOR|,
|SPHERE_DECLARATOR|, |SPHERE_VECTOR_DECLARATOR|, |SPHERE_SLICE_DECLARATOR|, 
|SPHERE_SLICE_VECTOR_DECLARATOR|,
|IS_HELIX_SLICE|, |IS_HELIX_SLICE_VECTOR|,
|IS_CONE|, |IS_CONE_VECTOR|, |IS_CONICAL|,
|IS_CONE_SLICE|, |IS_CONE_SLICE_VECTOR|,
|IS_CYLINDER|, |IS_CYLINDER_VECTOR|,
|IS_CYLINDER_SLICE|, |IS_CYLINDER_SLICE_VECTOR|, |IS_CYLINDRICAL|,
|IS_ELLIPSOID|, |IS_ELLIPSOID_VECTOR|, |IS_ELLIPSOID_SLICE|, 
|IS_ELLIPSOID_SLICE_VECTOR|, 
|IS_SPHERE|, |IS_SPHERE_VECTOR|, |IS_SPHERE_SLICE|, 
and |IS_SPHERE_SLICE_VECTOR|.

\initials{LDF 2005.06.08.}
Added |name_map| entries for
|SPHERE|, |SPHERE_VECTOR|, |SPHERE_SLICE|, 
|SPHERE_SLICE_VECTOR|, |SPHERE_DECLARATOR|, 
|SPHERE_VECTOR_DECLARATOR|, |SPHERE_SLICE_DECLARATOR|, 
|SPHERE_SLICE_VECTOR_DECLARATOR|, |IS_SPHERE|, 
|IS_SPHERE_VECTOR|, |IS_SPHERE_SLICE|, 
and |IS_SPHERE_SLICE_VECTOR|.

\initials{LDF 2005.10.26.}
Added |name_map| entries for |PLANE|, |PLANE_VECTOR|,
|PLANE_DECLARATOR|, |PLANE_VECTOR_DECLARATOR|.
|IS_PLANE|, and |IS_PLANE_VECTOR|.

\initials{LDF 2005.11.02.}
Added |name_map| entries for 
|IS_ON_ELLIPSE|, |IS_ON_CIRCLE|, |IS_ON_PARABOLA|, and
|IS_ON_HYPERBOLA|.

\initials{LDF 2005.11.21.}
Added |name_map| entries for |IS_VALID| and |IS_INVALID|.

\initials{LDF 2005.12.05.}
Added entries for |IS_ULONG_LONG| and |IS_ULONG_LONG_VECTOR|.

\initials{LDF 2005.12.14.}
Changed |NORMAL| to |GET_NORMAL|.

\initials{LDF 2007.02.06.}
Added entries for |TAND|, |ARCSIND|, |ARCCOSD|, 
and |ARCTAND|.

\initials{LDF 2007.07.09.}
Added |name_map| entry for |ARE_ON_CONIC_SECTION|.

\initials{LDF 2007.07.22.}
Added |name_map| entry for |ARE_DISTINCT|.

\initials{LDF 2007.08.03.}
Added |name_map| entries for 
|IS_NOT_PARALLEL|, 
|ARE_PARALLEL|, 
|ARE_NOT_PARALLEL|, 
|IS_PERPENDICULAR|,
|IS_NOT_PERPENDICULAR|,
|ARE_PERPENDICULAR|,
|ARE_NOT_PERPENDICULAR|,
|IS_NOT_COPLANAR|,
|ARE_COPLANAR|,
|ARE_NOT_COPLANAR|,
|IS_NOT_SKEW|, 
|ARE_SKEW|,
|ARE_NOT_SKEW|,
|IS_NOT_COLINEAR|,
|ARE_COLINEAR|,
and 
|ARE_NOT_COLINEAR|.

\initials{LDF 2007.10.13.}
Added |name_map| entry for |IS_ON_ARC|.

\initials{LDF 2007.11.08.}
Added |name_map| entries for |GET_PERPENDICULAR| and |GET_PERPENDICULAR_BASE|.

\initials{LDF 2007.11.08.}
Added |name_map| entries for |IS_ON_PLANE|, |IS_IN_REG_POLYGON| and 
|IS_IN_POLYGON|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=

   name_map[TIMES] = "TIMES";
   name_map[OVER] = "OVER";
   name_map[ANGLE] = "ANGLE";

   name_map[DOT_PRODUCT]   = "DOT_PRODUCT";
   name_map[CROSS_PRODUCT] = "CROSS_PRODUCT";

   name_map[GET_NORMAL] = "GET_NORMAL";
   name_map[UNIT_VECTOR] = "UNIT_VECTOR";

   name_map[GET_PERPENDICULAR]      = "GET_PERPENDICULAR";
   name_map[GET_PERPENDICULAR_BASE] = "GET_PERPENDICULAR_BASE";

   name_map[PLUS] = "PLUS";
   name_map[MINUS] = "MINUS";

   name_map[SQRT] = "SQRT";  

   name_map[SIND] = "SIND";  
   name_map[COSD] = "COSD";  
   name_map[TAND] = "TAND";  

   name_map[ARCSIND] = "ARCSIND";  
   name_map[ARCCOSD] = "ARCCOSD";  
   name_map[ARCTAND] = "ARCTAND";  


   name_map[MLOG] = "MLOG";  
   name_map[MEXP] = "MEXP";
   name_map[FLOOR] = "FLOOR";  
   name_map[UNIFORMDEVIATE] = "UNIFORMDEVIATE";

   name_map[PYTHAGOREAN_PLUS] = "PYTHAGOREAN_PLUS"; 
   name_map[PYTHAGOREAN_MINUS] = "PYTHAGOREAN_MINUS"; 

   name_map[OR] = "OR";
   name_map[AND] = "AND";
   name_map[EQUAL] = "EQUAL";
   name_map[NOT_EQUAL] = "NOT_EQUAL";
   name_map[LESS] = "LESS";
   name_map[LESS_OR_EQUAL] = "LESS_OR_EQUAL";
   name_map[GREATER]  = "GREATER";
   name_map[GREATER_OR_EQUAL] = "GREATER_OR_EQUAL";
   name_map[NOT] = "NOT";

   name_map[ASSIGN] = "ASSIGN";
   name_map[EQUATE] = "EQUATE";

   name_map[PLUS_ASSIGN] = "PLUS_ASSIGN";
   name_map[MINUS_ASSIGN] = "MINUS_ASSIGN";
   name_map[TIMES_ASSIGN] = "TIMES_ASSIGN";
   name_map[DIVIDE_ASSIGN] = "DIVIDE_ASSIGN";


   name_map[TRUE]                 = "TRUE";
   name_map[FALSE]                = "FALSE";
   name_map[IS_ODD]               = "IS_ODD";   
   name_map[IS_EVEN]              = "IS_EVEN";

   name_map[IS_CYCLE]             = "IS_CYCLE";
   name_map[IS_KNOWN]             = "IS_KNOWN";
   name_map[IS_UNKNOWN]           = "IS_UNKNOWN";
   name_map[CHAREXISTS]           = "CHAREXISTS";

   name_map[IS_VALID]             = "IS_VALID";
   name_map[IS_INVALID]           = "IS_INVALID";

   name_map[IS_SYNONYM]           = "IS_SYNONYM";
   name_map[IS_UNDECLARED]        = "IS_UNDECLARED";
   name_map[IS_BOOLEAN]           = "IS_BOOLEAN";
   name_map[IS_BOOL_POINT]        = "IS_BOOL_POINT";
   name_map[IS_BOOL_POINT_VECTOR] = "IS_BOOL_POINT_VECTOR";
   name_map[IS_STRING]            = "IS_STRING";
   name_map[IS_NUMERIC]           = "IS_NUMERIC";
   name_map[IS_ULONG_LONG]        = "IS_ULONG_LONG";
   name_map[IS_PEN]               = "IS_PEN";
   name_map[IS_DASH_PATTERN]      = "IS_DASH_PATTERN";
   name_map[IS_COLOR]             = "IS_COLOR";
   name_map[IS_COLOR_VECTOR]      = "IS_COLOR_VECTOR";
   name_map[IS_PICTURE]           = "IS_PICTURE";
   name_map[IS_TRANSFORM]         = "IS_TRANSFORM";
   name_map[IS_POINT]             = "IS_POINT";
   name_map[IS_POINT_VECTOR]      = "IS_POINT_VECTOR";
   name_map[IS_FOCUS]             = "IS_FOCUS";
   name_map[IS_NURB]              = "IS_NURB";
   name_map[IS_PATH]              = "IS_PATH";
   name_map[IS_TRIANGLE]          = "IS_TRIANGLE";
   name_map[REG_POLYGON]          = "IS_POLYGON";
   name_map[IS_REG_POLYGON]       = "IS_REG_POLYGON";
   name_map[IS_RECTANGLE]         = "IS_RECTANGLE";
   name_map[IS_ELLIPSE]           = "IS_ELLIPSE";
   name_map[IS_CIRCLE]            = "IS_CIRCLE";
   name_map[IS_HELIX]             = "IS_HELIX";
   name_map[IS_CUBOID]            = "IS_CUBOID";
   name_map[IS_POLYHEDRON]       = "IS_POLYHEDRON";

   name_map[IS_ELLIPSE_SLICE]           = "IS_ELLIPSE_SLICE";
   name_map[IS_CIRCLE_SLICE]            = "IS_CIRCLE_SLICE";
   name_map[IS_POLYHEDRON_SLICE]        = "IS_POLYHEDRON_SLICE";

   name_map[IS_ELLIPSE_SLICE_VECTOR]    = "IS_ELLIPSE_SLICE_VECTOR";
   name_map[IS_CIRCLE_SLICE_VECTOR]     = "IS_CIRCLE_SLICE_VECTOR";
   name_map[IS_POLYHEDRON_SLICE_VECTOR] = "IS_POLYHEDRON_SLICE_VECTOR";

   name_map[IS_ORIGAMI_FIGURE]    = "IS_ORIGAMI_FIGURE";

   name_map[IS_LINEAR]            = "IS_LINEAR";
   name_map[IS_PLANAR]            = "IS_PLANAR";

   name_map[IS_ELLIPTICAL]        = "IS_ELLIPTICAL";
   name_map[IS_CIRCULAR]          = "IS_CIRCULAR";
   name_map[IS_HELICAL]           = "IS_HELICAL";

   name_map[IS_POLYGONAL]         = "IS_POLYGONAL";
   name_map[IS_REG_POLYGONAL]     = "IS_REG_POLYGONAL";

   name_map[IS_TRIANGULAR]        = "IS_TRIANGULAR";
   name_map[IS_QUADRATICAL]       = "IS_QUADRATICAL";
   name_map[IS_PENTAGONAL]        = "IS_PENTAGONAL";
   name_map[IS_HEXAGONAL]         = "IS_HEXAGONAL";
   name_map[IS_HEPTAGONAL]        = "IS_HEPTAGONAL";
   name_map[IS_OCTAGONAL]         = "IS_OCTAGONAL";
   name_map[IS_NONAGONAL]         = "IS_NONAGONAL";
   name_map[IS_DECAGONAL]         = "IS_DECAGONAL";
   name_map[IS_ONDECAGONAL]       = "IS_ONDECAGONAL";
   name_map[IS_DODECAGONAL]       = "IS_DODECAGONAL";

   name_map[IS_RECTANGULAR]       = "IS_RECTANGULAR";
   name_map[IS_QUADRILATERAL]     = "IS_QUADRILATERAL";
   name_map[IS_CONVEX_POLYGONAL]  = "IS_CONVEX_POLYGONAL";
   name_map[IS_SQUARE]            = "IS_SQUARE";
   name_map[IS_CONVEX]            = "IS_CONVEX";
   name_map[IS_CONICAL]           = "IS_CONICAL";
   name_map[IS_PARABOLIC]         = "IS_PARABOLIC";
   name_map[IS_HYPERBOLIC]        = "IS_HYPERBOLIC";
   name_map[IS_TRAPEZOIDAL]       = "IS_TRAPEZOIDAL";
   name_map[IS_PRISMOIDAL]        = "IS_PRISMOIDAL";

   name_map[IS_CUBOIDAL]           = "IS_CUBOIDAL";
   name_map[IS_ELLIPSOIDAL]        = "IS_ELLIPSOIDAL";
   name_map[IS_SPHEROIDAL]         = "IS_SPHEROIDAL";
   name_map[IS_SPHERICAL]          = "IS_SPHERICAL";

   name_map[IS_ON_SEGMENT] = "IS_ON_SEGMENT";
   name_map[IS_ON_LINE] = "IS_ON_LINE ";
   name_map[IS_IN_TRIANGLE] = "IS_IN_TRIANGLE";

   name_map[IS_ON_PLANE]       = "IS_ON_PLANE";
   name_map[IS_IN_REG_POLYGON] = "IS_IN_REG_POLYGON";
   name_map[IS_IN_POLYGON]     = "IS_IN_POLYGON";         

   name_map[IS_IN_RECTANGLE] = "IS_IN_RECTANGLE";
   name_map[LOCATION] = "LOCATION";

   name_map[DISTANCE_TO_PLANE] = "DISTANCE_TO_PLANE";

   name_map[DISTANCE_ALONG_LINE] = "DISTANCE_ALONG_LINE";

   name_map[IS_PARALLEL] = "IS_PARALLEL";
   name_map[IS_NOT_PARALLEL] = "IS_NOT_PARALLEL"; 
   name_map[ARE_PARALLEL] = "ARE_PARALLEL";  
   name_map[ARE_NOT_PARALLEL] = "ARE_NOT_PARALLEL";  

   name_map[IS_PERPENDICULAR] = "IS_PERPENDICULAR"; 
   name_map[IS_NOT_PERPENDICULAR] = "IS_NOT_PERPENDICULAR"; 
   name_map[ARE_PERPENDICULAR] = "ARE_PERPENDICULAR"; 
   name_map[ARE_NOT_PERPENDICULAR] = "ARE_NOT_PERPENDICULAR"; 

   name_map[IS_COPLANAR] = "IS_COPLANAR";
   name_map[IS_NOT_COPLANAR] = "IS_NOT_COPLANAR"; 
   name_map[ARE_COPLANAR] = "ARE_COPLANAR"; 
   name_map[ARE_NOT_COPLANAR] = "ARE_NOT_COPLANAR"; 

   name_map[IS_SKEW] = "IS_SKEW";
   name_map[IS_NOT_SKEW] = "IS_NOT_SKEW"; 
   name_map[ARE_SKEW] = "ARE_SKEW"; 
   name_map[ARE_NOT_SKEW] = "ARE_NOT_SKEW"; 

   name_map[IS_COLINEAR] = "IS_COLINEAR";
   name_map[IS_NOT_COLINEAR] = "IS_NOT_COLINEAR"; 
   name_map[ARE_COLINEAR] = "ARE_COLINEAR"; 
   name_map[ARE_NOT_COLINEAR] = "ARE_NOT_COLINEAR"; 

   name_map[LENGTH] = "LENGTH";
   name_map[MAGNITUDE] = "MAGNITUDE";

   name_map[SIZE] = "SIZE";

   name_map[XPART] = "XPART";
   name_map[YPART] = "YPART";
   name_map[ZPART] = "ZPART";
   name_map[WPART] = "WPART";

   name_map[XXPART] = "XXPART";
   name_map[XYPART] = "XYPART";
   name_map[XZPART] = "XZPART";

   name_map[YXPART] = "YXPART";
   name_map[YYPART] = "YYPART";
   name_map[YZPART] = "YZPART";

   name_map[ZXPART] = "ZXPART";
   name_map[ZYPART] = "ZYPART";
   name_map[ZZPART] = "ZZPART";

   name_map[WXPART] = "WXPART";
   name_map[WYPART] = "WYPART";
   name_map[WZPART] = "WZPART";

   name_map[RED_PART] = "RED_PART";
   name_map[GREEN_PART] = "GREEN_PART";
   name_map[BLUE_PART] = "BLUE_PART";
   name_map[YELLOW_PART] = "YELLOW_PART";
   name_map[MAGENTA_PART] = "MAGENTA_PART";
   name_map[CYAN_PART] = "CYAN_PART";
   name_map[BLACK_PART] = "BLACK_PART";
   name_map[WHITE_PART] = "WHITE_PART";
   name_map[BLUE_VIOLET_PART] = "BLUE_VIOLET_PART";
   name_map[RED_ORANGE_PART] = "RED_ORANGE_PART";

   name_map[IS_NURB_VECTOR] = "IS_NURB_VECTOR";
   name_map[IS_PATH_VECTOR] = "IS_PATH_VECTOR";
   name_map[IS_TRIANGLE_VECTOR] = "IS_TRIANGLE_VECTOR";
   name_map[IS_POLYGON_VECTOR] = "IS_POLYGON_VECTOR";
   name_map[IS_REG_POLYGON_VECTOR] = "IS_REG_POLYGON_VECTOR";
   name_map[IS_RECTANGLE_VECTOR] = "IS_RECTANGLE_VECTOR";
   name_map[IS_SQUARE_VECTOR] = "IS_SQUARE_VECTOR";
   name_map[IS_ELLIPSE_VECTOR] = "IS_ELLIPSE_VECTOR";
   name_map[IS_CIRCLE_VECTOR] = "IS_CIRCLE_VECTOR";
   name_map[IS_HELIX_VECTOR] = "IS_HELIX_VECTOR";
   name_map[IS_CUBOID_VECTOR] = "IS_CUBOID_VECTOR";
   name_map[IS_POLYHEDRON_VECTOR] = "IS_POLYHEDRON_VECTOR";

   name_map[IS_ORIGAMI_FIGURE_VECTOR] = "IS_ORIGAMI_FIGURE_VECTOR";

   name_map[IS_BOOLEAN_VECTOR] = "IS_BOOLEAN_VECTOR";
   name_map[IS_STRING_VECTOR] = "IS_STRING_VECTOR";
   name_map[IS_NUMERIC_VECTOR] = "IS_NUMERIC_VECTOR";
   name_map[IS_ULONG_LONG_VECTOR] = "IS_ULONG_LONG_VECTOR";
   name_map[IS_TRANSFORM_VECTOR] = "IS_TRANSFORM_VECTOR";
   name_map[IS_PEN_VECTOR] = "IS_PEN_VECTOR";
   name_map[IS_DASH_PATTERN_VECTOR] = "IS_DASH_PATTERN_VECTOR";
   name_map[IS_FOCUS_VECTOR] = "IS_FOCUS_VECTOR";
   name_map[IS_PICTURE_VECTOR] = "IS_PICTURE_VECTOR";

   name_map[HELIX_SLICE] = "HELIX_SLICE";
   name_map[HELIX_SLICE_VECTOR] = "HELIX_SLICE_VECTOR";
   name_map[CONE] = "CONE";
   name_map[CONE_VECTOR] = "CONE_VECTOR";
   name_map[CONE_SLICE] = "CONE_SLICE";
   name_map[CONE_SLICE_VECTOR] = "CONE_SLICE_VECTOR";
   name_map[CYLINDER] = "CYLINDER";
   name_map[CYLINDER_VECTOR] = "CYLINDER_VECTOR";
   name_map[CYLINDER_SLICE] = "CYLINDER_SLICE";
   name_map[CYLINDER_SLICE_VECTOR] = "CYLINDER_SLICE_VECTOR";
   name_map[ELLIPSOID] = "ELLIPSOID";
   name_map[ELLIPSOID_VECTOR] = "ELLIPSOID_VECTOR";
   name_map[ELLIPSOID_SLICE] = "ELLIPSOID_SLICE";
   name_map[ELLIPSOID_SLICE_VECTOR] = "ELLIPSOID_SLICE_VECTOR";

   name_map[SPHERE] = "SPHERE";
   name_map[SPHERE_VECTOR] = "SPHERE_VECTOR";
   name_map[SPHERE_SLICE] = "SPHERE_SLICE";
   name_map[SPHERE_SLICE_VECTOR] = "SPHERE_SLICE_VECTOR";

   name_map[GLYPH] = "GLYPH";
   name_map[GLYPH_VECTOR] = "GLYPH_VECTOR";
   name_map[GLYPH_SLICE] = "GLYPH_SLICE";
   name_map[GLYPH_SLICE_VECTOR] = "GLYPH_SLICE_VECTOR";

   name_map[PLANE] = "PLANE";
   name_map[PLANE_VECTOR] = "PLANE_VECTOR";

   name_map[HELIX_SLICE_DECLARATOR] = "HELIX_SLICE_DECLARATOR";
   name_map[HELIX_SLICE_VECTOR_DECLARATOR] = "HELIX_SLICE_VECTOR_DECLARATOR";
   name_map[CONE_DECLARATOR] = "CONE_DECLARATOR";
   name_map[CONE_VECTOR_DECLARATOR] = "CONE_VECTOR_DECLARATOR";
   name_map[CONE_SLICE_DECLARATOR] = "CONE_SLICE_DECLARATOR";
   name_map[CONE_SLICE_VECTOR_DECLARATOR] = "CONE_SLICE_VECTOR_DECLARATOR";
   name_map[CYLINDER_DECLARATOR] = "CYLINDER_DECLARATOR";
   name_map[CYLINDER_VECTOR_DECLARATOR] = "CYLINDER_VECTOR_DECLARATOR";
   name_map[CYLINDER_SLICE_DECLARATOR] = "CYLINDER_SLICE_DECLARATOR";
   name_map[CYLINDER_SLICE_VECTOR_DECLARATOR] = "CYLINDER_SLICE_VECTOR_DECLARATOR";
   name_map[ELLIPSOID_DECLARATOR] = "ELLIPSOID_DECLARATOR";
   name_map[ELLIPSOID_VECTOR_DECLARATOR] = "ELLIPSOID_VECTOR_DECLARATOR";
   name_map[ELLIPSOID_SLICE_DECLARATOR] = "ELLIPSOID_SLICE_DECLARATOR";
   name_map[ELLIPSOID_SLICE_VECTOR_DECLARATOR] 
      = "ELLIPSOID_SLICE_VECTOR_DECLARATOR";

   name_map[SPHERE_DECLARATOR] = "SPHERE_DECLARATOR";
   name_map[SPHERE_VECTOR_DECLARATOR] = "SPHERE_VECTOR_DECLARATOR";
   name_map[SPHERE_SLICE_DECLARATOR] = "SPHERE_SLICE_DECLARATOR";
   name_map[SPHERE_SLICE_VECTOR_DECLARATOR] = "SPHERE_SLICE_VECTOR_DECLARATOR";

   name_map[GLYPH_DECLARATOR] = "GLYPH_DECLARATOR";
   name_map[GLYPH_VECTOR_DECLARATOR] = "GLYPH_VECTOR_DECLARATOR";
   name_map[GLYPH_SLICE_DECLARATOR] = "GLYPH_SLICE_DECLARATOR";
   name_map[GLYPH_SLICE_VECTOR_DECLARATOR] = "GLYPH_SLICE_VECTOR_DECLARATOR";

   name_map[PLANE_DECLARATOR] = "PLANE_DECLARATOR";
   name_map[PLANE_VECTOR_DECLARATOR] = "PLANE_VECTOR_DECLARATOR";

   name_map[IS_HELIX_SLICE] = "IS_HELIX_SLICE";
   name_map[IS_HELIX_SLICE_VECTOR] = "IS_HELIX_SLICE_VECTOR";

   name_map[IS_CONE] = "IS_CONE";
   name_map[IS_CONE_VECTOR] = "IS_CONE_VECTOR";
   name_map[IS_CONICAL] = "IS_CONICAL";
   name_map[IS_CONE_SLICE] = "IS_CONE_SLICE";
   name_map[IS_CONE_SLICE_VECTOR] = "IS_CONE_SLICE_VECTOR";
   name_map[IS_CYLINDER] = "IS_CYLINDER";
   name_map[IS_CYLINDER_VECTOR] = "IS_CYLINDER_VECTOR";
   name_map[IS_CYLINDER_SLICE] = "IS_CYLINDER_SLICE";
   name_map[IS_CYLINDER_SLICE_VECTOR] = "IS_CYLINDER_SLICE_VECTOR";
   name_map[IS_CYLINDRICAL] = "IS_CYLINDRICAL";
   name_map[IS_ELLIPSOID] = "IS_ELLIPSOID";
   name_map[IS_ELLIPSOID_VECTOR] = "IS_ELLIPSOID_VECTOR";
   name_map[IS_ELLIPSOID_SLICE] = "IS_ELLIPSOID_SLICE";
   name_map[IS_ELLIPSOID_SLICE_VECTOR] = "IS_ELLIPSOID_SLICE_VECTOR";

   name_map[IS_SPHERE] = "IS_SPHERE";
   name_map[IS_SPHERE_VECTOR] = "IS_SPHERE_VECTOR";
   name_map[IS_SPHERE_SLICE] = "IS_SPHERE_SLICE";
   name_map[IS_SPHERE_SLICE_VECTOR] = "IS_SPHERE_SLICE_VECTOR";

   name_map[IS_GLYPH] = "IS_GLYPH";
   name_map[IS_GLYPH_VECTOR] = "IS_GLYPH_VECTOR";
   name_map[IS_GLYPH_SLICE] = "IS_GLYPH_SLICE";
   name_map[IS_GLYPH_SLICE_VECTOR] = "IS_GLYPH_SLICE_VECTOR";

   name_map[IS_PLANE] = "IS_PLANE";
   name_map[IS_PLANE_VECTOR] = "IS_PLANE_VECTOR";

   name_map[IS_ON_ELLIPSE] = "IS_ON_ELLIPSE";
   name_map[IS_ON_CIRCLE] = "IS_ON_CIRCLE";
   name_map[IS_ON_PARABOLA] = "IS_ON_PARABOLA";
   name_map[IS_ON_HYPERBOLA] = "IS_ON_HYPERABOLA";

   name_map[IS_ON_ARC] = "IS_ON_ARC";

   name_map[ARE_DISTINCT] = "ARE_DISTINCT";

   name_map[ARE_ON_CONIC_SECTION] = "ARE_ON_CONIC_SECTION";

   name_map[IS_ON_SPHERE] = "IS_ON_SPHERE";
   name_map[WITH_TOLERANCE] = "WITH_TOLERANCE";

@q *** (3) Types for |numerics|.@>
@*2 Types for {\bf numerics}.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this section with entries for |MEASURE_TEXT| and |WITH_PRECISION|.
\ENDLOG

@<Define functions@>=

   name_map[MEASURE_TEXT]      = "MEASURE_TEXT";
   name_map[WITH_PRECISION]    = "WITH_PRECISION";

@q *** (3) Types for prime numbers.@>
@*2 Types for prime numbers.
\initials{LDF 2005.12.06.}

\LOG
\initials{LDF 2005.12.05.}
Added entries for |GET_PRIME|, |GET_NEAREST_PRIME|, and |GET_PRIME_FACTORS|.

\initials{LDF 2005.12.05.}
Added entries for |IS_PRIME| and |IS_COMPOSITE|.

\initials{LDF 2005.12.06.}
Added this section.  Moved the existing entries to here from 
where they were before.

\initials{LDF 2005.12.06.}
Added entries for |GET_PRIME_VECTOR|,
|GET_FERMAT_PRIME|, |GET_FERMAT_PRIME_VECTOR|,
|GET_GAUSS_PRIME|, |GET_GAUSS_PRIME_VECTOR|,
|GET_MERSENNE_PRIME|, |GET_MERSENNE_PRIME_VECTOR|,
|IS_PRIME_VECTOR|,
|IS_FERMAT_PRIME|, |IS_FERMAT_PRIME_VECTOR|,
|IS_GAUSS_PRIME|, |IS_GAUSS_PRIME_VECTOR|,
|IS_MERSENNE_PRIME|, and |IS_MERSENNE_PRIME_VECTOR|.
\ENDLOG

@<Define functions@>=

   name_map[IS_PRIME]             = "IS_PRIME";
   name_map[IS_COMPOSITE]         = "IS_COMPOSITE";

   name_map[GET_PRIME]         = "GET_PRIME";
   name_map[GET_NEAREST_PRIME] = "GET_NEAREST_PRIME";
   name_map[GET_PRIME_FACTORS] = "GET_PRIME_FACTORS";

   name_map[GET_PRIME_VECTOR] = "GET_PRIME_VECTOR";

   name_map[IS_PRIME] = "IS_PRIME";
   name_map[IS_PRIME_VECTOR] = "IS_PRIME_VECTOR";

   name_map[IS_COMPOSITE] = "IS_COMPOSITE";
   name_map[IS_COMPOSITE_VECTOR] = "IS_COMPOSITE_VECTOR";

   name_map[GET_FERMAT_PRIME] = "GET_FERMAT_PRIME";
   name_map[GET_FERMAT_PRIME_VECTOR] = "GET_FERMAT_PRIME_VECTOR";
   name_map[IS_FERMAT_PRIME] = "IS_FERMAT_PRIME";
   name_map[IS_FERMAT_PRIME_VECTOR] = "IS_FERMAT_PRIME_VECTOR";

   name_map[GET_GAUSS_PRIME] = "GET_GAUSS_PRIME";
   name_map[GET_GAUSS_PRIME_VECTOR] = "GET_GAUSS_PRIME_VECTOR";
   name_map[IS_GAUSS_PRIME] = "IS_GAUSS_PRIME";
   name_map[IS_GAUSS_PRIME_VECTOR] = "IS_GAUSS_PRIME_VECTOR";

   name_map[GET_MERSENNE_PRIME] = "GET_MERSENNE_PRIME";
   name_map[GET_MERSENNE_PRIME_VECTOR] = "GET_MERSENNE_PRIME_VECTOR";
   name_map[IS_MERSENNE_PRIME] = "IS_MERSENNE_PRIME";
   name_map[IS_MERSENNE_PRIME_VECTOR] = "IS_MERSENNE_PRIME_VECTOR";

@q *** (3) Tokens for matrix types.@>
@*2 Tokens for matrix types.
\initials{LDF 2007.11.28.}

\LOG
\initials{LDF 2007.11.28.}
Added this section.

\initials{LDF 2007.11.29.}
Added |name_map| entries for |IDENTITY_MATRIX|, |ZERO_MATRIX| and |ONE_MATRIX|.

\initials{LDF 2007.11.29.}
Added |name_map| entries for |IS_IDENTITY|, |IS_ZERO|, |IS_ONE|, |IS_MULTIPLIABLE|, 
and |IS_SINGULAR|.
\ENDLOG

@<Define functions@>=

   name_map[DOUBLE_TYPE_MATRIX]              = "DOUBLE_TYPE_MATRIX";
   name_map[FLOAT_TYPE_MATRIX]               = "FLOAT_TYPE_MATRIX";
   name_map[LONG_DOUBLE_TYPE_MATRIX]         = "LONG_DOUBLE_TYPE_MATRIX";
   name_map[INT_TYPE_MATRIX]                 = "INT_TYPE_MATRIX";
   name_map[UINT_TYPE_MATRIX]                = "UINT_TYPE_MATRIX";
   name_map[LONG_TYPE_MATRIX]                = "LONG_TYPE_MATRIX";
   name_map[ULONG_TYPE_MATRIX]               = "ULONG_TYPE_MATRIX";
   name_map[SHORT_TYPE_MATRIX]               = "SHORT_TYPE_MATRIX";
   name_map[USHORT_TYPE_MATRIX]              = "USHORT_TYPE_MATRIX";
   name_map[CHAR_TYPE_MATRIX]                = "CHAR_TYPE_MATRIX";
   name_map[UCHAR_TYPE_MATRIX]               = "UCHAR_TYPE_MATRIX";
   name_map[COMPLEX_TYPE_MATRIX]             = "COMPLEX_TYPE_MATRIX";
   name_map[COMPLEX_FLOAT_TYPE_MATRIX]       = "COMPLEX_FLOAT_TYPE_MATRIX";
   name_map[COMPLEX_LONG_DOUBLE_TYPE_MATRIX] = "COMPLEX_LONG_DOUBLE_TYPE_MATRIX";

   name_map[IDENTITY_MATRIX]                 = "IDENTITY_MATRIX";
   name_map[ZERO_MATRIX]                     = "ZERO_MATRIX";
   name_map[ONE_MATRIX]                      = "ONE_MATRIX";

   name_map[IS_IDENTITY] = "IS_IDENTITY";
   name_map[IS_ZERO] = "IS_ZERO";
   name_map[IS_ONE] = "IS_ONE";
   name_map[IS_MULTIPLIABLE] = "IS_MULTIPLIABLE";
   name_map[IS_SINGULAR] = "IS_SINGULAR";

@q *** (3) Types for |strings|.@>
@*2 Types for {\bf strings}.
\initials{LDF 2005.09.08.}

\LOG
\initials{LDF 2005.09.08.}
Added this section with an entry for |decimal|.

\initials{LDF 2005.09.08.}
Added entries for |binary|, |octal|, and |hexadecimal|.
\ENDLOG

@<Define functions@>=

  name_map[BINARY]      = "BINARY";
  name_map[OCTAL]       = "OCTAL";
  name_map[DECIMAL]     = "DECIMAL";
  name_map[HEXADECIMAL] = "HEXADECIMAL";


@q **** (4) Types for conic sections, quadric surfaces, and related types.@> 
@*3 Types for conic sections, quadric surfaces, and related types.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section with |name_map| entries for 
|PARABOLA|, |HYPERBOLA|,
|PARABOLOID|,  |HYPERBOLOID|, |PARABOLA_VECTOR|, |HYPERBOLA_VECTOR|,
|PARABOLOID_VECTOR|, |HYPERBOLOID_VECTOR|,
|PARABOLA_SLICE|, |HYPERBOLA_SLICE|, |PARABOLOID_SLICE|, 
|HYPERBOLOID_SLICE|, |PARABOLA_SLICE_VECTOR|, 
|HYPERBOLA_SLICE_VECTOR|, |PARABOLOID_SLICE_VECTOR|, 
|HYPERBOLOID_SLICE_VECTOR|, 
|PARABOLA_DECLARATOR|, |HYPERBOLA_DECLARATOR|,
|PARABOLOID_DECLARATOR|,  |HYPERBOLOID_DECLARATOR|, 
|PARABOLA_VECTOR_DECLARATOR|, |HYPERBOLA_VECTOR_DECLARATOR|,
|PARABOLOID_VECTOR_DECLARATOR|, |HYPERBOLOID_VECTOR_DECLARATOR|,
|PARABOLA_SLICE_DECLARATOR|, |HYPERBOLA_SLICE_DECLARATOR|, 
|PARABOLOID_SLICE_DECLARATOR|, 
|HYPERBOLOID_SLICE_DECLARATOR|, |PARABOLA_SLICE_VECTOR_DECLARATOR|, 
|HYPERBOLA_SLICE_VECTOR_DECLARATOR|, |PARABOLOID_SLICE_VECTOR_DECLARATOR|, 
|HYPERBOLOID_SLICE_VECTOR_DECLARATOR|,
|IS_PARABOLA|, |IS_HYPERBOLA|,
|IS_PARABOLOID|,  |IS_HYPERBOLOID|, |IS_PARABOLA_VECTOR|, |IS_HYPERBOLA_VECTOR|,
|IS_PARABOLOID_VECTOR|, |IS_HYPERBOLOID_VECTOR|,
|IS_PARABOLA_SLICE|, |IS_HYPERBOLA_SLICE|, |IS_PARABOLOID_SLICE|, 
|IS_HYPERBOLOID_SLICE|, |IS_PARABOLA_SLICE_VECTOR|, 
|IS_HYPERBOLA_SLICE_VECTOR|, |IS_PARABOLOID_SLICE_VECTOR|, 
|IS_HYPERBOLOID_SLICE_VECTOR|,
|IS_ON_PARABOLA|, |IS_ON_HYPERBOLA|, 
|GET_PARABOLA|, and |GET_HYPERBOLA|.

\initials{LDF 2005.11.07.}
Added |name_map| entries for |IS_PARABOLOIDAL| and |IS_HYPERBOLOIDAL|.

\initials{LDF 2007.07.29.}
Added |name_map| entries for 
|CONIC_SECTION_LATTICE|,
|CONIC_SECTION_LATTICE_VECTOR|,
|CONIC_SECTION_LATTICE_DECLARATOR|,
|CONIC_SECTION_LATTICE_VECTOR_DECLARATOR|,
|IS_CONIC_SECTION_LATTICE|,
and
|IS_CONIC_SECTION_LATTICE_VECTOR|.

\initials{LDF 2007.07.29.}
Added |name_map| entry for |GET_CONIC_SECTION_LATTICE|.

\initials{LDF 2007.10.13.}
Added |name_map| entries for |ARC|, |ARC_VECTOR|,
|ARC_DECLARATOR| and |ARC_VECTOR_DECLARATOR|,
|IS_ARC|, |IS_ARC_TYPE|, |IS_ARC_VECTOR| and |IS_ON_ARC|.

\initials{LDF 2007.11.04.}
Added |name_map| entries for |GET_RADIUS| and |GET_DIAMETER|.

\initials{LDF 2009.09.16.}
Added |name_map| entry for |CIRCUMFERENCE|.
\ENDLOG

@q ***** (5) Code.@> 

@<Define functions@>=

   name_map[PARABOLA] = "PARABOLA";
   name_map[HYPERBOLA] = "HYPERBOLA";

   name_map[ARC] = "ARC";

   name_map[CONIC_SECTION_LATTICE] = "CONIC_SECTION_LATTICE";
   name_map[PARABOLOID] = "PARABOLOID";
   name_map[HYPERBOLOID] = "HYPERBOLOID";
   name_map[PARABOLA_VECTOR] = "PARABOLA_VECTOR";
   name_map[HYPERBOLA_VECTOR] = "HYPERBOLA_VECTOR";

   name_map[ARC_VECTOR] = "ARC_VECTOR";

   name_map[CONIC_SECTION_LATTICE_VECTOR] = "CONIC_SECTION_LATTICE_VECTOR";
   name_map[PARABOLOID_VECTOR] = "PARABOLOID_VECTOR";
   name_map[HYPERBOLOID_VECTOR] = "HYPERBOLOID_VECTOR";
   name_map[PARABOLA_SLICE] = "PARABOLA_SLICE";
   name_map[HYPERBOLA_SLICE] = "HYPERBOLA_SLICE";
   name_map[PARABOLOID_SLICE] = "PARABOLOID_SLICE";
   name_map[HYPERBOLOID_SLICE] = "HYPERBOLOID_SLICE";
   name_map[PARABOLA_SLICE_VECTOR] = "PARABOLA_SLICE_VECTOR";
   name_map[HYPERBOLA_SLICE_VECTOR] = "HYPERBOLA_SLICE_VECTOR";
   name_map[PARABOLOID_SLICE_VECTOR] = "PARABOLOID_SLICE_VECTOR";
   name_map[HYPERBOLOID_SLICE_VECTOR] = "HYPERBOLOID_SLICE_VECTOR";
   name_map[PARABOLA_DECLARATOR] = "PARABOLA_DECLARATOR";
   name_map[HYPERBOLA_DECLARATOR] = "HYPERBOLA_DECLARATOR";

   name_map[ARC_DECLARATOR] = "ARC_DECLARATOR";

   name_map[CONIC_SECTION_LATTICE_DECLARATOR] = "CONIC_SECTION_LATTICE_DECLARATOR";
   name_map[PARABOLOID_DECLARATOR] = "PARABOLOID_DECLARATOR";
   name_map[HYPERBOLOID_DECLARATOR] = "HYPERBOLOID_DECLARATOR";
   name_map[PARABOLA_VECTOR_DECLARATOR] = "PARABOLA_VECTOR_DECLARATOR";
   name_map[HYPERBOLA_VECTOR_DECLARATOR] = "HYPERBOLA_VECTOR_DECLARATOR";

   name_map[ARC_VECTOR_DECLARATOR] = "ARC_VECTOR_DECLARATOR";

   name_map[CONIC_SECTION_LATTICE_VECTOR_DECLARATOR] 
      = "CONIC_SECTION_LATTICE_VECTOR_DECLARATOR";
   name_map[PARABOLOID_VECTOR_DECLARATOR] = "PARABOLOID_VECTOR_DECLARATOR";
   name_map[HYPERBOLOID_VECTOR_DECLARATOR] = "HYPERBOLOID_VECTOR_DECLARATOR";
   name_map[PARABOLA_SLICE_DECLARATOR] = "PARABOLA_SLICE_DECLARATOR";
   name_map[HYPERBOLA_SLICE_DECLARATOR] = "HYPERBOLA_SLICE_DECLARATOR";
   name_map[PARABOLOID_SLICE_DECLARATOR] = "PARABOLOID_SLICE_DECLARATOR";
   name_map[HYPERBOLOID_SLICE_DECLARATOR] = "HYPERBOLOID_SLICE_DECLARATOR";
   name_map[PARABOLA_SLICE_VECTOR_DECLARATOR] = "PARABOLA_SLICE_VECTOR_DECLARATOR";
   name_map[HYPERBOLA_SLICE_VECTOR_DECLARATOR] = "HYPERBOLA_SLICE_VECTOR_DECLARATOR";
   name_map[PARABOLOID_SLICE_VECTOR_DECLARATOR] = "PARABOLOID_SLICE_VECTOR_DECLARATOR";
   name_map[HYPERBOLOID_SLICE_VECTOR_DECLARATOR] = "HYPERBOLOID_SLICE_VECTOR_DECLARATOR";
   name_map[IS_PARABOLA] = "IS_PARABOLA";
   name_map[IS_HYPERBOLA] = "IS_HYPERBOLA";

   name_map[IS_ARC] = "IS_ARC";
   name_map[IS_ARC_TYPE] = "IS_ARC_TYPE";

   name_map[IS_CONIC_SECTION_LATTICE] = "IS_CONIC_SECTION_LATTICE";
   name_map[IS_PARABOLOID] = "IS_PARABOLOID";
   name_map[IS_HYPERBOLOID] = "IS_HYPERBOLOID";
   name_map[IS_PARABOLA_VECTOR] = "IS_PARABOLA_VECTOR";
   name_map[IS_HYPERBOLA_VECTOR] = "IS_HYPERBOLA_VECTOR";

   name_map[IS_ARC_VECTOR] = "IS_ARC_VECTOR";

   name_map[IS_CONIC_SECTION_LATTICE_VECTOR] = "IS_CONIC_SECTION_LATTICE_VECTOR";
   name_map[IS_PARABOLOID_VECTOR] = "IS_PARABOLOID_VECTOR";
   name_map[IS_HYPERBOLOID_VECTOR] = "IS_HYPERBOLOID_VECTOR";
   name_map[IS_PARABOLA_SLICE] = "IS_PARABOLA_SLICE";
   name_map[IS_HYPERBOLA_SLICE] = "IS_HYPERBOLA_SLICE";
   name_map[IS_PARABOLOID_SLICE] = "IS_PARABOLOID_SLICE";
   name_map[IS_HYPERBOLOID_SLICE] = "IS_HYPERBOLOID_SLICE";
   name_map[IS_PARABOLA_SLICE_VECTOR] = "IS_PARABOLA_SLICE_VECTOR";
   name_map[IS_HYPERBOLA_SLICE_VECTOR] = "IS_HYPERBOLA_SLICE_VECTOR";
   name_map[IS_PARABOLOID_SLICE_VECTOR] = "IS_PARABOLOID_SLICE_VECTOR";
   name_map[IS_HYPERBOLOID_SLICE_VECTOR] = "IS_HYPERBOLOID_SLICE_VECTOR";
   name_map[IS_ON_PARABOLA] = "IS_ON_PARABOLA";

   name_map[IS_ON_HYPERBOLA] = "IS_ON_HYPERBOLA";

   name_map[IS_ON_ARC] = "IS_ON_ARC";


   name_map[GET_PARABOLA] = "GET_PARABOLA";
   name_map[GET_HYPERBOLA] = "GET_HYPERBOLA";

   name_map[GET_CONIC_SECTION_LATTICE] = "GET_CONIC_SECTION_LATTICE";

   name_map[CIRCUMFERENCE]   = "CIRCUMFERENCE";

   name_map[GET_RADIUS]   = "GET_RADIUS";
   name_map[GET_DIAMETER] = "GET_DIAMETER";

   name_map[IS_PARABOLOIDAL]  = "IS_PARABOLOIDAL";
   name_map[IS_HYPERBOLOIDAL] = "IS_HYPERBOLOIDAL";

@q *** (3) Types for drawing.@>
@*2 Types for drawing.

\LOG
\initials{LDF 2004.08.23.}
Added entries for |WITH_COLOR_VECTOR|, |WITH_DRAW_COLOR_VECTOR|, 
and |WITH_FILL_COLOR_VECTOR|.

\initials{LDF 2004.11.05.}
Added entries for |DRAWDOT_IF|, |DRAWDOT_UNLESS|, 
|UNDRAWDOT_IF|, and |UNDRAWDOT_UNLESS|.

\initials{LDF 2004.11.07.}
Added entries for |DRAWDBLARROW| and |UNDRAWDBLARROW|.

\initials{LDF 2004.11.11.}
Added entries for |PICKUP|, |DROP_COLOR|, |DROP_DASH_PATTERN|, and 
|DROP_PEN|.

\initials{LDF 2004.11.12.}
Added entries for |PICKUP_DRAW_COLOR|, 
|PICKUP_FILL_COLOR|, |DROP_DRAW_COLOR|, and 
|DROP_FILL_COLOR|.

\initials{LDF 2004.11.14.}
Added entry for |DROP_ALL|.

\initials{LDF 2005.03.18.}
Added entries for |WITH_PEN_VECTOR| and 
|WITH_DASH_PATTERN_VECTOR|.

\initials{LDF 2005.04.11.}
Added entries for |CMY|, |CMYK|, and |RGB|.

\initials{LDF 2005.08.16.}
Added entry for |CLIP_TO|.
\ENDLOG 

@<Define functions@>=

  name_map[PENCIRCLE] = "PENCIRCLE";
  name_map[PENRAZOR] = "PENRAZOR";
  name_map[PENSPECK] = "PENSPECK";
  name_map[PENSQUARE] = "PENSQUARE";

  name_map[WITH_PEN] = "WITH_PEN";

  name_map[WITH_PEN_VECTOR] = "WITH_PEN_VECTOR";

  name_map[DASHED] = "DASHED";

  name_map[WITH_DASH_PATTERN_VECTOR] = "WITH_DASH_PATTERN_VECTOR";


  name_map[WITH_WEIGHT] = "WITH_WEIGHT";
  name_map[WITH_COLOR] = "WITH_COLOR";
  name_map[WITH_DRAW_COLOR] = "WITH_DRAW_COLOR";
  name_map[WITH_FILL_COLOR] = "WITH_FILL_COLOR";

  name_map[WITH_COLOR_VECTOR] = "WITH_COLOR_VECTOR";
  name_map[WITH_DRAW_COLOR_VECTOR] = "WITH_DRAW_COLOR_VECTOR";
  name_map[WITH_FILL_COLOR_VECTOR] = "WITH_FILL_COLOR_VECTOR";


  name_map[ON_PICTURE] = "ON_PICTURE";
  name_map[DRAWDOT] = "DRAWDOT";

  name_map[DRAWDOT_IF] = "DRAWDOT_IF";
  name_map[DRAWDOT_UNLESS] = "DRAWDOT_UNLESS";
  name_map[UNDRAWDOT_IF] = "UNDRAWDOT_IF";
  name_map[UNDRAWDOT_UNLESS] = "UNDRAWDOT_UNLESS";

  name_map[DRAW] = "DRAW";
  name_map[FILL] = "FILL";
  name_map[FILLDRAW] = "FILLDRAW";
  name_map[DRAWARROW] = "DRAWARROW";
  name_map[DRAWDBLARROW] = "DRAWDBLARROW";

  name_map[CLIP_TO] = "CLIP_TO";

  name_map[UNDRAWDOT] = "UNDRAWDOT";
  name_map[UNDRAW] = "UNDRAW";
  name_map[UNFILL] = "UNFILL";
  name_map[UNFILLDRAW] = "UNFILLDRAW";
  name_map[UNDRAWARROW] = "UNDRAWARROW";
  name_map[UNDRAWDBLARROW] = "UNDRAWDBLARROW";

  name_map[PICKUP]            = "PICKUP";
  name_map[DROP_COLOR]        = "DROP_COLOR";
  name_map[DROP_DASH_PATTERN] = "DROP_DASH_PATTERN";
  name_map[DROP_PEN]          = "DROP_PEN";

  name_map[PICKUP_DRAW_COLOR] = "PICKUP_DRAW_COLOR";
  name_map[PICKUP_FILL_COLOR] = "PICKUP_FILL_COLOR";
  name_map[DROP_DRAW_COLOR]   = "DROP_DRAW_COLOR";
  name_map[DROP_FILL_COLOR]   = "DROP_FILL_COLOR";

  name_map[CMY] = "CMY";
  name_map[CMYK] = "CMYK";
  name_map[RGB] = "RGB";

  name_map[DROP_ALL]   = "DROP_ALL";

@q *** (3) Types for setting.  @>
@*2 Types for setting.

\LOG
\initials{LDF 2004.06.08.}  
Added this section, with a |name_map| entry for |SET|.

\initials{LDF 2004.11.01.}
Added |name_map| entries for |WITH_CENTER|, |WITH_POINT_COUNT|, 
and |WITH_NORMAL|.

\initials{LDF 2004.11.01.}
Added |name_map| entries for 
|WITH_AXIS_H|, |WITH_AXIS_V|, and |WITH_DIAMETER|.

\initials{LDF 2004.11.02.}
Added |name_map| entry for |WITH_SIDES|.

\initials{LDF 2005.05.19.}
Added |name_map| entries for |WITH_START_DIAMETER|, 
|WITH_POINTS_PER_CYCLE|, |WITH_CYCLES|, and |WITH_VECTOR|.

\initials{LDF 2005.05.21.}
Changed |WITH_VECTOR| to |WITH_DIRECTION_VECTOR|.

\initials{LDF 2005.05.21.}
Added |name_map| entries  for |WITH_TYPE|
|NULL_TYPE|, |LOGARITHMIC|, |ARCHIMEDEAN|,
|PARABOLIC|, and |HYPERBOLIC|.

\initials{LDF 2005.05.24.}
Added |name_map| entries for |ELLIPTICAL|, |CYLINDRICAL|, 
|CONICAL|, |CIRCULAR|, |WITH_CURVE|, |WITH_PATH|, and 
|WITH_ENVELOPE|.

\initials{LDF 2005.10.19.}
Added |name_map| entries for 
|WITH_DIVISIONS|, |WITH_DIVISIONS_VERTICAL|, and 
|WITH_DIVISIONS_HORIZONTAL|.

\initials{LDF 2005.10.28.}
Added |name_map| entry for |WITH_RADIUS|.

\initials{LDF 2005.10.31.}
Added |name_map| entries for 
|WITH_AXIS_X|, |WITH_AXIS_Y|, and |WITH_AXIS_Z|.

\initials{LDF 2005.10.31.}
Added |name_map| entries for 
|WITH_DIVISIONS_X|, |WITH_DIVISIONS_Y|, and |WITH_DIVISIONS_Z|.  

\initials{LDF 2006.11.09.}
Added |name_map| entries for |SINGLE_NAPPED| and |DOUBLE_NAPPED|.

\initials{LDF 2009.11.18.}
Added |name_map| entries for 
|WITH_DIVISIONS_LATITUDE|, |WITH_DIVISIONS_LONGITUDE| and |WITH_SEGMENT_COUNT|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=


   name_map[SET] = "SET";

   name_map[WITH_CENTER] = "WITH_CENTER";
   name_map[WITH_POINT_COUNT] = "WITH_POINT_COUNT";
   name_map[WITH_NORMAL] = "WITH_NORMAL";

   name_map[WITH_DIVISIONS] = "WITH_DIVISIONS";
   name_map[WITH_DIVISIONS_VERTICAL] = "WITH_DIVISIONS_VERTICAL";
   name_map[WITH_DIVISIONS_HORIZONTAL] = "WITH_DIVISIONS_HORIZONTAL";

   name_map[WITH_DIVISIONS_LATITUDE] = "WITH_DIVISIONS_LATITUDE";
   name_map[WITH_DIVISIONS_LONGITUDE] = "WITH_DIVISIONS_LONGITUDE";

   name_map[WITH_DIVISIONS_X] = "WITH_DIVISIONS_X";
   name_map[WITH_DIVISIONS_Y] = "WITH_DIVISIONS_Y";
   name_map[WITH_DIVISIONS_Z] = "WITH_DIVISIONS_Z";

   name_map[WITH_SEGMENT_COUNT] = "WITH_SEGMENT_COUNT";

   name_map[WITH_AXIS_H] = "WITH_AXIS_H";
   name_map[WITH_AXIS_V] = "WITH_AXIS_V";
   name_map[WITH_DIAMETER] = "WITH_DIAMETER";
   name_map[WITH_RADIUS] = "WITH_RADIUS";

   name_map[WITH_AXIS_X] = "WITH_AXIS_X";
   name_map[WITH_AXIS_Y] = "WITH_AXIS_Y";
   name_map[WITH_AXIS_Z] = "WITH_AXIS_Z";


   name_map[WITH_SIDES] = "WITH_SIDES";

   name_map[WITH_START_DIAMETER]   = "WITH_START_DIAMETER";
   name_map[WITH_POINTS_PER_CYCLE] = "WITH_POINTS_PER_CYCLE";
   name_map[WITH_CYCLES]           = "WITH_CYCLES";
   name_map[WITH_DIRECTION_VECTOR] = "WITH_DIRECTION_VECTOR";

   name_map[WITH_TYPE]   = "WITH_TYPE";
   name_map[NULL_TYPE]   = "NULL_TYPE";
   name_map[LOGARITHMIC] = "LOGARITHMIC";
   name_map[ARCHIMEDEAN] = "ARCHIMEDEAN";
   name_map[PARABOLIC]   = "PARABOLIC";
   name_map[HYPERBOLIC]  = "HYPERBOLIC";

   name_map[ELLIPTICAL] = "ELLIPTICAL";
   name_map[CIRCULAR] = "CIRCULAR";
   name_map[CYLINDRICAL] = "CYLINDRICAL";
   name_map[CONICAL] = "CONICAL";

   name_map[SINGLE_NAPPED] = "SINGLE_NAPPED";
   name_map[DOUBLE_NAPPED] = "DOUBLE_NAPPED";

   name_map[WITH_CURVE] = "WITH_CURVE";
   name_map[WITH_PATH] = "WITH_PATH";
   name_map[WITH_ENVELOPE] = "WITH_ENVELOPE";


@q *** (3) Types for labels.  @>
@*2 Types for labels.

\LOG
\initials{LDF 2004.06.08.}  
Added this section, with |name_map| entries for
|LABEL|, |RT|, |LFT|, |TOP|, |BOT|, |URT|, |ULFT|, |LRT|, and |LLFT|.

\initials{LDF 2004.06.30.}
Added |name_map| entry for |DOTLABEL|.

\initials{LDF 2004.10.22.}
Added |name_map| entries for |SUPPRESS_LABELS| and 
|UNSUPPRESS_LABELS|.

\initials{LDF 2004.10.22.}
Added |name_map| entry for |KILL_LABELS|.

\initials{LDF 2004.11.06.}
Added |name_map| entries for
|LABEL_IF|, |LABEL_UNLESS|, |DOTLABEL_IF|, and |DOTLABEL_UNLESS|.

\initials{LDF 2004.11.10.}
Added |name_map| entries for
|LABELS_IF|, |LABELS_UNLESS|, |DOTLABELS_IF|, and |DOTLABELS_UNLESS|.

\initials{LDF 2004.12.01.}
Added |name_map| entry for |SCANTOKENS|. 

\initials{LDF 2004.12.13.}
Added |name_map| entry for |VERBATIM_METAPOST|. 

\initials{LDF 2005.01.25.}
Added |name_map| entry for |LET|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=

  name_map[LABEL] = "LABEL";
  name_map[DOTLABEL] = "DOTLABEL";
  name_map[RT]    = "RT";
  name_map[LFT]   = "LFT";
  name_map[TOP]   = "TOP";
  name_map[BOT]   = "BOT";
  name_map[URT]   = "URT";
  name_map[ULFT]  = "ULFT";
  name_map[LRT]   = "LRT";
  name_map[LLFT]  = "LLFT";

  name_map[SUPPRESS_LABELS]    = "SUPPRESS_LABELS";
  name_map[UNSUPPRESS_LABELS]  = "UNSUPPRESS_LABELS";


  name_map[LABEL_IF]        = "LABEL_IF"; 
  name_map[LABEL_UNLESS]    = "LABEL_UNLESS"; 
  name_map[DOTLABEL_IF]     = "DOTLABEL_IF"; 
  name_map[DOTLABEL_UNLESS] = "DOTLABEL_UNLESS"; 


  name_map[LABELS]           = "LABELS"; 
  name_map[LABELS_IF]        = "LABELS_IF"; 
  name_map[LABELS_UNLESS]    = "LABELS_UNLESS"; 
  name_map[DOTLABELS]        = "DOTLABELS"; 
  name_map[DOTLABELS_IF]     = "DOTLABELS_IF"; 
  name_map[DOTLABELS_UNLESS] = "DOTLABELS_UNLESS"; 

  name_map[SCANTOKENS] = "SCANTOKENS"; 

  name_map[VERBATIM_METAPOST] = "VERBATIM_METAPOST"; 

  name_map[LET] = "LET"; 

@q *** (3) Types for messages.  @>
@*2 Types for messages.

\LOG
\initials{LDF 2004.09.22.}
Added this section, with |name_map| entries for |MESSAGE| and |ERRMESSAGE|.

\initials{LDF 2004.10.20.}
Added |name_map| entry for |MEDIATE|.
\ENDLOG 

@<Define functions@>=

  name_map[MESSAGE]  = "MESSAGE";
  name_map[ERRMESSAGE]  = "ERRMESSAGE";
  name_map[PAUSE]  = "PAUSE";
  name_map[MEDIATE]  = "MEDIATE";



@q *** (3) Types for |Focuses|.  @>
@*2 Types for |Focuses|.
\initials{LDF 2004.06.08.}  

\LOG
\initials{LDF 2004.06.08.}  
Added this section, with |name_map| entries for 
|WITH_POSITION|, |WITH_DIRECTION|, |WITH_DISTANCE|, |WITH_ANGLE|, 
|WITH_AXIS|, |X_AXIS|, |Y_AXIS|, and |Z_AXIS|.

\initials{LDF 2004.06.08.}  
Added |name_map| entries for |PERSPECTIVE|,
|PARALLEL_X_Y|, |PARALLEL_X_Z|, |PARALLEL_Z_Y|, |AXONOMETRIC|, 
|ISOMETRIC|, and |SUPPRESS|.

\initials{LDF 2007.09.02.}
Added |name_map| entries for 
|GET_POSITION|,
|GET_DIRECTION|,
|GET_DISTANCE|,
|GET_UP|,
and
|GET_PERSPECTIVE_TRANSFORM|.
|GET_TRANSFORM| is already declared elsewhere.

\initials{LDF 2007.09.02.}
Added |name_map| entry for |RESET_ANGLE|.

\initials{LDF 2007.09.17.}
Added |name_map| entries for |PAN|, |PANNED|, |ZOOM|, and |ZOOMED|.

\initials{LDF 2007.09.19.}
Added |name_map| entries for |WITH_FOCUS_AXES| and |WITH_MAIN_AXES|.

\initials{LDF 2007.09.24.}
Added |name_map| entries for |TILT| and |TILTED|.

\initials{LDF 2007.09.24.}
Added |name_map| entries for |TILT| and |TILTED|.
\ENDLOG 

@q **** (4) Code.@> 

@<Define functions@>=
  name_map[WITH_POSITION] = "WITH_POSITION";
  name_map[WITH_DIRECTION] = "WITH_DIRECTION";
  name_map[WITH_DISTANCE] = "WITH_DISTANCE";
  name_map[WITH_ANGLE] = "WITH_ANGLE";
  name_map[WITH_AXIS] = "WITH_AXIS";
  name_map[X_AXIS] = "X_AXIS";
  name_map[Y_AXIS] = "Y_AXIS";
  name_map[Z_AXIS] = "Z_AXIS";

  name_map[WITH_FOCUS_AXES] = "WITH_FOCUS_AXES";
  name_map[WITH_MAIN_AXES]  = "WITH_MAIN_AXES";

  name_map[GET_POSITION] = "GET_POSITION";
  name_map[GET_DIRECTION] = "GET_DIRECTION";
  name_map[GET_DISTANCE] = "GET_DISTANCE";
  name_map[GET_UP] = "GET_UP";@/
  /* Entry for |GET_TRANSFORM| is already created elsewhere.  
     \initials{LDF 2007.09.02.}  */@/
  name_map[GET_PERSPECTIVE_TRANSFORM] = "GET_PERSPECTIVE_TRANSFORM";

  name_map[RESET_ANGLE] = "RESET_ANGLE";

  name_map[PAN]    = "PAN";
  name_map[PANNED] = "PANNED";

  name_map[ZOOM]   = "ZOOM";
  name_map[ZOOMED] = "ZOOMED";  

  name_map[TILT]   = "TILT";  
  name_map[TILTED] = "TILTED";  

@q *** (3) Types for modifying |Shapes|.@>
@*2 Types for modifying |Shapes|.
\initials{LDF 2004.11.01.}

\LOG
\initials{LDF 2004.11.01.}
Added this section with a 
|name_map| entry for |CLEAR_CONNECTORS|.
\ENDLOG

@<Define functions@>=

   name_map[CLEAR_CONNECTORS] = "CLEAR_CONNECTORS";

@q *** (3) Types for figures.  @>
@*2 Types for figures.

\LOG
\initials{LDF 2004.06.19.}
Added this section, with |name_map| entries for |BEGINFIG| 
and |ENDFIG|. 

\initials{LDF 2005.06.11.}
Added |name_map| entries for |BEGINCHAR| and |ENDCHAR|. 
\ENDLOG

@<Define functions@>=

  name_map[BEGINFIG]          = "BEGINFIG";
  name_map[ENDFIG]            = "ENDFIG";

  name_map[BEGINCHAR]          = "BEGINCHAR";
  name_map[ENDCHAR]            = "ENDCHAR";

@q *** (3) Tokens for outputting |Pictures|.  @>
@*2 Tokens for outputting |Pictures|.

\LOG
\initials{LDF 2004.06.26.}  
Added entry for |WITH_FACTOR|.

\initials{LDF 2004.06.26.}  Added entries for 
|NO_SORT|, |MAX_Z_SORT|, |MIN_Z_SORT|, |MEAN_Z_SORT|, 
|WITH_MIN_X_PROJ|, |WITH_MAX_X_PROJ|, 
|WITH_MIN_Y_PROJ|, |WITH_MAX_Y_PROJ|, 
|WITH_MIN_Z_PROJ|, and |WITH_MAX_Z_PROJ|. 

\initials{LDF 2004.06.29.}
Changed |WITH_MIN_X_PROJ| to |MIN_Y_PROJ|.  Did the same for
|MAX_X_PROJ|, |MIN_Y_PROJ|, etc.

\initials{LDF 2004.07.14.}
Added |name_map| entry for |CLEAR|.

\initials{LDF 2005.03.13.}
Added |name_map| entries for |WITH_SURFACE_HIDING| 
and |WITHOUT_SURFACE_HIDING|.
\ENDLOG

@<Define functions@>=

  name_map[OUTPUT]          = "OUTPUT";
  name_map[CLEAR]           = "CLEAR";
  name_map[WITH_FOCUS]      = "WITH_FOCUS";

  name_map[WITH_PROJECTION]  = "WITH_PROJECTION";
  name_map[WITH_FACTOR]      = "WITH_FACTOR";

  name_map[PERSPECTIVE]      = "PERSPECTIVE";
  name_map[PARALLEL_X_Y]     = "PARALLEL_X_Y";
  name_map[PARALLEL_X_Z]     = "PARALLEL_X_Z";
  name_map[PARALLEL_Z_Y]     = "PARALLEL_Z_Y";
  name_map[AXONOMETRIC]      = "AXONOMETRIC";
  name_map[ISOMETRIC]        = "ISOMETRIC";
  name_map[SUPPRESS]         = "SUPPRESS";

  name_map[NO_SORT]         = "NO_SORT";
  name_map[MAX_Z_SORT]      = "MAX_Z_SORT";
  name_map[MIN_Z_SORT]      = "MIN_Z_SORT";
  name_map[MEAN_Z_SORT]     = "MEAN_Z_SORT";
  name_map[MIN_X_PROJ]      = "MIN_X_PROJ";
  name_map[MAX_X_PROJ]      = "MAX_X_PROJ";
  name_map[MIN_Y_PROJ]      = "MIN_Y_PROJ";
  name_map[MAX_Y_PROJ]      = "MAX_Y_PROJ";
  name_map[MIN_Z_PROJ]      = "MIN_Z_PROJ";
  name_map[MAX_Z_PROJ]      = "MAX_Z_PROJ";

  name_map[WITH_SURFACE_HIDING] = "WITH_SURFACE_HIDING";

  name_map[WITHOUT_SURFACE_HIDING] = "WITHOUT_SURFACE_HIDING";

@q *** (3) Tokens for conic sections and other curves.@>
@ Tokens for conic sections and other curves.
\initials{LDF 2007.08.03.}

The |name_map| entry for |WITH_FOCUS| is added above, among the tokens for 
outputting |Pictures|.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2005.11.14.}
Added |name_map| entries for |WITH_FOCUS_0|, |WITH_FOCUS_1|,
|WITH_VERTEX|, |WITH_VERTEX_0| and |WITH_VERTEX_1|.

\initials{LDF 2005.11.15.}
Added |name_map| entries for
|WITH_MAJOR_AXIS_LENGTH|, 
|WITH_HALF_MAJOR_AXIS_LENGTH|, 
|WITH_MINOR_AXIS_LENGTH|, 
|WITH_HALF_MINOR_AXIS_LENGTH|, 
|WITH_DIRECTRIX|, 
|WITH_PARAMETER|, 
|WITH_HALF_PARAMETER|, 
|WITH_LINEAR_ECCENTRICITY|, 
|WITH_NUMERICAL_ECCENTRICITY|, 
|WITH_INCREMENT_VALUE|, 
and
|WITH_MAX_EXTENT|.

\initials{LDF 2005.11.15.}
Added |name_map| entries for |GET_FOCUS|
and |GET_VERTEX|.

\initials{LDF 2005.11.17.}
Added |name_map| entries for |DISCRIMINANT|, |TANGENT|, 
and |CURVATURE|.

\initials{LDF 2005.11.18.}
Added |name_map| entry for |STANDARDIZE|.

\initials{LDF 2007.07.30.} 
Added |name_map| entry for |TRAVERSE|.

\initials{LDF 2007.08.03.}
Added |name_map| entries for 
|GET_LATTICE_POINT|, 
|GET_LATTICE_POINTS|, 
|GET_NEXT_POINT|, 
|GET_CYCLE_VALUE|, 
|DRAW_LATTICE|, 
|LABEL_LATTICE|, 
and
|WITH_CYCLE_VALUE|.

\initials{LDF 2007.08.03.}
Changed |WITH_INCREMENT_VALUE| to |WITH_INCREMENT|. 

\initials{LDF 2007.08.03.}
Added |name_map| entries for |GET_ANGLE_POINT| and |GET_PARALLEL|.

\initials{LDF 2007.08.05.}
Added |name_map| entry for |WITH_INCREMENTS|.

\initials{LDF 2007.08.07.}
Added |name_map| entries for |SHIFT_LATTICE|,
|WITH_SHIFT| and |WITH_NO_SHIFT|.

\initials{LDF 2007.08.16.}
Added |name_map| entries for |DOTLABEL_LATTICE|. 
\ENDLOG 

@q **** (4) Code @> 

@<Define functions@>=

   name_map[WITH_VERTEX]   = "WITH_VERTEX";

   name_map[GET_FOCUS]     = "GET_FOCUS";

   name_map[GET_VERTEX]    = "GET_VERTEX";

   name_map[DISCRIMINANT]  = "DISCRIMINANT";
   name_map[TANGENT]       = "TANGENT";

   name_map[TRAVERSE]      = "TRAVERSE";

   name_map[CURVATURE]     = "CURVATURE";

   name_map[STANDARDIZE]   = "STANDARDIZE";

   name_map[SHIFT_LATTICE] = "SHIFT_LATTICE";

   name_map[WITH_MAJOR_AXIS_LENGTH] = "WITH_MAJOR_AXIS_LENGTH";
   name_map[WITH_HALF_MAJOR_AXIS_LENGTH] = "WITH_HALF_MAJOR_AXIS_LENGTH";
   name_map[WITH_MINOR_AXIS_LENGTH] = "WITH_MINOR_AXIS_LENGTH";
   name_map[WITH_HALF_MINOR_AXIS_LENGTH] = "WITH_HALF_MINOR_AXIS_LENGTH";

   name_map[WITH_DIRECTRIX] = "WITH_DIRECTRIX";
   name_map[WITH_PARAMETER] = "WITH_PARAMETER";
   name_map[WITH_HALF_PARAMETER] = "WITH_HALF_PARAMETER";

   name_map[WITH_LINEAR_ECCENTRICITY] = "WITH_LINEAR_ECCENTRICITY";
   name_map[WITH_NUMERICAL_ECCENTRICITY] = "WITH_NUMERICAL_ECCENTRICITY";

   name_map[WITH_INCREMENT] = "WITH_INCREMENT";
   name_map[WITH_INCREMENTS] = "WITH_INCREMENTS";

   name_map[WITH_MAX_EXTENT] = "WITH_MAX_EXTENT";

   name_map[WITH_SHIFT]    = "WITH_SHIFT"; 
   name_map[WITH_NO_SHIFT] = "WITH_NO_SHIFT";

   name_map[GET_LATTICE_POINT] = "GET_LATTICE_POINT"; 
   name_map[GET_LATTICE_POINTS] = "GET_LATTICE_POINTS";  

   name_map[GET_ANGLE_POINT] = "GET_ANGLE_POINT";
   name_map[GET_PARALLEL] = "GET_PARALLEL";

   name_map[GET_NEXT_POINT] = "GET_NEXT_POINT";  
   name_map[GET_CYCLE_VALUE] = "GET_CYCLE_VALUE";  
   name_map[DRAW_LATTICE] = "DRAW_LATTICE";  
   name_map[WITH_CYCLE_VALUE] = "WITH_CYCLE_VALUE"; 

   name_map[LABEL_LATTICE]    = "LABEL_LATTICE"; 
   name_map[DOTLABEL_LATTICE] = "DOTLABEL_LATTICE"; 

@q *** (3) Types for projections.@>   
@*2 Types for projections.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section with the entry for |PROJECT|.

\initials{LDF 2005.04.18.}
Added the entry for |PROJECTED|.

\initials{LDF 2005.04.19.}
Added the entry for |WITH_Z|.
\ENDLOG

@<Define functions@>=

  name_map[PROJECT] = "PROJECT";
  name_map[PROJECTED] = "PROJECTED";
  name_map[WITH_Z] = "WITH_Z";

@q *** (3) Types for showing objects referenced by variables.  @>
@*2 Types for showing objects referenced by variables.

\LOG
\initials{LDF 2004.06.09.}  
Added this section with the entry for |SHOW|. 

\initials{LDF 2005.09.13.}
Added the entry for |FIXED|.
\ENDLOG 

@<Define functions@>=

  name_map[SHOW]          = "SHOW";
  name_map[FIXED]         = "FIXED";



@q *** (3) Types for intersections.  @>
@*2 Types for intersections.

\LOG
\initials{LDF 2004.09.05.}
Added this section.  Creating |name_map| entries for 
|INTERSECTION_POINT| and |INTERSECTION_POINTS|.

\initials{LDF 2005.10.28.}
Added |name_map| entry for |INTERSECTION|.
\ENDLOG


@<Define functions@>=

   name_map[INTERSECTION]        = "INTERSECTION";
   name_map[INTERSECTION_POINT]  = "INTERSECTION_POINT";
   name_map[INTERSECTION_POINTS] = "INTERSECTION_POINTS";

@q *** (3) Types for conditionals.  @>
@*2 Types for conditionals.

\LOG
\initials{LDF 2004.09.09.}
Added this section with |name_map| entries for 
|IF|, |ELSE|, |ELSEIF|, and |FI|.
\ENDLOG

@<Define functions@>=

  name_map[IF] = "IF";
  name_map[ELSE] = "ELSE";
  name_map[ELSEIF] = "ELSEIF";
  name_map[FI] = "FI";


@q *** (4) Types for loops.  @>
@*2 Types for loops.

\LOG
\initials{LDF 2004.09.09.}
Added this section with |name_map| entries for 
|FOR|, |FORSUFFIXES|, |FOREVER|, |EXITIF|, |STEP|, |UNTIL|, 
and |ENDFOR|.

\initials{LDF 2004.09.13.}
Added |name_map| entry for |END_LOOP_PREFIX|.

\initials{LDF 2004.09.14.}
Removed |name_map| entry for |END_LOOP_PREFIX|.

\initials{LDF 2004.09.22.}
Changed |EXITIF| to |EXIT_IF| and added |EXIT_UNLESS|.

\initials{LDF 2004.09.22.}
Changed |FORSUFFIXES| to |FOR_SUFFIXES| and |ENDFOR| to |END_FOR|. 

\initials{LDF 2004.11.26.}
Added |name_map| entries for |UPTO|, |DOWNTO|, 
and |FOR_SUFFIXES_INTERNAL|.

\initials{LDF 2005.01.19.}
Added |name_map| entry for |FOR_SUFFIXES_INTERNAL_START|.
\ENDLOG

@<Define functions@>=

  name_map[FOR] = "FOR";
  name_map[FOR_SUFFIXES] = "FOR_SUFFIXES";
  name_map[FOR_SUFFIXES_INTERNAL] = "FOR_SUFFIXES_INTERNAL";
  name_map[FOREVER] = "FOREVER";
  name_map[EXIT_IF] = "EXIT_IF";
  name_map[EXIT_UNLESS] = "EXIT_UNLESS";
  name_map[STEP] = "STEP";
  name_map[UNTIL] = "UNTIL";
  name_map[END_FOR] = "END_FOR";
  name_map[UPTO] = "UPTO";
  name_map[DOWNTO] = "DOWNTO";


@q *** (3) Types for groups.  @>
@*2 Types for groups.

\LOG
\initials{LDF 2004.09.12.}
Added this section with |name_map| entries for 
|BEGIN_GROUP|, |END_GROUP|,  and |SAVE|.
\ENDLOG

@<Define functions@>=

  name_map[BEGIN_GROUP] = "BEGIN_GROUP";
  name_map[END_GROUP] = "END_GROUP";
  name_map[SAVE] = "SAVE";

@q *** (3) Types for transformations.@>
@*2 Types for transformations.
\initials{LDF 2005.04.16.}

\LOG
\initials{LDF 2005.04.16.}
Added this section with |name_map| entries for |INVERSE| 
and |INVERT|.

\initials{LDF 2007.10.14.}
Added |name_map| entries for |TRANSPOSE| and |TRANSPOSED|. 
\ENDLOG

@<Define functions@>=

  name_map[INVERSE] = "INVERSE";
  name_map[INVERT]  = "INVERT";

  name_map[INVERSE] = "TRANSPOSE";
  name_map[INVERSE] = "TRANSPOSED";

@q *** (3) Types for extracting sub-objects.@>
@*2 Types for extracting sub-objects.
\initials{LDF 2004.10.08.}

\LOG
\initials{LDF 2004.10.08.}
Added this section with |name_map| entries for 
|GET_TRANSFORM|,
|GET_POINT|,
|GET_POINTS|,
|GET_CONNECTOR|,
|GET_CONNECTORS|,
|GET_PEN|,
|GET_DASH_PATTERN|,
|GET_DASH_PATTERN|,
|GET_DRAWDOT_COLOR|,
|GET_DRAW_COLOR|,
|GET_FILL_COLOR|,
|GET_COLORS|,
|GET_CIRCLE|,
|GET_ELLIPSE|,
|GET_PATH|,
|GET_RECTANGLE|, and
|GET_REG_POLYGON|.

\initials{LDF 2004.10.09.}
Added |name_map| entry for |GET_CENTER|.

\initials{LDF 2004.11.13.}
Added |name_map| entries for |HALF|, |QUARTER|, and |SEGMENT|.

\initials{LDF 2004.11.25.}
Added |name_map| entries for |WITH_START|, |WITH_END|, |WITH_SIZE|, 
and |WITH_FRACTION|.

\initials{LDF 2004.11.25.}
Added |name_map| entry for |WITH_CLOSED|.

\initials{LDF 2005.03.17.}
Removed the |name_map| entry for |GET_DRAWDOT_COLOR|.

\initials{LDF 2006.11.06.}
Added |name_map| entries for |GET_BASE_CENTER| and |GET_CAP_CENTER|.

\initials{LDF 2006.11.09.}
Added |name_map| entries for |GET_APEX|, |GET_BASE|, and |GET_CAP|.

\initials{LDF 2007.07.09.}
Added |name_map| entry for |GET_BRANCH|.

\initials{LDF 2007.08.03.}
Added |name_map| entry for |GET_PATH_POINT|.

\initials{LDF 2007.08.16.}
Added |name_map| entries for |GET_APPROX_CENTER|,
|GET_TRUE_CENTER| and |GET_POINT_SIX|.

\initials{LDF 2007.08.17.}
Added |name_map| entries for |GET_POLYGON|, 
|GET_PENTAGON|, |GET_HEXAGON|, |GET_HEPTAGON|, 
|GET_OCTAGON|, |GET_NONAGON|, |GET_DECAGON|,
|GET_HENDECAGON|, and |GET_DODECAGON|.

\initials{LDF 2007.08.19.}
Added |name_map| entries for |GET_PASCAL_POINT|, |GET_PASCAL_POINTS|, and 
|GET_PASCAL_LINE|.

\initials{LDF 2007.08.21.}
Added |name_map| entries for |SET_TRANSFORM|, 
|RESET_TRANSFORM| and |DELETE_TRANSFORM|.
\ENDLOG

@q **** (4) Code.@> 

@<Define functions@>=

  name_map[GET_TRANSFORM]    = "GET_TRANSFORM";
  name_map[SET_TRANSFORM]    = "SET_TRANSFORM";
  name_map[RESET_TRANSFORM]  = "RESET_TRANSFORM";
  name_map[DELETE_TRANSFORM] = "DELETE_TRANSFORM";

  name_map[GET_POINT] = "GET_POINT";
  name_map[GET_POINTS] = "GET_POINTS";
  name_map[GET_PATH_POINT] = "GET_PATH_POINT";
  name_map[GET_CONNECTOR] = "GET_CONNECTOR";
  name_map[GET_CONNECTORS] = "GET_CONNECTORS";
  name_map[GET_PEN] = "GET_PEN";
  name_map[GET_DASH_PATTERN] = "GET_DASH_PATTERN";
  name_map[GET_DASH_PATTERN] = "GET_DASH_PATTERN";
  name_map[GET_DRAW_COLOR] = "GET_DRAW_COLOR";
  name_map[GET_FILL_COLOR] = "GET_FILL_COLOR";
  name_map[GET_COLORS] = "GET_COLORS";

  name_map[GET_PASCAL_POINT] = "GET_PASCAL_POINT";
  name_map[GET_PASCAL_POINTS ] = "GET_PASCAL_POINTS ";
  name_map[GET_PASCAL_LINE] = "GET_PASCAL_LINE";

  name_map[GET_CENTER] = "GET_CENTER";

  name_map[GET_APPROX_CENTER] = "GET_APPROX_CENTER";
  name_map[GET_TRUE_CENTER]   = "GET_TRUE_CENTER";
  name_map[GET_POINT_SIX]     = "GET_POINT_SIX";

  name_map[GET_CIRCLE] = "GET_CIRCLE";
  name_map[GET_ELLIPSE] = "GET_ELLIPSE";
  name_map[GET_PATH] = "GET_PATH";
  name_map[GET_RECTANGLE] = "GET_RECTANGLE";
  name_map[GET_REG_POLYGON] = "GET_REG_POLYGON";

  name_map[GET_POLYGON] = "GET_POLYGON"; 
  name_map[GET_PENTAGON] = "GET_PENTAGON";
  name_map[GET_HEXAGON] = "GET_HEXAGON"; 
  name_map[GET_HEPTAGON] = "GET_HEPTAGON"; 
  name_map[GET_OCTAGON] = "GET_OCTAGON"; 
  name_map[GET_NONAGON] = "GET_NONAGON";
  name_map[GET_DECAGON] = "GET_DECAGON";
  name_map[GET_HENDECAGON] = "GET_HENDECAGON";
  name_map[GET_DODECAGON] = "GET_DODECAGON";

  name_map[GET_BRANCH] = "GET_BRANCH";

  name_map[GET_BASE]  = "GET_BASE";
  name_map[GET_CAP]   = "GET_CAP";
  name_map[GET_APEX] = "GET_APEX";

  name_map[GET_BASE_CENTER] = "GET_BASE_CENTER";
  name_map[GET_CAP_CENTER] = "GET_CAP_CENTER";

  name_map[HALF] = "HALF";
  name_map[QUARTER] = "QUARTER";
  name_map[SEGMENT] = "SEGMENT";

  name_map[WITH_START]    = "WITH_START";
  name_map[WITH_END]      = "WITH_END";
  name_map[WITH_SIZE]     = "WITH_SIZE";
  name_map[WITH_FRACTION] = "WITH_FRACTION";
  name_map[WITH_CLOSED]   = "WITH_CLOSED";


@q *** (3) Types for generating objects.@>
@*2 Types for generating objects.
\initials{LDF 2007.07.20.}

\LOG
\initials{LDF 2007.07.20.}
Added this section with |name_map| entries for 
|WITH_TEST|, |WITH_NO_TEST|, |WITH_RECTIFY|, and |WITH_NO_RECTIFY|.

\initials{LDF 2007.07.27.}
Added |name_map| entries for |WITH_CULL| and |WITH_NO_CULL|.

\initials{LDF 2007.08.03.}
Added |name_map| entries for |WITH_TRANSFORM| and |WITH_NO_TRANSFORM|.
\ENDLOG

@q **** (4) Code.@> 

@<Define functions@>=

   name_map[WITH_TEST]       = "WITH_TEST";
   name_map[WITH_NO_TEST]    = "WITH_NO_TEST";
   name_map[WITH_CULL]       = "WITH_CULL";
   name_map[WITH_NO_CULL]    = "WITH_NO_CULL";

   name_map[WITH_RECTIFY]    = "WITH_RECTIFY";
   name_map[WITH_NO_RECTIFY] = "WITH_NO_RECTIFY";

   name_map[WITH_TRANSFORM]    = "WITH_TRANSFORM";
   name_map[WITH_NO_TRANSFORM] = "WITH_NO_TRANSFORM";


@q *** (3) Types for macros.@>
@*2 Types for macros.
\initials{LDF 2004.12.16.}

\LOG
\initials{LDF 2004.12.16.}
Added this section with entries for
|MACRO_TYPE|,
|VARDEF_TYPE|,
|PRIMARYDEF_TYPE|,
|SECONDARYDEF_TYPE|,
|TERTIARYDEF_TYPE|,
|DEFMACRO|,
|VARDEF|,
|PRIMARYDEF|, 
|SECONDARYDEF|, 
|TERTIARYDEF|, 
|ENDDEF|, 
|SUFFIX|, 
|TEXT|, and
|EXPR|.

\initials{LDF 2004.12.20.}
Changed |DEFMACRO| to |DEF|.

\initials{LDF 2004.12.21.}
Added entry for |DEFUN|.

\initials{LDF 2004.12.28.}
Added entries for 
|MACRO_VECTOR|,
|PRIMARYDEF_VECTOR|,
|SECONDARYDEF_VECTOR|,
|TERTIARYDEF_VECTOR|,
|MACRO_DECLARATOR|,
|PRIMARYDEF_DECLARATOR|,
|SECONDARYDEF_DECLARATOR|,
|TERTIARYDEF_DECLARATOR|,
|MACRO_VECTOR_DECLARATOR|,
|PRIMARYDEF_VECTOR_DECLARATOR|,
|SECONDARYDEF_VECTOR_DECLARATOR|,
and
|TERTIARYDEF_VECTOR_DECLARATOR|.

\initials{LDF 2004.12.29.}
Added entry for |DEF| again.

\initials{LDF 2005.06.09.}
Removed the entry for |DEFUN|.
\ENDLOG

@q **** (4) Code.@> 

@<Define functions@>=

   name_map[MACRO] = "MACRO";
   name_map[PRIMARYDEF] = "PRIMARYDEF";
   name_map[SECONDARYDEF] = "SECONDARYDEF";
   name_map[TERTIARYDEF] = "TERTIARYDEF";


   name_map[MACRO_VECTOR] = "MACRO_VECTOR";
   name_map[PRIMARYDEF_VECTOR] = "PRIMARYDEF_VECTOR";
   name_map[SECONDARYDEF_VECTOR] = "SECONDARYDEF_VECTOR";
   name_map[TERTIARYDEF_VECTOR] = "TERTIARYDEF_VECTOR";


   name_map[MACRO_DECLARATOR] = "MACRO_DECLARATOR";
   name_map[PRIMARYDEF_DECLARATOR] = "PRIMARYDEF_DECLARATOR";
   name_map[SECONDARYDEF_DECLARATOR] = "SECONDARYDEF_DECLARATOR";
   name_map[TERTIARYDEF_DECLARATOR] = "TERTIARYDEF_DECLARATOR";


   name_map[MACRO_VECTOR_DECLARATOR] = "MACRO_VECTOR_DECLARATOR";
   name_map[PRIMARYDEF_VECTOR_DECLARATOR] = "PRIMARYDEF_VECTOR_DECLARATOR";
   name_map[SECONDARYDEF_VECTOR_DECLARATOR] = "SECONDARYDEF_VECTOR_DECLARATOR";
   name_map[TERTIARYDEF_VECTOR_DECLARATOR] = "TERTIARYDEF_VECTOR_DECLARATOR";



   name_map[DEF] = "DEF";
   name_map[ENDDEF] = "ENDDEF";

@q *** (3) Types for enclosed and enclosing figures.@>
@*2 Types for enclosed and enclosing figures.
\initials{LDF 2004.11.16.}

\LOG
\initials{LDF 2004.11.16.}
Added this section with entries for
|IN_CIRCLE|, 
|OUT_CIRCLE|, 
|IN_ELLIPSE|, 
|OUT_ELLIPSE|, 
|IN_RECTANGLE|, 
|OUT_RECTANGLE|, 
|IN_SPHERE|, 
|OUT_SPHERE|, 
|IN_ELLIPSOID|, 
|OUT_ELLIPSOID|, 
|IN_CUBOID|, and
|OUT_CUBOID|.
\ENDLOG

@<Define functions@>=

   name_map[IN_CIRCLE] = "IN_CIRCLE";
   name_map[OUT_CIRCLE] = "OUT_CIRCLE";
   name_map[IN_ELLIPSE] = "IN_ELLIPSE";
   name_map[OUT_ELLIPSE] = "OUT_ELLIPSE";
   name_map[IN_RECTANGLE] = "IN_RECTANGLE";
   name_map[OUT_RECTANGLE] = "OUT_RECTANGLE";
   name_map[IN_SPHERE] = "IN_SPHERE";
   name_map[OUT_SPHERE] = "OUT_SPHERE";
   name_map[IN_ELLIPSOID] = "IN_ELLIPSOID";
   name_map[OUT_ELLIPSOID] = "OUT_ELLIPSOID";
   name_map[IN_CUBOID] = "IN_CUBOID";
   name_map[OUT_CUBOID] = "OUT_CUBOID";


@q *** (3) Tokens for vector-type objects.@>
@*2 Tokens for vector-type objects.
\initials{LDF 2005.01.05.}

\LOG
\initials{LDF 2005.01.05.}
Added this section with |name_map| entries for
|PUSH_BACK| and |POP_BACK|.

\initials{LDF 2005.01.07.}
Added |name_map| entry for |LAST|.

\initials{LDF 2007.07.22.}
Added |name_map| entry for |CULL|.

\initials{LDF 2007.07.27.}
Added |name_map| entries for |CULLED|, |RECTIFY|, and |RECTIFIED|.
\ENDLOG

@<Define functions@>=

   name_map[CULL]       = "CULL";
   name_map[CULLED]     = "CULLED";

   name_map[LAST]       = "LAST";

   name_map[PUSH_BACK]  = "PUSH_BACK";
   name_map[POP_BACK]   = "POP_BACK";

   name_map[RECTIFY]    = "RECTIFY";
   name_map[RECTIFIED]  = "RECTIFIED";


@q *** (3) Tokens for |triangles|.@>
@*2 Tokens for {\bf triangles}.
\initials{LDF 2007.10.02.}

\LOG
\initials{LDF 2007.10.02.}
Added this section with the |name_map| entry for
|GET_PLANE|.
\ENDLOG

@<Define functions@>=

   name_map[GET_PLANE] = "GET_PLANE";


@q *** (3) Tokens for |triangles|.@>
@*2 Tokens for {\bf triangles}.
\initials{LDF 2005.01.20.}

\LOG
\initials{LDF 2005.01.20.}
Added this section with entries for
|WITH_SSS|, |WITH_SAS|, |WITH_SAA|, |WITH_ASA|, 
|WITH_SSA_B|, |WITH_SSA_L|, and |WITH_SSA_S|. 

\initials{LDF 2005.01.23.}
Added entry for |WITH_SSA_A|.  
I'd forgotten it before.

\initials{LDF 2005.01.23.}
Removed the entries for |WITH_SSA_A| and |WITH_SSA_B|.

\initials{LDF 2005.01.23.}
Added entry for |WITH_POINTS|.

\initials{LDF 2005.10.25.}
Removed the entries for 
|WITH_SSS|, |WITH_SAS|, |WITH_SAA|, |WITH_ASA|, |WITH_SSA_L|,
and |WITH_SSA_S|.
\ENDLOG

@<Define functions@>=

   name_map[WITH_POINTS] = "WITH_POINTS";



@q *** (3) Tokens for quadric surfaces.@>
@*2 Tokens for quadric surfaces.
\initials{LDF 2005.10.25.}

\LOG
\initials{LDF 2005.10.25.}
Added this section with entries for |GLOBE_TYPE| and |PANEL_TYPE|.

\initials{LDF 2005.10.25.}
Changed |GLOBE_TYPE| and |PANEL_TYPE| to |SPHERE_GLOBE_TYPE| 
and |SPHERE_PANEL_TYPE|, respectively.  

\initials{LDF 2007.08.06.}
Added |name_map| entries for |INTRUDE|, |EXTRUDE|, |INTRUDED|, and 
|EXTRUDED|.
\ENDLOG

@q **** (4) Code.@>   

@<Define functions@>=

   name_map[SPHERE_GLOBE_TYPE] = "SPHERE_GLOBE_TYPE";
   name_map[SPHERE_PANEL_TYPE] = "SPHERE_PANEL_TYPE";

   name_map[INTRUDE]   = "INTRUDE";
   name_map[EXTRUDE]   = "EXTRUDE";

   name_map[INTRUDED]  = "INTRUDED";
   name_map[EXTRUDED]  = "EXTRUDED";


@q *** (3) Tokens for |Polyhedra|.@> 
@*2 Tokens for {\bf Polyhedra}.
\initials{LDF 2005.12.20.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.10.12.}
Decide whether |WITH_TABS| is needed and delete it, if it isn't.
\ENDTODO 

\LOG
\initials{LDF 2005.12.20.}
Added this section with the entries for |GET_NET|, |WITH_HALF|,
and |GREAT_RHOMBICOSIDODECAHEDRON|.

\initials{LDF 2005.12.20.}
Added entries for |TETRAHEDRON|, |CUBE|, |OCTAHEDRON|,
|DODECAHEDRON|, |ICOSAHEDRON|, and |TRUNC_OCTAHEDRON|.

\initials{LDF 2007.10.02.}
Added the |name_map| entry for |WITH_TABS|.

\initials{LDF 2007.10.12.}
Added the token declaration for |GET_TABS|.

\initials{LDF 2007.10.12.}
Added the |name_map| entry for |GET_TABS|.  |WITH_TABS| may not be needed, 
but I'm leaving it here for the present.

\initials{LDF 2007.10.12.}
Added the |name_map| entries for |WITH_STITCH_LINES|,
|WITH_NO_STITCH_LINES|, and |WITH_STITCH_DIVISIONS|.

\initials{LDF 2007.10.22.}
Added the |name_map| entry for |RHOMBIC_TRIACONTAHEDRON|.

\initials{LDF 2007.10.24.}
Added the |name_map| entry for |WITH_RHOMBUS_SIDE_LENGTH|.

\initials{LDF 2007.10.26.}
Added the |name_map| entries for |GET_RHOMBUS| and |WITH_SIDE_LENGTH|.
\ENDLOG

@<Define functions@>=

   name_map[GET_NET]   = "GET_NET";
   name_map[GET_TABS]  = "GET_TABS";

   name_map[GET_RHOMBUS] = "GET_RHOMBUS";

   name_map[TETRAHEDRON]                  = "TETRAHEDRON";
   name_map[CUBE]                         = "CUBE";
   name_map[OCTAHEDRON]                   = "OCTAHEDRON";
   name_map[DODECAHEDRON]                 = "DODECAHEDRON";
   name_map[ICOSAHEDRON]                  = "ICOSAHEDRON";
   name_map[TRUNC_OCTAHEDRON]             = "TRUNC_OCTAHEDRON";
   name_map[GREAT_RHOMBICOSIDODECAHEDRON] = "GREAT_RHOMBICOSIDODECAHEDRON";
   name_map[RHOMBIC_TRIACONTAHEDRON]      = "RHOMBIC_TRIACONTAHEDRON";

   name_map[WITH_HALF]                = "WITH_HALF";
   name_map[WITH_TABS]                = "WITH_TABS";
   name_map[WITH_SIDE_LENGTH]         = "WITH_SIDE_LENGTH";
   name_map[WITH_RHOMBUS_SIDE_LENGTH] = "WITH_RHOMBUS_SIDE_LENGTH";

   name_map[WITH_STITCH_LINES] = "WITH_STITCH_LINES";
   name_map[WITH_NO_STITCH_LINES] = "WITH_NO_STITCH_LINES";
   name_map[WITH_STITCH_DIVISIONS] = "WITH_STITCH_DIVISIONS";

@q *** (3) Tokens for surface hiding.@>
@*2 Tokens for surface hiding.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this section with entries for |DECOMPOSE| 
and |WITH_LEVEL|.

\initials{LDF 2005.04.14.}
Added the entry for |WITH_RECTANGLES|.
\ENDLOG

@q **** (4) Code.@> 

@<Define functions@>=

   name_map[DECOMPOSE]        = "DECOMPOSE";
   name_map[WITH_LEVEL]       = "WITH_LEVEL";
   name_map[WITH_RECTANGLES]  = "WITH_RECTANGLES";


@q *** (3) Tokens for |Nurbs|.@>
@*2 Tokens for |Nurbs|.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section with entries for
|KNOT|, |WEIGHT|, |WITH_KNOTS|, and |WITH_WEIGHTS|.

\initials{LDF 2005.01.27.}
Added entries for |WITH_TIME_PARAMETER|,
|WITH_ORDER|, and |GENERATE|.

\initials{LDF 2005.01.28.}
Changed |WITH_ORDER| to |WITH_POWER|.
\ENDLOG

@q **** (4) Code.@>   

@<Define functions@>=

   name_map[KNOT] = "KNOT";
   name_map[WEIGHT] = "WEIGHT";
   name_map[WITH_KNOTS] = "WITH_KNOTS";
   name_map[WITH_WEIGHTS] = "WITH_WEIGHTS";

   name_map[WITH_TIME_PARAMETER] = "WITH_TIME_PARAMETER";
   name_map[WITH_POWER]          = "WITH_POWER";

   name_map[GENERATE]            = "GENERATE";


@q *** (3) Tokens for |Polygons|.@>
@*2 Tokens for |Polygons|.
\initials{LDF 2006.01.20.}

\LOG
\initials{LDF 2006.01.20.}
Added this section with the entry for |DISENTANGLE|.
\ENDLOG

@q **** (4) Code.@>   

@<Define functions@>=

   name_map[DISENTANGLE] = "DISENTANGLE";

@q *** (3) Tokens for |origami_figures|.@>
@*2 Tokens for |origami_figures|.
\initials{LDF 2005.02.03.}

\LOG
\initials{LDF 2005.02.03.}
Added this section.  It's currently empty.
\ENDLOG

@q **** (4) Code.@>   

@<Define functions@>=


@q **** (4).@> 
@
@<Define functions@>=
  

   return 0;

}  /* End of |initialize_name_map| definition.  */



@q * (1) Functions for variable declarations.@> 
@* Functions for variable declarations.
\initials{LDF 2005.06.08.}

\LOG
\initials{LDF 2005.06.08.}
Added this section.
\ENDLOG


@q ** (2)@> Vector variable declaration function.
@*1 Vector variable declaration function.
\initials{LDF 2005.06.08.}

\LOG
\initials{LDF 2005.06.08.}
Added this function.


\initials{LDF 2005.06.09.}
Changed the name of this function from
|Scan_Parse::vector_variable_decl_func| to 
|Scan_Parse::variable_decl_func|.
There's no need for separate versions for simple and vector-type
variables.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=

void*
Scan_Parse::variable_decl_func(char* arg1,
                               void* arg2,
                               unsigned int type,
                               void* parameter)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

   Int_Void_Ptr ivp = variable_type(scanner_node,
                                    static_cast<Id_Map_Entry_Node>(arg2),
                                    static_cast<string>(arg1),
                                     type);
  if (ivp.i != 0)
    {
      cerr_strm << thread_name 
                << "ERROR!  "
                << "In 'Scan_Parse::variable_decl_rule_func_0()':"
                << endl << "`Scan_Parse::variable_type()' failed."
                << "Exiting function with return value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
 
      return 0;

   } /* |if (ivp.i != 0)| 
         (|Scan_Parse::variable_type| failed.)  */


   else /* (|ivp.i == 0|---|Scan_Parse::variable_type| succeeded.)  */
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << thread_name 
                     << "In 'Scan_Parse::variable_decl_rule_func_0()':"
                     << endl 
                     << "`Scan_Parse::variable_type()' succeeded.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm); 
           cerr_strm.str(""); 
         } 
#endif /* |DEBUG_COMPILE|  */@;          
                          
       return ivp.v;

     }  /* |else| (|ivp.i == 0|---|Scan_Parse::variable_type| succeeded.)  */  

}  /* End of |Scan_Parse::variable_decl_func| definition.  */

@q * (1) Functions for assignments.@> 
@* Functions for assignments.
\initials{LDF 2005.10.19.}

\LOG
\initials{LDF 2005.10.19.}
Added this section.
\ENDLOG


@q * (1) Functions for labels.@> 
@* Functions for labels.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@q ** (2) |label_bool_point_func|.@> 
@*1 {\bf label\_bool\_point\_func}.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this function.

\initials{LDF 2005.12.12.}
@:BUG FIX@> BUG FIX:  Fixed the way the |Bool_Point| is tested.  Previously, 
plain \.{label} and \.{dotlabel} failed, when the |bool| value was |false|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::label_bool_point_func(void* parameter,
                                  int label_type, 
                                  int suffix, 
                                  void* str, 
                                  real num,   
                                  void* bp, 
                                  void* col, 
                                  void* dot_col,
                                  void* pict) 
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";


   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   string* s               = static_cast<string*>(str);
   Color*  c               = static_cast<Color*>(col); 
   Color*  dot_c           = static_cast<Color*>(dot_col); 
   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(pict); 


@q **** (4)@> 

   if (bp == static_cast<void*>(0))
      {

          delete s;
          delete c;
          delete dot_c;

          cerr_strm << thread_name 
                    << "WARNING!  In `Scan_Parse::label_bool_point_func()':"
                    << endl 
                    << "`Bool_Point*' is null.  Can't label it."
                    << endl 
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          return 1;
      }  /* |bp == 0|  */ 


@q **** (4)@> 

    Bool_Point* bool_pt = static_cast<Bool_Point*>(bp);


    if (   (!bool_pt->b && (   label_type == LABEL_IF     
                                 || label_type == DOTLABEL_IF))
        || (bool_pt->b  && (   label_type == LABEL_UNLESS 
                                 || label_type == DOTLABEL_UNLESS)))
       {
           delete bool_pt;
           delete s;
           delete c;
           delete dot_c;

           return 0;
       }

@q **** (4)@> 

   if (s == static_cast<string*>(0))
      {
           stringstream label_strm;
           label_strm << num;
           s = new string;
           *s = label_strm.str();          
      }

@q **** (4)@> 

              switch (label_type)
                 {
                    case LABEL_IF: 
                       label_type = LABEL;
                       break;

                    case LABEL_UNLESS:
                       label_type = LABEL;
                       break;

                    case DOTLABEL_IF: 
                       label_type = DOTLABEL;
                       break;

                    case DOTLABEL_UNLESS:
                       label_type = DOTLABEL;
                       break;

                 } /* |switch (label_type)|  */
  
                  
                   Point* p; 

                   p = create_new<Point>(bool_pt->pt);

                   delete bool_pt;
                   bool_pt = 0;

                   return label_point_command(static_cast<Scanner_Node>(parameter),
                                              label_type,
                                              suffix,
                                              s,
                                              p,
                                              0,      
                                              c,
                                              dot_c,
                                              entry);

}  /* |Scan_Parse::label_bool_point_func| definition.  */

@q * (1). Functions for |strings|.@> 
@* Functions for {\bf strings}.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this section.
\ENDLOG

@q ** (2) |string_primary_rule_func|.@> 
@*1 {\bf string\_primary\_rule\_func}.
\initials{LDF 2005.11.03.}

This function uses the ``Registered Trademark'' character,
decimal 174, octal 256.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=

void*
Scan_Parse::string_primary_rule_func(void* v, void* parameter)
{
    if (!v)
       return 0;

    string* s = static_cast<string*>(v); 

    string::size_type t;

    while(1)
       {
           t = s->find("\\\\"); 
           if (t == string::npos)
              break;
           s->replace(t, 2, "");  /* ``Registered Trademark'' symbol.  */
       }

    while(1)
       {
           t = s->find("\\n"); 
           if (t == string::npos)
              break;
           s->replace(t, 2, "\n");
       }

    while(1)
       {
           t = s->find("\\t"); 
           if (t == string::npos)
              break;
           s->replace(t, 2, "\t");
       }

    while(1)
       {
           t = s->find("\\\""); 
           if (t == string::npos)
              break;
           s->replace(t, 2, "\"");
       }

    while(1)
       {
           t = s->find(""); 
           if (t == string::npos)
              break;
           s->replace(t, 1, "\\");
       }
   

    return v;

  
}  /* End of |Scan_Parse::string_primary_rule_func| definition.  */

@q * (1) Functions for |numeric| expressions.@> 
@* Functions for {\bf numeric} expressions.
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this section.
\ENDLOG

@q ** (2) |numeric_primary| rule function 0.@> 
@*1 \numeric primary> rule function 0.
This function is called in the rule 
\numeric primary> $\longrightarrow$ \numeric operator> 
\numeric primary>. in \filename{pnumexpr.w}
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this function.

\initials{LDF 2007.02.06.}
Changed the code for the cases |operator_value == PLUS|
and |operator_value == MINUS|.
Formerly, the absolute value of 
|operator_value| was used.  This failed when I removed code 
from the rule \numeric primary> $\longrightarrow$ 
\numeric operator> \numeric primary> and put it in this 
function.
\ENDLOG   

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::numeric_primary_rule_func_0(int          operator_value,
                                        real         operand,
                                        real*        result,
                                        Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4) Unary plus and minus.@>
@ Unary plus and minus.
\initials{LDF 2007.02.06.}

@q ***** (5) Unary plus.@>
@ Unary plus or minus.
\initials{LDF Undated.}

@<Define parser rule functions@>=

  if (operator_value == PLUS) 
  {
     *result = operand;
     return 0;
  }

@q ***** (5) Unary minus.@>
@ Unary minus.
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this section.
\ENDLOG   

@<Define parser rule functions@>=

  else if (operator_value == MINUS) 
  {
     *result = -operand;
     return 0;
  }

@q **** (4) SQRT. @>
@ \.{SQRT}.
\initials{LDF Undated.}

@<Define parser rule functions@>=

  else if (operator_value == SQRT)
  {
     *result = sqrt(operand);
     return 0;
  }  

@q **** (4) Trigonometric functions.@>
@ Trigonometric functions.
\initials{LDF 2007.02.06.}

@q ***** (5) SIND.  @>
@ \.{SIND}.
\initials{LDF Undated.}

\LOG
\initials{LDF 2006.02.23.}
Now setting |*result| to 0, if the value returned by |sin() < .00001|. 

\initials{LDF 2013.12.11.}
Added conditionally compiled code for the cases that |real| is a |typedef| for |float|
or |double|.  This eliminates a warning from GCC.
\ENDLOG 

@<Define parser rule functions@>=

  else if (operator_value == SIND)
      {

          real r;

#if LDF_REAL_FLOAT
          operand = fmodf(operand, 360.0F);
          r = sin((PI/180.0F) * operand);
#elif LDF_REAL_DOUBLE
          operand = fmod(operand, 360.0D);
          r = sin((PI/180.0D) * operand);
#else /* Default.  */
          operand = fmodf(operand, 360.0F);
          r = sin((PI/180.0F) * operand);
#endif
          
          *result = (fabs(r) < .00001) ? 0 : r;
          return 0;
          
      }

@q ***** (5) COSD. @>
@ \.{COSD}.

\LOG
\initials{LDF 2006.02.23.}
Now setting |*result| to 0, if the value returned by |cos() < .00001|. 

\initials{LDF 2013.12.11.}
Added conditionally compiled code for the cases that |real| is a |typedef| for |float|
or |double|.  This eliminates a warning from GCC.
\ENDLOG 

@<Define parser rule functions@>=

  else if (operator_value == COSD)
     {

          real r;

#if LDF_REAL_FLOAT
          operand = fmodf(operand, 360.0F);
          r = cos((PI/180.0F) * operand);
#elif LDF_REAL_DOUBLE
          operand = fmod(operand, 360.0D);
          r = cos((PI/180.0D) * operand);
#else /* Default.  */
          operand = fmodf(operand, 360.0F);
          r = cos((PI/180.0F) * operand);

#endif

          *result = (fabs(r) < .00001) ? 0 : r;
          return 0;
     }

@q ***** (5) TAND.  @>
@ \.{TAND}.

\LOG
\initials{LDF 2007.02.06.}
Added this section.

\initials{LDF 2013.12.11.}
Added conditionally compiled code for the cases that |real| is a |typedef| for |float|
or |double|.  This eliminates a warning from GCC.
\ENDLOG 

@<Define parser rule functions@>=

  else if (operator_value == TAND)
     {

#if LDF_REAL_FLOAT
          operand = fmodf(operand, 360.0F); 
#elif LDF_REAL_DOUBLE
          operand = fmod(operand, 360.0D);  
#else /* Default.  */
          operand = fmodf(operand, 360.0F); 
#endif

@q ****** (6)@> 

          if (   fabs((fabs(operand) -  90.0))  < Point::epsilon() 
              || fabs((fabs(operand) -  270.0)) < Point::epsilon())
          {

              cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                        << endl 
                        << "Invalid value for `operand':  " << operand << "."
                        << endl 
                        << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                        << "and will try to continue."
                        << endl;

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              *result = INVALID_REAL;
              return 1;
          }

@q ****** (6)@> 

          else 
          {
              try 
              {
                 real r = tan((PI/180.0) * operand);
                 *result = (fabs(r) < .00001) ? 0 : r;
              }
              catch (...) 
              {
                   
                  cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                            << endl 
                            << "`tand' failed on operand " << operand << "."
                            << endl 
                            << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                            << "and will try to continue."
                            << endl;

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

                  *result = INVALID_REAL;
                  return 1;

              }  /* |catch|  */

              return 0;

          }

     }  /* |else if (operator_value == TAND)|  */

@q ***** (5) ARCSIND.  @>
@ \.{ARCSIND}.
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this section.
\ENDLOG

@<Define parser rule functions@>=

   else if (operator_value == ARCSIND)
   {

@q ****** (6)@> 

          if (operand < -1 || operand > 1)
          {

              cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                        << endl 
                        << "Value for `operand' lies outside the domain of "
                        << "the `arcsin' function:  " << operand << "."
                        << endl 
                        << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                        << "and will try to continue."
                        << endl;

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              *result = INVALID_REAL;
              return 1;
          }

@q ****** (6)@> 

          else
          {
              try 
              {
                 real r = asin(operand);
                 *result = (fabs(r) < Point::epsilon()) ? 0 : (180.0 / PI) * r;
              }
              catch (...) 
              {
                   
                  cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                            << endl 
                            << "`sind' failed on operand " << operand << "."
                            << endl 
                            << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                            << "and will try to continue."
                            << endl;

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

                  *result = INVALID_REAL;
                  return 1;

              }  /* |catch|  */

              return 0;

          }  /* |else|  */
 
@q ****** (6)@> 

   }  /* |else if (operator_value == ARCSIND)|  */


@q ***** (5) ARCCOSD.  @>
@ \.{ARCCOSD}.
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this section.
\ENDLOG

@<Define parser rule functions@>=

   else if (operator_value == ARCCOSD)
   {


@q ****** (6)@> 

          if (operand < -1 || operand > 1)
          {

              cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                        << endl 
                        << "Value for `operand' lies outside the domain of "
                        << "the `arccos' function:  " << operand << "."
                        << endl 
                        << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                        << "and will try to continue."
                        << endl;

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              *result = INVALID_REAL;
              return 1;
          }

@q ****** (6)@> 

          else
          {
              try 
              {
                 real r = acos(operand);
                 *result = (fabs(r) < Point::epsilon()) ? 0 : (180.0 / PI) * r;
              }
              catch (...) 
              {
                   
                  cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                            << endl 
                            << "`cosd' failed on operand " << operand << "."
                            << endl 
                            << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                            << "and will try to continue."
                            << endl;

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

                  *result = INVALID_REAL;
                  return 1;

              }  /* |catch|  */

              return 0;

          }  /* |else|  */
 
@q ****** (6)@> 

   }  /* |else if (operator_value == ARCCOSD)|  */

@q ***** (5) ARCTAND.  @>
@ \.{ARCTAND}.
\initials{LDF 2007.02.06.}

\LOG
\initials{LDF 2007.02.06.}
Added this section.
\ENDLOG

@<Define parser rule functions@>=

   else if (operator_value == ARCTAND)
   {


@q ****** (6)@> 

          real domain_value = PI/2; 

          if (operand < -domain_value || operand > domain_value)
          {

              cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                        << endl 
                        << "Value for `operand' lies outside the domain of "
                        << "the `arctan' function:  " << operand << "."
                        << endl 
                        << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                        << "and will try to continue."
                        << endl;

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              *result = INVALID_REAL;
              return 1;
          }

@q ****** (6)@> 

          else
          {
              try 
              {
                 real r = atan(operand);
                 *result = (fabs(r) < Point::epsilon()) ? 0 : (180.0 / PI) * r;
              }
              catch (...) 
              {
                   
                  cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                            << endl 
                            << "`tand' failed on operand " << operand << "."
                            << endl 
                            << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                            << "and will try to continue."
                            << endl;

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

                  *result = INVALID_REAL;
                  return 1;

              }  /* |catch|  */

              return 0;

          }  /* |else|  */
 
@q ****** (6)@> 

   }  /* |else if (operator_value == ARCTAND)|  */

@q ***** (5)@> 

@q **** (4) Logarithms and the exponential function.  @>
@ Logarithms and the exponential function.
\initials{LDF 2007.02.06.}

@q ***** (5) MLOG. @>
@ \.{MLOG}.
See Knuth, {\it The METAFONTbook}, p.~67.
\initials{LDF 2004.04.29.}

  
\LOG
\initials{LDF 2004.04.29.}  
Programmed this case.
\ENDLOG 

@<Define parser rule functions@>=

  else if (operator_value == MLOG)
  {
      *result = 256 * log(operand);
      return 0;
  }
 

@q ***** (5) MEXP. @>
@ \.{MEXP}.

See Knuth, {\it The METAFONTbook}, p.~67.
\initials{LDF 2004.04.29.}

\LOG
\initials{LDF 2004.04.29.}  
Programmed this case.
\ENDLOG 

@<Define parser rule functions@>=

  else if (operator_value == MEXP)
    {

      real e = exp(1.0);
      real r = operand / 256.0;

      *result = pow(e, r);
      return 0;
    }

@q **** (4) FLOOR. @>
@ \.{FLOOR}.
@<Define parser rule functions@>=

  else if (operator_value == FLOOR)
    {
      *result = floor(operand);
      return 0;
    }

@q **** (4) UNIFORMDEVIATE. @>
@ \.{UNIFORMDEVIATE}.
@<Define parser rule functions@>=

  else if (operator_value == UNIFORMDEVIATE)
  {
      cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0'"
                << endl 
                << "`numeric_operator' == `UNIFORMDEVIATE'."
                << "Haven't programmed this case yet!\n" 
                << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                << "and will try to continue."
                << endl;

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *result = INVALID_REAL;
      return 1;
  }

@q **** (4) Invalid value for |numeric_operator|.  @>
@ Invalid value for |numeric_operator|.
@<Define parser rule functions@>=

  else 
  {
      cerr_strm << "ERROR! In `Scan_Parse::numeric_primary_rule_func_0':"
                << endl 
                << "Invalid value for `numeric_operator': "
                << operator_value << "." << endl
                << "Setting `numeric_primary' to `INVALID_NUMERIC' "
                << "and will try to continue."
                << endl;

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *result = INVALID_REAL;
      return 1;
  }

@q **** (4)@> 

}  /* End of |Scan_Parse::numeric_primary_rule_func_0| definition.  */

@q * (1) Functions for |complex| expressions.@> 
@* Functions for {\bf complex} expressions.
\initials{LDF 2007.12.11.}

\LOG
\initials{LDF 2007.12.11.}
Added this section.
\ENDLOG

@q ** (2) |complex_primary| rule function 0.@> 
@*1 \complex primary> rule function 0.
\initials{LDF 2007.12.11.}

\LOG
\initials{LDF 2007.12.11.}
Added this function.
\ENDLOG   

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::complex_primary_rule_func_0(void* v,
                                        int op,
                                        void* parameter)

{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   Complex* c = static_cast<Complex*>(v);

@q **** (4)@>

   if (!c)
   {

        cerr_strm << thread_name << "ERROR!  "
                  << "In `Scan_Parse::complex_primary_rule_func_0':"
                  << endl 
                  << "The complex operand is null."
                  << endl 
                  << "Exiting function unsuccessfully with return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete c;
  
        return 0;


   }  /* |if (!c)|  */


@q **** (4).@>

#if ! (HAVE_LIBGSL & HAVE_GSL_GSL_COMPLEX_H)

    cerr_strm << thread_name << "ERROR!  "
              << "In `Scan_Parse::complex_primary_rule_func_0':"
              << endl 
              << "The GNU Scientific Library or its complex facilities,"
              << endl 
              << "which are required for this function, are unavailable."
              << endl 
              << "Exiting function unsuccessfully with return value 0.";

    log_message(cerr_strm);
    cerr_message(cerr_strm, error_stop_value);
    cerr_strm.str("");

    delete c;

    return 0;

@q **** (4)@>

#else

@q ***** (5)@>

  if (op == PLUS)  /* Unary plus --- do nothing.  */
  {

       return static_cast<void*>(c); 

  }  /* |if (op == PLUS)|  */

@q ***** (5)@>

  else if (op == MINUS)  /* Unary minus  */
  {
     *c = -*c;  

     return static_cast<void*>(c); 

  }  /* |else if (op == MINUS)|  */


@q ***** (5)@>

   else 
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Scan_Parse::complex_primary_rule_func_0':"
                 << endl 
                 << "`op' has invalid value:  " << name_map[op] 
                 << " (" << op << ")"
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete c;

       return 0;

   }  /* |else|  (|op| has invalid value)  */


@q ***** (5)@>

#endif 

@q **** (4)@>


   return 0;

}  /* End of |Scan_Parse::complex_primary_rule_func_0| 
      definition  */


@q ** (2) |complex_arith_op| rule function 0.@> 
@*1 \complex arith op> rule function 0.
\initials{LDF 2007.12.11.}

\LOG
\initials{LDF 2007.12.11.}
Added this function.
\ENDLOG   

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::complex_arith_op_rule_func(void* v,
                                       void* w,
                                       int op,
                                       void* parameter)

{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   Complex* c = static_cast<Complex*>(v);
   Complex* d = static_cast<Complex*>(w);

@q **** (4)@>

   if (!(c && d))
   {

        cerr_strm << thread_name << "ERROR!  "
                  << "In `Scan_Parse::complex_arith_op_rule_func':"
                  << endl 
                  << "One or both of the complex operands are null."
                  << endl 
                  << "Exiting function unsuccessfully with return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete c;
        delete d;
  
        return 0;


   }  /* |if (!(c && d))|  */


@q **** (4).@>

#if ! (HAVE_LIBGSL & HAVE_GSL_GSL_COMPLEX_H)

    cerr_strm << thread_name << "ERROR!  "
              << "In `Scan_Parse::complex_arith_op_rule_func':"
              << endl 
              << "The GNU Scientific Library or its complex facilities,"
              << endl 
              << "which are required for this function, are unavailable."
              << endl 
              << "Exiting function unsuccessfully with return value 0.";

    log_message(cerr_strm);
    cerr_message(cerr_strm, error_stop_value);
    cerr_strm.str("");

    delete c;
    delete d;

    return 0;

@q **** (4)@>

#else

@q ***** (5)@>

  if (op == TIMES)
  {

       *c *= *d;
       delete d;
       return static_cast<void*>(c); 

  }  /* |if (op == TIMES)|  */

@q ***** (5)@>

  else if (op == OVER)
  {
     *c /= *d;
     delete d;
     return static_cast<void*>(c); 

  }  /* |else if (op == OVER)|  */


@q ***** (5)@>

  else if (op == PLUS)
  {
     *c += *d;
     delete d;
     return static_cast<void*>(c); 

  }  /* |else if (op == OVER)|  */

@q ***** (5)@>

  else if (op == MINUS)
  {
     *c -= *d;
     delete d;
     return static_cast<void*>(c); 

  }  /* |else if (op == OVER)|  */

@q ***** (5)@>

   else 
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Scan_Parse::complex_arith_op_rule_func':"
                 << endl 
                 << "`op' has invalid value:  " << name_map[op] 
                 << " (" << op << ")"
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete c;
       delete d;

       return 0;

   }  /* |else|  (|op| has invalid value)  */


@q ***** (5)@>

#endif 

@q **** (4)@>


   return 0;

}  /* End of |Scan_Parse::complex_arith_op_rule_func| 
      definition  */

@q * (1) Functions for |matrix| expressions.@> 
@* Functions for {\bf matrix} expressions.
\initials{LDF 2007.12.20.}

\LOG
\initials{LDF 2007.12.20.}
Added this section.
\ENDLOG

@q ** (2) |matrix_secondary| rule function 0.@> 
@*1 \matrix secondary> rule function 0.
\initials{LDF 2007.12.20.}

\LOG
\initials{LDF 2007.12.20.}
Added this function.
\ENDLOG   

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::matrix_secondary_rule_func_0(void* v, void* w, void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4)@>

   Matrix* m0 = static_cast<Matrix*>(v);
   Matrix* m1 = static_cast<Matrix*>(w);

@q **** (4)@>

   if (!(m0 && m1))
   {
      cerr_strm << thread_name 
                << "ERROR!  In `Scan_Parse::matrix_secondary_rule_func_0':"
                << endl 
                << "One or both of the pointers to `Matrix' is null.  Can't multiply."
                << endl 
                << "Exiting function unsuccessfully with return value (void*) 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");


      delete m0;
      delete m1;
      return 0;

   }  /* |if (!(m0 && m1))|  */

@q **** (4)@>

   else if (!m0->is_multipliable(*m1))
   {

       cerr_strm << thread_name 
                 << "ERROR!  In `Scan_Parse::matrix_secondary_rule_func_0':"
                 << endl 
                 << "Matrices are not multipliable."
                 << endl 
                 << "Exiting function unsuccessfully with return value (void*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete m0;
       delete m1;
       return 0;
   }

@q **** (4) Perform matrix multiplication.@>

@ Perform matrix multiplication.
\initials{LDF 2007.12.23.}

\LOG
\initials{2008.12.18.}
Got rid of extra |Matrix|.
\ENDLOG

@<Define parser rule functions@>=

   else
   {

@q ***** (5)@>

      Matrix* m2 = new Matrix;

      *m2 = *m0 * *m1;

      delete m0;       
      delete m1;       

      return static_cast<void*>(m2);

@q ***** (5)@>

   } /* |else|  */

}  /* End of |Scan_Parse::matrix_secondary_rule_func_0| definition.  */

@q * (1) Functions for |point| expressions.@> 
@* Functions for {\bf point} expressions.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section.
\ENDLOG

@q ** (2) |point_secondary| rule function 0.@> 
@*1 \point secondary> rule function 0.
This function is called in the rule 
\point secondary> $\longrightarrow$ 
\point secondary> \.{PROJECTED} \focus primary>.
in \filename{ppntexpr.w}
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this function.

\initials{LDF 2005.04.15.}
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.04.19.}
Changed the name of this function from 
|point_primary_rule_func_0| to |point_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z|.  Now passing 
|!(static_cast<bool>(with_z))| to |Point::copy_coords|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::point_secondary_rule_func_0(void* ppoint, 
                                        void* ffocus,
                                        int with_z,
                                        Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

   Point* p = static_cast<Point*>(ppoint);
   Focus* f = static_cast<Focus*>(ffocus);

   p->project(*f);

   p->copy_coords('p', 'w', !(static_cast<bool>(with_z)), scanner_node);

   Transform t = f->get_transform();

   t.inverse(true);

   *p *= t;

   delete f;

   return p;

}  /* End of |Scan_Parse::point_secondary_rule_func_0| definition.  */

@q * (1) Functions for |transform| expressions.@> 
@* Functions for {\bf transform} expressions.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section.
\ENDLOG

@q ** (2) |transform_primary| rule function 0.@> 
@*1 \transform primary> rule function 0.
This function is called in the rule 
\transform primary> $\longrightarrow$ \.{GET\_TRANSFORM} 
\focus expression>.
\initials{LDF 2005.04.16.}

\LOG
\initials{LDF 2005.04.16.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::transform_primary_rule_func_0(void* ffocus, 
                                          Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

   if (ffocus == static_cast<Focus*>(0))
      return 0;

   Focus* f = static_cast<Focus*>(ffocus);

   Transform* t = create_new<Transform>(f->get_transform());

   delete f;

   return t;


} /* End of |Scan_Parse::transform_primary_rule_func_0| definition.  */

@q ** (2) |transform_primary| rule function 1.@> 
@*1 \transform primary> rule function 1.
This function is called in the rules 
\transform primary> $\longrightarrow$ \.{INVERSE} 
\transform expression>
and 
\transform primary> $\longrightarrow$ \.{TRANSPOSED} 
\transform expression>.
\initials{LDF 2005.04.16.}
\initials{LDF 2007.10.14.}

\LOG
\initials{LDF 2005.04.16.}
Added this function.

\initials{LDF 2007.10.14.}
Changed the |void* ttransform| argument to |Transform* transform|
and added |int command| argument.
Modified this function so that it can be used for transposition 
as well as inversion.  
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::transform_primary_rule_func_1(Transform* transform, 
                                          int command,
                                          Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

   string s;

   if (command == INVERSE)
      s = "invert";
   else if (command == TRANSPOSED)
      s = "transpose";
   else
   {
       cerr_strm << thread_name 
                 << "ERROR!  In `Scan_Parse::transform_primary_rule_func_1':"
                 << endl 
                 << "Invalid command:  " << name_map[command]
                 << endl
                 << "Exiting function unsuccessfully with return value 0.";

       delete transform;
       return 0;       
   }

@q **** (4)@>

   if (transform == static_cast<Transform*>(0))
   {

       cerr_strm << thread_name 
                 << "ERROR!  In `Scan_Parse::transform_primary_rule_func_1':"
                 << endl 
                 << "`Transform*' is null.  Can't " << s << "."
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       return 0;
   }

@q **** (4)@>

   if (command == INVERSE)
      transform->inverse(true);
   else if (command == TRANSPOSED)
      transform->transpose(true);

   return static_cast<void*>(transform); 

} /* End of |Scan_Parse::transform_primary_rule_func_1| definition.  */



@q * (1) Functions for |path| expressions.@> 
@* Functions for {\bf path} expressions.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section.
\ENDLOG

@q ** (2) |path_primary| rule function 0.@> 
@*1 \path primary> rule function 0.
This function is called in the rule 
\path secondary> $\longrightarrow$ 
\path secondary> \.{PROJECTED} \focus primary>
\with z optional>
in \filename{ppthexpr.w}.
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.15.}
Added this function.

\initials{LDF 2005.04.15.}
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.04.19.}
Changed the name of this function from |path_primary_rule_func_0| 
to |path_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z|.  Now passing 
|!(static_cast<bool>(with_z))| to |Path::copy_coords|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::path_secondary_rule_func_0(void* ppath, 
                                       void* ffocus,
                                       int with_z,
                                       Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

   Path* p = static_cast<Path*>(ppath);
   Focus* f = static_cast<Focus*>(ffocus);

   p->project(*f);

   p->copy_coords('p', 'w', !(static_cast<bool>(with_z)), scanner_node);

   Transform t = f->get_transform();

   t.inverse(true);

   *p *= t;

   delete f;

   return static_cast<void*>(p);

} /* End of |Scan_Parse::path_secondary_rule_func_0| definition.  */

@q * (1) Functions for |polygon| expressions.@> 
@* Functions for {\bf polygon} expressions.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section.
\ENDLOG

@q ** (2) |polygon_secondary| rule function 0.@> 
@*1 \polygon secondary> rule function 0.
This function is called in the rule 
\polygon secondary> $\longrightarrow$ 
\polygon secondary> \.{PROJECTED} \focus primary>
in \filename{ppygexpr.w}.
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.15.}
Added this function.

\initials{LDF 2005.04.19.}
Changed the name of this function from 
|polygon_primary_rule_func_0| to 
|polygon_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z|.  Now passing 
|!(static_cast<bool>(with_z))| to |Path::copy_coords|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=
void*
Scan_Parse::polygon_secondary_rule_func_0(void* ppolygon, 
                                          void* ffocus,
                                          int with_z,
                                          Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

   Polygon* p = static_cast<Polygon*>(ppolygon);
   Focus* f = static_cast<Focus*>(ffocus);

   p->project(*f);

   p->copy_coords('p', 'w', !(static_cast<bool>(with_z)), scanner_node);

   Transform t = f->get_transform();

   t.inverse(true);

   *p *= t;

   delete f;

   return static_cast<void*>(p);

} /* End of |Scan_Parse::polygon_secondary_rule_func_0| definition.  */

@q * (1) Functions for Quadric Surfaces.@> 
@* Functions for Quadric Surfaces.
\initials{LDF 2006.11.09.}

\LOG
\initials{LDF 2006.11.09.}
Added this section.
\ENDLOG

@q ** (2) Get element.@> 
@*1 Get element.
\initials{LDF 2006.11.09.}

\LOG
\initials{LDF 2006.11.09.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=

void*
Scan_Parse::quad_surf_get_element_func(void* parameter, 
                                       unsigned int command,
                                       unsigned int type,
                                       void* object,
                                       int arg_0,
                                       int arg_1)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>


   if (type == Shape::CONE_TYPE)
   {
       Cone* c = static_cast<Cone*>(object);

@q ***** (5)@> 

       if (command == GET_APEX)
       {
           Point* p = create_new<Point>(0);
           *p = c->apex;
           delete c;
           c = 0;
           object = 0;
           return static_cast<void*>(p); 
       }

@q ***** (5)@> 

       else if (command == GET_BASE)
       {


           if (c->type == Shape::CIRCULAR_CONE_TYPE)
           {
               Circle* k = create_new<Circle>(c->circles[0]);
               delete c;
               c = 0;
               object = 0;
               return static_cast<void*>(k); 
           }  
              
@q ****** (6)@>

           else if (c->type == Shape::ELLIPTICAL_CONE_TYPE)
           {
               Ellipse* e = create_new<Ellipse>(c->ellipses[0]);
               delete c;
               c = 0;
               object = 0;
               return static_cast<void*>(e); 
           }  

@q ****** (6)@>

       }  /* |if (command == GET_BASE)|  */ 


@q ***** (5)@> 

       else if (command == GET_CAP)
       {

@q ****** (6)@> 

           if (c->nap_type != Cone::DOUBLE_NAPPED_TYPE)
           {
               delete c;
               c = 0;
               object = 0;
               return 0;
           }

@q ****** (6)@> 

           else if (c->type == Shape::CIRCULAR_CONE_TYPE)
           {
               Circle* k = create_new<Circle>(c->circles.back());
               delete c;
               c = 0;
               object = 0;
               return static_cast<void*>(k); 
           }  
              
@q ****** (6)@>

           else if (c->type == Shape::ELLIPTICAL_CONE_TYPE)
           {
               Ellipse* e = create_new<Ellipse>(c->ellipses.back());
               delete c;
               c = 0;
               object = 0;
               return static_cast<void*>(e); 
           }  

@q ****** (6)@>

       }  /* |else if (command == GET_CAP)|  */ 


@q ***** (5)@> 

      else if (command == GET_CIRCLE)
      {
 

@q ****** (6)@> 

          if (c->type != Cone::CIRCULAR_CONE_TYPE)
          {

               delete c;
               c = 0;
               object = 0;
               return 0;
          }

@q ****** (6)@> 

          else if (arg_0 <  c->circles.size())
          {
              Circle* k = create_new<Circle>(c->circles[arg_0]);
              delete c;
              c = 0;
              object = 0;
              return static_cast<void*>(k); 
          }
            
@q ****** (6)@> 

          else 
          {
              delete c;
              c = 0;
              object = 0;
              return 0;
          }


@q ****** (6)@> 

      }  /* |else if (command == GET_CIRCLE)|  */


@q ***** (5)@> 

      else if (command == GET_ELLIPSE)
      {
 
@q ****** (6)@> 

          if (c->type != Cone::ELLIPTICAL_CONE_TYPE)
          {
               delete c;
               c = 0;
               object = 0;
               return 0;
          }

@q ****** (6)@> 

          else if (arg_0 < c->ellipses.size())
          {
              Ellipse* e = create_new<Ellipse>(c->ellipses[arg_0]);
              delete c;
              c = 0;
              object = 0;
              return static_cast<void*>(e); 
          }
            
@q ****** (6)@> 

          else 
          {
              delete c;
              c = 0;
              object = 0;
              return 0;
          }


@q ****** (6)@> 

      }  /* |else if (command == GET_ELLIPSE)|  */


@q ***** (5)@> 

       if (command == GET_PATH)
       {


           if (arg_0 < c->paths.size())
           {
               Path* p = create_new<Path>(c->paths[arg_0]);
               delete c;
               c = 0;
               object = 0;
               return static_cast<void*>(p); 
           }  

           else
           {
               delete c;
               c = 0;
               object = 0;
               return 0;

           }
              
@q ****** (6)@>

      }


@q ***** (5)@> 
 
   }  /* |if (type == Shape::CONE_TYPE)|  */


@q **** (4).@>

    return 0;

}  /* End of |Scan_Parse::quad_surf_get_element_func|  */




@q * (1) Functions for operation assignments.@> 
@* Functions for operation assignments.
\initials{LDF 2005.05.12.}

\LOG
\initials{LDF 2005.05.12.}
Added this section.
\ENDLOG

@q ** (2) Operation assignments for |Pictures|.@> 
@*1 Operation assignments for {\bf Pictures}.
\initials{LDF 2005.05.12.}

\LOG
\initials{LDF 2005.05.12.}
Added this section.
\ENDLOG


@q *** (3) Operation assignment |Picture| rule function 0.@> 
@*2 Operation assignment {\bf Picture} rule function 0.
\initials{LDF 2005.05.12.}

\LOG
\initials{LDF 2005.05.12.}
Added this function.  It's called in the action for the parser rule
\operation assignment> $\longrightarrow$ \picture variable> 
\.{PLUS\_ASSIGN} \picture expression> in \.{popassgn.w}.
\ENDLOG


@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::operation_assignment_picture_rule_func_0(
                                         void* to_picture_entry,
                                         void* from_picture_entry,
                                         Scanner_Node scanner_node)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node p_entry 
       = static_cast<Id_Map_Entry_Node>(to_picture_entry); 
   
   if (p_entry == static_cast<Id_Map_Entry_Node>(0))
      {
         cerr_strm << "ERROR!  "
                   << "In 'Scan_Parse::operation_assignment_picture"
                   << "rule_func_0':" 
                   << endl 
                   << "'picture' variable is void.  Can't assign."
                   << endl << "Exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");


         return 1;
       
      }  /* |if (p_entry == 0)|  */

@q ***** (5)@>  

   Picture* p;

   if (p_entry->object == static_cast<void*>(0))
      {
         p = new Picture;
         p->clear();
         p_entry->object = static_cast<void*>(p);
      }

   else
      {
          p = static_cast<Picture*>(p_entry->object);
      }  


@q ***** (5)@>  

   Id_Map_Entry_Node q_entry 
       = static_cast<Id_Map_Entry_Node>(from_picture_entry); 
   

   if (q_entry == static_cast<Id_Map_Entry_Node>(0))
      {
         cerr_strm << "ERROR!  "
                   << "In 'Scan_Parse::operation_assignment_picture"
                   << "rule_func_0':" 
                   << endl 
                   << "'picture_expression' is void.  Can't assign."
                   << endl << "Exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         return 1;
       
      }  /* |if (q_entry == 0)|  */

@q ***** (5)@>  

   Picture* q;

   if (q_entry->object == static_cast<void*>(0))
      {
         q = new Picture;
         q->clear();
         q_entry->object = static_cast<void*>(q);
      }

   else
      {
          q = static_cast<Picture*>(q_entry->object);
      }  


@q ***** (5)@>  

   *p += *q;

   return 0;

@q ***** (5)@>  

} /* End of |Scan_Parse::operation_assignment_picture_rule_func_0| 
     definition.  */

@q * (1) Functions for set commands.@> 
@* Functions for set commands.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this section.
\ENDLOG

@q ** (2) set commands for non-|Shape|-types.@> 
@*1 Set commands for non-{\bf Shape}-types.
\initials{LDF 2007.11.28.}

\LOG
\initials{LDF 2007.11.28.}
Added this section.
\ENDLOG

@q *** (3) set |Matrix| rule function 0.@> 
@*2 set {\bf Matrix} rule function 0.
\initials{LDF 2007.11.28.}

\LOG
\initials{LDF 2007.11.28.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=

int
Scan_Parse::set_matrix_rule_func_0(void* curr_var,
                                   real rows,
                                   real columns,
                                   void* parameter)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Scan_Parse::set_matrix_rule_func_0'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
               
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@>

#if ! (HAVE_LIBGSL & HAVE_GSL_GSL_MATRIX_H)

    cerr_strm << thread_name << "ERROR!  In `Scan_Parse::set_matrix_rule_func_0':"
              << endl 
              << "The GNU Scientific Library or its matrix facilities,"
              << endl 
              << "which are required for this function, are unavailable."
              << endl 
              << "Exiting function with return value 1.";

    log_message(cerr_strm);
    cerr_message(cerr_strm, error_stop_value);
    cerr_strm.str("");
    
    return 1;

#endif 

@q ***** (5)@>

   if (curr_var == static_cast<void*>(0) || parameter == static_cast<void*>(0))
       return 1;
    
    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

    Matrix* curr_matrix = static_cast<Matrix*>(entry->object);

    if (curr_matrix == static_cast<Matrix*>(0))
    {
        curr_matrix = create_new<Matrix>(0); 
        entry->object = static_cast<void*>(curr_matrix);
    }

@q ***** (5)@>

    cerr << "rows == " << rows << endl;
    cerr << "columns == " << columns << endl;


/* START HERE!!  Add code for setting |type| and |tolerance|.
   LDF 2007.12.21.
*/ 

    int status = curr_matrix->set(Matrix::MATRIX_REAL_TYPE,  /* |type| argument  */
                                  static_cast<size_t>(floor(rows + .5)),
                                  static_cast<size_t>(floor(columns + .5)),
                                  -1,  /* |real ttolerance| argument.  */
                                  scanner_node);

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::set_matrix_rule_func_0' successfully "
                << "with return value " << status << ".";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
               
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    return status;

}  /* End of |Scan_Parse::set_matrix_rule_func_0| definition.  */

@q ** (2) Set commands for |Shape|-types.@> 
@*1 Set commands for {\bf Shape}-types.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this section.
\ENDLOG

@q *** (3) set |parabola| rule function 0.@> 
@*2 set {\bf parabola} rule function 0.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=

int
Scan_Parse::set_parabola_rule_func_0(void* curr_var,
                                     void* parameter)
{

 
   if (curr_var == static_cast<void*>(0) || parameter == static_cast<void*>(0))
       return 1;

    
    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

    Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

    Parabola_Set_Option_Struct* options = scanner_node->parabola_set_option_struct;

    Parabola* curr_parabola = static_cast<Parabola*>(entry->object);

    if (curr_parabola == static_cast<Parabola*>(0))
       {
           curr_parabola = create_new<Parabola>(0); 
           entry->object = static_cast<void*>(curr_parabola);
       }

@q ***** (5)@>

           int status = curr_parabola->set(options, scanner_node);

@q ****** (6)@>

           delete scanner_node->parabola_set_option_struct;
           scanner_node->parabola_set_option_struct = 0;

    return 0;

}  /* End of |Scan_Parse::set_parabola_rule_func_0| definition.  */

@q *** (3) set |Hyperbola| rule function 0.@> 
@*2 set {\bf Hyperbola} rule function 0.
\initials{LDF 2005.11.14.}

\LOG
\initials{LDF 2005.11.14.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=

int
Scan_Parse::set_hyperbola_rule_func_0(void* curr_var,
                                      void* parameter)
{

 
   if (curr_var == static_cast<void*>(0) || parameter == static_cast<void*>(0))
       return 1;

    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

    Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

    Hyperbola_Set_Option_Struct* options = scanner_node->hyperbola_set_option_struct;

    Hyperbola* curr_hyperbola = static_cast<Hyperbola*>(entry->object);

    if (curr_hyperbola == static_cast<Hyperbola*>(0))
       {
           curr_hyperbola = create_new<Hyperbola>(0); 
           entry->object = static_cast<void*>(curr_hyperbola);
       }

@q **** (4)@> 

           int status = curr_hyperbola->set(options, scanner_node);

@q ***** (5)@> 

           delete scanner_node->hyperbola_set_option_struct;
           scanner_node->hyperbola_set_option_struct = 0;

    return 0;

}  /* End of |Scan_Parse::set_hyperbola_rule_func_0| definition.  */

@q *** (3) set |Arc| rule function 0.@> 
@*2 set {\bf Arc} rule function 0.
\initials{LDF 2007.11.25.}

\LOG
\initials{LDF 2007.11.25.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=

int
Scan_Parse::set_arc_rule_func_0(void* curr_var,
                                void* parameter)
{

 
   if (curr_var == static_cast<void*>(0) || parameter == static_cast<void*>(0))
       return 1;
    
    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

    Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

    Arc_Options* options = scanner_node->arc_options;

    scanner_node->arc_options = 0;

    Arc* curr_arc = static_cast<Arc*>(entry->object);

    if (curr_arc == static_cast<Arc*>(0))
    {
        curr_arc = create_new<Arc>(0); 
        entry->object = static_cast<void*>(curr_arc);
    }

@q ***** (5)@>

    int status = curr_arc->set(options, scanner_node);

@q ****** (6)@>

    return status;

}  /* End of |Scan_Parse::set_arc_rule_func_0| definition.  */

@q *** (3) set |Helix| rule function 0.@> 
@*2 set {\bf Helix} rule function 0.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \helix variable> 
\set helix option list> in \.{psetcmnd.w}.
It currently has a dummy definition;  it just returns 0.

\initials{LDF 2005.05.20.}
Replaced the dummy definition with a real one.

\initials{LDF 2005.05.21.}
Removed the |void* option_list|.  The |void* parameter| argument is now required.

\initials{LDF 2005.05.21.}
@:BUG FIX@> BUG FIX: 
Now deleting |Helix_Set_Option_Struct* options| and setting it and
|scanner_node->helix_set_option_struct| to 0 before returning.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_helix_rule_func_0(void* curr_var,
                                  void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Helix_Set_Option_Struct* options = scanner_node->helix_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_helix_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->helix_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Helix* curr_helix;

   if (entry->object == static_cast<void*>(0))
      {
          curr_helix = create_new<Helix>(0);
          entry->object = static_cast<void*>(curr_helix); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_helix = static_cast<Helix*>(entry->object); 

@q ***** (5).@>

    return curr_helix->set(options, scanner_node);

    delete options;
    options = 0;
          
    scanner_node->helix_set_option_struct = 0;

} /* End of |Scan_Parse::set_helix_rule_func_0| 
     definition.  */

@q *** (3) set |cone| rule function 0.@> 
@*2 set {\bf cone} rule function 0.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \cone variable> 
\set cone option list> in \.{psetcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_cone_rule_func_0(void* curr_var,
                                 void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Cone_Set_Option_Struct* options = scanner_node->cone_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_cone_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->cone_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Cone* curr_cone;

   if (entry->object == static_cast<void*>(0))
      {
          curr_cone = create_new<Cone>(0);
          entry->object = static_cast<void*>(curr_cone); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_cone = static_cast<Cone*>(entry->object); 

@q ***** (5).@>

    curr_cone->set(options, scanner_node);

    scanner_node->cone_set_option_struct = 0;

} /* End of |Scan_Parse::set_cone_rule_func_0| 
     definition.  */

@q *** (3) set |cylinder| rule function 0.@> 
@*2 set {\bf cylinder} rule function 0.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \cylinder variable> 
\set cylinder option list> in \.{psetcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_cylinder_rule_func_0(void* curr_var,
                                     void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Cylinder_Set_Option_Struct* options = scanner_node->cylinder_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_cylinder_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->cylinder_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Cylinder* curr_cylinder;

   if (entry->object == static_cast<void*>(0))
      {
          curr_cylinder = create_new<Cylinder>(0);
          entry->object = static_cast<void*>(curr_cylinder); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_cylinder = static_cast<Cylinder*>(entry->object); 

@q ***** (5).@>

    return curr_cylinder->set(options, scanner_node);

    delete options;
    options = 0;
          
    scanner_node->cylinder_set_option_struct = 0;

} /* End of |Scan_Parse::set_cylinder_rule_func_0| 
     definition.  */


@q *** (3) set |ellipsoid| rule function 0.@> 
@*2 set {\bf ellipsoid} rule function 0.
\initials{LDF 2005.05.26.}

\LOG
\initials{LDF 2005.05.26.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \ellipsoid variable> 
\set ellipsoid option list> in \.{psetcmnd.w}.

\initials{LDF 2005.10.31.}
Commented-in code for calling |Ellipsoid::set|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_ellipsoid_rule_func_0(void* curr_var,
                                      void* parameter)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Ellipsoid_Set_Option_Struct* options = scanner_node->ellipsoid_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_ellipsoid_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->ellipsoid_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Ellipsoid* curr_ellipsoid;

   if (entry->object == static_cast<void*>(0))
      {
          curr_ellipsoid = create_new<Ellipsoid>(0);
          entry->object = static_cast<void*>(curr_ellipsoid); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_ellipsoid = static_cast<Ellipsoid*>(entry->object); 

@q ***** (5).@>

    curr_ellipsoid->set(options, scanner_node);

    delete options;
    options = 0;
          
    scanner_node->ellipsoid_set_option_struct = 0;

} /* End of |Scan_Parse::set_ellipsoid_rule_func_0| 
     definition.  */

@q *** (3) set |sphere| rule function 0.@> 
@*2 set {\bf sphere} rule function 0.
\initials{LDF 2005.06.06.}

\LOG
\initials{LDF 2005.06.06.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \sphere variable> 
\set sphere option list> in \.{psetcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_sphere_rule_func_0(void* curr_var,
                                   void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Sphere_Set_Option_Struct* options = scanner_node->sphere_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_sphere_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->sphere_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Sphere* curr_sphere;

   if (entry->object == static_cast<void*>(0))
      {
          curr_sphere = create_new<Sphere>(0);
          entry->object = static_cast<void*>(curr_sphere); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_sphere = static_cast<Sphere*>(entry->object); 

@q ***** (5).@>
@ 
\LOG
\initials{LDF 2005.10.19.}
Now calling |curr_sphere->set(options, scanner_node)|.  Previously, this was 
commented-out.
\ENDLOG

@<Define parser rule functions@>=


    curr_sphere->set(options, scanner_node);

    delete options;
    options = 0;
          
    scanner_node->sphere_set_option_struct = 0;

    return 0;

} /* End of |Scan_Parse::set_sphere_rule_func_0| 
     definition.  */

@q *** (3) set |sphere_development| rule function 0.@> 
@*2 set {\bf sphere\_development} rule function 0.
\initials{LDF 2009.11.17.}

\LOG
\initials{LDF 2009.11.17.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \sphere_development variable> 
\set sphere_development option list> in \.{psetcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_sphere_development_rule_func_0(void* curr_var,
                                               void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Sphere_Development_Set_Option_Struct* options 
      = scanner_node->sphere_development_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_sphere_development_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->sphere_development_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   Sphere_Development* curr_sphere_development;

   if (entry->object == static_cast<void*>(0))
      {
          curr_sphere_development = create_new<Sphere_Development>(0);
          entry->object = static_cast<void*>(curr_sphere_development); 
  
      } /* |if (entry->object == 0)|  */

   else
      curr_sphere_development = static_cast<Sphere_Development*>(entry->object); 

@q ***** (5).@>
@ 
@<Define parser rule functions@>=


    curr_sphere_development->set(options, scanner_node);

    delete options;
    options = 0;
          
    scanner_node->sphere_development_set_option_struct = 0;

    return 0;

} /* End of |Scan_Parse::set_sphere_development_rule_func_0| 
     definition.  */



@q *** (3) set |paraboloid| rule function 0.@> 
@*2 set {\bf paraboloid} rule function 0.
\initials{LDF 2006.01.25.}

\LOG
\initials{LDF 2006.01.25.}
Added this function.  It's called in the action for the parser rule
\set command> $\longrightarrow$ \.{SET} \paraboloid variable> 
\set paraboloid option list> in \.{psetcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@<Define parser rule functions@>=
int
Scan_Parse::set_paraboloid_rule_func_0(void* curr_var,
                                       void* parameter)

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q ***** (5).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(curr_var);

   Paraboloid_Set_Option_Struct* options = scanner_node->paraboloid_set_option_struct; 

@q ***** (5)@>  

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Scan_Parse::set_paraboloid_rule_func_0()':"
                    << endl 
                    << "'entry' == 0.  "
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->paraboloid_set_option_struct = 0;

          return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5)@>  
 
   if (!(   options->type == Paraboloid::ELLIPTICAL_TYPE 
         || options->type == Paraboloid::HYPERBOLIC_TYPE))
      {

          cerr_strm << thread_name 
                    << "ERROR!  In `Scan_Parse::set_paraboloid_rule_func_0()':"
                    << endl 
                    << "`options->type' is invalid:  " << options->type
                    << endl 
                    << "It should be either `Paraboloid::ELLIPTICAL_TYPE' "
                    << "nor `Paraboloid::HYPERBOLIC_TYPE'."
                    << endl 
                    << "Deleting 'options' and exiting function with "
                    << "return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete options;
          options = 0;
          
          scanner_node->paraboloid_set_option_struct = 0;

          return 1;
   
      }  /* |if (!(   options->type == Paraboloid::ELLIPTICAL_TYPE 
                  || options->type == Paraboloid::HYPERBOLIC_TYPE))|  */

@q ***** (5)@> 

   if (entry->object == static_cast<void*>(0) && options->type == Paraboloid::ELLIPTICAL_TYPE)
      {
          Elliptical_Paraboloid* curr_paraboloid
             = create_new<Elliptical_Paraboloid>(0);

          entry->object = static_cast<void*>(curr_paraboloid); 
 
          curr_paraboloid->set(options, scanner_node);

  
      } /* |if (entry->object == 0 && options->type == Paraboloid::ELLIPTICAL_TYPE)|  */


@q ***** (5)@> 


   else if (   entry->object == static_cast<void*>(0) 
            && options->type == Paraboloid::HYPERBOLIC_TYPE)
      {
          Hyperbolic_Paraboloid* curr_paraboloid
             = create_new<Hyperbolic_Paraboloid>(0);
  
          entry->object = static_cast<void*>(curr_paraboloid); 

          curr_paraboloid->set(options, scanner_node);
  
      } /* |if (entry->object == 0 && options->type == Paraboloid::HYPERBOLIC_TYPE)|  */

@q ***** (5)@> 

   else if (entry->object != static_cast<void*>(0))
      {
          Paraboloid* curr_paraboloid = static_cast<Paraboloid*>(entry->object);

          unsigned short curr_type = curr_paraboloid->get_type();

@q ****** (6)@> 

          if (options->type == Paraboloid::ELLIPTICAL_TYPE)
              {

                  if (curr_type == Paraboloid::ELLIPTICAL_TYPE)
                      curr_paraboloid->set(options, scanner_node);

                  else
                     {
                         delete curr_paraboloid;
                         curr_paraboloid = 0;
                         Elliptical_Paraboloid* curr_elliptical_paraboloid
                            = create_new<Elliptical_Paraboloid>(0);

                         curr_elliptical_paraboloid->set(options, scanner_node);
                         entry->object = static_cast<void*>(curr_elliptical_paraboloid); 
                     }
          }  /* |if (options->type == Paraboloid::ELLIPTICAL_TYPE)|  */


@q ****** (6)@> 

          if (options->type == Paraboloid::HYPERBOLIC_TYPE)
              {

                  if (curr_type == Paraboloid::HYPERBOLIC_TYPE)
                      curr_paraboloid->set(options, scanner_node);

                  else
                     {
                         delete curr_paraboloid;
                         curr_paraboloid = 0;
                         Hyperbolic_Paraboloid* curr_hyperbolic_paraboloid
                            = create_new<Hyperbolic_Paraboloid>(0);

                         curr_hyperbolic_paraboloid->set(options, scanner_node);
                         entry->object = static_cast<void*>(curr_hyperbolic_paraboloid);
                     }
          }  /* |if (options->type == Paraboloid::HYPERBOLIC_TYPE)|  */


@q ****** (6)@> 
           
      }  /* |else if (entry->object != 0)|  */

@q ***** (5)@> 

    delete options;
    options = 0;
          
    scanner_node->paraboloid_set_option_struct = 0;

    return 0;

} /* End of |Scan_Parse::set_paraboloid_rule_func_0| 
     definition.  */


@q * (1) Functions for extracting information.@> 
@* Functions for extracting information.
\initials{LDF 2009.09.09.}

\LOG
\initials{LDF 2009.09.09.}
Added this section.
\ENDLOG

@q ** (2) |sphere_size_func|.@> 
@*1 {\bf sphere\_size\_func}.
\initials{LDF 2009.09.09.}

\LOG
\initials{LDF 2009.09.09.}
Added this function.
\ENDLOG

@<Define parser rule functions@>=
int
Scan_Parse::sphere_size_func(void* v, void* parameter)
{

   Sphere* s = static_cast<Sphere*>(v);

   real r = 0;

   if (s)
   {
       r = s->size();
       delete s;
       s = 0;
   }

   return r;

}  /* End of |Scan_Parse::sphere_size_func| definition.  */



@q * (1) Functions for terminal output.@> 
@* Functions for terminal output.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this section.
\ENDLOG

@q ** (2) |message_command_func|.@> 
@*1 {\bf message\_command\_func}.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this function.
\ENDLOG

@<Define parser rule functions@>=
int
Scan_Parse::message_command_func(int message_type, void* v, void* parameter)
{

    if (v)
      {

        string* s = static_cast<string*>(v); 

        stringstream cerr_strm;
        string thread_name      = ""; 
        bool error_stop_value;


        Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

        if (scanner_node)
           scanner_node->get_thread_name_and_stop_values(&thread_name, &error_stop_value);
  
        bool is_errmessage = (message_type == ERRMESSAGE) ? error_stop_value : false;

        cerr_strm << thread_name;

        if (is_errmessage)
          cerr_strm << "ERROR! ";

        cerr_strm << *s;
        
        log_message(cerr_strm); 
        cerr_message(cerr_strm, is_errmessage);
        cerr_strm.str(""); 
        

        delete s;

      }   /* |if (v)|  */

        return 0;  

}  /* End of |Scan_Parse::message_command_func| definition.  */


@q * (1) Functions for intersections.@> 
@* Functions for intersections.
\initials{LDF 2006.01.20.}

\LOG
\initials{LDF 2006.01.20.}
Added this section.
\ENDLOG

@q ** (2) Intersection of a |Polyhedron| and a linear |Path|.@> 
@*1 Intersection of a {\bf Polyhedron} and a linear {\bf Path}.
\initials{LDF 2006.01.20.}

\LOG
\initials{LDF 2006.01.20.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define parser rule functions@>=

void*
Scan_Parse::polyhedron_path_intersection_func(Polyhedron* p,
                                              Path* q,
                                              void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>
  
#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "Entering `Scan_Parse::polyhedron_path_intersection_func'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

      }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


@q **** (4) Error handling:  |Polyhedron* p| and/or |Path* q| is null.@> 

@ Error handling:  |Polyhedron* p| and/or |Path* q| is null.
\initials{LDF 2006.01.20.}

@<Define parser rule functions@>=

   if (!(p && q))
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Scan_Parse::polyhedron_path_intersection_func':"
                    << endl 
                    << "`Polyhedron* p' and/or `Path* q' is null."
                    << endl
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete p;
          delete q;

          p = 0;
          q = 0;

          return 0;

      }  /* |if (!(p && q))|  */


@q **** (4) Error handling:  The |Path| pointed to by |q| is non-linear.@> 

@ Error handling:  The |Path| pointed to by |q| is non-linear.@> 
\initials{LDF 2006.01.20.}

@<Define parser rule functions@>=

   if (!q->is_linear())
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Scan_Parse::polyhedron_path_intersection_func':"
                    << endl 
                    << "`Path' is non-linear.  Can't handle this case yet."
                    << endl
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete p;
          delete q;

          p = 0; 
          q = 0;

          return 0;

      }  /* |if (!q->is_linear())|  */


@q **** (4)@> 
@
\LOG
\initials{LDF 2006.01.23.}
Changed |Pointer_Vector<Point>* pv| to |Pointer_Vector<Point>* bpv|.
\ENDLOG 
@<Define parser rule functions@>=

   Pointer_Vector<Bool_Point>* bpv = p->intersection_points(q, scanner_node);
    
   delete p;
   delete q;

   p = 0;
   q = 0;

@q **** (4)@> 

   return static_cast<void*>(bpv);

}  /* End of |Scan_Parse::polyhedron_path_intersection_func| definition.  */
                      


@q * (1) Putting parser rule functions together.@>
@* Putting parser functions together.
\initials{LDF 2005.04.15.}

This is what's compiled.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.06.09.}
Now including |@<Define functions@>|.  Currently, this section contains 
the definition of |initialize_name_map|, which I've moved from 
\filename{pbsndecl.w} to this file (\filename{prrfnc0.web}).
\ENDLOG 

@c
@<Include files@>@;
@<Define functions@>@;
@<Define parser rule functions@>@;

@ This is what's written to \filename{prrfnc0.h}.
\initials{LDF 2005.04.09.}

@(prrfnc0.h@>=
#ifndef LDF_PRRFNC0_H_KNOWN
#define LDF_PRRFNC0_H_KNOWN
@=/* Nothing.  */@>@/
#endif


@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
