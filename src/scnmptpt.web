@q scnmptpt.web@>
@q Created by Laurence D. Finston Thu 20 Jan 2022 05:14:09 AM CET  @>

@q * (1) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing.  @>
@q Copyright (C) 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA@>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html.@>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @>
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @>
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>




@q  * (1) Scanner for MetaPost logging output.  @>
@* Scanner for MetaPost logging output.
\initials{LDF 2022.01.20.}

@
@<Include files@>=

#include "loader.h++"

#include <string.h>

#ifdef __GNUC__
#include <getopt.h> 
#endif 

#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "helices.h++"
#include "origami.h++"
#if 0
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++" 
#include "sphrdevl.h++" 
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"
#include "imetfncs.h++"
#include "deftfncs.h++"
#include "sctpcrt.h++"  
#include "sctpfncs.h++"  
#include "prrfnc0.h++"
#include "mpoutput.h++"

@q  ** (2) Start conditions.  @>
@ Start conditions.

@<Start conditions@>=

@q  ** (2) Options.  @>
@ Options.

@<Options@>=
@=%option header-file="scnmptpt.h++"@>
@=%option reentrant@>
@=%option prefix="zz"@>
@=%option noyywrap@>

@q ** (2) Name definitions.  @>
@ Name definitions.  
@<Name definitions@>=

NUMBER [-]?[0-9]+(\.[0-9]+)?
POINT \({NUMBER},[[:space:]]*{NUMBER}\) 

@q * (1) Local variables for |zzlex|.  @>
@ Local variables for {\bf zzlex}.
\initials{LDF 2012.06.25.}

@<Local variables for |zzlex|@>=

bool DEBUG = true;  /* |false|  */

Scanner_Node scanner_node = static_cast<Scanner_Node>(yyextra); 


@q ** (2) Code to be executed each time |zzlex| is entered.  @>

@ Code to be executed each time {\bf zzlex} is entered.  This code must be
indented or it causes an error when FLEX is run.  The start condition on entry
to {\bf zzlex} can be set here.
\initials{LDF 2012.06.27.}

@<Execute on entry to |zzlex|@>=

   cerr << "Entering `zzlex'." << endl;

@q ** (2) Rules.  @>
@ Rules.


@q *** (3) @> 
@ 
@<Rules@>= 
@="START PATH" {@> 

#if DEBUG_COMPILE 
   if (DEBUG) 
   { 
       cerr << "In `zzlex':  START PATH" << endl; 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */  

   if (scanner_node->metapost_output_struct == 0)
      scanner_node->metapost_output_struct = new Metapost_Output_Struct;

   scanner_node->metapost_output_struct->path_vector.push_back(create_new<Path>(0));

@=}@> 

@q *** (3) @> 
@ 
@<Rules@>= 
@="END PATH" {@> 

#if DEBUG_COMPILE 
   if (DEBUG) 
   { 
       cerr << "In `zzlex':  END PATH" << endl;
       scanner_node->metapost_output_struct->path_vector.back()->show();

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */  



@=}@> 


@q *** (3) @>
@
@<Rules@>=
@=controls[[:space:]]*{POINT}[[:space:]]*and[[:space:]]*{POINT} {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  `controls .. and point':  " << yytext << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   

@=}@>

@q *** (3) @>
@
@<Rules@>=
@=controls[[:space:]]*{POINT} {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  `controls point':  " << yytext << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>

@q *** (3) @>
@
@<Rules@>=
@={POINT} {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  A point:  " << yytext << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>

@q *** (3) @>
@
@<Rules@>=
@={NUMBER} {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  A number:  " << yytext << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>

@q *** (3) @>
@
@<Rules@>=
@=cycle {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  `cycle'." << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>

@q *** (3) @>
@
@<Rules@>=
@=\.\. {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  `connector':  " << yytext << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>


@q *** (3) @>
@
@<Rules@>=
@=[[:space:]] {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  whitespace, ignoring:  \"" << yytext << "\"" << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@=}@>

@q *** (3) End-of-file (EOF).  @>
@ End-of-file (EOF).

@<Rules@>=
@=<<EOF>> {@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "In `zzlex':  Read EOF.  Returning." << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

@=}@>


@ Putting scanner together.
@c
@=%{@>
@<Include files@>@;@/
using namespace std;
@=%}@>
@<Start conditions@>@;@/
@<Options@>@;@/
@<Name definitions@>@;@/
@=%%@>
@=%{@>
@<Local variables for |zzlex|@>@;@/
@=%}@>
@<Execute on entry to |zzlex|@>@;@/
@q Rules @>
@<Rules@>@;@/
@=%%@>
@q User code@>


 
@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))           @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

