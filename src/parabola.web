@q parabola.web @>
@q Created by Laurence D. Finston (LDF) Mon Nov  7 18:26:47 CET 2005 @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Parabolae.@>
@** Parabolae\quad ({\tt parabola\PERIOD web}).\hfil

\LOG
\initials{LDF 2005.11.07.}
Created this file.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"

@q * (1) Parabola class definition.@>
@* {\bf Parabola} class definition.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this |class| definition.

\initials{LDF 2005.11.21.}
Added |real max_extent|.

\initials{LDF 2005.11.28.}
Removed |real max_extent|.  Made it member of |Conic_Section|.
\ENDLOG

@<Define |class Parabola|@>=

class Parabola : public Path, public Conic_Section
{

   protected:
   
   public:

  @<Declare |Parabola| functions@>@;
};

@q ** (2) Static member variable definitions.@>
@*1 Static member variable definitions.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.  It is currently empty.
\ENDLOG

@q *** (3) Code.@> 

@<Define |static| |class Parabola| data members@>=

@q * (1) Constructors and setting functions.@>
@* Constructors and setting functions.@>
\initials{LDF 2005.11.07.}

@q ** (2) Default constructor.  No arguments.@>
@*1 Default constructor. No arguments.
@^\cfunc{Parabola}{Parabola}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.09.}
Now setting |conic_section_type = PARABOLA_TYPE|.

\initials{LDF 2005.11.21.}
Now setting |real numerical_eccentricity| to 1.

\initials{LDF 2005.11.21.}
Now setting |real max_extent| to 0.

\initials{LDF 2005.11.25.}
Now setting |real axis_h| and |real axis_v| to |INVALID_REAL|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Parabola| functions@>=
Parabola(void);

@q *** (3) Definition.@>

@
@<Define |Parabola| functions@>= 
Parabola::Parabola(void)
{

   shape_type         = PARABOLA_TYPE;
   conic_section_type = PARABOLA_TYPE;

   numerical_eccentricity = 1;
   max_extent = 0;

   axis_h = axis_v = INVALID_REAL;

   return;

}

@q ** (2) Setting function.@> 
@*1 Setting function.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.21.}
Now setting |numerical_eccentricity| to 1.

\initials{LDF 2005.11.21.}
No longer declaring |real max_extent|.  It's now a member of |class Parabola|.

\initials{LDF 2005.11.25.}
Now setting |real axis_h| and |real axis_v| to |INVALID_REAL|.
\ENDLOG

@q *** (3) Declaration.  @>

@<Declare |Parabola| functions@>=
int
set(Parabola_Set_Option_Struct* options = 0, Scanner_Node scanner_node = 0);

@q *** (3) Definition.  @>

@
@<Define |Parabola| functions@>= 
int
Parabola::set(Parabola_Set_Option_Struct* options, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>
 
   real increment_value;

   numerical_eccentricity = 1;
 
   axis_h = axis_v = INVALID_REAL;

@q **** (4) |options == static_cast<Parabola_Set_Option_Struct*>(0)|.  Use defaults.@> 
@ |options == static_cast<Parabola_Set_Option_Struct*>(0)|.  Use defaults.
\initials{LDF 2005.11.07.}

@<Define |Parabola| functions@>= 

    if (options == static_cast<Parabola_Set_Option_Struct*>(0))  
       {

            /* Use defaults.  Not programmed yet.
               LDF 2005.11.07.  */

            vertex_0.set(0, 0, 0);
            focus_0 = INVALID_POINT;
            parameter       = DEFAULT_PARAMETER;
            max_extent      = DEFAULT_MAX_EXTENT;
            increment_value = DEFAULT_INCREMENT_VALUE;
       }

@q **** (4) |options != static_cast<Parabola_Set_Option_Struct*>(0)|.@> 
@ |options != static_cast<Parabola_Set_Option_Struct*>(0)|.  
\initials{LDF 2005.11.07.}

@<Define |Parabola| functions@>= 

    else   /* |options != static_cast<Parabola_Set_Option_Struct*>(0)|  */
       {
         
@q ***** (5) |parameter|.@> 

           if (options->parameter != INVALID_REAL)
              {
#if 0 
                  cerr << "options->parameter == " << options->parameter << endl;
#endif 

                  parameter = options->parameter;
                  options->parameter = INVALID_REAL;
              }
            else
               parameter = DEFAULT_PARAMETER;

@q ***** (5)@> 

           if (options->max_extent != INVALID_REAL)
              {
                  max_extent = options->max_extent;
                  options->max_extent = INVALID_REAL;
              }
            else
               max_extent = DEFAULT_MAX_EXTENT;

@q ***** (5)@> 

           if (options->increment_value != INVALID_REAL)
              {
                  increment_value = options->increment_value;
                  options->increment_value = INVALID_REAL;
              }
            else
               increment_value = DEFAULT_INCREMENT_VALUE;

@q ***** (5) |focus|.@> 

           if (options->focus)
              {
                  focus_0 = *(options->focus);
                  delete options->focus;
                  options->focus = 0;
              }
            else
               focus_0 = INVALID_POINT;

@q ***** (5) |vertex|.@> 

           if (options->vertex)
              {
                  vertex_0 = *(options->vertex);
                  delete options->vertex;
                  options->vertex = 0;
              }
            else if (focus_0 == INVALID_POINT)
                vertex_0.set(0, 0, 0);
           
            else 
               vertex_0 = INVALID_POINT;

@q ***** (5)@> 

       }  /* |else| (|options != static_cast<Parabola_Set_Option_Struct*>(0)|)  */

@q **** (4) Check |focus_0| and |vertex_0| for consistency.@> 
@ Check |focus_0| and |vertex_0| for consistency.
\initials{LDF 2005.11.09.}

@<Define |Parabola| functions@>= 

   if (!(vertex_0 == INVALID_POINT || focus_0 == INVALID_POINT))
      {
          cerr_strm << thread_name << "ERROR!  In `Parabola::set()':"
                    << endl 
                    << "`vertex_0' and `focus_0' shouldn't both be set.  "
                    << "Using `vertex_0' and resetting `focus_0'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          focus_0 = INVALID_POINT;

      }  /* |if|  */

@q **** (4) Generate |Path|.@> 
@ Generate |Path|.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.18.}
@:BUG FIX@> BUG FIX:  Now pushing |".."| onto |connectors|.
\ENDLOG

@<Define |Parabola| functions@>= 

    real curr_x = 0;
    real curr_z = 0;

    Point* curr_pt = 0;
    
    real p = .5 * parameter;

    Point shift_pt = INVALID_POINT;

    deque<Point*> curr_deque;

if (vertex_0 == INVALID_POINT)
       {
           shift_pt = focus_0;
           shift_pt.shift(-p); 
       }

    else if (focus_0 == INVALID_POINT)
       {
          focus_0.set(p, 0, 0);
          focus_0.shift(vertex_0);
       }

@q ***** (5) Create the |Point| on |points| corresponding to |vertex_0|. @> 
@ Create the |Point| on |points| corresponding to |vertex_0|.
\initials{LDF 2005.11.09.}

@<Define |Parabola| functions@>= 

    curr_pt = create_new<Point>(ORIGIN);

    if (!(vertex_0 == INVALID_POINT || vertex_0 == ORIGIN))
       curr_pt->shift(vertex_0);
  
    else if (shift_pt != INVALID_POINT)
       curr_pt->shift(shift_pt);

    curr_deque.push_front(curr_pt);

@q ***** (5) Create the other |Points|.@>
@ Create the other |Points|.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.21.}
@:BUG FIX@> BUG FIX:  Fixed the way the |Path| is generated.
\ENDLOG 

@<Define |Parabola| functions@>= 

    for (real t = increment_value; curr_x < max_extent; t += increment_value)
       {
           curr_x = (t * t) / (2 * p);
  
           if (curr_x > max_extent)
              break;

           curr_z = t;

           curr_pt = create_new<Point>(0);
           curr_pt->set(curr_x, 0, curr_z);

           if (!(vertex_0 == INVALID_POINT || vertex_0 == ORIGIN))
              curr_pt->shift(vertex_0);
  
           else if (shift_pt != INVALID_POINT)
              curr_pt->shift(shift_pt);
                       
           curr_deque.push_front(curr_pt);

           curr_pt = create_new<Point>(0);
           curr_pt->set(curr_x, 0, -curr_z);

           if (!(vertex_0 == INVALID_POINT || vertex_0 == ORIGIN))
              curr_pt->shift(vertex_0);
  
           else if (shift_pt != INVALID_POINT)
              curr_pt->shift(shift_pt);
                       
           curr_deque.push_back(curr_pt);
         
       }  /* |for|  */    

    for (deque<Point*>::const_iterator iter = curr_deque.begin();
         iter != curr_deque.end();
         ++iter)
        {
            points.push_back(*iter);
        }

    curr_deque.clear();
    
    if (vertex_0 == INVALID_POINT)
       {
           vertex_0 = shift_pt;
       }

    *this += string("..");

@q **** (4) Exit function successfully with return value 0.@>
@ Exit function successfully with return value 0.
\initials{LDF 2005.11.09.}

@<Define |Parabola| functions@>= 

    return 0;

}  /* End of |Parabola::set| definition.  */

@q * (1) Destructor.@> 
@* Destructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
~Parabola(void);

@q *** (3) Definition.  @>

@
@<Define |Parabola| functions@>= 
Parabola::~Parabola(void)
{
   return;
}

@q * (1) Pseudo-constructor for dynamic allocation.@>
@* Pseudo-constructor for dynamic allocation.

@q ** (2) Pointer argument.@>
@*1 Pointer argument.
@^\cfunc{Parabola}{create\_new\_parabola}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Parabola|@>=
Parabola* 
create_new(const Parabola* c, Scanner_Node scanner_node);

@q ** (2) Reference argument.@>
@*1 Reference argument.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Parabola|@>=
Parabola* 
create_new(const Parabola& c, Scanner_Node scanner_node);

@q * (1) Assignment.@> 
@* Assignment.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Assignment from a |Parabola|.@> 
@*1 Assignment from a |Parabola|.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.07.}
Now setting |focus0 = p.focus0|.

\initials{LDF 2005.11.09.}
No longer setting |focus0 = p.focus0|.  Now calling 
|Conic_Section::operator=(p)|

\initials{LDF 2005.11.21.}
Now setting |max_extent = p.max_extent|.

\initials{LDF 2005.11.28.}
No longer setting |max_extent = p.max_extent|.  This is now done in 
|Conic_Section::operator=|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual
Parabola&
operator=(const Parabola& c);

@q *** (3) Definition.@> 

@
@<Define |Parabola| functions@>=

Parabola&
Parabola::operator=(const Parabola& p)
{
    if (this == &p) /* Make sure it's not self-assignment. */
       return *this;
    
     Conic_Section::operator=(p);
     Path::operator=(p);

     return *this;

}  /* End of |Parabola::operator=(const Parabola& h)| definition.  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return PARABOLA_TYPE;
}

@q ** (2) Get discriminant.@>
@*1 Get discriminant.

\LOG
\initials{LDF 2005.11.17.}
Added this function.

\initials{LDF 2005.11.17.}
Changed the return type of this function from |real| to |Real_Triple|.
If not |INVALID_REAL_TRIPLE|, the return value contains the discriminant,
the slope, and the z-intercept.

\initials{LDF 2005.11.18.}
Changed |Path&| argument to |const Path&|.  Added optional |Transform*| 
argument with default 0.

\initials{LDF 2005.11.18.}
Removed the code for finding the transformation that puts
|*this| into standard position.  Now calling |Parabola::standardize| 
instead.

\initials{LDF 2005.11.24.}
@:BUG FIX@> BUG FIX:  Now passing 
|pth.get_point(0)| and |pth.get_point(1)|
to |Point::intersection_point| instead of 
|p.get_point(0)| and |p.get_point(1)|.

\initials{LDF 2005.11.27.}
Changed to account for the fact that |Parabola::standardize| now returns 
a |Transform*| rather than a |Transform|.  Added error handling code to check
for the case that this |Transform*| is null.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
Real_Triple
get_discriminant(const Path& p, 
                 Transform* t = 0, 
                 Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Parabola| functions@>=
Real_Triple
Parabola::get_discriminant(const Path& p, 
                           Transform* t, 
                           Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    Plane q = get_plane();

    if (!(   p.is_linear()
          && p.get_point(0).is_on_plane(q)
          && p.get_point(1).is_on_plane(q)))
      {

          return INVALID_REAL_TRIPLE;
      }

@q **** (4)@> 

    Point normal = q.normal;
    Path pth = p;

    Point y_axis_pt(0, 1, 0);

    if (normal == y_axis_pt)
       {

           if (t != static_cast<Transform*>(0))
              t->reset();
       }
    
@q **** (4)@> 

    else /* |normal != y_axis_pt|  */ 
       {

           Transform* u = standardize(scanner_node); 

@q ***** (5)@> 
@
\LOG
\initials{LDF 2005.11.27.}
Added this section.
\ENDLOG

@<Define |Parabola| functions@>=

           if (u == static_cast<Transform*>(0))
              { 
                  cerr_strm << thread_name 
                            << "ERROR!  In `Parabola::get_discriminant()':"
                            << endl 
                            << "`Parabola::standardize()' failed."
                            << endl 
                            << "Deleting `Transform* t', setting it to 0, and exiting function "
                            << "unsuccessfully"
                            << endl 
                            << "with return value `INVALID_REAL_TRIPLE'.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");
 
                  delete t;
                  t = 0;            

                  return INVALID_REAL_TRIPLE;
                           
              }  /* |if (u == static_cast<Transform*>(0))|  */

@q ***** (5)@> 

           pth *= *u;

           if (t != static_cast<Transform*>(0))
              *t = u->inverse();

delete u;
           u = static_cast<Transform*>(0);   

       }  /* |else| (|normal != y_axis_pt|)  */ 

@q **** (4)@> 

    real half_parameter = parameter / 2;

    real slope = pth.slope('x', 'z');

    Bool_Point bp =  Point::intersection_point(pth.get_point(0), pth.get_point(1),
                                               ORIGIN, Point(0, 0, 1));

    real z_int = bp.pt.get_z();

return Real_Triple((half_parameter * (half_parameter - (2 * slope * z_int))),
                       slope,
                       z_int);

}  /* End of |Parabola::get_discriminant| definition. */

@q ** (2) Location.@> 
@*1 Location.
\initials{LDF 2005.11.21.}

Return values:\hfil\break
\item{0} 
|Point| lies on the segment of the parabola represented 
by the |Parabola| object.
\smallskip
%
\item{1} 
|Point| lies on the parabola, but not the segment, represented 
by the |Parabola| object.
\smallskip
%
\item{2} 
|Point| lies in the region enclosed by the branches of the parabola and the 
line connecting the end points of the segment.
\smallskip
%
\item{3} 
|Point| lies between the branches of the parabola, but
outside the region enclosed by them and the line connecting the 
end points of the segment.
\smallskip
%
\item{-1} 
|Point| is coplanar with the |Parabola|, but does not lie on the curve 
or between the branches.
\smallskip
%
\item{-2} 
|Point| is not coplanar with the |Parabola|.
\smallskip
%
\item{-3} 
The |Parabola| is not parabolic.
\smallskip
%
\item{-4}
The |Point| is invalid.
\smallskip
%
\item{-5}
|Parabola::location| failed.
\smallskip
%
\item{-6}
Something has gone terribly wrong.
%
\par
\initials{LDF 2005.11.21.}
\initials{LDF 2005.11.27.}

\LOG
\initials{LDF 2005.11.21.}
Added this function.

\initials{LDF 2005.11.27.}
Changed to account for the fact that |Parabola::standardize| now returns 
a |Transform*| rather than a |Transform|.  Added error handling code to check
for the case that this |Transform*| is null.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
signed short
location(Point q, 
         Scanner_Node scanner_node = 0, 
         real tolerance = Shape::DEFAULT_TOLERANCE) const;

@q *** (3) Definition.@> 
@
@<Define |Parabola| functions@>=
signed short
Parabola::location(Point q, 
                   Scanner_Node scanner_node,
                   real tolerance) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (!is_parabolic())
       return -3;

    if (q == INVALID_POINT)
         return -4;

    Transform* t = standardize(scanner_node);

@q **** (4)@> 
@
\LOG
\initials{LDF 2005.11.27.}
Added this section.
\ENDLOG

@<Define |Parabola| functions@>=

    if (t == static_cast<Transform*>(0))
       {
           cerr_strm << thread_name 
                     << "ERROR!  In `Parabola::location()':"
                     << endl 
                     << "`Parabola::standardize()' failed."
                     << endl 
                     << "Exiting function unsuccessfully "
                     << "with return value -5.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");
 
           return -5;
                           
       }  /* |if (t == static_cast<Transform*>(0))|  */

@q **** (4)@> 

    q *= *t;

    if (fabs(q.get_y()) > tolerance)
       return -2;    

    real z_2 = q.get_z();
    z_2 *= z_2;
  
    real q_x = q.get_x();

    real r = parameter * q_x;
  
    if (fabs(z_2 - r) <= tolerance)
       {
           if(q_x < max_extent)
              return 0;
           else 
              return 1;
       }

    if (z_2 < r)
       {
           if (q_x < max_extent)
              return 2;  
           else 
              return 3;
       }

    delete t;
    t = 0;

    return -1;

}  /* End of |Parabola::location| definition.  */

@q * (1) Predicates.@> 
@* Predicates.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Is whatever.@>
@*1 Is whatever.
@^\cfunc{Parabola}{is\_whatever}@>

\LOG
\initials{LDF 2005.11.21.}
Added this function.
\ENDLOG 

@<Declare |Parabola| functions@>=
virtual
bool
is_whatever(void) const;

@
@<Define |Parabola| functions@>=
bool
Parabola::is_whatever(void) const
{

  return is_parabolic();
}

@q ** (2) Is parabolic.@>
@*1 Is parabolic.

@q *** (3) |Parabola| version.@>
@*1 {\bf Parabola} version.
@^\cfunc{Parabola}{is\_parabolic}@>

\LOG
\initials{LDF 2005.11.21.}
Added this function.  It currently has a dummy definition 
and returns |true| immediately.
\ENDLOG 

@<Declare |Parabola| functions@>=
virtual
bool
is_parabolic(void) const;

@
@<Define |Parabola| functions@>=
bool
Parabola::is_parabolic(void) const
{

  return true;
}

@q *** (3) |Path| version.@> 
@*2 {\bf Path} version.
@^\cfunc{Path}{is\_parabolaal}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.  It is declared in \filename{paths.web}.
It currently has a dummy definition and returns |false|.
\ENDLOG

@q **** (4) Definition.@> 
  
@
@<Define |Path| functions@>=
bool
Path::is_parabolic(Scanner_Node scanner_node) const
{
   return false;

} /* End of |Path::is_parabolic| definition.  */

@q * (1) Transformations.@>
@* Transformations. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) Multiplication by a |Transform| with assignment.@>
@*2 Multiplication by a |Transform| with assignment.
@^\cofunc{Parabola}{*=}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.09.}
Now calling |Conic_Section::operator*=(t)|.
\ENDLOG 

@<Declare |Parabola| functions@>=
virtual
Transform
operator*=(const Transform& t);

@
@<Define |Parabola| functions@>=
Transform
Parabola::operator*=(const Transform& t)
{
   Conic_Section::operator*=(t);
   return Path::operator*=(t);
}

@q ** (2) Rotatation around the main axes.@>
@*1 Rotation  around the main axes. 
@^\cfunc{Parabola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
Transform 
rotate(const real x, const real y = 0, const real z = 0);

@
@<Define |Parabola| functions@>=
Transform 
Parabola::rotate(const real x, const real y, const real z)
{
  Transform t;
  t.rotate(x, y, z);
  return operator*=(t);
}

@q ** (2) Scale. @>
@*1 Scale. 
@^\cfunc{Parabola}{scale}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
Transform 
scale(real x, real y = 1, real z = 1);

@
@<Define |Parabola| functions@>=
Transform 
Parabola::scale(real x, real y, real z)
{
   Transform t;
   t.scale(x, y, z);
   return operator*=(t);
}

@q ** (2) Shear.@>
@*1 Shear. 
@^\cfunc{Parabola}{shear}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=

virtual
Transform 
shear(real xy, real xz = 0, real yx = 0, real yz = 0, 
      real zx = 0, real zy = 0);

@
@<Define |Parabola| functions@>=
Transform 
Parabola::shear(real xy, real xz, real yx, real yz, 
      real zx, real zy)
{
  Transform t;
  t.shear(xy, xz, yx, yz, zx, zy);
  return operator*=(t);

}

@q ** (2) Shift.@>
@*1 Shift. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) |real| arguments.@>
@*2 {\bf real} arguments. 
@^\cfunc{Parabola}{shift}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
Transform 
shift(real xx, real yy = 0, real zz = 0);

@
@<Define |Parabola| functions@>=
Transform
Parabola::shift(real xx, real yy, real zz)
{
  Transform t;
  t.shift(xx, yy, zz);
  return operator*=(t);
}

@q *** (3) Point argument.@>

@*2 {\bf Point} argument. 
@^\cfunc{Parabola}{shift}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
Transform 
shift(const Point& p);

@
@<Define |Parabola| functions@>=
Transform 
Parabola::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}

@q ** (2) Shift times. @>
@*1 Shift times. 
\initials{LDF 2005.11.07.}

@q *** (3) real arguments. @>

@*2 {\bf real} arguments. 
@^\cfunc{Parabola}{shift\_times}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.  
\ENDLOG

@<Declare |Parabola| functions@>=

virtual
void 
shift_times(real x, real y = 1, real z = 1);

@
@<Define |Parabola| functions@>=

void 
Parabola::shift_times(real x, real y, real z)
{

    Path::shift_times(x, y, z);
  
    return;
}

@q *** (3) Point argument. @>

@*2 {\bf Point} argument. 
@^\cfunc{Parabola}{shift\_times}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=
virtual
void
shift_times(const Point& p);

@
@<Define |Parabola| functions@>=
void
Parabola::shift_times(const Point& p)
{
  return shift_times(p.get_x(), p.get_y(), p.get_z());
}

@q ** (2) Rotatation around an arbitrary axis.@>
@*1 Rotatation around an arbitrary axis. 
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) Point arguments.@>

@*2 {\bf Point} arguments.
@^\cfunc{Parabola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=

virtual
Transform 
rotate(const Point& p0, const Point& p1, const real angle = 180);

@
@<Define |Parabola| functions@>=
Transform 
Parabola::rotate(const Point& p0, const Point& p1, const real angle)
{
  Transform t;
  t.rotate(p0, p1, angle);
  return operator*=(t);
}

@q *** (3) Path argument.@>

@*2 {\bf Path} arguments.
@^\cfunc{Parabola}{rotate}@>
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Parabola| functions@>=

virtual
Transform 
rotate(const Path& p, const real angle = 180);

@
@<Define |Parabola| functions@>=

Transform 
Parabola::rotate(const Path& p, const real angle)
{
   if (!p.is_linear())
     {
        return INVALID_TRANSFORM;
     }

   return rotate(p.get_point(0),
                 p.get_last_point(), angle);  
}   

@q ** (2) Standardize.@> 
@*1 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.

\initials{LDF 2005.11.27.}
@:BUG FIX@> BUG FIX:  No longer returning |Transform t| immediately, if
|*this| lies in the x-z plane.  It's possible that |focus_0| may not 
lie on the x-axis, in this case.

\initials{LDF 2005.11.27.}
Changed return type from |Transform| to |Transform*|.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.11.27.}
Add error handling code for the case that |*this| can't be put 
into standard position.
\ENDTODO 

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual
Transform*
standardize(Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Parabola| functions@>=
Transform*
Parabola::standardize(Scanner_Node scanner_node) const
{
    Transform* t = create_new<Transform>(0);

    Plane q = get_plane();

    Point normal = q.normal;

    normal.shift(vertex_0);

    t->align_with_axis(vertex_0, normal, 'y');
    
    Point vertex = vertex_0;
    Point focus  = focus_0;

    vertex *= focus *= *t;
    
    while (focus.get_x() < 0 || focus.get_z() < 0)
       {
          focus *= t->rotate(0, 90);
       }

    real angle = focus.angle(Point(1, 0, 0));

    focus *= t->rotate(0, -angle);
    
    return t;

} /* End of |Parabola::standardize| definition.  */

@q * (1) Intersections.@> 
@* Intersections.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) |Plane*| argument.@> 
@*1 {\bf Plane} pointer argument.
\initials{LDF 2005.11.21.}

\LOG
\initials{LDF 2005.11.21.}
Added this function.

\initials{LDF 2005.11.30.}
@:BUG FIX@> BUG FIX:  Now checking the return value of 
|Plane::intersection_line|.  If it's |INVALID_LINE|, this function returns 0.
Now passing |Scanner_Node scanner_node| argument to |Plane::intersection_line|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual
Pointer_Vector<Bool_Point>*
intersection_points(const Plane* p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Parabola| functions@>=
Pointer_Vector<Bool_Point>*
Parabola::intersection_points(const Plane* p, Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   Plane q = get_plane();

   Line r = p->intersection_line(q, scanner_node);

@q **** (4)@> 

   if (r == INVALID_LINE)
      {
          cerr_strm << thread_name 
                    << "WARNING!  In `Parabola::intersection_points()':"
                    << endl;
          if (p->point.is_on_plane(q))
             cerr_strm << "The plane of `*this' and `*p' coincident, ";
    
          else 
             cerr_strm << "The plane of `*this' and `*p' are parallel, ";

          cerr_strm << "i.e., there are infinitely many intersections."
                    << endl 
                    << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if (r == INVALID_LINE)|  */

@q **** (4)@> 

   Path s = r.get_path();

   Pointer_Vector<Bool_Point>* bpv = intersection_points(&s);

   return bpv;

}  /* End of |Parabola::intersection_points(const Plane* p, [etc.])|
      definition.  */

@q ** (2) |Path*| argument.@> 
@*1 {\bf Path} pointer argument.
\initials{LDF 2005.11.17.}

\LOG
\initials{LDF 2005.11.17.}
Added this function.  Programmed the case that |*p| and |*this| are 
coplanar.  I haven't programmed the case that they're non-coplanar yet.

\initials{LDF 2005.11.18.}
Removed code for transforming the copies of |*p| and |*this|.  
The transformations are now done in |Parabola::get_discriminant|. 
It is not necessary to copy and transform |*this|.

\initials{LDF 2005.11.21.}
Changed the return value from |Pointer_Vector<Point>*| to
|Pointer_Vector<Bool_Point>*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual
Pointer_Vector<Bool_Point>*
intersection_points(const Path* p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Parabola| functions@>=
Pointer_Vector<Bool_Point>*
Parabola::intersection_points(const Path* p, Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (p == static_cast<Path*>(0))
       {
           cerr_strm << thread_name 
                     << "ERROR!  In `Parabola::intersection_points(Path* p, [etc.])':"
                     << endl 
                     << "`p' == 0.  Exiting function with return value 0.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           return 0;
       }  /* |if (p == static_cast<Path*>(0))|  */

@q **** (4)@> 

    else if (!p->is_linear())
       {
           cerr_strm << thread_name 
                     << "ERROR!  In `Parabola::intersection_points(Path* p, [etc.])':"
                     << endl 
                     << "`*p' is non-linear.  Can't handle this case yet."
                     << endl 
                     << "Exiting function with return value 0.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");
                    
           return 0;
       }  /* |else if (!p.is_linear())|  */

@q **** (4) |*p| and |*this| are coplanar.@> 

@ |*p| and |*this| are coplanar.
\initials{LDF 2005.11.17.}

@<Define |Parabola| functions@>=

    Plane q = get_plane();
   
    if (   p->get_point(0).is_on_plane(q) 
        && p->get_last_point().is_on_plane(q))
       {

#if DEBUG_COMPILE
           if (DEBUG)
              {
                   cerr << "Path lies in plane of Parabola."  << endl;
              }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@> 

           real half_parameter = parameter / 2;

           Transform* t = create_new<Transform>(0);

           Real_Triple r = get_discriminant(*p, t, scanner_node);

           real discriminant = r.first;
           real slope        = r.second;
           real z_int        = r.third;

           real curr_x;
           real curr_z;

           Bool_Point* curr_bool_pt;
           Pointer_Vector<Bool_Point>* bpv;

@q ***** (5) |slope| is infinite or |slope == INVALID_REAL|.@> 

@ |slope| is infinite or |slope == INVALID_REAL|.

\LOG
\initials{LDF 2005.11.24.}
Added this section.
\ENDLOG 

@<Define |Parabola| functions@>=

           if (!finite(slope) || slope == INVALID_REAL)
              {
                  Point q = p->get_point(0);
                  q *= t->inverse();

                  curr_x = q.get_x();

                  curr_z = sqrt(parameter * curr_x);

                  bpv = new Pointer_Vector<Bool_Point>;

                  curr_bool_pt = new Bool_Point;

                  curr_bool_pt->pt.set(curr_x, 0, curr_z);
                  curr_bool_pt->pt *= *t;
                  curr_bool_pt->b = !location(curr_bool_pt->pt);

                  *bpv += curr_bool_pt;

                  curr_bool_pt = new Bool_Point;

                  curr_bool_pt->pt.set(curr_x, 0, -curr_z);
                  curr_bool_pt->pt *= *t;
                  curr_bool_pt->b = !location(curr_bool_pt->pt);

                  *bpv += curr_bool_pt;

                  return bpv;

              }  /* |if (!finite(slope) || slope == INVALID_REAL)|  */

@q ***** (5)@> 
@
@<Define |Parabola| functions@>=

           if (discriminant < 0)
              return 0; 

           bpv = new Pointer_Vector<Bool_Point>;

           real slope_squared = slope * slope;

           real discriminant_root = sqrt(discriminant);

@q ***** (5)@> 

@q ****** (6)@> 
@
\LOG
\initials{LDF 2005.11.21.}
Added this section.
\ENDLOG
@<Define |Parabola| functions@>=

           if (slope == ZERO_REAL)
              {
                   Point temp_pt = p->get_point(0);
                   temp_pt *= t->inverse();

                   curr_z = temp_pt.get_z();
                   curr_x = (curr_z * curr_z) / parameter;

                   curr_bool_pt = new Bool_Point;
                   curr_bool_pt->pt.set(curr_x, 0, curr_z);
                   curr_bool_pt->b = !location(curr_bool_pt->pt);

                   curr_bool_pt->pt *= *t;

                   *bpv += curr_bool_pt;

              }  /* |if (slope == ZERO_REAL)|  */

@q ****** (6)@> 
@
\LOG
\initials{LDF 2005.11.21.}
Now setting |curr_bool_pt->b| to |!location(curr_bool_pt->pt)|.
\ENDLOG 
@<Define |Parabola| functions@>=

           else  /* |slope != ZERO_REAL|  */
              {

@q ******* (7)@> 

                  if (discriminant >= 0)
                    {
                         curr_x =   (half_parameter - (slope * z_int) + discriminant_root) 
                                  / slope_squared;

                         curr_z = (half_parameter + discriminant_root) / slope;

                         curr_bool_pt = new Bool_Point;
                         curr_bool_pt->pt.set(curr_x, 0, curr_z);

                         curr_bool_pt->pt *= *t;
                         
                         curr_bool_pt->b = !location(curr_bool_pt->pt); 

                         *bpv += curr_bool_pt;

                     }

@q ******* (7)@> 

                   if (discriminant > 0)
                       {
                           curr_x =   (half_parameter - (slope * z_int) - discriminant_root) 
                                    / slope_squared;

                           curr_z = (half_parameter - discriminant_root) / slope;

                           curr_bool_pt = new Bool_Point;

                           curr_bool_pt->pt.set(curr_x, 0, curr_z);

                           curr_bool_pt->pt *= *t;

                           curr_bool_pt->b = !location(curr_bool_pt->pt); 

                           *bpv += curr_bool_pt;

                        } 

@q ******* (7)@> 

              }  /* |else| (|slope != ZERO_REAL|)  */  

@q ****** (6)@>                 
 
@q ***** (5)@> 

           delete t;
           t = static_cast<Transform*>(0);

           return bpv;

@q ***** (5)@> 

       }  /* |if (   p->get_point(0).is_on_plane(q) 
               && p->get_last_point().is_on_plane(q))|  */ 

@q **** (4) |*p| and |*this| are non-coplanar.@> 

@ |*p| and |*this| are non-coplanar.
\initials{LDF 2005.11.17.}

\LOG
\initials{LDF 2005.11.21.}
Programmed this case.
\ENDLOG 

@<Define |Parabola| functions@>=

    else  /* |*this| and |*p| are non-coplanar.  */
       {

            Bool_Point* bp = new Bool_Point;
            *bp = q.intersection_point(p->get_point(0), p->get_last_point());

            if (bp->pt == INVALID_POINT)
               {
                   delete bp;
                   return 0;
               }

            else
               {

                   Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;

                   bp->b = !location(bp->pt);

                   *bpv += bp;
                   return bpv;
               }

       }   /*  |*this| and |*p| are non-coplanar.  */

@q **** (4)@> 

}  /* End of |Parabola::intersection_points| definition.  */

@q ** (2) |Plane| reference argument.@> 
@*1 {\bf Plane} reference argument.

@q * (1) Modifying.@> 
@* Modifying.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this section.
\ENDLOG

@q ** (2) Set cycle.@> 
@*1 Set cycle.
\initials{LDF 2005.11.18.}

Enough points must be used for the curve, because using |"&"| 
to connect it with the line segment connecting the
end points causes an error in MetaPost.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Parabola| functions@>=
virtual
int
set_cycle(const bool b = true, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 
@
@<Define |Parabola| functions@>=
int
Parabola::set_cycle(const bool b, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   if (b && !is_cycle())
   {
      adjust_connectors();
      *this += string("..");
      Point* p = create_new<Point>(points[points.size() - 1]);
      points.push_back(p);
      *this += string("--");
      p = create_new<Point>(points[0]);
      points.push_back(p);
      *this += string("..");
      Path::set_cycle(true);
   }

@q **** (4)@> 

   else if (!b && is_cycle())
      {
          
          int j = points.size() - 1;

          for (vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
               iter != connector_type_vector.end();
               ++iter)
          {
             delete *iter;
             *iter = 0;
          }

          connector_type_vector.clear();

          Path::set_cycle(false);  

          for (int i = 0; i < 2; ++i)
             {
                 delete points[j--];
                 points.pop_back();
             }


          *this += string("..");

      }  

@q **** (4)@> 

    return 0;      

}  /* End of |Parabola::set_cycle| definition.  */

@q * (1) Show.@> 
@* Show.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.07.}
Added code for showing |focus0.|

\initials{LDF 2005.11.09.}
Removed code for showing |focus0.|  Now calling |Conic_Section::show|.
\ENDLOG

@q ** 23) Declaration.@> 

@<Declare |Parabola| functions@>=

virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1) const;

@q ** (2) Definition.@> 

@
@<Define |Parabola| functions@>=
void 
Parabola::show(string text, char coords,
            const bool do_persp, const bool do_apply,
            Focus* f, const unsigned short proj,
            const real factor) const

{

    if (text == "")
       text = "Parabola";

    Conic_Section::show(text, coords, do_persp, do_apply, f, proj, factor);

    Path::show("Path:", coords, do_persp, do_apply, f, proj, factor);

    return;

} /* End of |Parabola::show| definition.  */

@q * (1) Parabola_Set_Option_Struct.@> 
@* {\bf Parabola\_Set\_Option\_Struct}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q ** (2) Struct definition.@> 
@*1 Struct definition.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this |struct| definition.

\initials{LDF 2005.11.07.}
Added the data members
|Point* vertex|, 
|real parameter|, 
|real linear_eccentricity|, 
|real numerical_eccentricity|,
and 
|Path* directrix|.

\initials{LDF 2005.11.08.}
Removed |real half_parameter|.

\initials{LDF 2005.11.09.}
Added |real max_extent| and |real increment_value|.

\initials{LDF 2005.11.21.}
Removed |real numerical_eccentricity|.
The numerical eccentricity of a parabola is always 1.
\ENDLOG

@<Define |struct Parabola_Set_Option_Struct|@>=

struct
Parabola_Set_Option_Struct
{

   Point* focus;
   Point* vertex;
   real parameter;
   real linear_eccentricity;
   Path* directrix;

   real max_extent;
   real increment_value;

@<Declare |Parabola_Set_Option_Struct| functions@>@;

};

@q ** (2) |Parabola_Set_Option_Struct| functions.@> 
@*1 {\bf Parabola\_Set\_Option\_Struct} functions.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q *** (3) Constructors.@>
@*2 Constructors.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section.
\ENDLOG

@q **** (4) Default constructor.@>   
@*3 Default constructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.07.}
Now setting |Point* focus| to 0.

\initials{LDF 2005.11.07.}
Now setting 
|Point* vertex|
|real parameter|
|real linear_eccentricity|
|real numerical_eccentricity| 
and 
|Path* directrix|
all to 0.

\initials{LDF 2005.11.08.}
Removed |real half_parameter|.

\initials{LDF 2005.11.09.}
Now setting the |reals| |parameter|, |linear_eccentricity|, and 
|numerical_eccentricity| to |INVALID_REAL|.

\initials{LDF 2005.11.09.}
Now setting the |reals| |max_extent| and |increment_value| to 
|INVALID_REAL|.

\initials{LDF 2005.11.21.}
Removed |Parabola_Set_Option_Struct::numerical_eccentricity|.
The numerical eccentricity of a parabola is always 1.
\ENDLOG

@q ***** (5) Declaration.@>  

@<Declare |Parabola_Set_Option_Struct| functions@>=

Parabola_Set_Option_Struct(void);

@q ***** (5) Definition.@>  

@
@<Define |Parabola_Set_Option_Struct| functions@>=

Parabola_Set_Option_Struct::Parabola_Set_Option_Struct(void) 
{
    focus = 0;
    vertex = 0;
    directrix = 0;

    parameter              = INVALID_REAL;
    linear_eccentricity    = INVALID_REAL;
    max_extent             = INVALID_REAL;
    increment_value        = INVALID_REAL;

    return;
}

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.07.}
Now deleting |Point* focus|.

\initials{LDF 2005.11.08.}
Now deleting |Point* vertex|
and |Point*  directrix|.
\ENDLOG

@q **** (4) Declaration.@>  

@<Declare |Parabola_Set_Option_Struct| functions@>=

~Parabola_Set_Option_Struct(void); 

@q **** (4) Definition.@>  

@
@<Define |Parabola_Set_Option_Struct| functions@>=

Parabola_Set_Option_Struct::~Parabola_Set_Option_Struct(void) 
{
    delete focus;
    delete vertex;
    delete directrix;

    return;
}

@q *** (3) Clear.@> 
@*2 Clear.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.

\initials{LDF 2005.11.07.}
Now deleting |Point* focus| and setting it to 0.

\initials{LDF 2005.11.08.}
Now deleting |Point* vertex|
and |Path* directrix|, and setting them and 
|real parameter|, |real linear_eccentricity|,
|real numerical_eccentricity|, and |real directrix| to 0.

\initials{LDF 2005.11.21.}
Removed |Parabola_Set_Option_Struct::numerical_eccentricity|.
The numerical eccentricity of a parabola is always 1.
\ENDLOG

@q **** (4) Declaration.@>  

@<Declare |Parabola_Set_Option_Struct| functions@>=

int 
clear(void); 

@q **** (4) Definition.@>  

@
@<Define |Parabola_Set_Option_Struct| functions@>=

int
Parabola_Set_Option_Struct::clear(void)
{

    delete focus;
    focus = 0;

    delete vertex;
    vertex = 0;
    
    delete directrix;
    directrix = 0;

    parameter = 0;
    
    linear_eccentricity = 0;

    return 0;

}  /* End of |Parabola_Set_Option_Struct::clear| definition.  */

@q * (1) Putting Parabola together. @>
@* Putting {\bf Parabola} together.

@q ** (2) This is what's compiled.@> 

This is what's compiled.

@c
@<Include files@>@;
@<Define |class Parabola|@>@;
@<Define |static| |class Parabola| data members@>@;
@<Define |struct Parabola_Set_Option_Struct|@>@;
@<Define |Parabola| functions@>@;
@<Define |Parabola_Set_Option_Struct| functions@>@;
@<Declare non-member template functions for |Parabola|@>@;
@<Define |Path| functions@>@;

@q ** (2) This is what's written to "parabola.h".@> 

@ This is what's written to \filename{parabola.h}.

@(parabola.h@>=
@<Define |class Parabola|@>@;
@<Define |struct Parabola_Set_Option_Struct|@>@;
@<Declare non-member template functions for |Parabola|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
