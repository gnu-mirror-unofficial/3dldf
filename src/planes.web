@q planes.web @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc.  @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Plane.@>
@** Plane\quad ({\tt planes\PERIOD web}).\hfil
\initials{LDF 2002.10.29.}  |Planes| are not |Shapes|.  They are used for
performing vector operations.  A |Plane| is defined by a |Point|
representing a point on the plane, a |Point| representing the normal
to the plane, and the distance of the plane from the origin.

\LOG
\initials{LDF 2002.04.12.}  
Created this file.  Removed the code for |Plane| from 
\filename{points.web} and put it here.

\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  
Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@q * Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.09.}  Now including \filename{creatnew.h}.

\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"

@q * Plane struct definition.@>
@* {\bf Plane struct} definition.
@f Plane Line
@<Define |struct Plane|@>=
struct Plane
{
 public:
  Point normal;
  Point point;
  real distance;
  @<Declare |Plane| functions@>@;
};

@q * (1) Constructors.@>
@* Constructors.

@q ** (2) Default constructor.@>
@*1 Default constructor.
@^\cfunc{Plane}{Plane}@>

Creates a degenerate |Plane| with
|point@t$\equiv$@>normal@t$\equiv$@>origin|, and
|distance@t$\equiv$@>0|.  I could have made the |Plane| be equal to
|INVALID_PLANE|, but there's probably no reason for doing so.  A
|Plane| constructed using this constructor will probably be set using
the assignment operator or |Path::get_plane| immediately, or very
soon after being declared. 
\initials{LDF 2003.06.06.}  

\LOG
\initials{LDF 2003.06.06.}  
Added this function.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@<Declare |Plane| functions@>=
Plane(void);

@
@<Define |Plane| functions@>=
Plane::Plane(void)
{
  Point origin_pt(0, 0, 0);  
  normal = point = origin_pt;
  distance = 0;
}

@q ** (2) Copy constructor.@>
@*1 Copy constructor.
@^\cfunc{Plane}{Plane}@>

\LOG
\initials{LDF 2003.06.06.}  
Added this function.
\ENDLOG 

@<Declare |Plane| functions@>=
Plane(const Plane& p);

@
@<Define |Plane| functions@>=
Plane::Plane(const Plane& p)
{
  *this = p;
  return;
}

@q ** (2) |Point| arguments.@>
@*1 {\bf Point} arguments.
@^\cfunc{Plane}{Plane}@>

\LOG
\initials{LDF 2003.06.03.}  
Changed this function.  
@:BUG FIX@> BUG FIX:  |distance| is now calculated,
instead of being passed as an argument.  |normal| is now made a unit
vector. 

\initials{LDF 2003.06.06.}  
Changed, so that if |point| or |normal| is
equal to |INVALID_POINT|, the other one is also set to
|INVALID_POINT|, and |distance| is set to |INVALID_REAL|.  

\initials{LDF 2003.06.06.}  
Arguments are no longer optional.  I've made this
change, because I've added a default constructor.

\initials{LDF 2003.06.06.}  
Added conditional to test for case that
|point@t$\equiv$@>normal|.  In this case, a warning message is printed
to standard error, they are both set to
|INVALID_POINT|, and |distance| is set to |INVALID_REAL|. 

\initials{LDF 2003.06.24.}  
@:BUG FIX@> BUG FIX:  Formerly, |INVALID_PLANE| was
returned, if |point == normal|.  This has been changed, so that
|INVALID_PLANE| is returned, if |normal == origin|.  There is, of
course, no reason why |point| shouldn't be equal to |normal|.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG

@<Declare |Plane| functions@>=
Plane(const Point& p, const Point& n);

@
@<Define |Plane| functions@>=
Plane::Plane(const Point& p, const Point& n)
     : point(p), normal(n)
{

    Point origin_pt(0, 0, 0);

    point.apply_transform();
    normal.apply_transform();
    
    if(point == INVALID_POINT)
      {
          normal = INVALID_POINT;
          distance = INVALID_REAL;
          return;
      }
    else if(normal == INVALID_POINT)
      {
          point = INVALID_POINT;
          distance = INVALID_REAL;
          return;
      }

    else if(normal == origin_pt)
      {
          cerr << "WARNING! In Plane():\nnormal == origin_pt. "
            << "Plane is INVALID_PLANE.\n\n";
          point = INVALID_POINT;
          distance = INVALID_REAL;
          return;
      }

    normal.unit_vector(true);
    distance = -point.dot_product(normal);
    if (fabs(distance) < Point::epsilon())

      distance = 0;
    return;

} /* End of |Plane::Plane(const Point& p, const Point& n)| definition.  */

@q * (1) Assignment.@>
@* Assignment.

\LOG
\initials{LDF 2003.06.06.}  
Added this function.
\ENDLOG

@<Declare |Plane| functions@>=
const Plane&
operator=(const Plane& p);

@
@<Define |Plane| functions@>=
const Plane&
Plane::operator=(const Plane& p)
{
  if (this == &p) /* Make sure it's not self-assignment.  
                     \initials{LDF 2003.06.06.}  */
    return *this;
    
  point = p.point;
  normal = p.normal;
  distance = p.distance;
  return p;
}

@q * (1) Comparing |Planes|.@>
@* Comparing {\bf Planes}.
\LOG
\initials{LDF 2003.06.06.}  Added this section.
\ENDLOG

@q ** (2) Equality.@>
@*1 Equality.
\initials{LDF 2003.06.06.}  

\LOG
\initials{LDF 2003.06.06.}  
Added this function.

\initials{LDF 2005.11.01.}
@:BUG FIX@> BUG FIXES:  Fixed the conditional.
Formerly, this function returned |false| if |point != p.point|, 
even if the |Points| just represented different points on the same plane.
I also no longer compare |distance| and |p.distance| using |==|, but
compare the absolute value of the difference of their absolute values
to |Point::epsilon|.

\initials{LDF 2005.11.02.}
Now allowing |normal == -p.normal|.
\ENDLOG

@<Declare |Plane| functions@>=
bool
operator==(const Plane& p) const;

@
@<Define |Plane| functions@>=
bool
Plane::operator==(const Plane& p) const
{

   return (   (point == p.point || (point.is_on_plane(p) && p.point.is_on_plane(*this))) 
          && (normal == p.normal || normal == -p.normal)
          && fabs(fabs(distance) - fabs(p.distance)) < Point::epsilon());

}

@q ** (2) Inequality.@>
@*1 Inequality.

\LOG
\initials{LDF 2003.06.06.}  
Added this function.
\ENDLOG

@<Declare |Plane| functions@>=
bool
operator!=(const Plane& p) const;

@
@<Define |Plane| functions@>=
bool
Plane::operator!=(const Plane& p) const
{
  return !(operator==(p));
}

@q * (1) Get distance.@>
@* Get distance.  

@q ** (2) |Point| argument.@>

@*1 {\bf Point} argument.  
@^\cfunc{Plane}{get\_distance}@>

\initials{LDF 2003.06.03.} 
This function returns a |Real_Short r|, where |r.first| is the
distance of the |Point| from the |Plane|.  |r.first| is always
positive.  |r.second| can take on the following values:
%
\item{0} If the |Point| lies in the |Plane|.
%
\item{1} If it lies on the side of the |Plane| pointed at by the
normal to the |Plane|, considered to be the ``outside''.
%
\item{-1} If it lies on the side of the |Plane| {\it not\/} pointed at
by the normal to the |Plane|, considered to be the ``inside''.

\LOG
\initials{LDF 2003.06.03.}  
Changed the definition of this function.  The old
definition was incorrect.  Also changed return type from |real| to
|Real_Short|.  

\initials{LDF 2003.06.04.}  
@:BUG FIX@> BUG FIX:  In the case that 
|r_fabs < Point::epsilon|, now |r_fabs| is set to 0.  Previously,
|r| was, which was wrong, because |r_fabs| is returned, not |r|.
Also, I now set |r_fabs| and |s| to 0 separately, because they are of
different types.  I don't believe any compiler would have trouble with
this, but I think it's cleaner if they are assigned to separately.

\initials{LDF 2004.10.23.}
Added optional |Scanner_Node scanner_node| argument with default 0.
It's not used for anything yet, though.

\initials{LDF 2005.11.02.}
Added optional |real tolerance| argument with default -1.
\ENDLOG 

@<Declare |Plane| functions@>=
Real_Short
get_distance(const Point& p, 
             Scanner_Node scanner_node = 0, 
             real tolerance = -1) const;

@
@<Define |Plane| functions@>=
Real_Short
Plane::get_distance(const Point& p, Scanner_Node scanner_node, real tolerance) const 
{

   if (tolerance == -1)
      tolerance = Shape::DEFAULT_TOLERANCE;

  real r = (p - point).dot_product(normal);
  real r_fabs = fabs(r);

  signed short s;

  if (r_fabs < tolerance)
    {
      r_fabs = 0;
      s = 0;
    }
  else
      s = static_cast<signed short>(r/r_fabs);

  return Real_Short(r_fabs, s);
}

@q ** (2) No argument.@>
@*1 No argument.  
@^\cfunc{Plane}{get\_distance}@>

\initials{LDF 2003.06.03.}  
This version of |get_distance| returns
the data member |distance| and its sign, i.e., the
distance of |origin| to the |Plane|, and which side of the
|Plane| it lies on.
I'm not using |origin| as the default for an optional |Point|
argument, because of problems that may arise, when I implement
|user_coordinates| and |view_coordinates|.

\LOG
\initials{LDF 2003.06.03.}  
Added this function.
\ENDLOG 

@<Declare |Plane| functions@>=
Real_Short
get_distance(void) const;

@
@<Define |Plane| functions@>=
Real_Short
Plane::get_distance(void) const 
{
  real f = fabs(distance);
  signed short s = static_cast<signed short>(distance/f);
  return Real_Short(f, s);
}

@q * (1) |Point| is on |Plane|.@>
@* {\bf Point} is on {\bf Plane}.
\initials{LDF 2003.06.04.}  

This function returns |true|, if the |Point| lies on the
|Plane p|, otherwise |false|.  Declared in \filename{points.web}.
Must be defined here, because |Plane| is an incomplete type in that
file. 
\initials{LDF 2003.06.04.}  

\LOG
\initials{LDF 2003.06.04.}  
Added this function.  

\initials{LDF 2005.11.02.}
Added |real tolerance| argument.

\initials{LDF 2007.11.08.}
Now setting |tolerance| to $.0001$ instead of the return value of |Point::epsilon|, 
if the |tolerance| argument passed is |< 0|.
\ENDLOG 

@<Define |Point| functions@>=
bool
Point::is_on_plane(const Plane& p, real tolerance) const
{
     if (tolerance < 0)
        tolerance = .0001;

     return fabs(p.get_distance(*this).first) <= tolerance;
}

@q * (1) Get base of perpendicular.@>
@* Get base of perpendicular.
\initials{LDF 2004.10.10.}

@q ** (2) Point version.@>
@*1 {\bf Point} version.
@^\cfunc{Point}{get\_perpendicular\_base}@>
|get_perpendicular_base| is declared in \filename{points.web}.  
It must be defined here, because it has a |Plane| argument, and 
|Plane| is an incompletely defined type there.  

\LOG
\initials{LDF 2004.10.10.}
Added this function.

\initials{LDF 2004.10.11.}
Made this function |const|.
Added |const Scanner_Node scanner_node| argument.
Now calling |scanner_node->get_thread_name_and_stop_values|.
\ENDLOG

@<Define |Point| functions@>=
int
Point::get_perpendicular_base(const Plane& p,
                              Point* base,
                              const Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

  bool DEBUG = false; /* |true| */ @; 

  using namespace Scan_Parse;

  stringstream cerr_strm;
  
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
						   &error_stop_value,
						   &warning_stop_value);

@q **** (4) @>   

  Point normal = p.normal;
  normal *= -1;
  real t = (p.distance - normal.dot_product(*this));
  *base = *this + (t * normal);

@q *** (3) Error handling:  |base| is not on |Plane a|.@> 
@q *** (3) Exit function with return value 1.          @>

@ Error handling:  |base| is not on |Plane p|. Exit function 
with return value 1. 
\initials{LDF 2004.10.10.}

@<Define |Point| functions@>=

  if (!base->is_on_plane(p))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Point::get_perpendicular_base()':" 
                << endl
                << "`Point base' is not on `Plane p'." << endl
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (!base.is_on_plane(p))|  */

@q *** (3) |base| is on |Plane p|.                        @> 
@q *** (3) Exit function successfully with return value 0.@>

@ |base| is on |Plane p|. Exit function successfully 
with return value 0.
\initials{LDF 2004.10.10.}

@<Define |Point| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG) /* |base.is_on_plane(p)|  */
      {

        cerr_strm << thread_name 
                  << "In `Point::get_perpendicular_base()':" 
                  << endl
                  << "`Point base' is on `Plane p'." << endl
                  << "Exiting function successfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        
       }  /* |else if (DEBUG)| (|base.is_on_plane(p)|)  */
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

}  /* End of |Point::get_perpendicular_base| definition.  */

@q * (1) Get |Path|.@>
@* Get {\bf Path}.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function declaration.  The definition is 
in \filename{path.web}.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Plane| functions@>=

@q ** (3) Definition.@> 
Path*
get_path(Scanner_Node scanner_node = 0) const;

@q * (1) Get |Rectangle|.@>
@* Get {\bf Rectangle}.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function declaration.  The definition is 
in \filename{rectangs.web}.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Plane| functions@>=

@q ** (3) Definition.@> 
Rectangle*
get_rectangle(Scanner_Node scanner_node = 0) const;

@q * (1) Reflection in a |Plane|.@>
@* Reflection in a {\bf Plane}.

@q ** (2) Point version.@>

@*1 {\bf Point} version.
@^\cfunc{Point}{reflect\_in}@>
|reflect_in| is declared in \filename{points.web}.  It must be defined
here, because it has a |Plane| argument, and |Plane| is an
incompletely defined type there.  
\initials{LDF 2003.09.05.}

Please note that this function tries to allocate memory on the free 
store for the |Point| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.03.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.03.}

\LOG
\initials{LDF 2003.09.05.}  
Added this function.

\initials{LDF 2004.10.03.}
Added |const Scanner_Node scanner_node| argument 
and changed return type from |Point| to |Shape*|.  
Now trying to allocate memory on the free store for the |Point| 
pointed at by the pointer to |Shape| returned by this function.
If allocation fails, this function rethrows |bad_alloc|.

\initials{LDF 2004.10.03.}
Now calling |Scanner_Type::get_thread_name_and_stop_values|.  
Made error output thread-safe. 

\initials{LDF 2004.10.09.}
Changed the name of this function from |reflect| to |reflect_in|.

\initials{LDF 2004.10.10.}
Changed the name of the local variable |Point foot| to |base|.
Now calling |get_perpendicular_base| to set its value.

\initials{LDF 2004.10.12.}
Rewrote this function.  Following a system update, having |Shape*| as
the return value no longer worked.
\ENDLOG 

@q *** (3) Definition.@> 

@<Define |Point| functions@>=
int
Point::reflect_in(const Plane& p, 
                  void* v,
                  const Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

  bool DEBUG = false; /* |true| */ @; 

  using namespace Scan_Parse;

  stringstream cerr_strm;
  
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
						   &error_stop_value,
						   &warning_stop_value);

@q **** (4) @>   

  Point* reflection = static_cast<Point*>(v);

@q **** (4) If |reflection == 0|, try to allocate memory @> 
@q **** (4) for it on the free store.@> 

@ If |reflection == 0|, try to allocate memory for it
@ on the free store.
\initials{LDF 2004.10.12.}

@<Define |Point| functions@>=

   if (reflection == static_cast<Point*>(0))
     {
        cerr_strm << thread_name 
                  << "WARNING! In `Point::reflect_in()':"
                  << endl << "`reflection' == 0. "
                  << "Will try to allocate memory on the free store for it.";
 
        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");

try
          {
             reflection = create_new<Point>(0, scanner_node);
          }

@q ***** (5) Error handling:  |create_new<Point>| failed.@>   

@ Error handling:  |create_new<Point>| failed.
\initials{LDF 2004.10.12.}

@<Define |Point| functions@>=

       catch (bad_alloc)
          {
             
              cerr_strm << thread_name 
                        << "ERROR! In `Point::reflect_in()':"
                        << endl << "`create_new<Point>()' failed. "
                        << "Rethrowing `bad_alloc'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              throw;

          } /* |catch (bad_alloc)|  */

@q ***** (5) |create_new<Point>| succeeded.@>           

@ |create_new<Point>| succeeded.
\initials{LDF 2004.10.12.}

@<Define |Point| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Point::reflect_in()':"
                   << endl << "`create_new<Point>()' succeeded.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5) @>   

     } /* |if (reflection == 0)|  */

@q **** (4) Try to find reflection.@> 

@ Try to find reflection.
\initials{LDF 2004.10.03.}

@<Define |Point| functions@>=

   Point base;

   int status = get_perpendicular_base(p, &base);

@q ***** (5) Error handling:  |get_perpendicular_base| failed.@>
@q ***** (5) Delete |reflection| and exit function with         @> 
@q ***** (5) return value 1.                                    @> 

@ Error handling:  |get_perpendicular_base| failed.
Delete |reflection| and exit function 
with return value 1.
\initials{LDF 2004.10.03.}

@<Define |Point| functions@>=

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Point::reflect_in()':" 
                << endl
                << "`get_perpendicular_base()' failed. " 
                << "Deleting `reflection' and "
                << "exiting function with "
                << "return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete reflection;

      return 1;

    } /* |status != 0|  */

@q ***** (5) |get_perpendicular_base| succeeded.@> 

@ |get_perpendicular_base| succeeded.
Calculate the reflection, set |*reflection|, and exit function 
successfully with return value 0.
\initials{LDF 2004.10.03.}

@<Define |Point| functions@>=

  *reflection = (2 * base) - *this;

  return 0;

} /* End of |Point::reflect_in| definition.  */

@q * (1) Reflection off of a |Plane|.@>
@* Reflection off of a {\bf Plane}.
\initials{LDF 2004.10.08.}

@q ** (2) Point version.@>

@*1 {\bf Point} version.
@^\cfunc{Point}{reflect\_off}@>
|reflect_off| is declared in \filename{points.web}.  It must be defined
here, because it has a |Plane| argument, and |Plane| is an
incompletely defined type there.  
\initials{LDF 2004.10.08.}

If this function succeeds, the pointer passed to it via the 
|void* v| argument will point to the |Point| representing the 
reflection of |*this| and it will return 0.
\initials{LDF 2004.10.11.}

If |v == 0|, this function will try to allocate memory on the free 
store for this |Point|.  
Programmers who use this function must therefore 
ensure that this memory is freed.
\initials{LDF 2004.10.08.}

If allocation fails, this function throws a |bad_alloc| exception.  
If it fails for some other reason, it frees the dynamically allocated 
memory and returns 1.  If this function succeeds, it returns 0.
\initials{LDF 2004.10.08.}

\LOG
\initials{LDF 2004.10.09.}
Added this function.

\initials{LDF 2004.10.11.}
Added |const Point& direction| argument.

\initials{LDF 2004.10.12.}
Started rewriting this function.
Added |void* v| argument and changed return value from
|Shape*| to |int|.  Following a system update, 
having |Shape*| as the return value no longer worked.

\initials{LDF 2004.12.06.}
Changed the type of the |direction| argument from 
|const Point&| to |Point|.

\initials{LDF 2004.12.08.}
Now returning 1 immediately if the |void* v| argument is null
and not trying to allocate memory for it |Point* reflection|, 
which is what |v| is cast to.

\initials{LDF 2004.12.09.}
Now casting the |void* v| argument to |Pointer_Vector<Point>* pv|
rather than |Point* reflection|.  Added error handling for the cases
|pv == 0| and |pv->ctr < 4|.
\ENDLOG 

@q *** (3) Definition.@> 

@<Define |Point| functions@>=
int
Point::reflect_off(const Plane& p,
                   Point direction,
                   void* v,
                   const Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@> 

  bool DEBUG = false; /* |true| */ @; 

  using namespace Scan_Parse;

  stringstream cerr_strm;
  
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
						   &error_stop_value,
						   &warning_stop_value);

@q **** (4).@> 

  Pointer_Vector<Point>* pv = static_cast<Pointer_Vector<Point>*>(v);

@q **** (4) Error handling:  |pv == 0|.  @> 

@ Error handling:  |pv == 0|.  Return 1.
\initials{LDF 2004.12.09.}

\LOG
\initials{LDF 2004.12.09.}
Added this section.
\ENDLOG

@<Define |Point| functions@>=
  
  if (pv == static_cast<Pointer_Vector<Point>*>(0))
     {

         cerr_strm << thread_name << "ERROR!  In `Point::reflect_off()':"
                   << endl 
                   << "`Pointer_Vector<Point>* pv' == 0."
                   << endl << "Returning 1.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
      
         return 1;

      }  /* |if (pv == 0)|  */

@q **** (4) Error handling:  |pv->ctr < 4|.  @> 

@ Error handling:  |pv->ctr < 4|.  Delete |pv| and return 1.
\initials{LDF 2004.12.09.}

\LOG
\initials{LDF 2004.12.09.}
Added this section.

\initials{LDF 2004.12.10.}
Now setting |pv| to 0.
\ENDLOG

@<Define |Point| functions@>=

  if (pv->ctr < 4)
     {

         cerr_strm << thread_name << "ERROR!  In `Point::reflect_off()':"
                   << endl 
                   << "`Pointer_Vector<Point>* pv->ctr' < 4."
                   << endl << "Deleting `pv', setting it to 0, "
                   << "and returning 1.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
       
         delete pv;
         pv = 0;
        
         return 1;

      }  /* |if (pv->ctr < 4)|  */

@q **** (4) @>   
@
@<Define |Point| functions@>=

  Point* reflection = pv->v[0];

@q **** (4) Error handling:  |reflection == 0|.  @> 

@ Error handling:  |reflection == 0|.  Return 1.
\initials{LDF 2004.12.08.}

\LOG
\initials{LDF 2004.12.08.}
No longer trying to allocate memory.  Returning 1 instead.

\initials{LDF 2004.12.10.}
Now deleting |pv| and setting it to 0.
\ENDLOG 

@<Define |Point| functions@>=
  
  if (reflection == static_cast<Point*>(0))
     {

         cerr_strm << thread_name << "ERROR!  In `Point::reflect_off()':"
                   << endl 
                   << "`reflection' == 0. "
                   << endl << "Deleting `pv', setting it to 0, "
                   << "and returning 1.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
      
         delete pv;
         pv = 0;

         return 1;

      }  /* |if (reflection == 0)|  */

@q **** (4) Error handling:  |*this == INVALID_POINT @>
@q **** (4) || direction == INVALID_POINT|.          @>

@ Error handling:  
|*this == INVALID_POINT || direction == INVALID_POINT|.
\initials{LDF 2004.10.11.}

\LOG
\initials{LDF 2004.12.08.}
No longer checking whether |*reflection == INVALID_POINT|.
There was no reason to do this.
\ENDLOG 

@<Define |Point| functions@>=

  if (*this == INVALID_POINT || direction == INVALID_POINT)
  {

      cerr_strm << thread_name << "ERROR! In `Point::reflect_off()':"
                << endl 
                << "`*this' and/or `direction' is "
                << "equal to `INVALID_POINT'."
                << endl << "Deleting `reflection', setting it to 0,"
                << endl 
                << "and exiting function with return value 1.";
          
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete reflection;
     
      reflection = 0;

      return 1;

  } /* |if (   *this == INVALID_POINT || direction == INVALID_POINT)|  */

@q **** (4) Error handling:  |direction == origin|.@> 

@ Error handling:  |direction == origin|.
\initials{LDF 2004.10.11.}

@<Define |Point| functions@>=

  Point origin;

  if (direction == origin)
  {

        cerr_strm << thread_name << "ERROR! In `Point::reflect_off()':"
                  << endl 
                  << "`direction'  == (0, 0, 0)."
                  << endl << "Deleting `reflection', setting it to 0,"
                  << endl 
                  << "and exiting function with return value 1.";
            
        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete reflection;
       
        reflection = 0;

        return 1;

  }  /* |if (direction == *this)|  */

@q **** (4) Determine which side of |p| |this| is on.@> 

@ Determine which side of |p| |this| is on and set |Point normal|
accordingly.
\initials{LDF 2004.12.05.}

\LOG
\initials{LDF 2004.12.05.}
Added this section.
\ENDLOG

@<Define |Point| functions@>=

   Point normal = p.normal;

   Real_Short rs = p.get_distance(*this);

@q ***** (5) Error handling:  |rs.first == 0|, i.e., |*this| lies in |p|.@>

@ Error handling:  |rs.first == 0|, i.e., |*this| lies in |p|.
\initials{LDF 2004.12.05.}

@<Define |Point| functions@>=

   if (rs.first == ZERO_REAL)
     {
        cerr_strm << thread_name << "ERROR! In `Point::reflect_off()':"
                  << endl 
                  << "`*this' lies in `p'.  Can't reflect."
                  << endl << "Deleting `reflection', setting it to 0,"
                  << endl 
                  << "and exiting function with return value 1.";
                
        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete reflection;
        
        reflection = 0;

        return 1;

     } /* |if (rs.first == 0)|  */

@q ***** (5) |rs.first != 0|.  If |rs.second < 0|, set |normal *= -1|.@>

@ |rs.first != 0|.  If |rs.second < 0|, set |normal *= -1|.
\initials{LDF 2004.12.05.}

@<Define |Point| functions@>=

   if (rs.second < 0)
      normal *= -1;

@q **** (4) Find the intersection of the line from |*this| @>
@q **** (4) through |*this + direction| and |p|.           @> 

@ Find the intersection of the line from |*this| through 
|*this + direction| and |p|.             
\initials{LDF 2004.12.05.}

@<Define |Point| functions@>=

   Bool_Point bp = p.intersection_point(*this, direction + *this);

@q ***** (5) Error handling:  |bp.b == false|.  No intersection point.@> 

@ Error handling:  |bp.b == false|.  No intersection point.
\initials{LDF 2004.12.05.}

@<Define |Point| functions@>=

   if (!bp.b)
      {
          cerr_strm << thread_name << "ERROR! In `Point::reflect_off()':"
                    << endl 
                    << "The ray doesn't intersect the plane.  Can't reflect "
                    << "the `point'."
                    << endl << "Deleting `reflection', setting it to 0,"
                    << endl 
                    << "and exiting function with return value 1.";
                
        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete reflection;
        
        reflection = 0;

        return 1;

      }  /* |if (!bp.b)|  */

@q **** (4) Calculate |reflection| and other |Points|.@> 

@ Calculate |reflection| and other |Points|.
\initials{LDF 2004.10.11.}

\LOG
\initials{LDF 2004.12.09.}
Now setting |pv[1]| through |pv[3]|.
\ENDLOG 

@<Define |Point| functions@>=

  direction.unit_vector(true);

  *reflection = direction - (2 * direction.dot_product(normal)) * normal;

  *reflection *= (bp.pt - *this).magnitude();

  *(pv->v[1]) = *(pv->v[3]) = *reflection;

  pv->v[1]->unit_vector(true);
  *(pv->v[1]) += bp.pt; /* Unit reflection.  */

  *(pv->v[2]) = bp.pt; /* Intersection point of ray and plane.  */

  pv->v[3]->unit_vector(true);  /* Unit vector of reflection, not
                                   shifted to |bp.pt|.  */

  *reflection += bp.pt;

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_mutex.lock(); 
        cerr_strm << thread_name << "In `Point::reflect_off()':";

        cerr << cerr_strm.str() << endl;
        log_message(cerr_strm); 
        cerr_strm.str(""); 

        reflection->show("reflection:");
        cerr << "Type <RETURN> to continue. ";
        getchar(); 
        cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Exit function successfully with return value 0.@>

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.11.}

@<Define |Point| functions@>=

  return 0;

}  /* End of |Point::reflect_off| definition.  */

@q * (1) Intersection.@>
@* Intersection.

@q ** (2) Intersection with a line.@>
@*1 Intersection with a line.

@q *** (3) |Point| arguments.@>
@*2 {\bf Point} arguments.
\initials{LDF 2003.06.03.}  

\LOG
\initials{LDF 2003.06.03.}  
Added this function.

\initials{LDF 2005.12.11.}
Added the optional argument |bool suppress_warnings| with the default |false|,
and the optional argument |Scanner_Node scanner_node| with the default 0.
Made warning output thread-safe.
\ENDLOG 

@<Declare |Plane| functions@>=
Bool_Point
intersection_point(const Point& p0, 
                   const Point& p1, 
                   bool suppress_warnings = false,
                   Scanner_Node scanner_node = 0) const;

@
@<Define |Plane| functions@>=
Bool_Point
Plane::intersection_point(const Point& p0, 
                          const Point& p1,
                          bool suppress_warnings,
                          Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    Bool_Point bp;

    real denominator = (p0 - p1).dot_product(normal);

@q **** (4)@> 

@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.06.03.}  
Handle cases: |Path| is in |Plane|, and |Path| is in a parallel
|Plane|.  
\ENDTODO 

@<Define |Plane| functions@>=

  if (denominator == ZERO_REAL)  
    {
         if (!suppress_warnings)  
            {
                cerr_strm << thread_name 
                          << "WARNING!  "
                          << "In `Plane::intersection_point(const Point&, const Point&, [etc.])':"
                          << endl 
                          << "denominator is 0.  Can't divide. "
                          << "Path is either in Plane, or parallel to Plane." << endl
                          << "Haven't programmed these cases yet." << endl
                          << "Exiting function unsuccessfully with return value "
                          << "`INVALID_BOOL_POINT'.";

                log_message(cerr_strm);
                cerr_message(cerr_strm, error_stop_value);
                cerr_strm.str("");

            }  /* |if (!suppress_warnings)|  */

         return INVALID_BOOL_POINT;

    }  /* |if (denominator == 0)|  */

@q **** (4)@> 

  real numerator = p0.dot_product(normal) + distance;

  bp.pt = p0 + ((numerator / denominator) * (p1 - p0));

  bp.b = (bp.pt != INVALID_POINT) ? true : false;

  return bp;

} /* End of |Plane::intersection_point| definition.  */

@q *** (3) |Path| argument.@>
@*2 {\bf Path} argument.
\initials{LDF 2003.06.03.}  Defined in \filename{paths.web}, because
|Path| is an incomplete type in this file.
\LOG
\initials{LDF 2003.06.03.}  Added this function.
\ENDLOG 
@<Declare |Plane| functions@>=
Bool_Point
intersection_point(const Path& p) const;

@q ** (2) Intersection of two |Planes|.@>
@*1 Intersection of two {\bf Planes}.
@^\cfunc{Plane}{intersection\_line}@>

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.10.29.}  
Look up and explain!
\ENDTODO 

\LOG
\initials{LDF 2003.06.04.}  
Changed to |const|.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.11.30.}
Added |Scanner_Node scanner_node| argument and made warning output thread-safe.  
Removed debugging output.  Formatting changes.

\initials{LDF 2005.12.13.}
Added optional |bool suppress_warnings| argument with default |false|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Plane| functions@>=
Line
intersection_line(const Plane& pl, 
                  Scanner_Node scanner_node = 0,
                  bool suppress_warnings = false) const;

@q *** (3) Definition.@> 

@
@<Define |Plane| functions@>=
Line
Plane::intersection_line(const Plane& pl, 
                         Scanner_Node scanner_node,
                         bool suppress_warnings) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

  Point origin_pt(0, 0, 0);

  Point pl_normal(pl.normal);

@
@:??@> ?? Do I need |direction_vector|?
\initials{LDF 2002.10.29.}

@<Define |Plane| functions@>=

  Point direction_vector = normal.cross_product(pl_normal);  

@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF Undated.}
|Ellipse::intersection_points(Ellipse&)| calls this function 
to find out whether two |Planes| are coincident,
so sometimes I don't want to see these messages.  
I may decide to add an argument |bool silent| to
this function. 
@:??@> Add |bool silent|?? 
\ENDTODO 

@<Define |Plane| functions@>=

  if (direction_vector == origin_pt)
    {
        if (!suppress_warnings)
           {        
         
               cerr_strm << thread_name << "WARNING!  In `Plane::intersection_line()':"
                         << endl;

               if (distance == pl.distance && !suppress_warnings)
                  cerr_strm << "`Planes' are coincident.  ";

               else 
                  cerr_strm << "`Planes` are parallel.";

               log_message(cerr_strm);
               cerr_message(cerr_strm, warning_stop_value);
               cerr_strm.str("");

           }  /* |if (!suppress_warnings)|  */

         return INVALID_LINE;

    } /* Outer |if|. */
  
@  At least one of the x, y, or z components of |direction_vector|
must be non-zero, otherwise, this function would have exited by
now. 
\initials{LDF Undated.}

@<Define |Plane| functions@>=
  real x, y, z;

  real d = distance;
  real e = pl.distance;

  real nx = normal.get_x();
  real ny = normal.get_y();
  real nz = normal.get_z();

  real mx = pl.normal.get_x();
  real my = pl.normal.get_y();
  real mz = pl.normal.get_z();

  real vx = direction_vector.get_x();
  real vy = direction_vector.get_y();
  real vz = direction_vector.get_z();

  if (direction_vector.get_x() != ZERO_REAL)
    {
      x = 0;
      y = -1 * ((d*mz - e*nz) / vx);
      z = (d*my - e*ny) / vx;
    }
  else if (direction_vector.get_y() != ZERO_REAL)
    {
      x = (d * mz - e * nz) / vy;
      y = 0;
      z = -1 * ((d * mx - e * nx) / vy);
    }
  else 
    {
      x = -1 * ((d * my - e * ny) / vz);
      y = (d * mx - e * nx) / vz;
      z = 0;
    }

   Point point_on_line(x, y, z);  
 
   return Line(point_on_line, direction_vector);

}  /* End of |Plane::intersection_line(const Plane& pl, [etc.])| definition.  */

@q * (1) Show.@>
@* Show.
@^\cfunc{Plane}{show}@>
\LOG
\initials{LDF 2003.06.06.}  Minor change to the conditional that handles |text|. 

\initials{LDF 2003.06.06.}  Made |show() const|.
\ENDLOG 
@<Declare |Plane| functions@>=
void
show(string text = "") const;

@
@<Define |Plane| functions@>=
void
Plane::show(string text) const
{
  if (text == "")
    text = "Plane:";
  cerr << text << endl;

  if (*this == INVALID_PLANE)
    {
      cerr << "INVALID_PLANE. Can't show." << endl << endl;
      return;
    }
  
  normal.show("normal:");
  point.show("point:");
  cerr << "distance == " << distance << endl << endl;

}

@q * (1) Global constants for Plane.@>
@* Global constants for {\bf Plane}.
@<|Plane| global constants@>=
extern const Plane INVALID_PLANE(INVALID_POINT,
                                 INVALID_POINT);

@
@<Declarations for the header file@>=
extern const Plane INVALID_PLANE;

@q * (1) Putting Plane together.@>
@* Putting {\bf Plane} together.

@ This is what's compiled.
@c
@<Include files@>@;
@<Define |struct Plane|@>@;
@<|Plane| global constants@>@;
@<Define |Plane| functions@>@;
@<Define |Point| functions@>@;

@ This is what's written to \filename{planes.h}. 
@(planes.h@>=
@<Define |struct Plane|@>@;
@<Declarations for the header file@>@;

@q run-gxx-on-file:"points.c" @>
@q run-cweb-on-file:"points.web" @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDF.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
