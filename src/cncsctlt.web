@q cncsctlt.web@>
@q Created by Laurence Finston Sun Jul 29 16:12:27 CEST 2007 @>
      
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Conic_Section_Lattice.@>
@** Conic Section Lattice\quad ({\tt cncsctlt\PERIOD web}).\hfil

\LOG
\initials{LDF 2007.07.29.}
Created this file.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"

@q * (1) Conic_Section_Lattice class definition.@>
@* {\bf Conic\_Section\_Lattice} class definition.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this |class| definition.

\initials{LDF 2007.08.06.}
Added |friend| declaration for 
|Pointer_Vector<Point, Point>::get_conic_section_lattice|.

\initials{LDF 2007.08.16.}
Added |Point approx_center| and |Point true_center|.

\initials{LDF 2007.08.19.}
Removed |real last_increment|.
\ENDLOG

@q ** (2) Code.@> 

@<Define |class Conic_Section_Lattice|@>=

class Conic_Section_Lattice
{

   friend 
   Conic_Section_Lattice*
   Pointer_Vector<Point, Point>::get_conic_section_lattice(
                                 Scanner_Node scanner_node,
                                 bool do_cull,
                                 bool do_rectify,
                                 real tolerance,
                                 bool do_test,
                                 bool do_transform,
                                 Transform* t);
   protected:
  
      Point lattice_points[5];
      deque<Point*> lattice;

      Point pt6;

      Point approx_center;
      Point true_center;
  
      signed short cycle_position;

      vector<real> increment_vector;
    
      Transform* transform;
   
   public:

      @<Declare |static| |class Conic_Section_Lattice| data members@>@;


      @<Declare |Conic_Section_Lattice| functions@>@;
};

@q ** (2) Static member variable declarations and initializations.@>
@*1 Static member variable declarations and initializations.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.

\initials{LDF 2007.08.26.}
Now declaring and initializing |real CSL_DEFAULT_TOLERANCE|.
\ENDLOG

@<Declare |static| |class Conic_Section_Lattice| data members@>=

static const real CSL_DEFAULT_TOLERANCE;

@q *** (3) Code.@> 
@
@<Initialize |static| |class Conic_Section_Lattice| data members@>=

const real Conic_Section_Lattice::CSL_DEFAULT_TOLERANCE = .0001; 

@q ** (2) |Conic_Section_Lattice| functions.@> 
@*1 {\bf Conic\_Section\_Lattice} functions.
\initials{LDF 2007.08.05.}

\LOG
\initials{LDF 2007.08.05.}
Added this section.
\ENDLOG

@q *** (3) Default Constructor.@> 
@*2 Default Constructor.
\initials{LDF 2007.08.05.}

\LOG
\initials{LDF 2007.08.05.}
Added this function.

\initials{LDF 2007.08.06.}
Added code.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Conic_Section_Lattice(void);

@q **** (4) Definition.  @>

@
@<Define |Conic_Section_Lattice| functions@>= 
Conic_Section_Lattice::Conic_Section_Lattice(void)
{
   pt6 = INVALID_POINT;
   approx_center = INVALID_POINT;
   true_center = INVALID_POINT;
   cycle_position = 0;
   transform = 0;
   return;
}

@q *** (3) Destructor.@> 
@*2 Destructor.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
virtual
~Conic_Section_Lattice(void);

@q **** (4) Definition.  @>

@
@<Define |Conic_Section_Lattice| functions@>= 
Conic_Section_Lattice::~Conic_Section_Lattice(void)
{
   delete transform;
   return;
}



@q *** (3) Pseudo-constructor for dynamic allocation.@>
@*2 Pseudo-constructor for dynamic allocation.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG

@q **** (4) Pointer argument.@>
@*3 Pointer argument.@>
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Conic_Section_Lattice|@>=

Conic_Section_Lattice* 
create_new(const Conic_Section_Lattice* p, Scanner_Node scanner_node = 0);

@q **** (4) Reference argument.@>
@*3 Referece argument.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function declaration.
\ENDLOG

@<Declare non-member template functions for |Conic_Section_Lattice|@>=
Conic_Section_Lattice* 
create_new(const Conic_Section_Lattice& p, Scanner_Node scanner_node = 0);

@q *** (3) Assignment.@> 
@*2 Assignment.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG

@q **** (4) Assignment from a |Conic_Section_Lattice|.@> 
@*3 Assignment from a |Conic_Section_Lattice|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function.

\initials{LDF 2007.08.06.}
Added code.

\initials{LDF 2007.08.07.}
@:BUG FIX@> BUG FIX:  Now calling |shift_lattice(c.cycle_position)| 
if |cycle_position != 0|.  
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
virtual
Conic_Section_Lattice&
operator=(const Conic_Section_Lattice& c);

@q ***** (5) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=

Conic_Section_Lattice&
Conic_Section_Lattice::operator=(const Conic_Section_Lattice& c)
{
    if (this == &c) /* Make sure it's not self-assignment. */
       return *this;
 
    lattice.clear();
 
    for (int i = 0; i < 5; ++i)
    {
       lattice_points[i] = c.lattice_points[i];
       lattice.push_back(&(lattice_points[i]));
    }

    pt6           = c.pt6;
    approx_center = c.approx_center;
    true_center   = c.true_center;

    cycle_position = 0;
 
    if (c.cycle_position != 0)
       shift_lattice(c.cycle_position);

    increment_vector.clear();
 
    for (vector<real>::const_iterator iter = c.increment_vector.begin();
         iter != c.increment_vector.end();
         ++iter)
    {
       increment_vector.push_back(*iter);
    }

    delete transform;
    transform = 0;

    if (c.transform)
    {
       transform = create_new<Transform>(c.transform);
       
    }   

    return *this;

}  /* End of 
      |Conic_Section_Lattice::operator=(const Conic_Section_Lattice& c)| 
      definition.  */

@q *** (3) Multiplication by a |Transform| with assignment.@>
@*2 Multiplication by a {\bf Transform} with assignment.
\initials{LDF 2007.08.21.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.21.}
Change the way |transform| is handled.  This needs to be tested.
\ENDTODO 

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Transform
operator*=(const Transform& t);

@q **** (4) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Transform
Conic_Section_Lattice::operator*=(const Transform& t)
{
   
    for (int i = 0; i < 5; ++i)
    {
        lattice_points[i] *= t;
    }
 
    if (pt6 != INVALID_POINT)
       pt6 *= t;

    if (approx_center != INVALID_POINT)
       approx_center *= t;

    if (true_center != INVALID_POINT)
       true_center *= t;

    if (transform)
    {
       delete transform;
       transform = 0;
    }
   
    return t;

}  /* End of |Conic_Section_Lattice::operator*=(const Transform&)| 
      definition.  */

@q *** (3) Setting elements.@> 
@ Setting elements.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this section.
\ENDLOG

@q **** (4) Set Transform.@> 
@*3 Set Transform.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
void
set_transform(const Transform& t, Scanner_Node scanner_node = 0)
{

   if (!transform)
      transform = create_new<Transform>(0);

   *transform = t;

   return;

}  /* End of |Conic_Section_Lattice::set_transform| definition.  */

@q **** (4) Reset Transform.@> 
@*3 Reset Transform.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
void
reset_transform(Scanner_Node scanner_node = 0)
{

   if (!transform)
      transform = create_new<Transform>(0);

   transform->reset();

   return;

}  /* End of |Conic_Section_Lattice::set_transform| definition.  */

@q **** (4) Delete Transform.@> 
@*3 Delete Transform.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
void
delete_transform(Scanner_Node scanner_node = 0)
{

   delete transform;
   transform = 0;

   return;

}  /* End of |Conic_Section_Lattice::set_transform| definition.  */

@q *** (3) Getting |Points|, |Paths|, etc.@> 
@*2 Getting {\bf Points}, {\bf Paths}, etc.
\initials{LDF 2007.08.03.}

@q **** (4) Get Approximate Center.@> 
@*3 Get Approximate Center.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
Point
get_approx_center(Scanner_Node scanner_node = 0)
{

   return approx_center;

}  /* End of |Conic_Section_Lattice::get_approx_center| definition.  */

@q **** (4) Get True Center.@> 
@*3 Get True Center.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
Point
get_true_center(Scanner_Node scanner_node = 0)
{

   return true_center;

}  /* End of |Conic_Section_Lattice::get_true_center| definition.  */

@q **** (4) Get Point 6.@> 
@*3 Get Point 6.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
Point
get_point_6(Scanner_Node scanner_node = 0)
{

   return pt6;

}  /* End of |Conic_Section_Lattice::get_true_center| definition.  */

@q **** (4) Get Point.@> 
@*3 Get Point.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this function.

\initials{LDF 2007.08.04.}
Changed |real increment| argument to |real* increment| and 
the default from .1 to 0.  This makes it possible to check whether
|real* Conic_Section_Lattice_Options::increment| has been set using
the |WITH_INCREMENT| option or not.

\initials{LDF 2007.08.07.}
Added optional |bool do_shift| argument with the default |true|.
\ENDLOG

@q ***** (5) Full version.@> 
@*4 Full version.
\initials{LDF 2007.08.13.} 

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Point*
get_point(Scanner_Node scanner_node = 0,
          signed short cycle_value = 0,
          real* increment = 0,
          bool do_shift = true,
          bool lattice_point_flag = false);


@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Point*
Conic_Section_Lattice::get_point(Scanner_Node scanner_node,
                                 signed short cycle_value,
                                 real* increment,
                                 bool do_shift,
                                 bool lattice_point_flag)
{
@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7)@> 

   int status;
   Point* p = create_new<Point>(0);

@q ******* (7) Shift |lattice| according to |cycle_value|.@>       
@ Shift |lattice| according to |cycle_value|.
\initials{LDF 2007.08.07.}

@<Define |Conic_Section_Lattice| functions@>=

@q ******* (7)@> 
@ 
@<Define |Conic_Section_Lattice| functions@>=

   if (increment && *increment == floor(*increment))
   {
      do_shift = false;
      lattice_point_flag = true;
   }

@q ******* (7)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

   if (lattice_point_flag == true )
   {

@q ******** (8) Error handling:  |lattice_point_flag == true| @> 
@q ******** (8) and |*increment| is a non-integer.            @>

@ Error handling:  |lattice_point_flag == true| 
and |*increment| is a non-integer.           
\initials{LDF 2007.08.07.}
 
@<Define |Conic_Section_Lattice| functions@>=

      if (increment && *increment != floor(*increment))
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Conic_Section_Lattice::get_point':"
                    << endl
                    << "`lattice_point_flag' == true' and "
                    << "`*increment' is not an integer."
                    << endl 
                    << "Exiting function unsuccessfully with "
                    << "return value (Point*) 0.";
 
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete increment;
          increment = 0;

          return 0;

      }  /* |if (increment && *increment != floor(increment))|  */

@q ******** (8)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

       else if (!increment || (   *increment > 0 
                               && static_cast<int>(*increment) % 5 
                               == 0))
       {
           *p = *(lattice[0]);

       }

@q ******** (8)@> 

       else
       {
           while (*increment < 0)
              *increment += 5;

           *p = *(lattice[static_cast<int>(*increment) % 5]); 
       }

@q ******** (8)@> 

       delete increment;
       increment = 0;

       return p;

   }  /* |if (lattice_point_flag == true)|  */

@q ******* (7) Set |increment|, if necessary.@>       
@ Set |increment|, if necessary.
@<Define |Conic_Section_Lattice| functions@>=

   if (!increment)
      increment = new real(.1);

   if (do_shift && *increment > 1)
   {

      while (cycle_value < 0)
         cycle_value += 5;

      cycle_value %= 5;

      if (cycle_value != 0)
         status = shift_lattice(cycle_value, scanner_node);

      real r;
      real q;
      r = modf(*increment, &q);

      status = shift_lattice(static_cast<int>(q) % 5, scanner_node);

      cycle_value += static_cast<int>(q) % 5;

      *increment = r; 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << "In `Conic_Section_Lattice::get_point':"
                << endl 
                << "`do_shift' == `true' and `*increment' > 1."
                << endl 
                << "Shifted lattice by this amount:  " << q
                << endl
                << "New value of `*increment':  " << *increment;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    

   }  /* |if (do_shift && *increment > 1)|  */

@q ******* (7) Set Pascal points.@> 
@ Set Pascal points.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added error handling code.
Removed the local |Point*| variables |A|, |B|, |C|, |D|, and |E|.
Now using the elements of |lattice| directly.
\ENDLOG 

@<Define |Conic_Section_Lattice| functions@>=

   Point X;
   Point Y;
   Point Z;
 
   Path q[4];

   q[0].set(*(lattice[0]), *(lattice[2]));  /* $AC$  */
   q[1].set(*(lattice[1]), *(lattice[3]));  /* $BD$  */

   try 
   {
       X = q[0].intersection_point(q[1]).pt;

       q[2].set(*(lattice[1]), *(lattice[4]));  /* $BE$  */
       q[3].set(*(lattice[0]), *(lattice[4]));  /* $AE$  */ 

       Z.set(lattice[0]->mediate(*(lattice[4]), *increment));

       Y = Point::intersection_point(
                     X, Z, *(lattice[1]), *(lattice[4])).pt;  /* $XY$ and $BE$  */   

       *p = Point::intersection_point(
                      *(lattice[2]), Y, *(lattice[3]), Z).pt;  /* $CY$ and $DZ$  */   

   }  /* |try|  */
 
   catch (...)
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_point':"
                 << endl
                 << "Failed to find Pascal points."
                 << endl 
                 << "Exiting function unsuccessfully with "
                 << "return value (Point*) 0.";
 
       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete p;
       delete increment;
       increment = 0;

       return 0;

   }  /* |catch|  */

@q ******* (7)@>       
@
@<Define |Conic_Section_Lattice| functions@>=

    if (cycle_value != 0) 
       shift_lattice(-cycle_value, scanner_node);

    delete increment;
    increment = 0;

    return p;
       
} /* End of |Conic_Section_Lattice::get_point| definition.  */

@q ***** (5) "Pared-down" versions of |get_point|.@>
@*4 ``Pared-down'' versions of {\bf get\_point}.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this section.
\ENDLOG

@q ****** (6) Pared-down version with |Point*| as return value.@> 
@*5 Pared-down version with |Point*| as return value.
\initials{LDF 2007.08.13.}

\LOG
\initials{LDF 2007.08.13.}
Added this function.

\initials{LDF 2007.08.19.}
Removed the local |Point*| variables |A|, |B|, |C|, |D|, and |E|.
Now using the elements of |lattice| directly.

\initials{LDF 2007.08.21.}
Removed code from this function.  It now calls the version of |get_point|
that returns a plain |Point| (rather than a |Point*|).
\ENDLOG

@q ******* (7) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Point*
get_point(Scanner_Node scanner_node,
          real increment);


@q ******* (7) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Point*
Conic_Section_Lattice::get_point(Scanner_Node scanner_node,
                                 real increment)


{
   Point p = get_point(increment);

   if (p == INVALID_POINT)
      return 0;
   else 
      return create_new<Point>(p);
       
} /* End of |Conic_Section_Lattice::get_point| definition.  */

@q ****** (6) Pared-down version with |Point| as return value.@> 
@*5 Pared-down version with |Point| as return value.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ******* (7) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Point
get_point(real increment);


@q ******* (7) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Point
Conic_Section_Lattice::get_point(real increment)


{

   Point p;

   Point X;
   Point Y;
   Point Z;
 
   Path q[4];

   q[0].set(*(lattice[0]), *(lattice[2]));  /* $AC$  */
   q[1].set(*(lattice[1]), *(lattice[3]));  /* $BD$  */

   try
   {
      X = q[0].intersection_point(q[1]).pt;

      q[2].set(*(lattice[1]), *(lattice[4]));  /* $BE$  */
      q[3].set(*(lattice[0]), *(lattice[4]));  /* $AE$  */

      Z.set(lattice[0]->mediate(*(lattice[4]), increment));  /* $AE$  */

      Y = Point::intersection_point(
                    X, Z, *(lattice[1]), *(lattice[4])).pt;  /* $XZ$ and $BE$ */

      p = Point::intersection_point(
                    *(lattice[2]), Y, *(lattice[3]), Z).pt;  /* $CY$ and $DZ$ */
   }
   catch (...)
   {
      return INVALID_POINT;
   }

   return p;
       
} /* End of |Conic_Section_Lattice::get_point| definition.  */

@q ******* (7)@>

@q ****** (6)@>

@q ***** (5)@>

@q **** (4) Get Transform.@> 
@*3 Get Transform.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration and Definition.@> 

@<Declare |Conic_Section_Lattice| functions@>=
inline
Transform* 
get_transform(Scanner_Node scanner_node = 0)
{

   if (transform)
      return create_new<Transform>(transform);
   else
      return 0;

}  /* End of |Conic_Section_Lattice::get_transform| definition.  */



@q **** (4) Pascal Points and Line.@> 
@*3 Pascal Points and Line.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this section.
\ENDLOG

@q ***** (5) Get Pascal Point.@> 
@*4 Get Pascal Point.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this function.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Point*
get_pascal_point(real r, real increment, Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Point*
Conic_Section_Lattice::get_pascal_point(real r, 
                                        real increment, 
                                        Scanner_Node scanner_node)
{
@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7) Error handling:  |r < 0 || r > 2|.@>
@ Error handling:  |r < 0 || r > 2|
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   if (r < 0 || r > 2)
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_pascal_point':"
                 << endl 
                 << "Invalid value for `real r' argument:  " << r 
                 << " (< 0 || > 2)"
                 << endl
                 << "Exiting function unsuccessfully with return value "
                 << "(Point*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");
   
       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;
  
       return 0;

   }  /* |if (r < 0 || r > 2)|  */


@q ******* (7)@>

   signed short cycle_value = 0;
   bool do_shift            = true;

   if (scanner_node && scanner_node->conic_section_lattice_options)
   {
       cycle_value = scanner_node->conic_section_lattice_options->cycle_value;
       do_shift    = scanner_node->conic_section_lattice_options->do_shift;

       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;

   }
   
   if (do_shift)
   {
      if (cycle_value != 0)
         shift_lattice(cycle_value);

      while (increment < 0)
      {
         shift_lattice(-1);
         increment += 1.0;
      }

      while (increment >= 1.0)
      {
          shift_lattice(1);
          increment -= 1.0;
      }   

   } /* |if (do_shift)|  */


@q ******* (7)@>

   unsigned short s = static_cast<unsigned short>(floor(r + .5));

   Point X;
   Point Y;
   Point Z;
 
   Path q[4];

@q ******** (8)@>

   try
   {

      q[0].set(*(lattice[0]), *(lattice[2]));  /* $AC$  */
      q[1].set(*(lattice[1]), *(lattice[3]));  /* $BD$  */

      X = q[0].intersection_point(q[1]).pt;

      q[2].set(*(lattice[1]), *(lattice[4]));  /* $BE$  */
      q[3].set(*(lattice[0]), *(lattice[4]));  /* $AE$  */

      Z.set(lattice[0]->mediate(*(lattice[4]), increment));  /* $AE$  */

      Y = Point::intersection_point(
                    X, Z, *(lattice[1]), *(lattice[4])).pt;  /* $XZ$ and $BE$ */

   }  /* |try|  */

@q ******** (8)@>

   catch (...)
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_pascal_point':"
                 << endl 
                 << "Failed to find Pascal points."
                 << endl 
                 << "Exiting function unsuccessfully with return value "
                 << "(Point*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");
  
       return 0;

   }  /* |catch|  */

@q ******** (8)@>

@q ******* (7)@>

   if (s == 0)
   {
       return create_new<Point>(X);
   }  
   else if (s == 1)
   {
       return create_new<Point>(Y);
   }  
   else if (s == 2)
   {
       return create_new<Point>(Z);
   }  
   else
   {
        cerr_strm << thread_name << "ERROR!  "
                  << "In `Conic_Section_Lattice::get_pascal_point':"
                  << endl 
                  << "This can't happen!  Invalid value for Pascal point number:  "
                  << s 
                  << endl 
                  << "Exiting function unsuccessfully with return value "
                  << "(Point*) 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
  
        return 0;

   }  /* |else|  */

}  /* End of |Conic_Section_Lattice::get_pascal_point| definition.  */


@q ***** (5) Get Pascal Points.@> 
@*4 Get Pascal Points.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this function.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Pointer_Vector<Point>*
get_pascal_points(real increment, Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Pointer_Vector<Point>*
Conic_Section_Lattice::get_pascal_points(real increment, Scanner_Node scanner_node)
{
@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7)@>

   signed short cycle_value = 0;
   bool do_shift            = true;

   if (scanner_node && scanner_node->conic_section_lattice_options)
   {
       cycle_value = scanner_node->conic_section_lattice_options->cycle_value;
       do_shift    = scanner_node->conic_section_lattice_options->do_shift;

       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;

   }
   
   if (do_shift)
   {
      if (cycle_value != 0)
         shift_lattice(cycle_value);

      while (increment < 0)
      {
         shift_lattice(-1);
         increment += 1.0;
      }

      while (increment >= 1.0)
      {
          shift_lattice(1);
          increment -= 1.0;
      }   

   } /* |if (do_shift)|  */


@q ******* (7)@>

   Point X;
   Point Y;
   Point Z;
 
   Path q[4];

@q ******** (8)@>

   try
   {

      q[0].set(*(lattice[0]), *(lattice[2]));  /* $AC$  */
      q[1].set(*(lattice[1]), *(lattice[3]));  /* $BD$  */

      X = q[0].intersection_point(q[1]).pt;

      q[2].set(*(lattice[1]), *(lattice[4]));  /* $BE$  */
      q[3].set(*(lattice[0]), *(lattice[4]));  /* $AE$  */

      Z.set(lattice[0]->mediate(*(lattice[4]), increment));  /* $AE$  */

      Y = Point::intersection_point(
                    X, Z, *(lattice[1]), *(lattice[4])).pt;  /* $XZ$ and $BE$ */

   }  /* |try|  */

@q ******** (8)@>

   catch (...)
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_pascal_points':"
                 << endl 
                 << "Failed to find Pascal points."
                 << endl 
                 << "Exiting function unsuccessfully with return value "
                 << "(Point*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");
  
       return 0;

   }  /* |catch|  */

@q ******** (8)@>

@q ******* (7)@>

   Pointer_Vector<Point>* pv = new Pointer_Vector<Point>;

   *pv += create_new<Point>(X);
   *pv += create_new<Point>(Y);
   *pv += create_new<Point>(Z);

   return pv;

}  /* End of |Conic_Section_Lattice::get_pascal_points| definition.  */

@q ***** (5) Get Pascal Line.@> 
@*4 Get Pascal Line.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this function.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Path*
get_pascal_line(real increment, Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Path*
Conic_Section_Lattice::get_pascal_line(real increment, Scanner_Node scanner_node)
{
@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7)@>

   Pointer_Vector<Point>* pv = get_pascal_points(increment, scanner_node);

@q ******* (7) Error handling:  |Conic_Section_Lattice::get_pascal_points| @>
@q ******* (7) failed.                                                     @>
@ Error handling:  |Conic_Section_Lattice::get_pascal_points| failed.
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   if (pv == static_cast<Pointer_Vector<Point>*>(0))
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_pascal_line':"
                 << endl 
                 << "`Conic_Section_Lattice::get_pascal_points' failed."
                 << endl
                 << "Exiting function unsuccessfully with return value "
                 << "(Path*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 0;

   }  /* |if (pv == static_cast<Pointer_Vector<Point>*>(0))|  */

@q ******* (7) Error handling:  |*pv| contains too few |Points|.@>
@ Error handling:  |*pv| contains too few |Points|.
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   if (pv->ctr < 3)
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::get_pascal_line':"
                 << endl 
                 << "`Pointer_Vector<Point> *pv' contains too few points:"
                 << endl
                 << "`pv->ctr' == " << pv->ctr
                 << endl 
                 << "Exiting function unsuccessfully with return value "
                 << "(Path*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete pv;

       return 0;

   }  /* |if (pv->ctr < 3)|  */


@q ******* (7)@>

   Point XY = *(pv->v[0]) - *(pv->v[1]);
   Point XZ = *(pv->v[0]) - *(pv->v[2]);
   Point YZ = *(pv->v[1]) - *(pv->v[2]);

   real XY_mag = XY.magnitude();
   real XZ_mag = XZ.magnitude();
   real YZ_mag = YZ.magnitude();

   Path* q = create_new<Path>(0);

   if (   XY_mag >= XZ_mag
       && XY_mag >= YZ_mag)
   {
       q->set(*(pv->v[0]), *(pv->v[1]));  /* $XY$  */
   }
   else if (   XZ_mag >= XY_mag
            && XZ_mag >= YZ_mag)
   { 
       q->set(*(pv->v[0]), *(pv->v[2]));  /* $XZ$  */
   }
   else 
   { 
       q->set(*(pv->v[1]), *(pv->v[2]));  /* $YZ$  */
   }

   delete pv;

   return q;


}  /* End of |Conic_Section_Lattice::get_pascal_line| definition.  */


@q **** (4) Get Polygons.@> 
@*3 Get Polygons.
\initials{LDF 2007.08.17.}

\LOG
\initials{LDF 2007.08.17.}
Added this section.
\ENDLOG

@q ***** (5) Get Polygon.@> 
@*4 Get Polygon.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.

\initials{LDF 2007.08.19.}
Changed return value from |Polygon| to |Polygon*|.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Polygon*
get_polygon(Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Polygon*
Conic_Section_Lattice::get_polygon(Scanner_Node scanner_node)
{

   return 0;  

}  /* End of |Conic_Section_Lattice::get_polygon| definition.  */


@q ***** (5) Get Pentagon.@> 
@*4 Get Pentagon.
\initials{LDF 2007.08.17.}

\LOG
\initials{LDF 2007.08.17.}
Added this function.

\initials{LDF 2007.08.20.}
@:BUG FIX@> BUG FIX: 
\initials{LDF 2007.08.20.}
Now setting |polygon->set_center| to |approx_center|.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Polygon*
get_pentagon(Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Polygon*
Conic_Section_Lattice::get_pentagon(Scanner_Node scanner_node)
{

@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7) Error handling:  At least one |Point| on |lattice_points| @>
@q ******* (7) is equal to |INVALID_POINT|.  Return 0.                   @>

@ Error handling:  At least one |Point| on |lattice_points| 
is equal to |INVALID_POINT|.  Return 0.                              
\initials{LDF 2007.08.17.}

@<Define |Conic_Section_Lattice| functions@>=

   for (int i = 0; i < 5; ++i)
   {

@q ******** (8)@> 

      if (lattice_points[i] == INVALID_POINT)
      { 
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Conic_Section_Lattice::get_pentagon':"
                    << endl
                    << "A point on |lattice_points| is equal to |INVALID_POINT|."
                    << endl 
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if|  */

@q ******** (8)@> 

   }  /* |for|  */ 

@q ******* (7)@> 

   Polygon* polygon = create_new<Polygon>(0);

   for (int i = 0; i < 5; ++i)
      *polygon += *(lattice[i]);

   polygon->set_cycle(true);
   polygon->set_center(approx_center);

   return polygon;  

}  /* End of |Conic_Section_Lattice::get_pentagon| definition.  */


@q ***** (5) Get Hexagon.@> 
@*4 Get Hexagon.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.

\initials{LDF 2007.08.20.}
@:BUG FIX@> BUG FIX: 
\initials{LDF 2007.08.20.}
Now setting |polygon->set_center| to |approx_center|.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
Polygon*
get_hexagon(Scanner_Node scanner_node = 0);

@q ****** (6) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Polygon*
Conic_Section_Lattice::get_hexagon(Scanner_Node scanner_node)
{

@q ******* (7) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ******* (7) Error handling:  At least one |Point| on |lattice_points| @>
@q ******* (7) is equal to |INVALID_POINT|.  Return 0.                   @>

@ Error handling:  At least one |Point| on |lattice_points| 
is equal to |INVALID_POINT|.  Return 0.                              
\initials{LDF 2007.08.17.}

@<Define |Conic_Section_Lattice| functions@>=

   for (int i = 0; i < 5; ++i)
   {

@q ******** (8)@> 

      if (lattice_points[i] == INVALID_POINT)
      { 
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Conic_Section_Lattice::get_hexagon':"
                    << endl
                    << "A point on |lattice_points| is equal to |INVALID_POINT|."
                    << endl 
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if|  */

@q ******** (8)@> 

   }  /* |for|  */ 


@q ******* (7) Warning:  |pt6 == INVALID_POINT|.@> 
@ Warning:  |pt6 == INVALID_POINT|.  Call |get_pentagon| instead
and return its return value.
\initials{LDF 2007.08.17.}

@<Define |Conic_Section_Lattice| functions@>=

   if (pt6 == INVALID_POINT)
   {
      cerr_strm << thread_name << "WARNING!  "
                << "In `Conic_Section_Lattice::get_hexagon':"
                << endl
                << "Point 6 == `INVALID_POINT'.  Calling "
                << "`get_pentagon' instead.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, warning_stop_value);
      cerr_strm.str("");

      return get_pentagon(scanner_node);

   }  /* |if (pt6 == INVALID_POINT)|  */

@q ******* (7)@> 

   Polygon* polygon = create_new<Polygon>(0);

   for (int i = 0; i < 5; ++i)
      *polygon += *(lattice[i]);

   *polygon += pt6;   
   *polygon += "--";

   polygon->set_center(approx_center);
   polygon->set_cycle(true);

   return polygon;  

}  /* End of |Conic_Section_Lattice::get_hexagon| definition.  */

@q *** (3) Get plane.@>
@*2 Get plane.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Conic_Section_Lattice| functions@>=
Plane
get_plane(void);

@q **** (4) Definition.@>
@
@<Define |Conic_Section_Lattice| functions@>=
Plane
Conic_Section_Lattice::get_plane(void)
{
   Path q;

   if (   lattice[0] == static_cast<Point*>(0) 
       || *lattice[0] == INVALID_POINT
       || lattice[1] == static_cast<Point*>(0) 
       || *lattice[1] == INVALID_POINT      
       || lattice[2] == static_cast<Point*>(0) 
       || *lattice[2] == INVALID_POINT)
      return INVALID_PLANE;

   q += *lattice[0];
   q += *lattice[1];
   q += *lattice[2];
 
   return q.get_plane();

}  /* End of |Conic_Section_Lattice::get_plane| definition.  */


@q *** (3) Shift lattice.@> 
@*2 Shift lattice.
\initials{LDF 2007.08.07.}

\LOG
\initials{LDF 2007.08.07.}
Added this section.
\ENDLOG

@q **** (4) |signed short| argument.@> 
@*3 {\bf signed short} argument.
\initials{LDF 2007.08.07.}

\LOG
\initials{LDF 2007.08.07.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
int
shift_lattice(int cycle_value = 1, Scanner_Node scanner_node = 0);


@q ***** (5) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
int
Conic_Section_Lattice::shift_lattice(int cycle_value, 
                                     Scanner_Node scanner_node)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Conic_Section_Lattice::shift_lattice'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    


@q ****** (6)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << "`cycle_value' == " << cycle_value;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

   if (cycle_value == 0)
   {
       cerr_strm << "WARNING!  In `Conic_Section_Lattice::shift_lattice':"
                 << endl 
                 << "`cycle_value' == 0.  Not shifting."
                 << endl 
                 << "Exiting function with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, warning_stop_value);
       cerr_strm.str("");

       return 0;
                
   }  /* |if (cycle_value == 0)|  */


@q ****** (6)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

   while (cycle_value < 0)
      cycle_value += 5;

   cycle_value %= 5;

   cycle_position += cycle_value;

   cycle_position %= 5;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << "`cycle_value' after adjustment:  " << cycle_value;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
   
@q ****** (6)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

   Point* p;

   for (int i = 0; i < cycle_value; ++i)
   {
      p = lattice.back();
      lattice.pop_back();
      lattice.push_front(p);
   }


@q ****** (6)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Exiting `Conic_Section_Lattice::shift_lattice' "
                << "successfully with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    


   return 0;

}  /* End of |Conic_Section_Lattice::shift_lattice| definition.  */

@q *** (3) Traverse.@> 
@*2 Traverse.
\initials{LDF 2007.08.08.}

\LOG
\initials{LDF 2007.08.08.}
Added this function.

\initials{LDF 2007.08.08.}
Added code.
\ENDLOG


@q **** (4) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

Pointer_Vector<Point>* 
traverse(real start = 0, real end = 4, Scanner_Node scanner_node = 0);

@q **** (4) Definition.@> 

@
@<Define |Conic_Section_Lattice| functions@>=
Pointer_Vector<Point>* 
Conic_Section_Lattice::traverse(real start, 
                                real end,
                                Scanner_Node scanner_node)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Entering `Conic_Section_Lattice::traverse'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Get options or set defaults if there are none.@> 
@ Get options or set defaults if there are none.
\initials{LDF 2007.08.08.}

@<Define |Conic_Section_Lattice| functions@>=

   Conic_Section_Lattice_Options* opt = 0;
   
   bool do_shift = true;
   bool quit_on_error = true;
   signed short cycle_value = 0;
   vector<real> increment_vector;
   real tolerance = CSL_DEFAULT_TOLERANCE;

   if (scanner_node && scanner_node->conic_section_lattice_options)
   {
      opt = scanner_node->conic_section_lattice_options;

      do_shift = opt->do_shift;
      quit_on_error = opt->quit_on_error;
      cycle_value = opt->cycle_value;
      increment_vector = opt->increment_vector;
      if (opt->tolerance > 0)
         tolerance = opt->tolerance;
   }


@q ***** (5)@> 
@
\LOG
\initials{LDF 2007.08.14.}
Added this section.
\ENDLOG

@<Define |Conic_Section_Lattice| functions@>=

   if (start == end)
   {
      real* r = new real(start);
      Point* p = get_point(scanner_node, 
                           cycle_value,
                           r,
                           do_shift);

      if (p != static_cast<Point*>(0))
      {  
          Pointer_Vector<Point>* pv = new Pointer_Vector<Point>;
          *pv += p;
          return pv;
      }
      else
         return 0;

      }  /* |if (start == end)|  */


@q ***** (5)@> 
@
\LOG
\initials{LDF 2007.08.14.}
Added this section.
\ENDLOG

@<Define |Conic_Section_Lattice| functions@>=

   bool reverse_flag = false;
   
   if (start > end)
   {
      reverse_flag = true;
      real r = start;
      start = end;
      end = r;
   }

@q ***** (5)@> 

   real increment;

   if (increment_vector.size() == 0)
   {
      increment_vector.push_back(.1);
   }

@q ***** (5)@> 

   Pointer_Vector<Point>* pv = new Pointer_Vector<Point>; 

   Point p;
   Point* q = static_cast<Point*>(0);

   bool b = true;

@q ***** (5)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_mutex.lock(); 
       cerr << "`start' == " << start << endl
            << "`end' == " << end << endl
            << "`increment_vector.size()' == " 
            << increment_vector.size()
            << endl;
       cerr_mutex.unlock();  

   }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 


   vector<real>::iterator iter = increment_vector.begin();
   increment = *iter;
   ++iter;

   real start_temp;
   real end_temp;

   start_temp = start;
   end_temp   = end;

@q ***** (5)@> 

   if (do_shift)
   {

@q ****** (6)@> 

      if (start_temp < 0)
      {

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_mutex.lock(); 
       cerr << "`start_temp' == " << start_temp
            << " (< 0).  Shifting lattice counterclockwise." 
            << endl;
       cerr_mutex.unlock();  

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7)@> 

          while (start_temp < 0)
          {
              shift_lattice(-1);
              start_temp += 1.0;
              end_temp   += 1.0;
          }   

@q ******* (7)@> 

      }  /* |if (start_temp < 0)|  */

@q ****** (6)@> 

      else if (start_temp > 0)
      {
#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_mutex.lock(); 
      cerr << "`start_temp' == " << start_temp
           << " (< 0).  Shifting lattice clockwise." << endl;
      cerr_mutex.unlock();  

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7)@> 

          while (start_temp >= 1.0)
          {
              shift_lattice(1);
              start_temp -= 1.0;
              end_temp   -= 1.0;
          }   

      }  /* |else if (start_temp > 0)|  */

@q ****** (6)@> 

      int i = 0;

      while (start <= end || (start > end && start - end < tolerance))
      {

@q ******* (7)@> 

          if (fabs(start_temp) < tolerance)
          {

#if DEBUG_COMPILE
              if (DEBUG)   
              {
                  cerr_mutex.lock(); 
                  cerr << "`start_temp' == " << start_temp
                       << endl
                       << "Setting `p' to `lattice[0]'."
                       << endl;
                  cerr_mutex.unlock();  

              }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;

             p = *(lattice[0]);
             *pv += create_new<Point>(p);

             start_temp += increment;
             start += increment;

          }

@q ******* (7)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
 
          if (   fabs(start_temp - 1.0) > tolerance 
                 && (   start <= end 
                     || (start > end && start - end < tolerance)))
          {
             cerr_mutex.lock(); 
             cerr << "Loop condition holds." << endl;
             cerr_mutex.unlock();  
          }
          else
          {
             cerr_mutex.lock(); 
             cerr << "Loop condition doesn't hold." << endl;
             cerr_mutex.unlock();  
          }

          cerr_mutex.lock(); 
          cerr << "start_temp == " << start_temp << endl;
          cerr_mutex.unlock();  

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
  

          while (   fabs(start_temp - 1.0) > tolerance 
                 && (   start <= end 
                     || (start > end && start - end < tolerance)))
          {

#if DEBUG_COMPILE
          if (DEBUG)
          {
              cerr_mutex.lock(); 
              cerr << "Beginning of `while' loop for " << i << "--" 
                   << (i + 1) << "." << endl
                   << "`start_temp' == " << start_temp<< endl;
              cerr_mutex.unlock();  
            
          }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

             q = get_point(scanner_node, start_temp);

/* START HERE!!  LDF 2007.08.13.  Add code for checking magnitude
   of |Points| against a test value.  
   Also, make it possible to have |start > end|.  
*/ 

             if (q == static_cast<Point*>(0) && quit_on_error)
             {
                cerr_strm << thread_name << "ERROR!  "
                          << "In `Conic_Section_Lattice::traverse':"
                          << endl 
                          << "`Conic_Section_Lattice::get_point' returned 0 "
                          << "and `quit_on_error' == `true'."
                          << endl
                          << "Quitting.";
                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 goto A;
                         
             }  /* |if|  */

             else if (q == static_cast<Point*>(0))
             {
                cerr_strm << thread_name << "WARNING!  "
                          << "In `Conic_Section_Lattice::traverse':"
                          << endl 
                          << "`Conic_Section_Lattice::get_point' returned 0 "
                          << "and `quit_on_error' == `false'."
                          << endl
                          << "Continuing.";
                 log_message(cerr_strm);
                 cerr_message(cerr_strm, warning_stop_value);
                 cerr_strm.str("");

             }  /* |else if|  */

             else  /* |q != static_cast<Point*>(0)|  */
             {
                *pv += q;
             }

             q = static_cast<Point*>(0);
             start_temp += increment;
             start += increment;

          }  /* |while|  */

@q ******* (7)@> 

          shift_lattice(1);
          start_temp -=1.0;
      
          if (iter != increment_vector.end())
          {
             increment = *iter;
             ++iter;
#if 0 
             cerr << "Getting new `increment' == " << increment << endl;
#endif 
          }
#if 0 
          else
             cerr << "Not getting new `increment'.";

          cerr << "`increment' == " << increment << endl;
#endif 

@q ******* (7)@> 

         ++i;

      }  /* |while(start <= end)|  */

@q ****** (6)@> 

   }  /* |if (do_shift)|  */
   

   A:  /* Place to go, if nested loop needs to be exited.  
          \initials{LDF 2007.08.14.}  */

   if (pv->ctr <= 0)
   {
      cerr_strm << thread_name 
                << "WARNING!  In `Conic_Section_Lattice::traverse':"
                << endl 
                << "No points found.  Exiting function with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete pv;
      return 0;

   }  /* |if (pv->ctr <= 0)|  */
  

@q ***** (5).@>

   if (reverse_flag)
   {
      pv->reverse();
   }


#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Exiting `Conic_Section_Lattice::traverse'"
                << endl
                << "successfully with return value `Pointer_Vector<Point>*'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   if (scanner_node)
   {
      delete scanner_node->conic_section_lattice_options;
      scanner_node->conic_section_lattice_options = 0;
   }
   

   return pv;

}  /* End of |Conic_Section_Lattice::traverse| definition.  */


@q *** (3) Creating objects of conic section types.@>
@*2 Creating objects of conic section types.
\initials{LDF 2007.09.26.}

\LOG
\initials{LDF 2007.09.26.}
Added this section.
\ENDLOG

@q **** (4) Get |Ellipse|.@>
@*3 Get {\bf Ellipse}.
\initials{LDF 2007.09.26.}

\LOG
\initials{LDF 2007.09.26.}
Added this function.  
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Conic_Section_Lattice| functions@>=
Ellipse*
get_ellipse(Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>
@
@<Define |Conic_Section_Lattice| functions@>=
Ellipse*
Conic_Section_Lattice::get_ellipse(Scanner_Node scanner_node)
{
 
@q ****** (6) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Conic_Section_Lattice::get_ellipse'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@>

/* START HERE!! LDF 2007.09.26.  */ 



@q ****** (6)@>

   Ellipse* e = create_new<Ellipse>(0);


@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Exiting `Conic_Section_Lattice::get_ellipse' "
                << "successfully with return value `Ellipse*'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


   return e;

}  /* End of |Conic_Section_Lattice::get_ellipse| definition.  */

@q **** (4) Get |Circle|.@>
@*3 Get {\bf Circle}.
\initials{LDF 2007.09.26.}

\LOG
\initials{LDF 2007.09.26.}
Added this function.  It currently has a dummy definition and 
returns 0 immediately.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Conic_Section_Lattice| functions@>=
Circle*
get_circle(Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>
@
@<Define |Conic_Section_Lattice| functions@>=
Circle*
Conic_Section_Lattice::get_circle(Scanner_Node scanner_node)
{

   return 0;

}  /* End of |Conic_Section_Lattice::get_circle| definition.  */

@q **** (4) Get |Parabola|.@>
@*3 Get {\bf Parabola}.
\initials{LDF 2007.09.26.}

\LOG
\initials{LDF 2007.09.26.}
Added this function.  It currently has a dummy definition and 
returns 0 immediately.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Conic_Section_Lattice| functions@>=
Parabola*
get_parabola(Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>
@
@<Define |Conic_Section_Lattice| functions@>=
Parabola*
Conic_Section_Lattice::get_parabola(Scanner_Node scanner_node)
{

   return 0;

}  /* End of |Conic_Section_Lattice::get_parabola| definition.  */

@q **** (4) Get |Hyperbola|.@>
@*3 Get {\bf Hyperbola}.
\initials{LDF 2007.09.26.}

\LOG
\initials{LDF 2007.09.26.}
Added this function.  It currently has a dummy definition and 
returns 0 immediately.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Conic_Section_Lattice| functions@>=
Hyperbola*
get_hyperbola(Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>
@
@<Define |Conic_Section_Lattice| functions@>=
Hyperbola*
Conic_Section_Lattice::get_hyperbola(Scanner_Node scanner_node)
{

   return 0;

}  /* End of |Conic_Section_Lattice::get_hyperbola| definition.  */

@q *** (3) Intersections.@> 
@*2 Intersections.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG

@q **** (4) |Path| argument.@> 
@*3 {\bf Path} argument.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.

\initials{LDF 2007.08.21.}
Added the optional |real| arguments |tolerance| and |increment|.
The default for both is -1.

\initials{LDF 2007.08.21.}
@:BUG FIX@> BUG FIX: 
Now deleting |Polygon* polygon|.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

Pointer_Vector<Bool_Point>*
intersection_points(Path q, 
                    real tolerance = -1, 
                    real increment = -1,
                    Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@> 

@
@<Define |Conic_Section_Lattice| functions@>=
Pointer_Vector<Bool_Point>*
Conic_Section_Lattice::intersection_points(Path q, 
                                           real tolerance,
                                           real increment,
                                           Scanner_Node scanner_node)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Entering `Conic_Section_Lattice::intersection_points' "
                << "(with `Path' argument).";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

/* START HERE!!  
   Must ensure that |pt6 != INVALID_REAL|.  If it is, call |get_point|
   and set it.

   Change |*(lattice[0])|, etc., to |*lattice[0]|, i.e., remove the 
   parentheses.

   LDF 2007.08.17.  */ 

   Polygon* polygon = get_pentagon(scanner_node);

#if 0 
#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_mutex.lock();
      cerr << "In `Conic_Section_Lattice::intersection_points':" << endl;
      polygon->show("`*polygon':");
      cerr_mutex.unlock();  
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
#endif 


@q ****** (6)@>

   Point normal = polygon->get_normal();

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_mutex.lock();
       normal.show("`normal':");
       cerr_mutex.unlock();
   } /* |if (DEBUG)| */ 
#endif /* |DEBUG_COMPILE| */@;


   Point q0 = q.get_point(0);
   Point q1 = q.get_point(1);
   Point q_mid = q0.mediate(q1);

   Plane plane = polygon->get_plane();

@q ****** (6) WARNING:  If |Conic_Section_Lattice| and |Path| are non-coplanar, @>
@q ****** (6) return 0.                                                         @>

@ WARNING:  If |Conic_Section_Lattice| and |Path| are non-coplanar, return 0.
Can't handle this case yet.
\initials{LDF 2007.08.20.}

@<Define |Conic_Section_Lattice| functions@>=

   if (!(q0.is_on_plane(plane) && q1.is_on_plane(plane)))
   {
       cerr_strm << thread_name << "WARNING!  "
                 << "In `Conic_Section_Lattice::intersection_points':"
                 << endl 
                 << "`Conic_Section_Lattice' and `Path' aren't coplanar."
                 << endl 
                 << "Can't handle this case yet.  Exiting function "
                 << "unsuccessfully"
                 << endl 
                 << "with return value (Pointer_Vector<Bool_Point>*) 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, warning_stop_value);
       cerr_strm.str("");
  
       delete polygon;

       return 0;

   }  /* |if (!(q0.is_on_plane() && q1.is_on_plane()))|  */


@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

    signed short start[2]  = {-1, -1};
    signed short start_ctr = 0;

    bool colinear = false;

@q ******* (7)@>

    if (   (    q0.is_on_line(*lattice[0], *lattice[1]).first
            && q1.is_on_line(*lattice[0], *lattice[1]).first)
        || (   q0.is_on_line(*lattice[1], *lattice[2]).first
            && q1.is_on_line(*lattice[1], *lattice[2]).first)
        || (   q0.is_on_line(*lattice[2], *lattice[3]).first
            && q1.is_on_line(*lattice[2], *lattice[3]).first)
        || (   q0.is_on_line(*lattice[3], *lattice[4]).first
            && q1.is_on_line(*lattice[3], *lattice[4]).first)
        || (   q0.is_on_line(*lattice[4], pt6).first
            && q1.is_on_line(*lattice[4], pt6).first)
        || (   q0.is_on_line(pt6, *lattice[0]).first
            && q1.is_on_line(pt6, *lattice[0]).first))
    {
        colinear = true;

#if DEBUG_COMPILE
   if (DEBUG)
   {
        cerr << "`Path' is colinear with one of the sides of the polygon." 
             << endl;

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    }  /* |if|  */

@q ******* (7)@>

    else
    {
#if DEBUG_COMPILE
       if (DEBUG)
       {
            cerr << "`Path' is not colinear with one of the sides of the polygon." 
                 << endl;
       }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    }  /* |else|  */
 
@q ******* (7)@>

@q ****** (6)@>
@ 
@<Define |Conic_Section_Lattice| functions@>=

    if (!colinear)
    {

@q ******* (7)@>

        Bool_Point_Pair bpp;

        try 
        {
            bpp = polygon->intersection_points(q, scanner_node, true);
        }
        catch (...)
        {
            cerr_strm << thread_name << "ERROR!  "
                      << "In `Conic_Section_Lattice::intersection_points':"
                      << endl 
                      << "`Polygon::intersection_points' failed."
                      << "Exiting function unsuccessfully with return value 0.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            delete polygon;

            return 0;                  

        }  /* |catch|  */

@q ******* (7)@>
@
@<Define |Conic_Section_Lattice| functions@>=
    
#if 0 
#if DEBUG_COMPILE
       if (DEBUG)
       {
          cerr_mutex.lock(); 
          cerr << "In `Conic_Section_Lattice::intersection_points':" << endl
               << "`bpp.first.b' == " << bpp.first.b << endl;
          bpp.first.pt.show("`bpp.first.pt':");

          cerr << "`bpp.second.b' == " << bpp.second.b << endl;
          bpp.second.pt.show("`bpp.second.pt':");
          cerr_mutex.unlock();  

       }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
#endif 

@q ******* (7)@>

       if (bpp.first.pt != INVALID_POINT)
       {

@q ******** (8)@>

          if (bpp.first.pt.is_on_segment(*(lattice[0]), *(lattice[1])).first)
          {
#if DEBUG_COMPILE
              if (DEBUG)
              {
                  cerr << "`start[" << start_ctr << "]' is on segment 0." << endl;

              }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 0;
          }   

@q ******** (8)@>

          if (bpp.first.pt.is_on_segment(*(lattice[1]), *(lattice[2])).first)
          {
#if DEBUG_COMPILE
             if (DEBUG)
             {
                cerr << "`start[" << start_ctr << "]' is on segment 1." 
                     << endl;
             }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


              start[start_ctr++] = 1;
          }   

@q ******** (8)@>

         if (   start_ctr < 2 
             && bpp.first.pt.is_on_segment(*(lattice[2]), *(lattice[3])).first)
         {

#if DEBUG_COMPILE
            if (DEBUG)
            {
               cerr << "`start[" << start_ctr << "]' is on segment 2." << endl;
 
           }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

             start[start_ctr++] = 2;

         }  

@q ******** (8)@>

         if (   start_ctr < 2 
             && bpp.first.pt.is_on_segment(*(lattice[3]), *(lattice[4])).first)
         {

#if DEBUG_COMPILE
            if (DEBUG)
            {

               cerr << "`start[" << start_ctr << "]' is on segment 3." << endl;       
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
       
            start[start_ctr++] = 3;

         }   

@q ******** (8)@>

        if (   start_ctr < 2 
            && bpp.first.pt.is_on_segment(*(lattice[4]), pt6).first)
        {

#if DEBUG_COMPILE
          if (DEBUG)
          {
             cerr << "`start[" << start_ctr << "]' is on segment 4." << endl;
          }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

           start[start_ctr++] = 4;
        } 

@q ******** (8)@>

   }  /* |if (bpp.first.pt != INVALID_POINT)|  */


@q ******* (7)@>

       if (   start_ctr < 2 
           && bpp.second.pt != INVALID_POINT)
       {

@q ******** (8)@>

          if (   start_ctr < 2 
              && bpp.second.pt.is_on_segment(*(lattice[0]), *(lattice[1])).first)
          {

#if DEBUG_COMPILE
            if (DEBUG)
            {
                cerr << "`start[" << start_ctr << "]' is on segment 0." << endl;
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 0;
          }   

@q ******** (8)@>

          if (   start_ctr < 2 
              && bpp.second.pt.is_on_segment(*(lattice[1]), *(lattice[2])).first)
          {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                cerr << "`start[" << start_ctr << "]' is on segment 1." << endl;
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 1;
          }  

@q ******** (8)@>

          if (   start_ctr < 2 
              && bpp.second.pt.is_on_segment(*(lattice[2]), *(lattice[3])).first)
          {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                cerr << "`start[" << start_ctr << "]' is on segment 2." << endl;
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 2;
          }   

@q ******** (8)@>

          if (   start_ctr < 2 
              && bpp.second.pt.is_on_segment(*(lattice[3]), *(lattice[4])).first)
          {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                cerr << "`start[" << start_ctr << "]' is on segment 3." << endl;
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 3;
          }   

@q ******** (8)@>

          if (   start_ctr < 2 
              && bpp.second.pt.is_on_segment(*(lattice[4]), pt6).first)
          {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                cerr << "`start[" << start_ctr << "]' is on segment 4." << endl;
            }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

              start[start_ctr++] = 4;
          }   

@q ******** (8)@>

       }  /* |if (bpp.second.pt != INVALID_POINT)|  */

#if DEBUG_COMPILE
       if (DEBUG)
       {
           cerr_strm << thread_name << "`start[0]' == " << start[0]
                     << ", `start[1]' == " << start[1];
           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

       } /* |if (DEBUG)| */

#endif /* |DEBUG_COMPILE| */@;

@q ****** (6)@>

    }  /*  |if (!colinear)|  */

@q ***** (5) Put objects into x-z plane.@> 
@ Put objects into x-z plane.
\initials{LDF 2007.08.20.}

@<Define |Conic_Section_Lattice| functions@>=

   Point y_axis_pt(0, 1, 0);
   Transform t;

   if (normal == y_axis_pt)
   {
#if 0 /* 1  */
         cerr << "`normal' == `y_axis_pt'" << endl;
#endif 
   }
   else
   {
#if 0 /* 1  */ 
      cerr << "`normal' != `y_axis_pt'"  << endl;
#endif 
      
      Point temp_pt = q_mid + normal;
#if 0 /* 1  */
      temp_pt.show("temp_pt:");
#endif 

      t.align_with_axis(q_mid, temp_pt, 'y');

#if 0
      t.show("t:");
#endif 

      *polygon *= q *= q0 *= q1 *= q_mid *= operator*=(t);

#if 0 
      show("*this:");
      polygon->show("polygon:");
      q.show("q:");
#endif 

   }  /* |else| (|normal != y_axis_pt|)  */


@q ***** (5) Align |q| with the z-axis and transform other objects accordingly.@>
@ Align |q| with the z-axis and transform other objects accordingly.
\initials{LDF 2007.08.21.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.21.}
Make it possible to set tolerance using an option.
\ENDTODO 

@<Define |Conic_Section_Lattice| functions@>=

   Point z_axis_pt(0, 0, 1);

   real angle = q1.angle(z_axis_pt);

   if (tolerance < 0)
      tolerance = CSL_DEFAULT_TOLERANCE;

#if 0 /* 1  */ 
   cerr << "`angle' == " << angle << endl;
#endif 

   Transform u;

@q ****** (6)@>

   if (fabs(angle) > tolerance)
   {

@q ******** (8)@>

       u.rotate(0, -angle);

       q0 *= q1 *= q_mid *= q *= u;

       angle = q1.angle(z_axis_pt);

#if 0 /* 1  */ 
       q.show("q after first rotation:");
       q_mid.show("q_mid after first rotation:");
       cerr << "`angle' after first  rotation == " << angle << endl;
#endif 

@q ******** (8)@>
         
       if (fabs(angle) > tolerance)
       {

@q ******** (8)@>

          u.rotate(0, 2 * angle);

          q0 *= q1 *= q_mid *= q *= u;

          angle = q1.angle(z_axis_pt);

#if 0 /* 1  */ 
          q.show("q after second rotation:");
          q_mid.show("q_mid after second rotation:");
          cerr << "`angle' after second rotation == " << angle << endl;
#endif 

@q ******** (8)@>

       }  /* |if (fabs(angle) > tolerance)| (inner conditional)  */

@q ******** (8)@>

   }  /* |if (fabs(angle) > tolerance)| (outer conditional)  */


   *this *= *polygon *= t *= u;

#if 0 /* 1  */ 
   show("*this after alignment:");
   polygon->show("*polygon after alignment:");
#endif 

   delete polygon;
   polygon = 0;

@q ***** (5) Check for intersections with lattice points.@>
@ Check for intersections with lattice points.
\initials{LDF 2007.08.20.}

@<Define |Conic_Section_Lattice| functions@>=

   unsigned short isect_ctr = 0;
   Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;
   Bool_Point bp;
   Bool_Real br;

@q ******* (7)@>
@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.21.}
Test this with a |Path| that intersects one or two lattice points.
\ENDTODO 

\LOG
\initials{LDF 2007.08.29.}
@:BUG FIX@> BUG FIX:  This now seems to work correctly.  
Must still be tested, though.
\ENDLOG 

@<Define |Conic_Section_Lattice| functions@>=

   for (int i = 0; i < 2; ++i)
   {

@q ******** (8)@>

       if (start[i] >= 0)
       {
#if 0 /* 1  */ 
          cerr << "`start[i]'  == " << start[i] << endl;             
          q0.show("q0:");
          q1.show("q1:");
#endif 

#if 0 
    cerr << "`i' == " << i  << endl
         << "`i % 5' == " << (i % 5) << endl
         << "`start[" << i << "] % 5" << " == " << (start[i] % 5) << endl;
#endif 

    for (int j = 0; j < 2; ++j)
    {

       br = lattice[start[i] % 5 + j]->is_on_segment(q0, q1);   

@q ******** (8)@>

          if (br.second != INVALID_REAL)
          {
#if 0 /* 1  */ 
              cerr << "Intersection point is `*lattice["  << (start[i] % 5 + j)
                   << "]" << endl;
#endif 

              bp.pt = *lattice[start[i] % 5 + j];
              bp.b  = br.first;
              *bpv += new Bool_Point(bp);
              ++isect_ctr;

              start[i] = -1;

              if (isect_ctr == 2)
              {
#if 0 /* 1  */ 
                  cerr << "Found two intersection points.  Returning `bpv'."
                       << endl;
#endif 

                  return bpv;
              }

          }  /* |if (br.second != INVALID_REAL)|  */

@q ******** (8)@>

          else
          {
#if 0 /* 1  */ 
              cerr << "Intersection point is not `*lattice["  << (start[i] % 5 + j) << "]."
                    << endl;
#endif 

          }
       
      } /* Inner |for|  */

@q ******** (8)@>

   }  /* |if (start[i] >= 0)|  */

@q ******** (8)@>

  }  /* |for|  */


@q ***** (5) Traverse.@>
@ Traverse.
\initials{LDF 2007.08.20.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.21.}
Add an option for setting |increment| to the parser rules.
\ENDTODO 

@<Define |Conic_Section_Lattice| functions@>=

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "Traversing." << endl
            << "`start[0]' == " << start[0]
            << ", `start[1]' == " << start[1] << endl;

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
   
@q ****** (6)@>


   if (increment <= 0)
      increment = .1;

   real save_increment = increment;

@q ****** (6)@>

   Point        curr_pt;
   signed short last_pos;
   signed short start_pos;
   signed short curr_pos;
   real curr_value = 0;
   real last_value = 0;
   real start_x;
   real curr_x;
   unsigned short ctr = 0;

   if (start[0] > 0)
   {
       shift_lattice(start[0]);
       start[0] = -1;
   }


   curr_pt = *lattice[0];

   A:

   start_x = curr_pt.get_x();

   if (fabs(start_x) < tolerance)
   {
      cerr_strm << thread_name  
                << "WARNING!  In `Conic_Section_Lattice::intersection_points':"
                << endl 
                << "`fabs(start_x)' < `tolerance'.  " 
                << "This can't happen."
                << endl 
                << "This case should have been caught above.  Continuing."
                << endl;

      log_message(cerr_strm);
      cerr_message(cerr_strm, warning_stop_value);
      cerr_strm.str("");

   }
   else if (start_x > 0)
      curr_pos = start_pos = 1;
   else
      curr_pos = start_pos = -1;

#if 0 /* 1  */
   cerr << "Before loop:  `curr_pos' == " << curr_pos << endl
        << "`curr_value' == " << curr_value << endl;
#endif 

@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

   while (curr_value < 1.5)
   {

#if 0 /* 1  */
       cerr << "Starting loop." << endl;
#endif 

       last_pos = curr_pos;
       curr_pt = get_point(curr_value);
       curr_x = curr_pt.get_x();
       
       if (fabs(curr_x) < tolerance)
          curr_pos = 0;
       else if (curr_x > 0)
          curr_pos = 1;
       else 
          curr_pos = -1;

#if 0 /* 1  */ 
       cerr << "In loop:  `curr_pos' == " << curr_pos << endl
            << "`curr_value' == " << curr_value << endl;
#endif 


@q ******* (7)@>
@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.21.}
Change |Point::clean| so that I can use it instead of shifting.
\ENDTODO

\LOG
\initials{LDF 2007.08.29.}
Added code for checking whether the |Point| is already on |bpv|.
\ENDLOG 

@<Define |Conic_Section_Lattice| functions@>=

       if (curr_pos == 0)
       {

          /* Put |Bool_Point| onto |bpv|, unless it's already there.   */

          if (fabs(curr_pt.get_x()) < tolerance)
             curr_pt.shift(-curr_pt.get_x());

          if (fabs(curr_pt.get_y()) < tolerance)
             curr_pt.shift(0, -curr_pt.get_y());

          if (fabs(curr_pt.get_z()) < tolerance)
             curr_pt.shift(0, 0, -curr_pt.get_z());

          bp.pt = curr_pt;

          br = curr_pt.is_on_line(q0, q1);

#if 0 
          curr_pt.show("curr_pt:");
          q0.show("q0:");
          q1.show("q1:");

          cerr << "`br' == " << br.first << ", " << br.second << endl;
#endif 

          bp.b = bp.pt.is_on_segment(q0, q1).first;

          bp.pt *= t.inverse();

          if (isect_ctr == 1 && bp.pt.is_equal(bpv->v[0]->pt, tolerance, scanner_node))
             break;
 
#if 0 /* 1  */ 
          cerr << "Got a point!  Ending loop." << endl;
#endif 


          *bpv += new Bool_Point(bp);

          last_value = curr_value;
          ++isect_ctr;

          if (isect_ctr == 2)
          {
#if 0 /* 1  */ 
              cerr << "Returning `bpv'." << endl;
#endif 

       
              return bpv;
          }

          break;

       }  /* |if (curr_pos == 0)|  */

@q ******* (7)@>

       else if (curr_pos != last_pos)
       {
#if 0 /* 1  */ 
           cerr << "Crossed the axis.  Performing binary search." << endl
                << "`last_value' == " << last_value << endl
                << "`curr_value' == " << curr_value << endl;
 #endif 
    
           increment /= 2;
           increment *= -1;

           last_value = curr_value;
           curr_value += increment;

       }  /* |else if (curr_pos != last_pos)|  
             (Binary search)  */


@q ******* (7)@>

       else 
       {
#if 0 /* 1  */ 
           cerr << "`curr_pos' == `last_pos'.  Continuing." << endl;
#endif 

           last_value = curr_value;
           curr_value += increment;
       }


@q ******* (7)@>

   }  /* |while|  */

   increment = save_increment;

   if (start[1] > 0)
   {
       shift_lattice(start[1] - start[0]);
       curr_pt = *lattice[0];
       start[1] = -1;
       ++ctr;
       goto A;

   }
@q ******* (7)@>
@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.25.}
Keep an eye on this.  Make sure it works, when testing the case that the 
line doesn't intersect the polygon.
\ENDTODO 

@<Define |Conic_Section_Lattice| functions@>=

   else if (ctr < 6)
   {
      shift_lattice(1);
      curr_value -= 1;
      curr_value += increment;
      curr_pt = get_point(curr_value);
       ++ctr;
      goto A;
   }
   else 
   {
      if (isect_ctr < 1)
      {
          delete bpv;
          return 0;
      }
      else
      {
          return bpv;
      }

   }  /* |else|  */
 
@q ******* (7)@>

@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Exiting `Conic_Section_Lattice::intersection_points' "
                << "(with `Path' argument) successfully"
                << endl 
                << "with return value `Pointer_Vector<Bool_Point>*'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    return bpv;
 

}  /* End of |Conic_Section_Lattice::intersection_points(Path p)| definition.  */ 


@q **** (4) |Ellipse| argument.@> 
@*3 {\bf Ellipse} argument.
\initials{LDF 2007.08.26.}

\LOG
\initials{LDF 2007.08.26.}
Added this function.  It currently merely contains a dummy definition, returning 0
immediately.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

Pointer_Vector<Bool_Point>*
intersection_points(Ellipse e,
                    real tolerance = -1, 
                    real increment = -1,
                    Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Pointer_Vector<Bool_Point>*
Conic_Section_Lattice::intersection_points(Ellipse e,
                                           real tolerance,
                                           real increment,
                                           Scanner_Node scanner_node)

{
   return 0;

}  /* End of |Conic_Section_Lattice::intersection_points| definition. 
      (Version with |Ellipse| argument.)  */

@q **** (4) |Circle| argument.@> 
@*3 {\bf Circle} argument.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

Pointer_Vector<Bool_Point>*
intersection_points(Circle c,
                    real tolerance = -1, 
                    real increment = -1,
                    Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@> 
@
@<Define |Conic_Section_Lattice| functions@>=
Pointer_Vector<Bool_Point>*
Conic_Section_Lattice::intersection_points(Circle c,
                                           real tolerance,
                                           real increment,
                                           Scanner_Node scanner_node)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Entering `Conic_Section_Lattice::intersection_points' "
                << "(with `Circle' argument).";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

   Plane plane = get_plane();

   Plane c_plane = c.get_plane();

   if (plane != c_plane)
   {
       cerr_strm << thread_name  
                 << "In `Conic_Section_Lattice::intersection_points' "
                 << "(with `Circle' argument):"
                 << endl
                 << "`plane' and `c_plane' are not equal." 
                 << endl
                 << "Can't handle this case yet."
                 << endl
                 << "Exiting function unsuccessfully with return value "
                 << "`(Pointer_Vector<Bool_Point>*) 0'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");
 
       return 0;

   }  /* |else|  */

@q ****** (6)@>

   Bool_Point bp;
   Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;

   if (increment < 0)
      increment = .1;

   real save_increment = increment;

   if (tolerance < 0)
      tolerance = CSL_DEFAULT_TOLERANCE;

   Point curr_pt;
   signed short last_pos;
   signed short curr_pos;

   real last_value;
 
   Point center = c.get_center();

   unsigned short isect_ctr = 0;

   curr_pt = *lattice[0];

   curr_pos = c.location(curr_pt, tolerance);

@q ****** (6)@>
@
@<Define |Conic_Section_Lattice| functions@>=

   Point normal = plane.normal;

@q ****** (6)@>

   unsigned short segment_ctr = 0;

   real curr_value = increment;
   real total_value = curr_value;

   bool isect_flag = false;

   while (total_value < 6.5 && isect_ctr < 4)
   {

       last_value = curr_value;
       last_pos = curr_pos;

       curr_pt = get_point(curr_value);

       curr_pos = c.location(curr_pt, tolerance);

@q ******* (7)@>

       if (curr_pos == 0)
       {
#if 0 
           cerr << "Got a point!" << endl;
#endif 
           bp.pt = curr_pt;
           bp.b  = true;
           *bpv += new Bool_Point(bp);
           ++isect_ctr;
       }

@q ******* (7)@>

       else if (curr_pos == last_pos)
       {
#if 0 
          cerr << "Continuing." << endl;
#endif 
       }

@q ******* (7)@>

       else
       {
#if 0 
          cerr << "Crossed `Circle'.  Performing binary search.";
#endif 

          while (curr_pos != 0)  /* Inner |while|  */
          {
             if (curr_pos == last_pos)
             {
                increment += increment / 4;
             }
             else
             {
                increment *= -1;
                increment /= 2;
             }

             last_value = curr_value;
             last_pos = curr_pos; 
             curr_value += increment;
             total_value += increment;
 
             curr_pt = get_point(curr_value);
             curr_pos = c.location(curr_pt, tolerance);

             if (curr_pos == 0)
             {
#if 0 
                cerr << "Got a point!" << endl;
#endif 
                bp.pt = curr_pt;
                bp.b  = true;
                *bpv += new Bool_Point(bp);
                ++isect_ctr;
               
                isect_flag = true;
 
                break;

             }  /* |if|  */

          }  /* Inner |while|  */

       }  /* |else|  */

@q ******* (7)@>

       increment = save_increment;
       total_value += increment;               
       curr_value  += increment;

       if (curr_value > 1)
       {
           curr_value -= 1;
           shift_lattice(1);
#if 0 
           cerr << "Shifting lattice." << endl;
#endif 
       }

@q ******* (7)@>

       if (isect_flag)
       {
           isect_flag = false;
           curr_pt = get_point(curr_value);
           curr_pos = c.location(curr_pt, tolerance);
       }


   }  /* |while|  */

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Exiting `Conic_Section_Lattice::intersection_points'"
                << endl 
                << "(with `Circle' argument) successfully with return value"
                << endl
                << "`Pointer_Vector<Bool_Point>*'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   return bpv;

}  /* End of |Conic_Section_Lattice::intersection_points| definition
      (|Circle| argument).  */ 


@q *** (3) Drawing.@> 
@*2 Drawing.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG

@q **** (4) Draw Lattice.@> 
@*3 Draw Lattice.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.  It must be defined in \filename{scanprsf.web}.

\initials{LDF 2007.08.19.}
Changed |Point*| argument to |real|.

\initials{LDF 2007.08.19.}
Made this function non-|const| because it must call 
|Conic_Section_Lattice::get_point|, which is a non-|const| function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

int
draw_lattice(real increment, void* parameter = 0);

@q *** (3) Labeling.@> 
@*2 Labeling.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG

@q **** (4) Label Lattice.@> 
@*3 Label Lattice.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function.  It must be defined in \filename{scanprsf.web}.

\initials{LDF 2007.08.19.}
Made this function non-|const|.
It needs to call |Conic_Section_Lattice::get_pascal_points|, 
which isn't a |const| function.

\initials{LDF 2007.08.19.}
Changed |void* ppoint| argument to |real increment|.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=
int
label_lattice(void* parameter, 
              int label_type, 
              int label_suffix, 
              real increment,
              void* ttransform,
              void* ttext_color,
              void* ddot_colr,
              void* eentry);

@q *** (3) Show.@> 
@*2 Show.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function.

\initials{LDF 2007.08.06.}
Added code.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section_Lattice| functions@>=

void 
show(string text = "", Scanner_Node scanner_node = 0) const;


@q **** (4) Definition.@> 

@
@<Define |Conic_Section_Lattice| functions@>=
void 
Conic_Section_Lattice::show(string text, Scanner_Node scanner_node) const
{

    if (text == "")
       text = "Conic_Section_Lattice:";

    cerr << text << endl;

    stringstream s;

    for (int i = 0; i < 5; ++i)
    {
       s << "lattice point " << i << ":";

       lattice[i]->show(s.str());
       s.str("");
    }

    cerr << "`cycle_position': " << cycle_position << endl;

    if (pt6 == INVALID_POINT)
       cerr << "`pt6' == `INVALID_POINT'." << endl;
    else
       pt6.show("Point 6 (test point):");

    if (approx_center == INVALID_POINT)
       cerr << "`approx_center' == `INVALID_POINT'." << endl;
    else
       approx_center.show("`approx_center':");

    if (true_center == INVALID_POINT)
       cerr << "`true_center' == `INVALID_POINT'." << endl;
    else
       true_center.show("`true_center':");

    if (transform)
       transform->show("`transform':");
    else
       cerr << "`transform' is null." << endl;

    return;
   
} /* End of |Conic_Section_Lattice::show| definition.  */


@q * (1) |Conic_Section_Lattice_Options|.@> 
@* {\bf Conic\_Section\_Lattice\_Options}.
\initials{LDF 2007.08.03.}

@q ** (2) Conic_Section_Lattice_Options struct definition.@>
@*1 {\bf Conic\_Section\_Lattice\_Options} struct definition.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this |struct| definition.

\initials{LDF 2007.07.30.}
Added data member |bool do_test|.

\initials{LDF 2007.08.04.}
Changed |real increment| to |real* increment|.  This makes it possible
to check whether it's been set or not.

\initials{LDF 2007.08.05.}
Changed |real increment| to |vector<real> increment_vector|.

\initials{LDF 2007.08.05.}
Added |real tolerance|.

\initials{LDF 2007.08.07.}
Added |bool do_shift|.

\initials{LDF 2007.08.08.}
Added |bool quit_on_error|.
\ENDLOG

@q *** (3) Definition@> 

@<Define |struct Conic_Section_Lattice_Options|@>=

struct Conic_Section_Lattice_Options
{
    bool do_cull;
    bool do_test;
    bool do_rectify;
    bool do_shift;
    bool do_transform;

    bool quit_on_error;

    bool lattice_point_flag;

    signed short cycle_value;
    vector<real> increment_vector;

    real tolerance;

    Transform* transform;
  
    @<Declare |Conic_Section_Lattice_Options| functions@>@;

};

@q ** (2) |Conic_Section_Lattice_Options| functions.@> 
@*1 {\bf Conic\_Section\_Lattice\_Options} functions.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this section.
\ENDLOG

@q *** (3) Default Constructor@> 
@*2 Default Constructor.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this function.
\ENDLOG

@<Declare |Conic_Section_Lattice_Options| functions@>=
Conic_Section_Lattice_Options(void);

@
@<Define |Conic_Section_Lattice_Options| functions@>=
Conic_Section_Lattice_Options::Conic_Section_Lattice_Options(void)
{

    do_cull       = true;
    do_test       = true;
    do_rectify    = true;
    do_shift      = true;
    do_transform  = true;
    quit_on_error = true;


    lattice_point_flag = false;

    cycle_value = 0;

    transform = 0;
  
    tolerance = -1;

    return;

}  /* End of |Conic_Section_Lattice_Options| default constructor
      definition  */

@q *** (3) Destructor@> 
@*2 Destructor.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this function.
\ENDLOG

@<Declare |Conic_Section_Lattice_Options| functions@>=
~Conic_Section_Lattice_Options(void);

@
@<Define |Conic_Section_Lattice_Options| functions@>=
Conic_Section_Lattice_Options::~Conic_Section_Lattice_Options(void)
{

    delete transform;
  
    return;

}  /* End of |Conic_Section_Lattice_Options| destructor
      definition.   */


@q *** (3) Show.@> 
@*2 Show.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this function.

\initials{LDF 2007.08.04.}
Added code.

\initials{LDF 2007.08.05.}
Changed to account for the fact that I've changed 
|real* Conic_Section_Lattice_Options::increment| to 
|vector<real> increment_vector|.
\ENDLOG


@<Declare |Conic_Section_Lattice_Options| functions@>=
void
show(string text = "", Scanner_Node scanner_node = 0);

@
@<Define |Conic_Section_Lattice_Options| functions@>=
void
Conic_Section_Lattice_Options::show(string text, Scanner_Node scanner_node)
{

    if (text == "")
       text = "Conic_Section_Lattice_Options:";

    cerr << "`do_cull' == " << do_cull 
         << endl 
         << "`tolerance' == " << tolerance
         << endl 
         << "`do_test' == " << do_test
         << endl 
         << "`do_rectify' == " << do_rectify
         << endl 
         << "`do_shift' == " << do_shift
         << endl 
         << "`do_transform' == " << do_rectify
         << endl 
         << "`quit_on_error' == " << quit_on_error
         << endl 
         << "`lattice_point_flag' == " << lattice_point_flag
         << endl 
         << "`with_cycle_value':  " << cycle_value 
         << endl;

    if (increment_vector.size() == 0)
       cerr << "`increment_vector' is empty." << endl;    

    else
    {
       int i = 0;
       cerr << "`increment_vector':" << endl;
       for (vector<real>::const_iterator iter = increment_vector.begin();
            iter != increment_vector.end();
            ++iter)
           cerr << i << ":  " << *iter << endl;   

    }  /* |else|  */

    if (transform)
       transform->show("`transform':");
    else
       cerr << "`transform' is null." << endl; 

    return;

}  /* End of |Conic_Section_Lattice_Options::show| definition.   */

@q * (1) Putting Conic_Section_Lattice and Conic_Section_Lattice_Options together.@>
@* Putting {\bf Conic\_Section} and {\bf Conic\_Section\_Lattice\_Options} together.

@q ** (2) This is what's compiled.@> 

This is what's compiled.

@c
@<Include files@>@;
@<Define |class Conic_Section_Lattice|@>@;
@<Define |struct Conic_Section_Lattice_Options|@>@;
@<Initialize |static| |class Conic_Section_Lattice| data members@>@;
@<Declare non-member template functions for |Conic_Section_Lattice|@>@;
@<Define |Conic_Section_Lattice| functions@>@;
@<Define |Conic_Section_Lattice_Options| functions@>@;

@q ** (2) This is what's written to "cncsctlt.h".@> 

@ This is what's written to \filename{cncsctlt.h}.

@(cncsctlt.h@>=
@<Define |class Conic_Section_Lattice|@>@;
@<Define |struct Conic_Section_Lattice_Options|@>@;
@<Declare non-member template functions for |Conic_Section_Lattice|@>@;


@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>



@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q run-mp-on-file:"persp.mp" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
