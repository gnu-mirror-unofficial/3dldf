%%%% sphrprj2.ldf
%%%% Created by Laurence D. Finston (LDF) Wed 10 Nov 2021 07:31:55 AM CET

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation, Inc.  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de


verbatim_metapost "verbatimtex \font\large=cmr12\font\largebx=cmbx12 etex;";
verbatim_metapost "verbatimtex \font\small=cmr7 etex;";

verbatim_metapost "prologues := 3;";

%% *** (3) Declarations

%% **** (4) Global variables

triangle a[][];
path r[][];
point A[][][];
point P[];
path Q[];



%% **** (4) Macro draw_sphere_projection

macro draw_sphere_projection;

%% !! START HERE:  LDF 2021.11.18.  Add parameters to macro.
% numeric small_pen_diam;
% numeric medium_pen_diam;
% numeric large_pen_diam;

def draw_sphere_projection {numeric rradius, boolean do_labels, boolean do_dashed} =

  
  numeric i, j;

  point p[];
  point temp_pt[];
  
  transform t[];

  picture vv[];

  pen dashed_pen;
  pen border_pen;
  pen large_pen;

  large_pen := pencircle scaled (.75mm, .75mm, .75mm);
  
  string s;

  numeric ang;
  
  ang := 15;  %% Arcs of (2 * ang == 30) degrees are used to find the points
              %% on the sphere that represent the corners of the trapezoids
              %% into which the surface of the sphere is divided.
              %% LDF 2010.08.06.

  focus f[];

  boolean do_thick_pens;

  set f0 with_position  (3, 10, -20) 
    with_direction (3, 10, 10) with_distance 20; 



  path m[];


  
%% *** (3) Set boolean values

%% These can be used for testing.  LDF 2010.08.04.

  do_thick_pens  	   := false; % true % true for testing

  if do_thick_pens:
    %message "Using thick pens";
    dashed_pen := pencircle scaled (.75mm, .75mm, .75mm);
    border_pen := pencircle scaled (.75mm, .75mm, .75mm);
  else:
    %message "Not using thick pens";
    dashed_pen := pencircle scaled (.5mm, .5mm, .5mm);
    border_pen := pencircle scaled (.5mm, .5mm, .5mm);
  fi;

% message "dashed_pen:"; 
% show dashed_pen;

% message "border_pen:"; 
% show border_pen;

%% **** (4)

  pickup pencircle scaled (.25mm, .25mm, .25mm);

%% **** (4)

  p0 := origin;
  p1 := (0, 1, 0);

  p2 := (rradius, 0);

  p3 := p2 rotated (0, 0,  ang);
  p4 := p2 rotated (0, 0, -ang);

  rotate p3 (0, ang);
  rotate p4 (0, ang);

  p5 := p2 rotated (0, 0, ang);
  p6 := p2 rotated (0, 0, -ang);

  rotate p5 (0, -ang);
  rotate p6 (0, -ang);

% message "p2:";
% show p2;

% message "p3:";
% show p3;

% message "p4:";
% show p4;

% message "p5:";
% show p5;

% message "p6:";
% show p6;


  m0 := p5 -- p3 -- p2 -- cycle;
  %draw m0;
  m1 := p5 -- p2 -- p6 -- cycle;
  %draw m1;
  m2 := p6 -- p4 -- p2 -- cycle;
  %draw m2;
  m3 := p4 -- p3 -- p2 -- cycle;
  %draw m3;

  
%% **** (4)

  p7 := p2 rotated (0, 0,  3ang);
  rotate p7 (0, ang);

  p8  := p2 rotated (0, 0, 3ang);

  rotate p8 (0, -ang);

  p9 := p2 rotated (0, 0, 2ang);

% message "magnitude (p9 - p7):"; 
% show magnitude (p9 - p7);

% message "magnitude (p9 - p8):"; 
% show magnitude (p9 - p8);

% message "p7:";
% show p7;

% message "p8:";
% show p8;

% message "p9:";
% show p9;

  m4 := p8 -- p9 -- p7 -- cycle;
  %draw m4;
  m5 := p8 -- p9 -- p5 -- cycle;
  %draw m5;
  m6 := p5 -- p9 -- p3 -- cycle;
  %draw m6;
  m7 := p3 -- p9 -- p7 -- cycle;
  %draw m7;

  
%% **** (4)

  p10 := p2 rotated (0, 0,  -3ang);
  rotate p10 (0, ang);

  p11  := p2 rotated (0, 0, -3ang);

  rotate p11 (0, -ang);

  p12 := p2 rotated (0, 0, -2ang);

% message "magnitude (p12 - p10):"; 
% show magnitude (p12 - p10);

% message "magnitude (p12 - p11):"; 
% show magnitude (p12 - p11);

% message "p10:";
% show p10;

% message "p11:";
% show p11;

% message "p12:";
% show p12;

  m8 := p6 -- p12 -- p11  -- cycle;
  %draw m8;
  m9 := p11 -- p12 -- p10 -- cycle;
  %draw m9;
  m10 := p10 -- p12 -- p4  -- cycle;
  %draw m10;
  m11 := p4 -- p12 -- p6   -- cycle;
  %draw m11;

%% **** (4)

  p13 := p2 rotated (0, 0,  5ang);
  rotate p13 (0, ang);

  p14  := p2 rotated (0, 0, 5ang);
  rotate p14 (0, -ang);

  p15 := p2 rotated (0, 0, 4ang);

% message "magnitude (p15 - p13):"; 
% show magnitude (p15 - p13);

% message "magnitude (p15 - p14):"; 
% show magnitude (p15 - p14);

% message "p13:";
% show p13;

% message "p14:";
% show p14;

% message "p15:";
% show p15;

  m12 := p14 -- p15 -- p8 -- cycle;
  %draw m12;
  m13 := p8 -- p15 -- p7 -- cycle;
  %draw m13;
  m14 := p7 -- p15 -- p13 -- cycle;
  %draw m14;
  m15 := p13 -- p15 -- p14 -- cycle;
  %draw m15;

%% **** (4)

  p16 := p2 rotated (0, 0,  -5ang);
  rotate p16 (0, ang);

  p17  := p2 rotated (0, 0, -5ang);
  rotate p17 (0, -ang);

  p18 := p2 rotated (0, 0, -4ang);

% message "magnitude (p18 - p16):"; 
% show magnitude (p18 - p16);

% message "magnitude (p18 - p17):"; 
% show magnitude (p18 - p17);

% message "p16:";
% show p16;

% message "p17:";
% show p17;

% message "p18:";
% show p18;

  m16 := p17 -- p18 -- p11 -- cycle;
  %draw m16;
  m17 := p10 -- p18 -- p11 -- cycle;
  %draw m17;
  m18 := p10 -- p18 -- p16 -- cycle;
  %draw m18;
  m19 := p16 -- p18 -- p17 -- cycle;
  %draw m19;


%% **** (4)

  p19 := (0, rradius);
  p20 := (0, -rradius);

  m20 := p14 -- p19 -- p13 -- cycle;
  %draw m20;
  m21 := p16 -- p20 -- p17 -- cycle;
  %draw m21;

%% **** (4) This can be used to determine which triangles are on or above the x-z plane.
%%          Since it's always the same, there's no need to calculate it.  The values
%%          found are used explicitly below.
%%          LDF 2021.11.10.

  % numeric_vector nv;
  
  % n := 0;
  % for i = 0 upto 21:
  %   j := ypart (get_point 0 m[i]);
  %   message "ypart (get_point 0 m[" & decimal i & "]):";
  %   show j;
  %   if j >= 0:
  %     message "filling.";
  %     fill m[i] with_color cv[n];
  %     n += 1;
  %     nv += i;
  %   else:
  %     message "Not filling.";
  %   fi;
  % endfor;

  % message "size nv:";
  % show size nv;
  
  % for i = 0 upto ((size nv) - 1):
  %   message "nv[" & decimal i & "] == " & decimal nv[i];
  %   j := nv[i];
  %   label("{\largebx " & decimal j & "}", mediate(mediate(get_point 0 m[j], get_point 1 m[j]), get_point 2 m[j]));
  % endfor;

%% **** (4) These are the triangles that are on or above the x-z plane.

  r[0][0] := m20;
  r[0][1] := m15;
  r[0][2] := m14;
  r[0][3] := m12;
  r[0][4] := m13;
  r[0][5] := m4;
  r[0][6] := m7;
  r[0][7] := m5;
  r[0][8] := m6;
  r[0][9] := m0;

  for j = 1 upto 11:
    for i = 0 upto 9:
      r[j][i] := r[0][i] rotated (0, j * 2ang);
    endfor;
  endfor;

%% **** (4) "Flatten" the triangles onto the x-z plane.  That is, the `r' triangles are
%%          copied (to `a') and the y-coordinates of all the points on the `a' triangles
%%          are set to 0.  The resulting triangles are then drawn.
%%          LDF 2021.11.10.
  
  for i = 0 upto 11:
    for j = 0 upto 9:
      temp_pt0 := get_point 0 r[i][j];
      temp_pt1 := get_point 1 r[i][j];
      temp_pt2 := get_point 2 r[i][j];

      temp_pt3 := (xpart temp_pt0, 0, zpart temp_pt0);
      temp_pt4 := (xpart temp_pt1, 0, zpart temp_pt1);
      temp_pt5 := (xpart temp_pt2, 0, zpart temp_pt2);

      set a[i][j] with_points (temp_pt3, temp_pt4, temp_pt5);
      draw a[i][j];

      if do_labels:
	label("$a_{" & decimal i & "}^{" & decimal j & "}$",
	    get_center a[i][j]);
      fi;
      
    endfor;
  endfor;
  
  % temp_pt6 := get_center a[11][9];
  % show temp_pt6;

  % dotlabel.top("0", get_point 0 a[11][9]);
  % dotlabel.rt("1", get_point 1 a[11][9]);
  % dotlabel.top("2", get_point 2 a[11][9]);
  
%% **** (4) Tick marks and gray lines
  
  point q[];
  
  q0 := (-(radius+1), 0, radius+1);
  q1 := (0, 0, (radius+1));
  q2 := (radius+1, 0, radius+1);
  q3 := (-(radius+1), 0);
  q4 := (radius+1, 0);
  q5 := (-(radius+1), 0, -(radius+1));
  q6 := (0, 0, -(radius+1));
  draw q3 -- q4 dashed evenly with_color dark_gray with_pen pencircle scaled (.5mm, .5mm, .5mm);
  draw q1 -- q6 dashed evenly with_color dark_gray with_pen pencircle scaled (.5mm, .5mm, .5mm);

%% **** (4)
  
  current_picture += vv0;

  drawdot origin with_color white with_pen pencircle scaled (.25cm, .25cm, .25cm);
  drawdot origin with_color black with_pen pencircle scaled (1mm, 1mm, 1mm);

  draw q0 -- (q0 shifted (-.5cm, 0));
  draw q0 -- (q0 shifted (.5cm, 0));
  draw q0 -- (q0 shifted (0, 0, .5cm));
  draw q0 -- (q0 shifted (0, 0, -.5cm));

  draw q1 -- (q1 shifted (-.5cm, 0));
  draw q1 -- (q1 shifted (.5cm, 0));
  draw q1 -- (q1 shifted (0, 0, .5cm));
  draw q1 -- (q1 shifted (0, 0, -.5cm));

  label.top("{\large Radius of Sphere:  " & decimal radius & "cm}", q1 shifted (0, 0, 1cm));
  

  if do_dashed:
    draw q2 -- (q2 shifted (-.5cm, 0));
    draw q2 -- (q2 shifted (.5cm, 0));
    draw q2 -- (q2 shifted (0, 0, .5cm));
    draw q2 -- (q2 shifted (0, 0, -.5cm));


    draw q3 -- (q3 shifted (-.5cm, 0));
    draw q3 -- (q3 shifted (.5cm, 0));
    draw q3 -- (q3 shifted (0, 0, .5cm));
    draw q3 -- (q3 shifted (0, 0, -.5cm));


    draw q4 -- (q4 shifted (-.5cm, 0));
    draw q4 -- (q4 shifted (.5cm, 0));
    draw q4 -- (q4 shifted (0, 0, .5cm));
    draw q4 -- (q4 shifted (0, 0, -.5cm));

    draw q5 -- (q5 shifted (-.5cm, 0));
    draw q5 -- (q5 shifted (.5cm, 0));
    draw q5 -- (q5 shifted (0, 0, .5cm));
    draw q5 -- (q5 shifted (0, 0, -.5cm));

    draw q6 -- (q6 shifted (-.5cm, 0));
    draw q6 -- (q6 shifted (.5cm, 0));
    draw q6 -- (q6 shifted (0, 0, .5cm));
    draw q6 -- (q6 shifted (0, 0, -.5cm));

    q7 := (radius+1, 0, -(radius+1));
    draw q7 -- (q7 shifted (-.5cm, 0));
    draw q7 -- (q7 shifted (.5cm, 0));
    draw q7 -- (q7 shifted (0, 0, .5cm));
    draw q7 -- (q7 shifted (0, 0, -.5cm));
  fi;
  
%% **** (4)

  for i = 0 upto 11:
    for j = 0 upto 9:
      A[i][j][0] := get_point 0 a[i][j];
      A[i][j][1] := get_point 1 a[i][j];
      A[i][j][2] := get_point 2 a[i][j];
      A[i][j][3] := mediate(get_point 0 a[i][j], get_point 1 a[i][j]);
      A[i][j][4] := mediate(get_point 1 a[i][j], get_point 2 a[i][j]);
      A[i][j][5] := mediate(get_point 2 a[i][j], get_point 0 a[i][j]);
    endfor;
  endfor;
      
  
  P0 := A[0][9][2];
  P1 := A[1][9][2];
  P2 := (.5 * unit_vector(P1 - P0)) shifted by P0;
  P3 := (.5 * unit_vector(P0 - P1)) shifted by P1;
  P4 := P2 shifted (0, 1);
  P5 := P0 rotated_around (P2, P4) 90;
  P6 := P5 shifted by (P3 - P2);

  P7 := mediate(P0, P2);
  P8 := P7 rotated (180, 0);

  P9  := P7 shifted (.5cm, 0);
  P10 := P8 shifted (.5cm, 0);

  Q0 := P2 -- P5 -- P6 -- P3;

  Q1 := P8 -- P10 -- P9 -- P7;

  % dotlabel.top("${A_0^9}_0$", A[0][9][0]);
  % dotlabel.top("${A_0^9}_1$", A[0][9][1]);
  % dotlabel.top("${A_0^9}_2$", A[0][9][2]);
  % dotlabel.top("${A_0^9}_3$", A[0][9][3]);
  % dotlabel.top("${A_0^9}_4$", A[0][9][4]);
  % dotlabel.top("${A_0^9}_5$", A[0][9][5]);

  
  % dotlabel.rt("$P_0$", P0);
  % dotlabel.rt("$P_1$", P1);
  % dotlabel.rt("$P_2$", P2);
  % dotlabel.rt("$P_3$", P3);
  % dotlabel.rt("$P_5$", P5);
  % dotlabel.rt("$P_6$", P6);
  % dotlabel.rt("$P_7$", P7);
  % dotlabel.rt("$P_8$", P8);
  % dotlabel.rt("$P_9$", P10);
  % dotlabel.rt("$P_10$", P10);

enddef;


%% *** (3) Figure 0, 8cm


numeric radius;

% color_vector cv;

% cv += red;
% cv += green;
% cv += blue;
% cv += cyan;
% cv += magenta;
% cv += yellow;
% cv += orange;
% cv += violet;
% cv += brown;
% cv += yellow_green;
% cv += green_yellow;
% cv += dark_green;
% cv += blue_violet;
% cv += gray;
% cv += light_gray;
% cv += dark_gray;
% cv += violet_red;
% cv += pink;

picture v[];

%% *** (3)

beginfig(0);
  radius := 8;
  draw_sphere_projection {radius, true, true};

  for i = 0 step 30 until 330:
    draw (Q0 rotated (0, i)) with_pen pencircle scaled (.25mm, .25mm, .25mm);
    undrawdot P2 rotated (0, i) with_pen pencircle scaled (.25mm, .25mm, .25mm);
    undrawdot P3 rotated (0, i) with_pen pencircle scaled (.25mm, .25mm, .25mm);

    draw (Q1 rotated (0, i)) with_pen pencircle scaled (.25mm, .25mm, .25mm);
    undrawdot P7 rotated (0, i) with_pen pencircle scaled (.25mm, .25mm, .25mm);
    undrawdot P8 rotated (0, i) with_pen pencircle scaled (.25mm, .25mm, .25mm);
    
  endfor;

  for i = 0 upto 11:
    for j = 0 upto 9:
      draw a[i][j] with_pen pencircle scaled (1mm, 1mm, 1mm);
    endfor;
  endfor;

  for i = 0 upto 11:
    for j = 0 upto 9:
      undraw a[i][j] with_pen pencircle scaled (.5mm, .5mm, .5mm);
    endfor;
  endfor;


  
  drawdot origin with_pen pencircle scaled (.25cm + 2pt, .25cm + 2pt, .25cm + 2pt);
  undrawdot origin with_pen pencircle scaled (.25cm, .25cm, .25cm);
  draw (-.25cm, 0) -- (.25cm, 0) with_pen pencircle scaled (.25mm, .25mm, .25mm);
  draw (0, 0,  -.25cm) -- (0, 0, .25cm) with_pen pencircle scaled (.25mm, .25mm, .25mm);
  drawdot origin with_pen pencircle scaled (.5mm, .5mm, .5mm);




  
endfig with_projection parallel_x_z no_sort;

%% *** (3)

beginfig(1);
  radius := 8;
  draw_sphere_projection {radius, true, true};

  for i = 0 step 30 until 330:
    draw (Q0 rotated (0, i)) with_pen pencircle scaled (.5mm, .5mm, .5mm);
    undrawdot P2 rotated (0, i) with_pen pencircle scaled (.5mm, .5mm, .5mm);
    undrawdot P3 rotated (0, i) with_pen pencircle scaled (.5mm, .5mm, .5mm);

    draw (Q1 rotated (0, i)) with_pen pencircle scaled (.5mm, .5mm, .5mm);
    undrawdot P7 rotated (0, i) with_pen pencircle scaled (.5mm, .5mm, .5mm);
    undrawdot P8 rotated (0, i) with_pen pencircle scaled (.5mm, .5mm, .5mm);
    
  endfor;

  for i = 0 upto 11:
    for j = 0 upto 9:
      draw a[i][j] with_pen pencircle scaled (2mm, 2mm, 2mm);
      undraw a[i][j] with_pen pencircle scaled (1mm, 1mm, 1mm);
    endfor;
  endfor;


  drawdot origin with_pen pencircle scaled (.25cm + 2pt, .25cm + 2pt, .25cm + 2pt);
  undrawdot origin with_pen pencircle scaled (.25cm, .25cm, .25cm);
  drawdot origin with_pen pencircle scaled (.5mm, .5mm, .5mm);
  draw (-.25cm, 0) -- (.25cm, 0) with_pen pencircle scaled (.25mm, .25mm, .25mm);
  draw (0, 0,  -.25cm) -- (0, 0, .25cm) with_pen pencircle scaled (.25mm, .25mm, .25mm);
endfig with_projection parallel_x_z no_sort;



%% *** (3)

beginfig(2);
  radius := 8;
  draw_sphere_projection {radius, true, true};
  fill a[0][0] with_color blue;
  fill a[6][0] with_color blue;
  fill a[3][0] with_color red;
  fill a[9][0] with_color red;
  fill a[1][0] with_color yellow;
  fill a[11][0] with_color yellow;
  fill a[5][0] with_color yellow;
  fill a[7][0] with_color yellow;
  fill a[2][0] with_color orange;
  fill a[4][0] with_color orange;
  fill a[8][0] with_color orange;
  fill a[10][0] with_color orange;
endfig with_projection parallel_x_z no_sort;

%% *** (3) End of 3DLDF code

verbatim_metapost "end;";

end;



%% ** (2) 

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%       GNU Emacs editor.  The local variable list is not evaluated when an 
%%       indirect buffer is visited, so it's necessary to evaluate the       
%%       following s-expression in order to use the facilities normally      
%%       accessed via the local variables list.                              
%%       LDF 2004.02.12.

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80) (ignore '(  
%% )) (setq outline-regexp "%% [*\f]+"))

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metapost
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% End:

