@q conicsct.web@>
      
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Conic_Sections.@>
@** Conic Sections\quad ({\tt conicsct\PERIOD web}).\hfil

\LOG
\initials{LDF 2005.11.01.}
Created this file.
\ENDLOG 

\immediate\write\functexifile{File:  conicsct.web^^J}

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"

@q * (1) Conic_Section class definition.@>
@* {\bf Conic\_Section} class definition.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this |class| definition.

\initials{LDF 2005.11.01.}
I tried deriving |Reg_Cl_Plane_Curve| and |Conic_Section|
from |Path| using |virtual|, but it didn't work.
I think it may have something to do with |Path::operator=()|.

\initials{LDF 2005.11.07.}
Added |Point vertex| and |real parameter|.

\initials{LDF 2005.11.09.}
Added |Path directrix|.

\initials{LDF 2005.11.09.}
Added |static const real DEFAULT_PARAMETER|.

\initials{LDF 2005.11.09.}
Added the |static const reals| |DEFAULT_MAX_EXTENT| and 
|DEFAULT_INCREMENT_VALUE|.

\initials{LDF 2005.11.14.}
Changed |focus0| and |focus1| to |focus_0| and |focus_|.
Replaced |vertex| with |vertex_0| and |vertex_1|.
Made the corresponding changes everywhere else without comment.

\initials{LDF 2005.11.25.}
Added |real axis_h| and |real axis_v|.

\initials{LDF 2005.11.28.}
Added |real max_extent|.
\ENDLOG

@<Define |class Conic_Section|@>=

class Conic_Section
{

   protected:
   
      unsigned short conic_section_type;

      Point focus_0;
      Point focus_1;
      Point vertex_0;
      Point vertex_1;
      real parameter;
      Path directrix;      

      real axis_h;
      real axis_v;

      real max_extent;


      real linear_eccentricity;
      real numerical_eccentricity;

   public:

       
      static const unsigned short CONIC_SECTION_NULL_TYPE;
      static const real           DEFAULT_PARAMETER;
      static const real           DEFAULT_MAX_EXTENT;
      static const real           DEFAULT_INCREMENT_VALUE;

      @<Declare |Conic_Section| functions@>@;
};

@q ** (2) Static member variable definitions.@>
@*1 Static member variable definitions.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.

\initials{LDF 2005.11.09.}
Now setting |const real DEFAULT_PARAMETER = 1|.

\initials{LDF 2005.11.09.}
Now setting the |const real DEFAULT_MAX_EXTENT = 10| and 
|const real DEFAULT_INCREMENT_VALUE = .25|.
\ENDLOG

@q *** (3) Code.@> 

@<Define |static| |class Conic_Section| data members@>=

   const unsigned short Conic_Section::CONIC_SECTION_NULL_TYPE   = 0;

   const real           Conic_Section::DEFAULT_PARAMETER         = 1;

   const real           Conic_Section::DEFAULT_MAX_EXTENT        = 10;
   const real           Conic_Section::DEFAULT_INCREMENT_VALUE   = .25;


@q * (1) Destructor.@> 
@* Destructor.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function.

\initials{LDF 2005.11.09.}
Now calling |directrix.clear()|.
\ENDLOG

@<Declare |Conic_Section| functions@>=
virtual
~Conic_Section(void);

@q *** (3) Definition.  @>

@
@<Define |Conic_Section| functions@>= 
Conic_Section::~Conic_Section(void)
{
   directrix.clear();
   return;
}

@q * (1) Assignment.@> 
@* Assignment.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.
\ENDLOG

@q ** (2) Assignment from a |Conic_Section|.@> 
@*1 Assignment from a |Conic_Section|.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function.

\initials{LDF 2005.11.09.}
Now assigning to the data members.

\initials{LDF 2005.11.17.}
@:BUG FIX@> BUG FIX:  Now assigning to the |reals| |parameter|,
|linear_eccentricity|, and |numerical_eccentricity|.

\initials{LDF 2005.11.27.}
@:BUG FIX@> BUG FIX:  Now assigning to the |reals| 
|axis_h| and |axis_v|.

\initials{LDF 2005.11.28.}
Now setting |real max_extent| to |c.max_extent|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual
Conic_Section&
operator=(const Conic_Section& c);

@q *** (3) Definition.@> 

@
@<Define |Conic_Section| functions@>=

Conic_Section&
Conic_Section::operator=(const Conic_Section& c)
{
    if (this == &c) /* Make sure it's not self-assignment. */
       return *this;

    clear();

    conic_section_type  = c.conic_section_type;
    focus_0             = c.focus_0;
    focus_1             = c.focus_1;
    vertex_0            = c.vertex_0;
    vertex_1            = c.vertex_1;
    directrix           = c.directrix;

    axis_h              = c.axis_h;   
    axis_v              = c.axis_v;

    max_extent          = c.max_extent;

    parameter           = c.parameter;
    linear_eccentricity = c.linear_eccentricity;
    numerical_eccentricity = c.numerical_eccentricity;

    return *this;

}  /* End of |Conic_Section::operator=(const Conic_Section& h)| definition.  */


@q * (1) Pascal's Theorem and the Braikenridge-Maclaurin Construction.@> 
@* Pascal's Theorem and the Braikenridge-Maclaurin Construction.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this section.
\ENDLOG

@q ** (2) Are on conic section.@> 
@* Are on conic section.
\initials{LDF 2007.07.09.}

@q *** (3) Five |Point| arguments.@> 
@*2 Five {\bf Point} arguments.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.

\initials{LDF 2007.07.20.}
Changed return value from |signed short| to |bool|.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section| functions@>=
static
bool
are_on_conic_section(const Point& A,
                     const Point& B,
                     const Point& C,
                     const Point& D,
                     const Point& E,
                     const Point& F,
                     void* parameter = 0,
                     real tolerance = -1,
                     Pointer_Vector<Point>* isect_pv = 0);

@q **** (4) Definition.@> 
@
@<Define |Conic_Section| functions@>=
bool
Conic_Section::are_on_conic_section(const Point& A,
                                    const Point& B,
                                    const Point& C,
                                    const Point& D,
                                    const Point& E,
                                    const Point& F,
                                    void* parameter,
                                    real tolerance,
                                    Pointer_Vector<Point>* isect_pv)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Conic_Section::are_on_conic_section' "
                << "with six `Point' arguments.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    

@q ***** (5) Make sure points all differ.@> 
@ Make sure points all differ.
\initials{LDF 2007.07.20.}

\LOG
\initials{LDF 2007.07.20.}
Added this section.
\ENDLOG

@<Define |Conic_Section| functions@>=

   if (  A == B || A == C || A == D || A == E || A == F
                || B == C || B == D || B == E || B == F
                          || C == D || C == E || C == F
                                    || D == E || D == F
                                              || E == F)
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "The six points don't all differ."
                 << "Exiting function unsuccessfully with return value `false'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return false;

   }  /* At least two |Points| are equal.  */


@q ***** (5) Make sure points are non-colinear.@> 
@ Make sure points are non-colinear.
\initials{LDF 2007.07.20.}

\LOG
\initials{LDF 2007.07.20.}
Added this section.
\ENDLOG

@<Define |Conic_Section| functions@>=

   if (   C.is_on_line(A, B).first 
       && D.is_on_line(A, B).first 
       && E.is_on_line(A, B).first
       && F.is_on_line(A, B).first)
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "The six points are all colinear."
                 << "Exiting function unsuccessfully with return value `false'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return false;

   }  /* |Points| are all colinear.  */


@q ***** (5) Make sure points are coplanar.@> 
@ Make sure points are coplanar.
\initials{LDF 2007.07.20.}

\LOG
\initials{LDF 2007.07.20.}
Added this section.
\ENDLOG

@<Define |Conic_Section| functions@>=


   Point normal;

@q ****** (6)@> 

   if ((normal = C.get_normal(A, B)) == INVALID_POINT)
   {
    if ((normal = D.get_normal(A, B)) == INVALID_POINT)
    {
     if ((normal = E.get_normal(A, B)) == INVALID_POINT)
     {
      if ((normal = F.get_normal(A, B)) == INVALID_POINT)
      {
       if ((normal = D.get_normal(B, C)) == INVALID_POINT)              
       {
        if ((normal = E.get_normal(B, C)) == INVALID_POINT)
        {
         if ((normal = F.get_normal(B, C)) == INVALID_POINT)
         {
          if ((normal = E.get_normal(C, D)) == INVALID_POINT)
          {
           if ((normal = F.get_normal(C, D)) == INVALID_POINT)
           {
            if ((normal = F.get_normal(D, E)) == INVALID_POINT)
            {
                cerr_strm << thread_name << "ERROR!  "
                          << "In `Conic_Section::are_on_conic_section':"
                          << endl 
                          << "Failed to set `Point normal'."
                          << "Exiting function unsuccessfully with return value `false'.";

                log_message(cerr_strm);
                cerr_message(cerr_strm, error_stop_value);
                cerr_strm.str("");

                return false;
                
            }}}}}}}}}}


#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr_mutex.lock(); 
              cerr << thread_name << "In `Conic_Section::are_on_conic_section':"
                   << endl;
              normal.show("`normal':");
              cerr_mutex.unlock();  
           }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@> 

   Plane q(A, normal);

   if (q == INVALID_PLANE)
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "Failed to create `Plane'.  "
                 << "Exiting function unsuccessfully with return value `false'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return false;

   }
#if DEBUG_COMPILE
   else
   {
       if (DEBUG)
       {
           
              cerr_mutex.lock(); 
              cerr << thread_name << "In `Conic_Section::are_on_conic_section':"
                   << endl;
              q.show("`Plane q':");
              cerr_mutex.unlock();  

       }  /* |if (DEBUG)|  */
   }   
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@> 

   if (!(   B.is_on_plane(q, tolerance) && C.is_on_plane(q, tolerance) 
         && D.is_on_plane(q, tolerance) && E.is_on_plane(q, tolerance) 
         && F.is_on_plane(q, tolerance)))
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "Points are not all coplanar.  "
                 << "Exiting function unsuccessfully with return value `false'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return false;
   }
#if DEBUG_COMPILE
   else
   {
       if (DEBUG)
       {
           cerr_strm << thread_name << "In `Conic_Section::are_on_conic_section':"
                     << endl 
                     << "Points are all coplanar.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");          
       }  /* |if (DEBUG)|  */
   }
#endif /* |DEBUG_COMPILE|  */@; 


@q ****** (6) End of testing for whether the |Points| are coplanar.@> 

@q ***** (5)@> 

   Point X;
   Point Y;
   Point Z;

   Bool_Point bp;

@q ***** (5) Find |Point X|.@> 
@ Find |Point X|.
\initials{LDF 2007.07.15.}

@<Define |Conic_Section| functions@>=

   bp =  Point::intersection_point(A, C, D, B);

   if (bp.b == false || bp.pt == INVALID_POINT)
   {
         cerr_strm << thread_name << "ERROR!  "
                   << "In `Conic_Section::are_on_conic_section':"
                   << endl 
                   << "The line segments `AC' and `DB' don't intersect.  "
                   << "Can't find point `X'."
                   << endl 
                   << "Exiting function unsuccessfully with return value `false'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         return false;

   }  /* |if (bp.b == false || bp.pt == INVALID_POINT)|  */


@q ****** (6)@> 

   else
   {
      X = bp.pt;

      if (isect_pv != static_cast<Pointer_Vector<Point>*>(0))
         *isect_pv += create_new<Point>(X);

#if DEBUG_COMPILE
      if (DEBUG)
      {
         cerr_mutex.lock(); 
         X.show("X:");
         cerr_mutex.unlock();  

      }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;    

   }  /* |else|  */

@q ***** (5) Find |Point Y|.@> 
@ Find |Point Y|.
\initials{LDF 2007.07.15.}

@<Define |Conic_Section| functions@>=

   bp =  Point::intersection_point(C, F, B, E);

   if (bp.b == false || bp.pt == INVALID_POINT)
   {
         cerr_strm << thread_name << "ERROR!  "
                   << "In `Conic_Section::are_on_conic_section':"
                   << endl 
                   << "The line segments `CF' and `BE' don't intersect.  "
                   << "Can't find point `Y'."
                   << endl 
                   << "Exiting function unsuccessfully with return value `false'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         delete isect_pv;
         isect_pv = 0;

         return false;

   }  /* |if (bp.b == false || bp.pt == INVALID_POINT)|  */


@q ****** (6)@> 

   else
   {
      Y = bp.pt;

      if (isect_pv != static_cast<Pointer_Vector<Point>*>(0))
         *isect_pv += create_new<Point>(Y);

#if DEBUG_COMPILE
      if (DEBUG)
      {
         cerr_mutex.lock(); 
         Y.show("Y:");
         cerr_mutex.unlock();  

      }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;    

   }  /* |else|  */

@q ***** (5) Find |Point Z|.@> 
@ Find |Point Z|.
\initials{LDF 2007.07.15.}

@<Define |Conic_Section| functions@>=

   bp =  Point::intersection_point(F, D, E, A);

   if (bp.b == false || bp.pt == INVALID_POINT)
   {
         cerr_strm << thread_name << "ERROR!  "
                   << "In `Conic_Section::are_on_conic_section':"
                   << endl 
                   << "The line segments `FD' and `EA' don't intersect.  "
                   << "Can't find point `Z'."
                   << endl 
                   << "Exiting function unsuccessfully with return value `false'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         delete isect_pv;
         isect_pv = 0;

         return false;

   }  /* |if (bp.b == false || bp.pt == INVALID_POINT)|  */


@q ****** (6)@> 

   else
   {
      Z = bp.pt;

      if (isect_pv != static_cast<Pointer_Vector<Point>*>(0))
         *isect_pv += create_new<Point>(Z);

#if DEBUG_COMPILE
      if (DEBUG)
      {
         cerr_mutex.lock(); 
         Z.show("Z:");
         cerr_mutex.unlock();  

      }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;    

   }  /* |else|  */


@q ***** (5) Determine whether |X|, |Y|, and |Z| are colinear and return.@> 
@ Determine whether |X|, |Y|, and |Z| are colinear and return.
\initials{LDF 2007.07.20.}

@<Define |Conic_Section| functions@>=

@q ***** (5)@> 

   bool b = X.is_on_line(Y, Z).first;

   if (b == false)
   {
       delete isect_pv;
       isect_pv = 0;
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Exiting `Conic_Section::are_on_conic_section' "
                 << "with return value " << b << ".";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   return b;

}  /* End of |Conic_Section::are_on_conic_section| definition.  */


@q *** (3) |Pointer_Vector<Point>*| argument.@> 
@*2 {\bf Pointer\_Vector\<Point>*} argument.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Conic_Section| functions@>=
static
signed short
are_on_conic_section(Pointer_Vector<Point>* pv,
                     void* parameter = 0,
                     real tolerance = -1,
                     Pointer_Vector<Point>* isect_pv = 0,
                     bool ignore_extra_points = true);

@q **** (4) Definition.@> 
@
@<Define |Conic_Section| functions@>=
signed short
Conic_Section::are_on_conic_section(Pointer_Vector<Point>* pv,
                                    void* parameter,
                                    real tolerance,
                                    Pointer_Vector<Point>* isect_pv,
                                    bool ignore_extra_points)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Conic_Section::are_on_conic_section' "
                << "with `Pointer_Vector<Point>*' argument.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    

    bool b;

@q ***** (5)@> 
@
@<Define |Conic_Section| functions@>=
   
   if (pv == static_cast<Pointer_Vector<Point>*>(0))
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "`Pointer_Vector<Point>*' argument is null."
                 << endl 
                 << "Returning `false'.";

       return false;


   }  /* |if (pv == static_cast<Pointer_Vector<Point>*>(0))|  */

@q ***** (5)@> 
@
@<Define |Conic_Section| functions@>=

   else if (pv->v.size() < 6)
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "The size of the `Pointer_Vector<Point>' referred to by"
                 << endl 
                 << "the pointer argument has fewer than six elements:  "
                 << pv->v.size()
                 << endl 
                 << "Exiting function unsuccessfully with return value `false'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return false;
       
   }  /* |else if (pv->v.size() < 6)|  */

@q ***** (5)@>    
@
@<Define |Conic_Section| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "In `Conic_Section::are_on_conic_section':"
                 << endl 
                 << "Calling the version of `Conic_Section::are_on_conic_section' "
                 << "with six `Point' arguments."
                 << endl 
                 << "Will return the latter's return value.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   b = are_on_conic_section(*pv->v[0], *pv->v[1], *pv->v[2], *pv->v[3], *pv->v[4], 
                            *pv->v[5], parameter, tolerance, isect_pv);

@q ***** (5)@> 

   if (ignore_extra_points)
      return b;

@q ***** (5)@> 

   else
   {
       /* START HERE!!  Add code for this case.  LDF 2007.07.15.  */ 
   }


@q ***** (5)@> 

}  /* End of |Conic_Section::are_on_conic_section| definition.  */

@q ** (2) Generate.@> 
@*1 Generate.
\initials{LDF 2007.07.03.}

\LOG
\initials{LDF 2007.07.03.}
Added this section.
\ENDLOG

@q ** (2) |Pointer_Vector<Point>*| argument.@> 
@*2 {\bf Pointer\_Vector<Point>*} argument.
@^\cfunc{Conic\_Section}{generate}@>
\cfunctexi{Conic\_Section}{generate}
\initials{LDF 2007.07.03.}

\LOG
\initials{LDF 2005.11.24.}
Added this function.

\initials{LDF 2007.06.26.}
Changed first argument from |Pointer_Vector<Bool_Point>*|
to |Pointer_Vector<Point>*|.  I don't know why I wanted to use the 
former before.

\initials{LDF 2007.07.03.}
Changed this function from |Ellipse::create_new_ellipse| to
|Conic_Section::generate|.

\initials{LDF 2007.07.03.}
Added |const unsigned short conic_section_type| argument.

\initials{LDF 2007.07.20.}
Added optional |bool test_points| argument with the default |true|.

\initials{LDF 2007.07.20.}
Added optional |bool rectify_points| argument with the default |true|.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.06.27.}
Add error handling.
\ENDTODO 

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
static
Path*
generate(Pointer_Vector<Point>* pv,
                   int increment_value, 
                   const unsigned short conic_section_type,
                   void* parameter = 0,
                   bool test_points = true,
                   bool rectify_points = true,
                   real tolerance = -1,
                   bool ignore_extra_points = true); 

@q *** (3) Definition.@> 
@
@<Define |Conic_Section| functions@>=
Path*
Conic_Section::generate(Pointer_Vector<Point>* pv, 
                        int increment_value, 
                        const unsigned short conic_section_type,
                        void* parameter, 
                        bool test_points,
                        bool rectify_points,
                        real tolerance,
                        bool ignore_extra_points)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Conic_Section::generate'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    

@q **** (4)@> 

   Path  q[5];
   int status;

@q **** (4) Test the |Pointer_Vector<Point>|.@> 
@ Test the |Pointer_Vector<Point>|.
\initials{LDF 2007.07.15.}

\LOG
\initials{LDF 2007.07.15.}
Added this section.
\ENDLOG

@q ***** (5) Error handling:  |pv == static_cast<Pointer_Vector<Point>*>(0)|.@> 
@ Error handling:  |pv == static_cast<Pointer_Vector<Point>*>(0)|.
\initials{LDF 2007.07.15.}

@<Define |Conic_Section| functions@>=

   if (pv == static_cast<Pointer_Vector<Point>*>(0))
   {
        cerr_strm << thread_name << "ERROR!  In `Conic_Section::generate':"
                  << endl 
                  << "`Pointer_Vector<Point>* pv' is null."
                  << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 0;

   }  /* |if (pv == static_cast<Pointer_Vector<Point>*>(0))|  */

@q ***** (5) Error handling:  |*pv| doesn't contain enough |Points|.@> 
@ Error handling:  |*pv| doesn't contain enough |Points|.
\initials{LDF 2007.07.15.}

This is only done if |test_points| is |true|.
\initials{LDF 2007.07.20.}

@<Define |Conic_Section| functions@>=

   if ((test_points && pv->v.size() < 6) || (!test_points && pv->v.size() < 5))
   {
       
        cerr_strm << thread_name << "ERROR!  In `Conic_Section::generate':"
                  << endl 
                  << "`Pointer_Vector<Point>' has too few points:  "
                  << pv->v.size()
                  << endl
                  << "At least 6 are required if testing the points and "
                  << "at least 5 if not."
                  << endl 
                  << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete pv;
       pv = 0;

       return 0;

   }  /* |if (   (test_points && pv->v.size() < 6) 
              || (!test_points && pv->v.size() < 5))|  */

@q ***** (5) Test points.@> 
@ Test points.
\initials{LDF 2007.07.20.}

@<Define |Conic_Section| functions@>=

   Pointer_Vector<Point>* isect_pv = 0;

   if (test_points)
   {

      isect_pv = new Pointer_Vector<Point>;

      bool b = are_on_conic_section(pv, 
                                    parameter, 
                                    tolerance, 
                                    isect_pv, 
                                    ignore_extra_points);
   
#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "In `Conic_Section::generate':"
                 << endl 
                 << "`Conic_Section::are_on_conic_section' returned " << b;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling:  |Conic_Section::are_on_conic_section| @> 
@q ***** (5)returned |false|.                                       @> 
@ Error handling:  |Conic_Section::are_on_conic_section| 
returned |false|.
\initials{LDF 2007.07.15.}

@<Define |Conic_Section| functions@>=

      if (b == false)
      {  
          cerr_strm << thread_name << "ERROR!  In `Conic_Section::generate':"
                    << endl 
                    << "`Conic_Section::are_on_conic_section' returned `false'."
                    << endl  
                    << "Can't generate curve.  Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete isect_pv;
          isect_pv = 0;

          delete pv;
          pv = 0;

          return 0;

      }  /* |if (b == false)|  */

   }  /* |if (test_points)|  */


@q **** (4) Rectify points.@> 
@ Rectify points.  This is only done if the argument 
|bool rectify_points == true|.
\initials{LDF 2007.07.20.}

If |test_points == false|, then the points on |*pv| need to be tested for
coplanarity, so |!test_points| is passed to 
|Pointer_Vector<Point, Point>::rectify| as the latter's |test_coplanar| argument.
\initials{LDF 2007.07.20.}

@<Define |Conic_Section| functions@>=

   if (rectify_points)
   {


/* START HERE!!  LDF 2007.07.27.  */ 

#if 0 
        status = pv->rectify(!test_points, parameter);
#else
        status = 0;
#endif 

@q ***** (5)@> 

#if DEBUG_COMPILE
        if (DEBUG)
        {

            cerr_strm << thread_name << "In `Conic_Section::generate':"
                      << endl 
                      << "`Pointer_Vector<Point, Point>::rectify' returned " 
                      << status << ".";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");


        }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@> 

       if (status != 0)
       {
            cerr_strm << thread_name << "ERROR!  In `Conic_Section::generate':"
                      << endl 
                      << "`Pointer_Vector<Point, Point>::rectify' failed, returning " 
                      << status << "."
                      << endl 
                      << "Exiting function unsuccessfully with return value 0.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            delete isect_pv;
            isect_pv = 0;

            delete pv;
            pv = 0;

            return 0;

       }  /* |if (status != 0)|  */


@q ***** (5)@> 


   }  /* |if (rectify_points)|  */
   

@q **** (4)@> 
@
@<Define |Conic_Section| functions@>=

   Point A = *(pv->v[0]);
   Point B = *(pv->v[1]);
   Point C = *(pv->v[2]);
   Point D = *(pv->v[3]);
   Point E = *(pv->v[4]);
   Point F = *(pv->v[5]);

   Point X;
   Point Y;
   Point Z;

   bool XYZ_set = false;

   if (isect_pv != static_cast<Pointer_Vector<Point>*>(0) && isect_pv->v.size() >= 3)
   {
      X = *isect_pv->v[0];
      Y = *isect_pv->v[1];
      Z = *isect_pv->v[2];
      XYZ_set = true;
   }

   delete pv;
   pv = 0;

   delete isect_pv;
   isect_pv = 0;
 
@q **** (4) Ellipse.@> 
@ Ellipse.
\initials{LDF 2007.07.03.}

@<Define |Conic_Section| functions@>=

   if (conic_section_type == Shape::ELLIPSE_TYPE)
   {


   }  /* |if (conic_section_type == Shape::ELLIPSE_TYPE)|  */

@q **** (4) Circle.@> 
@ Circle.
\initials{LDF 2007.07.03.}

@<Define |Conic_Section| functions@>=

   else if (conic_section_type == Shape::CIRCLE_TYPE)
   {

   }  /* |if (conic_section_type == Shape::CIRCLE_TYPE)|  */

@q **** (4) Parabola.@> 
@ Parabola.

@<Define |Conic_Section| functions@>=

   else if (conic_section_type == Shape::PARABOLA_TYPE)
   {

   }  /* |else if (conic_section_type == Shape::PARABOLA_TYPE)|  */

@q **** (4) Hyperbola.@> 
@ Hyperbola.
\initials{LDF 2007.07.03.}

@<Define |Conic_Section| functions@>=

   else if (conic_section_type == Shape::HYPERBOLA_TYPE)
   {

   }  /* |else if (conic_section_type == Shape::HYPERBOLA_TYPE)|  */

@q **** (4) Error handling:  Invalid conic section type.@> 
@ Error handling:  Invalid conic section type.
\initials{LDF 2007.07.03.}

@<Define |Conic_Section| functions@>=

   else 
   {

       cerr_strm << thread_name << "ERROR!  IN `Conic_Section::generate':"
                 << endl 
                 << "`conic_section_type' is invalid:  "
                 << Shape::type_name_map[conic_section_type] 
                 << " (" << conic_section_type << ")"
                 << endl 
                 << "Exiting unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete pv;
       pv = 0;

       return static_cast<Path*>(0);

   }  /* Invalid conic section type  */

@q **** (4)@> 

   Point temp_pt;

@q **** (4) Outer loop.@> 

   for (int i = 0; i < 5; ++i)
   {

       q[0].set(A, C);
       q[1].set(B, D);

       X = q[0].intersection_point(q[1]).pt;

       q[2].set(B, E);
       q[3].set(A, E);

       /* Intersection point of $AC$ and $BE$  */
       Y = q[0].intersection_point(q[2]).pt;  

       Z = A;

@q ***** (5) Inner loop.@> 

      for (int j = 0; j < increment_value; ++j)
      {

         Z.set(A.mediate(E, 
               j / static_cast<real>(increment_value)));

         Y = Point::intersection_point(X, Z, B, E).pt;  
 
         q[4] += Point::intersection_point(C, Y, D, Z).pt;

      }  /* |for|  (Inner loop)  */

@q ***** (5) Shift points.@> 

   temp_pt = E;

   E = D;
   D = C;
   C = B;
   B = A;
   A = temp_pt;

@q ***** (5)@> 

   }  /* |for|  (Outer loop)  */

@q **** (4) Testing.@> 

   Path* e = create_new<Path>(0);

   *e = q[4];

@q **** (4)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Exiting `Conic_Section::generate'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;    

   return e;

}  /* End of |Conic_Section::generate| definition. */

@q * (1) Clear.@> 
@* Clear.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.

\initials{LDF 2005.11.27.}
Now setting the |reals| |axis_h| and |axis_v| to |INVALID_REAL|.

\initials{LDF 2005.11.28.}
Now setting |real max_extent| to |INVALID_REAL|.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual
int
clear(void);

@q ** (3) Definition.@> 
@
@<Define |Conic_Section| functions@>=
int
Conic_Section::clear(void)
{
     conic_section_type = CONIC_SECTION_NULL_TYPE;

     focus_0                = INVALID_POINT; 
     focus_1                = INVALID_POINT; 
     vertex_0               = INVALID_POINT;
     vertex_1               = INVALID_POINT;
     parameter              = INVALID_REAL;
      
     axis_h                 = INVALID_REAL;
     axis_v                 = INVALID_REAL;

     max_extent             = INVALID_REAL;

     linear_eccentricity    = INVALID_REAL;
     numerical_eccentricity = INVALID_REAL;

     directrix.clear();      

}  /* End of |Conic_Section::clear()| definition.  */

@q * (1) Transformations.@> 
@* Transformations.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this section.
\ENDLOG

@q ** (2) Multiplication by a |Transform| with assignment.@> 
@*1 Multiplication by a {\bf Transform} with assignment.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 
@<Declare |Conic_Section| functions@>=
virtual
Transform
operator*=(const Transform& t);

@q *** (3) Definition.@> 
@
@<Define |Conic_Section| functions@>=
Transform
Conic_Section::operator*=(const Transform& t)
{

    if (vertex_0 != INVALID_POINT)
       vertex_0 *= t;

    if (vertex_1 != INVALID_POINT)
       vertex_1 *= t;

    if (focus_0 != INVALID_POINT)
       focus_0 *= t;

    if (focus_1 != INVALID_POINT)
       focus_1 *= t;

    directrix *= t;
  

    return t;

}  /* End of |Conic_Section::operator*=(const Transform& t)| definition.  */


@q ** (2) Standardize.@> 
@*1 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function declaration.

\initials{LDF 2005.11.27.}
Changed return type from |Transform| to |Transform*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual
Transform*
standardize(Scanner_Node scanner_node = 0) const = 0;

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return Shape::CONIC_SECTION_TYPE;
}

@q ** (2) Get |focus|.@> 
@*1 Get {\bf focus}.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.

\initials{LDF 2005.11.17.}
Changed the name of this function from |get_focus_0()| to |get_focus()|.
Added optional |const unsigned short s| argument with the default 0.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual 
const Point&
get_focus(const unsigned short s = 0, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Conic_Section| functions@>=
const Point&
Conic_Section::get_focus(const unsigned short s, Scanner_Node scanner_node) const
{
   if (s == 0)
      return focus_0;
   else if (s == 1)
      return focus_1;
   else
      return INVALID_POINT;
}

@q ** (2) Get |vertex|.@> 
@*1 Get {\bf vertex}.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.

\initials{LDF 2005.11.17.}
Changed the name of this function from |get_vertex_0()| to |get_vertex()|.
Added optional |const unsigned short s| argument with the default 0.

\initials{LDF 2005.12.16.}
Changed return type from |const Point&| to |Point|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual 
Point
get_vertex(const unsigned short s = 0, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Conic_Section| functions@>=
Point
Conic_Section::get_vertex(const unsigned short s, Scanner_Node scanner_node) const
{
   if (s == 0)
      return vertex_0;
   else if (s == 1)
      return vertex_1;
   else
      return INVALID_POINT;

}

@q ** (2) Get discriminant.@> 
@*1 Get discriminant.
\initials{LDF 2005.11.17.}

\LOG
\initials{LDF 2005.11.17.}
Added this function.

\initials{LDF 2005.11.18.}
Changed |Path&| argument to |const Path&|.  Added optional 
|Transform*| argument with default 0.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Conic_Section| functions@>=
virtual 
Real_Triple
get_discriminant(const Path& p,
                 Transform* t = 0,
                 Scanner_Node scanner_node = 0) const = 0;

@q *** (3) Definition.@> 


@q * (1) Predicates.@> 
@* Predicates.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.
\ENDLOG

@q ** (2) Is conic sectional.@>
@*1 Is conic sectional.
\initials{LDF 2005.11.01.}

@q *** (3) |Path| version.@> 
@*2 {\bf Path} version.
@^\cfunc{Path}{is\_conic\_sectional}@>
\cfunctexi{Path}{is\_conic\_sectional}
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function.  It is currently commented-out.
It will be declared in \filename{paths.web}.
\ENDLOG

@q **** (4) Definition.@> 
  
@
@<Define |Path| functions@>=

#if 0 
bool
Path::is_conic_sectional(Scanner_Node scanner_node) const
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q ***** (5)@>  
  
   return false;

} /* End of |Path::is_conic_sectional()| definition.  */
#endif 

@q ** (2) Is quadratic.@>
@*1 Is quadratic.
@^\cfunc{Conic\_Section}{is\_quadratic}@>
\cfunctexi{Conic\_Section}{is\_quadratic}
\initials{LDF 2005.11.21.}

\LOG
\initials{LDF 2005.11.21.}
Added this function.
\ENDLOG

@<Declare |Conic_Section| functions@>=
virtual
bool
is_quadratic() const;

@
@<Define |Conic_Section| functions@>=
bool
Conic_Section::is_quadratic() const
{
  return true;
}

@q ** (2) Is cubic.@>
@ Is cubic.
@^\cfunc{Conic\_Section}{is\_cubic}@>
\cfunctexi{Conic\_Section}{is\_cubic}

\LOG
\initials{LDF 2005.11.21.}
Added this function.
\ENDLOG

@<Declare |Conic_Section| functions@>=
virtual
bool
is_cubic() const;

@
@<Define |Conic_Section| functions@>=
bool
Conic_Section::is_cubic() const
{
  return false;
}

@q ** (2) Is quartic.@>
@*1 Is quartic.
@^\cfunc{Conic\_Section}{is\_quartic}@>
\cfunctexi{Conic\_Section}{is\_quartic}

\LOG
\initials{LDF 2005.11.21.}
Added this function.
\ENDLOG

@<Declare |Conic_Section| functions@>=
virtual
bool
is_quartic() const;

@
@<Define |Conic_Section| functions@>=
bool
Conic_Section::is_quartic() const
{
  return false;
}

@q * (1) Intersections.@> 
@* Intersections.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
Added this section.
\ENDLOG

@q ** (2) |Plane| reference argument.@> 
@*1 {\bf Plane} reference argument.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
Added this function.
\ENDLOG


@<Declare |Conic_Section| functions@>=
Path*
intersection(const Plane& p, Scanner_Node scanner_node = 0) const;

@q ***** (5) Definition.@> 

@
@<Define |Conic_Section| functions@>=

Path* 
Conic_Section::intersection(const Plane& p, Scanner_Node scanner_node) const 
{
   return 0;  

}  /* End of |Conic_Section::intersection(const Plane&, [etc.])| definition.  */

@q * (1) Show.@> 
@* Show.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function.

\initials{LDF 2005.11.09.}
Now showing data members.

\initials{LDF 2005.11.09.}
Added code for showing |conic_section_type|.

\initials{LDF 2005.11.17.}
Now outputting |string text|.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Conic_Section| functions@>=

virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1) const;


@q ** (2) Definition.@> 

@
@<Define |Conic_Section| functions@>=
void 
Conic_Section::show(string text, char coords,
            const bool do_persp, const bool do_apply,
            Focus* f, const unsigned short proj,
            const real factor) const

{
#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (text == "")
       text = "Conic_Section:";

    cerr << text 
         << endl 
         << "conic_section_type == ";

    if (conic_section_type == CONIC_SECTION_NULL_TYPE)
       cerr << "CONIC_SECTION_NULL_TYPE" << endl;

    else if (conic_section_type == Shape::ELLIPSE_TYPE)
       cerr << "ELLIPSE_TYPE" << endl;

    else if (conic_section_type == Shape::CIRCLE_TYPE)
       cerr << "CIRCLE_TYPE" << endl;

    else if (conic_section_type == Shape::PARABOLA_TYPE)
       cerr << "PARABOLA_TYPE" << endl;

    else if (conic_section_type == Shape::HYPERBOLA_TYPE)
       cerr << "HYPERBOLA_TYPE" << endl;

    else
       {
       cerr << thread_name << "ERROR!  In `Conic_Section::show()':"
            << "Invalid `conic_section_type':  " << conic_section_type
            << endl;

               if (error_stop_value)
                  {
                      cerr << "Type <RETURN> to continue: ";
                      getchar();   
                  }
       }


    focus_0.show("focus_0:");
    focus_1.show("focus_1:");
    vertex_0.show("vertex_0:");
    vertex_1.show("vertex_1:");

    cerr << "parameter == " << parameter
         << endl 
         << "linear_eccentricity == " << linear_eccentricity
         << endl 
         << "numerical_eccentricity == " << numerical_eccentricity
         << endl;

    directrix.show("directrix:", coords, do_persp, do_apply, f, proj, factor);
 
    return;

} /* End of |Conic_Section::show()| definition.  */

@q * (1) Putting Conic_Section together. @>
@* Putting {\bf Conic\_Section} together.

\immediate\write\functexifile{^^JEnd of file:  conicsct.web^^J}

@q ** (2) This is what's compiled.@> 

This is what's compiled.

\LOG
Now including |@<Define |static| |class Conic_Section| data members@>|.
\ENDLOG 

@c
@<Include files@>@;
@<Define |class Conic_Section|@>@;
@<Define |static| |class Conic_Section| data members@>@;
@<Define |Conic_Section| functions@>@;
@<Define |Path| functions@>@;

@q ** (2) This is what's written to "conicsct.h".@> 

@ This is what's written to \filename{conicsct.h}.

@(conicsct.h@>=
@<Define |class Conic_Section|@>@;



@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>



@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q run-mp-on-file:"persp.mp" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
