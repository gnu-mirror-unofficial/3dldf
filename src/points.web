@q points.web @>
          
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with "subscribe <email-address>" as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>


@q * (0) class Point.@>
@** {\bf class Point}\quad ({\tt points\PERIOD web}).\hfil

\initials{LDF 2002.10.20.}
|Point| is the most basic drawable (not fillable!) type.  All of the
other |Shapes| contain |Points| and are ultimately defined by their
|Points| and the relationships among them.  It is therefore
understandable that \filename{points.web} is by far the largest of the
source files of 3DLDF and that |Point| has the most functions of
any class in 3DLDF.  Many of the functions in the other classes
do little more than apply the |Point| version of the function to their
|Points|. 

\LOG
\initials{LDF 2003.11.12.}  Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@q * (1)  Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"

@q * (1) Point class definition.@>
@* {\bf Point} class definition.
\initials{LDF 2002.10.20.}

\item{$\bullet$} |world_coordinates| contains the coordinates of the |Point| in the
                 global coordinate system.
\item{$\bullet$} |user_coordinates| and |view_coordinates| are not currently
                 used.
\item{$\bullet$} |user_coordinates| is intended for use with a user-defined coordinate
   system.  For example, it may be convenient to define a coordinate
   system based on a plane defined by an object in a drawing.  The
   user-defined coordinate system will be defined in terms of the global
   coordinate system and the |world_coordinates| can be derived from the
   |user_coordinates| by using the appropriate transformation.
\item{$\bullet$} |projective_coordinates| is used for projecting the
   three-dimensional |Points| onto two-dimensions for output.
   Currently, the only projection routines are for perspective
   and parallel projection.  I plan to add others (axionometric, etc.)
   soon.  
\item{$\bullet$} |transform| is used for storing the transformations
   that are applied the |Point|.  It is not necessary to update
   |world_coordinates| (or |user_coordinates|, if they're being used)
   every time a |Point| is transformed.  The transformations can be
   saved up and their result applied to the |Point| when needed.  This
   will be when the |Point| or the |Shape| or |Label| containing it is
   output, or when a function (such as |get_x|) requires up-to-date
   coordinate values.    
\item{$\bullet$} |drawdot_value|, |drawdot_color|, and |pen| are used 
   in the drawing and undrawing functions and in%
   \break |Point::output|.  They are explained below.
\item{$\bullet$} |projective_extremes| is used in outputting
   |Pictures|.  It's for culling |Points| that are invisible
   using a particular |Focus|, or that lie outside the boundaries 
   passed as arguments to |Picture::output|.
\item{$\bullet$} |do_output| is for enabling or suppressing output of
   a |Point|.  It's needed when a |Point| has been culled, as
   described above.  Culling does not actually remove a |Point| (or
   any other |Shape|) from a |Picture|, so a way of suppressing output
   is needed.  However, it must be possible to enable output again,
   because the |Picture| may be output again using a different |Focus|
   and/or different values for the boundaries.
\item{$\bullet$} |measurement_units| is a |string| that is attached to
   the numerical values of the |projective_coordinates| when the \MP/
   code is output to |out_stream|.  It is currently |"cm"| and at the
   present time (2002.10.20), it's not a good idea to use more than
   one value for a single drawing.  Changing this will only become
   urgent when I start writing the input routine.  @:!! TO DO@> TO DO.

\LOG
\initials{LDF 2002.09.18.} 
Added |projective_extremes|.  
It contains the minimum and maximum values for 
x, y, and z in |projective_coordinates|.

\initials{LDF 2003.04.01.}  
Added |WORLD_VALUES|, |PROJ_VALUES|,
|USER_VALUES|, and |VIEW_VALUES|.  They are used in |label| for
labelling |Points| using the values in |world_coordinates|,
|projective_coordinates|, etc.

\initials{LDF 2003.05.06.}  
Changed |WORLD_VALUE|, |PROJ_VALUE|,
|USER_VALUE|, and |VIEW_VALUE| to |WORLD_VALUES|, |PROJ_VALUES|,
|USER_VALUES|, and |VIEW_VALUES|.  Added |WORLD_VALUES_X_Y|, 
|PROJ_VALUES_X_Y|,\newline |USER_VALUES_X_Y|, and
|VIEW_VALUES_X_Y| for suppressing the z-coordinate.

\initials{LDF 2003.05.20.}  
Added |WORLD_VALUES_Z|.

\initials{LDF 2004.06.01.}  
Made |drawdot_color| non-|const|.
Changed |ppen| from a |string| to a |Pen*|.

\initials{LDF 2005.03.17.}
Removed |Color* drawdot_color|.

\initials{LDF 2005.03.17.}
Removed |Pen* pen|.

\initials{LDF 2005.04.04.}
Added |valarray <real> world_extremes|.

\initials{LDF 2005.06.30.}
Added |valarray<real> pre_projective_coordinates| and
|valarray <real> pre_projective_extremes|.  I plan to use them for
surface hiding.
\ENDLOG 

@f Point Shape

@q ** (2) Definition.@>

@<Define |class Point|@>=

class Point : protected Shape
{
  friend Transform Transform::align_with_axis(Point, Point, char);

  private:
    Transform transform;
    valarray<real> world_coordinates;
    valarray<real> user_coordinates;
    valarray<real> view_coordinates;
    valarray<real> pre_projective_coordinates;
    valarray<real> projective_coordinates;

    signed short drawdot_value;

  protected:

    valarray <real> world_extremes;
    valarray <real> pre_projective_extremes;      
    valarray <real> projective_extremes;      


    bool do_output;  /* LDF 2002.09.18.  Added this data member.  */

  public:
    static string measurement_units;

    static const short WORLD_VALUES;
    static const short PROJ_VALUES;
    static const short USER_VALUES;
    static const short VIEW_VALUES;

    static const short WORLD_VALUES_X_Y;
    static const short PROJ_VALUES_X_Y;
    static const short USER_VALUES_X_Y;
    static const short VIEW_VALUES_X_Y;

    static const short WORLD_VALUES_Z;

    @<Declare |Point| constructors@>@;
    @<Declare |Point| functions@>@;
  };

@
\LOG
LDF 2003.04.01.  Added initialization of |WORLD_VALUES|, |PROJ_VALUES|,
|USER_VALUES|, and |VIEW_VALUES|.  They are used in |label| for
labelling |Points| using the values in |world_coordinates|,
|projective_coordinates|, etc.
@:!! KLUDGE@> !! KLUDGE:  Using the macro |SHRT_MAX|
because the |numeric_limits| template doesn't seem to be available
under GNU/Linux using GCC, at least not on the computer I'm using.

LDF 2003.05.06.
Added initialization of |WORLD_VALUES_X_Y|, |PROJ_VALUES_X_Y|,
|USER_VALUES_X_Y|, and |VIEW_VALUES_X_Y|

LDF 2003.05.22.  @:BUG FIX@> BUG FIX:  Changed |WORLD_VALUES_Z| so
that it's one less than |VIEW_VALUES_X_Y|.  Previously, it had the
same value.
\ENDLOG 
@<Define |static Point| data members@>=
string Point::measurement_units = "cm";

const short Point::WORLD_VALUES = SHRT_MAX;
const short Point::PROJ_VALUES = WORLD_VALUES - 1;
const short Point::USER_VALUES = WORLD_VALUES - 2;
const short Point::VIEW_VALUES = WORLD_VALUES - 3;

const short Point::WORLD_VALUES_X_Y = WORLD_VALUES - 4;
const short Point::PROJ_VALUES_X_Y = WORLD_VALUES - 5;
const short Point::USER_VALUES_X_Y = WORLD_VALUES - 6;
const short Point::VIEW_VALUES_X_Y = WORLD_VALUES - 7;

const short Point::WORLD_VALUES_Z  = WORLD_VALUES - 8;


@q * Type definitions and utility structures.@>
@* Type definitions and utility structures.
Some of the types are simple enough to be defined using |typedef|, but
others require |struct| definitions.
\LOG 
\initials{LDF 2002.04.10.}  Added these formatting instructions.  They are
duplicated using ``@@{\tt s}'' in\break
\filename{cwdriver.web}.
\ENDLOG 

@f Point_Pair            Point
@f Bool_Point            Point
@f Bool_Point_Pair       Point
@f Bool_Point_Quadruple  Point
@f Bool_Real_Point       Point

@q ** (2) Point_Pair and Bool_Point_Pair.@>
@*1 {\bf Point\_Pair} and {\bf Bool\_Point\_pair}.@>
@<Type definitions@>=
typedef pair <Point, Point> Point_Pair;
typedef pair <Bool_Point, Bool_Point> Bool_Point_Pair;

@q ** (2) Bool_Point.@>
@*1 {\bf Bool\_Point}.

\LOG
\initials{LDF 2002.04.15.} 
Added this section.
|Bool_Point| was formerly a
simple |typedef|.  I've had to change it to a |struct|, in order for
|Point::intersection_points| to return one.

\initials{LDF 2003.05.30.} 
Removed the definition of the default constructor to
the new section |@<Define |Bool_Point| functions@>|.  See below for an
explanation. 
\ENDLOG

@q *** (3) Definition.@>

@<Type definitions@>=
struct 
Bool_Point
{
  bool b;
  Point pt;

  @<Declare |Bool_Point| functions@>@;

};  

@q *** (3) |Bool_Point| functions.@>
@*2 {\bf Bool\_Point} functions.
\initials{LDF 2004.09.01.}

@q **** (4) Default constructor.@>
@*3 Default constructor.
\initials{LDF 2004.09.01.}

@ 
\LOG
\initials{} LDF 2003.05.30.  
Added this section, and the definition of
|Bool_Point(void)|.  Previously, |b| and |pt| were not set, so their
values were unpredictable.  I had to remove the definition from the
declaration of |Bool_Point|, because |INVALID_POINT| isn't defined,
when the declaration is read by the compiler. 
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Bool_Point| functions@>=
Bool_Point();

@q ***** (5) Definition.@>

@
@<Define |Bool_Point| functions@>=
Bool_Point::Bool_Point()
{
  b = false;
  pt = INVALID_POINT;
}

@q **** (4) |bool| and |const Point&| arguments.@>
@*3 {\bf bool} and {\bf const Point\AMP} arguments.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2004.11.11.}
Added this section.  This function was formerly defined inside the 
|class| definition for |Bool_Point|.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Bool_Point| functions@>=

Bool_Point(bool bb, const Point& ppt);

@q ***** (5) Definition.@> 

@
@<Define |Bool_Point| functions@>=

Bool_Point::Bool_Point(bool bb, const Point& ppt)
   : b(bb), pt(ppt)
{
   return;
}

@q **** (4) Destructor.@>   
@*3 Destructor.

\LOG
\initials{LDF 2004.11.11.}
Added this section.  This function was formerly defined inside the 
|class| definition for |Bool_Point|.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Bool_Point| functions@>=

~Bool_Point();

@q ***** (5) Definition.@> 

@
@<Define |Bool_Point| functions@>=

Bool_Point::~Bool_Point()
{
   return;
}


@q **** (4) Assignment operators.@>   
@*3 Assignment operators.
\initials{LDF 2004.11.11.}

@q ***** (5) |const Bool_Point&| argument.@> 
@*4 {\bf const Bool\_Point\AMP} argument.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2004.11.11.}
Added this section.  This function was formerly defined inside the 
|class| definition for |Bool_Point|.
Changed the return value from |void| to |const Bool_Point &|
(|*this| is returned).
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Bool_Point| functions@>=
const Bool_Point&
operator=(const Bool_Point& bp);

@q ****** (6) Definition.@> 

@
@<Define |Bool_Point| functions@>=

const Bool_Point&
Bool_Point::operator=(const Bool_Point& bp)
{
   b = bp.b;
   pt = bp.pt;
   return *this;
}


@q **** (4) |const bool&| argument.@>
@*3 {\bf const bool\AMP} argument.
\initials{LDF 2004.11.11.}

|pt| is set to |INVALID_POINT|.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2004.11.11.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Bool_Point| functions@>=
const Bool_Point&
operator=(const bool& bb);

@q ***** (5) Definition.@> 

@
@<Define |Bool_Point| functions@>=
const Bool_Point&
Bool_Point::operator=(const bool& bb)

{
   b = bb;
   pt = INVALID_POINT;
   return *this;
}

@q **** (4) |const Point&| argument.@>
@*3 {\bf const Point\AMP} argument.
\initials{LDF 2004.11.11.}

|b| is set to |true|.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2004.11.11.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Bool_Point| functions@>=
const Bool_Point&
operator=(const Point& p);

@q ***** (5) Definition.@> 

@
@<Define |Bool_Point| functions@>=
const Bool_Point&
Bool_Point::operator=(const Point& p)

{
   b = true;
   pt = p;
   return *this;
}


@q **** (4) Clear.@>   
@*3 Clear.
\initials{LDF 2005.01.06.}

\LOG
\initials{LDF 2005.01.06.}
Added this function.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Bool_Point| functions@>=

void
clear(void);

@q ****** (6) Definition.@> 

@
@<Define |Bool_Point| functions@>=

void
Bool_Point::clear(void)
{
   pt.clear();
   b = false;
}



@q **** (4) Show.@>
@*3 Show.
\initials{LDF 2004.09.01.}

@<Declare |Bool_Point| functions@>=
void
show(string text);

@
@<Define |Bool_Point| functions@>=
void
Bool_Point::show(string text)
{
  if (text == "")
    text = "bool_point:";
  
  cerr << text << endl;

  if (b)
    cerr << "true, ";
  else
    cerr << "false, ";
  
  pt.show();

  return;

}


@q ** (2) Bool_Point_Quadruple.@>

@*1 {\bf Bool\_Point\_Quadruple}.
It would be possible to define this as a |pair| of |pairs|, but then
the individual element   s would be nested inconveniently.  

@<Type definitions@>=
struct 
Bool_Point_Quadruple
{
  Bool_Point first;
  Bool_Point second;
  Bool_Point third;
  Bool_Point fourth;
  Bool_Point_Quadruple();
  Bool_Point_Quadruple(Bool_Point a, Bool_Point b,
                   Bool_Point c, Bool_Point d) :
                     first(a), second(b), third(c), fourth(d) {}
  void operator=(const Bool_Point_Quadruple& arg)
    {
      first.b = arg.first.b;
      first.pt = arg.first.pt;

      second.b = arg.second.b;
      second.pt = arg.second.pt;

      third.b = arg.third.b;
      third.pt = arg.third.pt;

      fourth.b = arg.fourth.b;
      fourth.pt = arg.fourth.pt;

    }
};

@q *** Default Constructor for {\bf Bool\_Point\_Quadruple}.@>
@ Default Constructor for {\bf Bool\_Point\_Quadruple}.
\LOG
LDF 2003.06.1.  Added this section.  Redefined
the default constructor |Bool_Point_Quadruple(void)|, so that |first|,
|second|, |third|, and |fourth| are all set to |INVALID_BOOL_POINT|.  In
order to do this, it was necessary to remove the definition from the
declaration of |Bool_Point_Quadruple|, because when the compiler sees
it, |INVALID_BOOL_POINT| isn't defined yet.
\ENDLOG
@<Define |Bool_Point_Quadruple| functions@>=
Bool_Point_Quadruple::Bool_Point_Quadruple() :
     first(INVALID_BOOL_POINT),
     second(INVALID_BOOL_POINT),
     third(INVALID_BOOL_POINT), 
     fourth(INVALID_BOOL_POINT) {}


@q ** (2) Bool_Real_Point.@>
@*2 {\bf Bool\_Real\_Point}.
\initials{LDF 2002.04.10.}  

|Line::intersection_point| returns a\newline
|Bool_Real_Point|.
I may change |Point::intersection_point| so that it calls
|Line::intersection_point| and returns a
|Bool_Real_Point|, too.
\initials{LDF 2002.04.10.}  

@:!! KLUDGE@> !! KLUDGE:  \VRB \newline§EVRB\ inserted in the text
above to avoid overfull boxes.
\initials{LDF 2002.10.26.}

\LOG
\initials{LDF 2002.04.10.}  
Added this type.
\ENDLOG 

@<Type definitions@>=
struct 
Bool_Real_Point
{
  bool  b;
  real  r;
  Point pt;

  Bool_Real_Point(); /* Default constructor.  */

  Bool_Real_Point(const Bool_Real_Point& brp)
    : b(brp.b), r(brp.r), pt(brp.pt)
      {}  /* Copy constructor.*/

  Bool_Real_Point(const bool& bb, const real& rr, const Point& ppt)
    : b(bb), r(rr), pt(ppt)
      {}  /* Construcor with |bool|, |real|, and |Point| arguments.  */
  
  void
  operator=(const Bool_Real_Point& brp)    /* Assignment operator.  */ 
    {
      b = brp.b;
      r = brp.r;
      pt = brp.pt;
    }
};


@q *** Default Constructor for {\bf Bool\_Real\_Point}.@>
@ Default Constructor for {\bf Bool\_Real\_Point}.
\LOG
LDF 2003.06.1.  Added this section.  Redefined
the default constructor |Bool_Real_Point(void)|, so that 
|b| is set to |false|, |r| is set to |INVALID_REAL|, and |pt| is set
to |INVALID_BOOL_POINT|.  In
order to do this, it was necessary to remove the definition from the
declaration of |Bool_Real_Point|, because when the compiler sees
it, |INVALID_REAL| and |INVALID_POINT| aren't defined yet.
\ENDLOG
@<Define |Bool_Real_Point| functions@>=
Bool_Real_Point::Bool_Real_Point() : b(false),
                                     r(INVALID_REAL),
                                     pt(INVALID_POINT) 
{}

@q * (1) Global constants.@>
@* Global constants.

\LOG
\initials{LDF 2002.09.25.}  
Changed this section.  I now know that |consts| have
internal linkage by default and that I must declare them with |extern|
in order to give them external linkage.

\initials{LDF 2004.06.08.}  
Removed declarations of |origin|.  I'm replacing it
with a predefined variable defined in |Scanner_Type::create|.

\initials{LDF 2005.10.30.}
Added declaration of |Point_Pair INVALID_POINT_PAIR|.

\initials{LDF 2005.11.09.}
Added declaration of |extern const Point ORIGIN|.
\ENDLOG 

@<Global constants@>=

extern const Point INVALID_POINT(INVALID_REAL, INVALID_REAL, INVALID_REAL);
extern const Point ORIGIN(0, 0, 0);
extern const Point_Pair INVALID_POINT_PAIR(INVALID_POINT, INVALID_POINT);

extern const Bool_Point INVALID_BOOL_POINT(false, INVALID_POINT);
extern const Bool_Point_Pair INVALID_BOOL_POINT_PAIR(INVALID_BOOL_POINT,
                                       INVALID_BOOL_POINT); 


extern const Bool_Real_Point INVALID_BOOL_REAL_POINT(false, INVALID_REAL,
                                       INVALID_POINT);
extern const Bool_Point_Quadruple
   INVALID_BOOL_POINT_QUADRUPLE(INVALID_BOOL_POINT,
                                INVALID_BOOL_POINT,
                                INVALID_BOOL_POINT,
                                INVALID_BOOL_POINT);



@
@<Declarations for the header file@>=

extern const Point      ORIGIN;
extern const Point      INVALID_POINT;
extern const Point_Pair INVALID_POINT_PAIR;

extern const Bool_Point INVALID_BOOL_POINT;
extern const Bool_Point_Pair INVALID_BOOL_POINT_PAIR; 


extern const Bool_Real_Point INVALID_BOOL_REAL_POINT;

extern const Bool_Point_Quadruple
   INVALID_BOOL_POINT_QUADRUPLE;


@q * (1) Constructors and setting functions.@>
@* Constructors and setting functions.

@ The |valarrays| I use for the various sets of coordinates can be
declared in the |class| declaration, but neither can their size be set
nor can they be initialized. |null_coordinates| is defined in
\filename{pspglb.web} and is a |valarray| of |reals| with 4 elements
$=0$. Setting |world_coordinates|, etc. to |null_coordinates| makes
them the right size. 

@q ** Initialize coordinates and limits.@>
@ Initialize coordinates and limits.

\LOG 
\initials{LDF 2002.4.3.}  
Now setting |world_coordinates[3]|, |user_coordinates[3]|, and 
|view_coordinates[3] = 1|.  It fixes a bug that showed
up when I tried to shift a |Point|
with coordinates $\equiv 0$. 

\initials{LDF 2004.06.01.}  
Removed the assignment |pen = ""| since
|pen| is now a |Pen*| instead of a |string|.

\initials{LDF 2005.04.04.}
Now resizing |world_extremes|.

\initials{LDF 2005.06.30.}
Now resizing |pre_projective_coordinates| and
|pre_projective_extremes|.
\ENDLOG 

@<Initialize coordinates and limits@>=

   world_coordinates.resize(4, 0);
   user_coordinates.resize(4, 0);        
   view_coordinates.resize(4, 0);        
   pre_projective_coordinates.resize(4, 0); 
   projective_coordinates.resize(4, 0); 
   transform.reset();

   world_coordinates[3] = 1; 
   user_coordinates[3] = 1;
   view_coordinates[3] = 1;

   world_extremes.resize(6, 0);
   pre_projective_extremes.resize(6, 0);
   projective_extremes.resize(6, 0);


@q ** (2) Default version.  No arguments.@>
@*1 Default version.  No arguments.
@^\cfunc{Point}{Point}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.06.02.}  
Now setting |pen| and |drawdot_color| to 0. 

\initials{LDF 2005.01.24.}
Now setting |shape_type = POINT_TYPE|.

\initials{LDF 2005.03.17.}
Now setting |draw_color_vector| and |fill_color_vector|
to 0.

\initials{LDF 2005.03.17.}
No longer setting |pen| to 0.
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Point| constructors@>=
Point(void);

@
@<Define |Point| constructors@>=
Point::Point(void)
{
  @<Initialize coordinates and limits@>@;
  do_output = true;

  pen_vector          = static_cast<Pointer_Vector<Pen>*>(0);
  dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);

  draw_color_vector   = static_cast<Pointer_Vector<Color>*>(0);
  fill_color_vector   = static_cast<Pointer_Vector<Color>*>(0);

  shape_type = POINT_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;
}



@q ** (2) Three real values.@>
@*1 Three {\bf real} values.
\initials{LDF Undated.}

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Point}{Point}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.12.01.}  
Made arguments |const|.

\initials{LDF 2004.05.02.}  Removed defaults for |y| and |z|.  Now all
arguments must be explicitly specified in calls to this function.
This is because I've removed |Point::CURR_Y| and |Point::CURR_Z| 
and it's not possible to use the new ``internal quantities'' that replace them as 
defaults. 

\initials{LDF 2004.06.02.}  
Now setting |pen| and |drawdot_color| to 0. 

\initials{LDF 2005.01.24.}
Now setting |shape_type = POINT_TYPE|.

\initials{LDF 2005.03.17.}
Now setting |draw_color_vector| and |fill_color_vector|
to 0.

\initials{LDF 2005.03.17.}
No longer setting |pen| to 0.
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Point| constructors@>=
Point(const real x, const real y, const real z);

@
@<Define |Point| constructors@>=
 Point::Point(const real x, const real y, const real z)
{

   @<Initialize coordinates and limits@>@;
  
   do_output = true;

   pen_vector          = static_cast<Pointer_Vector<Pen>*>(0);
   dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);

   draw_color_vector   = static_cast<Pointer_Vector<Color>*>(0);
   fill_color_vector   = static_cast<Pointer_Vector<Color>*>(0);

   shape_type = POINT_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
#if 0 
/* \initials{LDF 2002.10.23.}  |user_transform| is not currently in use.  It is
  intended for use in implementing user-defined coordinate systems.  */
  if (user_transform.is_identity())
#endif 
    
      world_coordinates[0] = x;
      world_coordinates[1] = y;
      world_coordinates[2] = z;
      world_coordinates[3] = 1;
}

@q *** (3) Setting function.@>
@*2 Setting function.
@^\cfunc{Point}{set}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.12.01.}  
Made arguments |const|.

\initials{LDF 2003.03.25.}  
Changed this function, so that it returns |*this| instead
of |void|.  This makes it possible to chain invocations of this
function. 

\initials{LDF 2004.05.02.}  
Removed defaults for |y| and |z|.  Now all
arguments must be explicitly specified in calls to this function.
This is because I've removed |Point::CURR_Y| and |Point::CURR_Z| 
and it's not possible to use the new ``internal quantities'' that replace them as 
defaults. 

\initials{LDF 2004.06.02.}  
Now deleting |pen| and |drawdot_color|, if
necessary, and setting them to 0.

\initials{LDF 2005.03.17.}
Now deleting |draw_color_vector| and |fill_color_vector|
and setting them to 0, if they aren't 0 already.

\initials{LDF 2005.03.17.}
No longer deleting |pen| and setting it to 0, 
if it's not already 0.
Now deleting |pen_vector| and |dash_pattern_vector| and
setting them to 0, if they're  not already 0.
\ENDLOG 

@<Declare |Point| functions@>=

const Point&
set(const real x, const real y, const real z);

@
@<Define |Point| functions@>=
const Point&
Point::set(const real x, const real y, const real z)
{
    Point p(x, y, z);

    if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
       {
           delete pen_vector;
           pen_vector = static_cast<Pointer_Vector<Pen>*>(0); 
       }

    if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
       {
           delete dash_pattern_vector;
           dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0); 
       }

   if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete draw_color_vector;
         draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

   if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete fill_color_vector;
         fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

    *this = p;
    do_output = true;
    return *this;  /* LDF 2003.03.25.  Added this.  Formerly, the return
                                       value was |void|.  */
}     


@q ** (2) Copy constructor.@>
@*1 Copy constructor.
@^\cfunc{Point}{Point}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.01.24.}
Now setting |shape_type = POINT_TYPE|.

\initials{LDF 2005.03.17.}
Now setting |draw_color_vector| and |fill_color_vector|
to 0.

\initials{LDF 2005.03.17.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Point| constructors@>=

Point(const Point& p);

@
@<Define |Point| constructors@>=
Point::Point(const Point& p)
{
   @<Initialize coordinates and limits@>@;

   draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
   fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);

   pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
   dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);

   *this = p;

   shape_type = POINT_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   do_output = true;

   return;

}

@q *** (3) Setting function.@>
@*2 Setting function.
@^\cfunc{Point}{set}@>
\initials{LDF 2002.10.23.}  

This function is unnecessary, because it does nothing
that the assignment operator can't do.  However, I've tried to use
|set| a couple of times with a |Point| argument, so it's convenient
to have it.  If nothing else, it prevents compilation from failing
occasionally. 
\initials{LDF 2002.10.23.}  

\LOG 
\initials{LDF 2002.10.23.}  
Added this function.

\initials{LDF 2005.03.17.}
Now deleting |draw_color_vector| and |fill_color_vector|
and setting them to 0, if they aren't 0 already.

\initials{LDF 2005.03.17.}
Now deleting |pen_vector| and |dash_pattern_vector| and
setting them to 0, if they're  not already 0.
\ENDLOG 

@<Declare |Point| functions@>=
void
set(const Point& p);

@
@<Define |Point| functions@>=
void
Point::set(const Point& p)
{

   if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete draw_color_vector;
         draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

   if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete fill_color_vector;
         fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

    if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
       {
           delete pen_vector;
           pen_vector = static_cast<Pointer_Vector<Pen>*>(0); 
       }

    if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
       {
           delete dash_pattern_vector;
           dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0); 
       }


  *this = p;
  do_output = true;
}     

@q * (1) Pseudo-constructor for dynamic allocation.@>
@* Pseudo-constructor for dynamic allocation.
|create_new<Point>| is meant to be used instead of |new| for
dynamic allocation of |Points|. 
It calls the default constructor (without arguments) and then sets
|on_free_store| to |true|.
\initials{LDF 2002.10.11.} 

It is used in various |Point| functions, and in |Path| and some
classes derived from |Path|, currently |Ellipse|, |Reg_Polygon|, and
|Rectangle|.  It is intended that objects of these types be declared,
i.e., unlike |Reg_Cl_Plane_Curve|, they are not meant to be used only as base
classes.  |Reg_Cl_Plane_Curve| does not use |create_new<Point>| and it is
unlikely that other classes of this kind will use it.
\initials{LDF 2002.10.11.} 

\LOG
\initials{LDF 2003.12.30.}  
Replaced the non-template
|create_new_point| functions with versions of the |create_new|
template function.  I believe the definitions shouldn't be necessary,
but at present they are.  Without them, the templates aren't
instantiated.  
\ENDLOG 

@q ** (2) Pointer argument.@>
@*1 Pointer argument.
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.12.30.}  
Changed the argument.  It's now a |const Point*|. 

\initials{LDF 2003.12.30.}  
Removed default argument ``0'', because
this caused a compiler error when using the DEC \CPLUSPLUS/ compiler.
Apparently, it suffices to declare a default argument in the template
declaration. 

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.

\initials{LDF 2004.10.11.}
Added default argument of 0 for |Scanner_Node scanner_node|.
\ENDLOG 

@<Declare non-member template functions for |Point|@>=

Point* 
create_new(const Point* p, Scanner_Node scanner_node = 0);

@q ** (2) Reference argument.@>
@*1 Referece argument.

\LOG
\initials{LDF 2003.12.30.}  
Changed argument from |Point| to |const Point&|.

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.

\initials{LDF 2004.10.11.}
Added default argument of 0 for |Scanner_Node scanner_node|.
\ENDLOG 
    
@<Declare non-member template functions for |Point|@>=
Point* 
create_new(const Point& p, Scanner_Node scanner_node = 0);

@q * (1) Destructor.@>
@* Destructor. 
@^\cfunc{Point}{\~{}Point}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.08.27.}  
Added a |virtual| destructor with an empty
definition, because GCC with the ``{\tt -Wall}'' option issued the following
warning:  
``{}`class Point' has virtual functions but non-virtual destructor''.

\initials{LDF 2004.06.21.}
Now deleting |pen| if it's non-zero and setting it to 0.  Doing the same 
for |drawdot_color|.

\initials{LDF 2005.03.17.}
Now deleting |draw_color_vector| and |fill_color_vector|
and setting them to 0, if they aren't 0 already.

\initials{LDF 2005.03.17.}
No longer deleting |pen| and setting it to 0, 
if it's not already 0.
Now deleting |pen_vector| and |dash_pattern_vector| and
setting them to 0, if they're  not already 0.
\ENDLOG 

@<Declare |Point| functions@>=
virtual
~Point(void);
  
@
@<Define |Point| functions@>=
Point::~Point(void)
{
   volatile bool DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_mutex.lock(); 
       cerr << "Entering `Point' destructor." << endl;
       cerr_mutex.unlock(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
       {
           delete pen_vector;
           pen_vector = static_cast<Pointer_Vector<Pen>*>(0); 
       }

    if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
       {
           delete dash_pattern_vector;
           dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0); 
       }


   if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete draw_color_vector;
         draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

   if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete fill_color_vector;
         fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

   return;

}  /* End of |Point::~Point(void)| definition.  */

@q * (1) Assignment. @>
@* Assignment.
@^\cofunc{Point}{=}@>


@q ** (2) |const Point&| argument.@> 
@*1 {\bf const Point\AMP} argument.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2003.03.25.}  
Changed this function, so that it returns |p| instead
of |void|.  This makes it possible to chain invocations of this
function. 

\initials{LDF 2002.09.18}.  
Now setting |projective_extremes| 
and |do_output|.  I think that it shouldn't be
necessary to do these things, but I've  added them just to be sure.

\initials{LDF 2003.03.25.} 
No returning |p|.  Formerly, the return value was |void|.

\initials{LDF 2004.06.02.}  
Changed the way |pen| and |drawdot_color| are
handled to reflect the fact that they are now pointers. 

\initials{LDF 2004.08.08.}
Added debugging output.

\initials{LDF 2004.10.12.}
Made debugging output thread-safe.

\initials{LDF 2005.03.17.}
Removed code for handling |drawdot_color| and 
added code for handling |draw_color_vector|.

\initials{LDF 2005.03.17.}
Replaced the code for handling |pen| with code for handling 
|pen_vector|.

\initials{LDF 2005.04.04.}
Now setting |world_extremes| to |p.world_extremes|.

\initials{LDF 2005.06.30.}
Now setting |pre_projective_coordinates| to |p.pre_projective_coordinates|
and |pre_projective_extremes| to |p.pre_projective_extremes|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
const Point&
operator=(const Point& p);

@q *** (3) Definition.@> 

@ 
@<Define |Point| functions@>=
const Point&
Point::operator=(const Point& p)
{


@q *** (3) Preliminaries.@> 

  volatile bool DEBUG = false; /* |true| */ @; 

  using namespace Scan_Parse;

  stringstream cerr_strm;
  
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";


@q *** (3).@> 

#if DEBUG_COMPILE
   if (DEBUG)
      {        
        cerr_strm << thread_name << "Entering 'Point::operator='.";
       
        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

  transform     = p.transform;

  drawdot_value = p.drawdot_value;

  if (   p.draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
      && draw_color_vector == static_cast<Pointer_Vector<Color>*>(0)) 
     ; /* Do nothing.  */@; 

  else if (   p.draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
           && draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
     {
        draw_color_vector = new Pointer_Vector<Color>;
        *draw_color_vector = *(p.draw_color_vector);
     }

  else if (   p.draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
           && draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
     *draw_color_vector = *(p.draw_color_vector);
     
  else if (   p.draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
           && draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
     {
        delete draw_color_vector;
        draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);

     }

  
  if (   p.pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
      && pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
     ;  /* Do nothing.  */@; 

  else if (   p.pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
           && pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      {
         pen_vector = new Pointer_Vector<Pen>;
         *pen_vector = *(p.pen_vector);
      }

  else if (   p.pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
           && pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
      *pen_vector = *(p.pen_vector);

  else if (   p.pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
           && pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
      {
         delete pen_vector;
         pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
      }

  world_coordinates = p.world_coordinates;

  user_coordinates = p.user_coordinates;

  view_coordinates = p.view_coordinates;

  pre_projective_coordinates = p.pre_projective_coordinates;
  projective_coordinates = p.projective_coordinates;

  world_extremes = p.world_extremes;  
  pre_projective_extremes = p.pre_projective_extremes;  
  projective_extremes = p.projective_extremes;  

  do_output = true; 

#if DEBUG_COMPILE
   if (DEBUG)
      {        
        cerr_strm << thread_name << "Exiting 'Point::operator='.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

      }
#endif /* |DEBUG_COMPILE|  */@; 


  return p;  


} /* End of |Point::operator=(const Point& p)| definition.  */

@q ** (2) |const Bool_Point&| argument.@> 
@*1 {\bf const Bool\_Point\AMP} argument.
\initials{LDF 2004.11.11.}

\LOG
\initials{LDF 2004.11.11.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
const Point&
operator=(const Bool_Point& bp);

@q *** (3) Definition.@> 

@ 
@<Define |Point| functions@>=
const Point&
Point::operator=(const Bool_Point& bp)
{

   return (*this = bp.pt);

} /* End of |Point::operator=(const Bool_Point& bp)| definition.  */


@q * (1) Clear.@>
@* Clear.  

I need this function because it's a |virtual| function in
|Shape|.

\LOG 
\initials{LDF 2002.10.27.}  
Redefined this function.  Formerly, it was inline and
empty.  Now it sets all of the x, y, and z coordinates to 0, and resets
|transform|.  It doesn't seem worthwhile to set |drawdot_value|,
|drawdot_color|, or |pen| to any particular values.

\initials{LDF 2005.03.17.}
Now deleting |drawdot_color|, |draw_color_vector|,
and |fill_color_vector| and setting them to 0, 
if they aren't 0 already.

\initials{LDF 2005.03.17.}
Now deleting |pen_vector| and |dash_pattern_vector| and
setting them to 0, if they're  not already 0.

\initials{LDF 2005.06.30.}
Now zeroing |pre_projective_coordinates|.
\ENDLOG 

@<Declare |Point| functions@>=
void 
clear(void);

@
@<Define |Point| functions@>=
void 
Point::clear(void)  
{

    if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
       {
           delete pen_vector;
           pen_vector = static_cast<Pointer_Vector<Pen>*>(0); 
       }

    if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
       {
           delete dash_pattern_vector;
           dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0); 
       }

   if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete draw_color_vector;
         draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }

   if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
         delete fill_color_vector;
         fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
      }


  for (int i = 0; i < 4; i++)
    {
      world_coordinates[i] = user_coordinates[i] 
                           = view_coordinates[i] 
                           = pre_projective_coordinates[i] 
                           = projective_coordinates[i] = 0;
    }

  transform.reset();
  return;


} /* End of |Point::clear| definition.  */



@q * (1) Clean.@>
@* Clean.
@^\cfunc{Point}{clean}@>

@q ** (2) Declaration.@>  

@<Declare |Point| functions@>=
void
clean(int factor = 1);

@q ** (2) Definition.@>  

@ 
@<Define |Point| functions@>=
void
Point::clean(int factor)
{
  apply_transform();
  real eps = epsilon() * factor;
  for(int i = 0; i < 4; i++)
    if (fabs(world_coordinates[i]) < eps)
      world_coordinates[i] = 0.0;
}

@q * (1) Copy coordinates.@>  
@* Copy coordinates.
@^\cfunc{Point}{copy\_coords}@>
\initials{LDF 2005.04.09.}

\LOG
\initials{LDF 2005.04.09.}
Added this function.

\initials{LDF 2005.04.11.}
Added code to this function.  Formerly, it returned 0 immediately.

\initials{LDF 2005.04.15.}
Added the optional argument |bool set_z_to_zero| 
with the default |false|.  
\ENDLOG

@q ** (2) Declaration.@>  

@<Declare |Point| functions@>=

virtual 
int 
copy_coords(const char from, 
            const char to, 
            bool set_z_to_zero = false,
            Scanner_Node scanner_node = 0);


@q ** (2) Definition.@>  

@ 
@<Define |Point| functions@>=
int 
Point::copy_coords(char from, 
                   char to, 
                   bool set_z_to_zero,
                   Scanner_Node scanner_node)
{

@q *** (3) @> 

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;


@q *** (3) @> 


   from = tolower(from);
   to   = tolower(to);

   if (!(   (   from == 'w' || from == 'p' 
             || from == 'u' || from == 'v')
         && (   to   == 'w' || to   == 'p' 
             || to   == 'u' || to   == 'v')))
      {
         
          cerr_strm << thread_name << "ERROR!  In 'Point::copy_coords':"
                    << endl 
                    << "Invalid 'from' and/or 'to' argument:"
                    << endl 
                    << "'from' == " << from << ", 'to' == " << to << "."
                    << endl 
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str();

          return 1;

      }  /* |if|  */


@q *** (3) @> 

   if (from == to)
      {
         
          cerr_strm << thread_name << "ERROR!  In 'Point::copy_coords':"
                    << endl 
                    << "Invalid arguments:  'from' == 'to' == " << to 
                    << endl 
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str();

          return 1;

      }  /* |if|  */


@q *** (3) @> 

   valarray<real> temp_coordinates(6);


   if (from == 'w')
      {
         temp_coordinates = world_coordinates;
         world_coordinates = 0;
 
      }

   else if (from == 'p')
      {
         temp_coordinates = projective_coordinates;
         projective_coordinates = 0;
 
      }

   else if (from == 'u')
      {
         temp_coordinates = user_coordinates;
         user_coordinates = 0;
 
      }

   else if (from == 'v')
      {
         temp_coordinates = view_coordinates;
         view_coordinates = 0;
 
      }



@q *** (3) @> 

   if (to == 'w')
      {
         world_coordinates = temp_coordinates;
         if (set_z_to_zero)
            world_coordinates[2] = 0;
      }

   else if (to == 'p')
      {
         projective_coordinates = temp_coordinates;
         if (set_z_to_zero)
            projective_coordinates[2] = 0;
 
      }

   else if (to == 'u')
      {
         user_coordinates = temp_coordinates;
         if (set_z_to_zero)
            user_coordinates[2] = 0;
 
      }

   else if (to == 'v')
      {
         view_coordinates = temp_coordinates;
         if (set_z_to_zero)
            view_coordinates[2] = 0;
 
      }

@q *** (3) @> 

   return 0;

} /* End of |Point::copy_coords| definition.  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF Undated.}

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return POINT_TYPE;
}

@q ** (2) Is identity.@>
@*1 Is identity. 
@^\cfunc{Point}{is\_identity}@>
\initials{LDF Undated.}

@<Declare |Point| functions@>=

inline
bool
is_identity()
{
  return (transform.is_identity());
}

@q ** (2) Is whatever.@>
@*1 Is whatever. 
@^\cfunc{Point}{is\_whatever}@>
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
bool
is_whatever(Scanner_Node scanner_node = 0,
            real tolerance = Shape::DEFAULT_TOLERANCE) const;

@
@<Define |Point| functions@>=

bool
Point::is_whatever(Scanner_Node scanner_node,
                   real tolerance) const
{
  return true;
}




@q ** (2) Epsilon.@>
@*1 Epsilon.
@^\cfunc{Point}{epsilon}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.1.2.}  
Now returning different values, depending on
whether |real| is |float| or |double|.
@:!! TO DO@> TO DO:  Try to find out what values would be best.  It
will be necessary to check how good the value for |double| is.


\initials{LDF 2004.1.2.} 
Made |epsilon| non-inline.
\ENDLOG 

@<Declare |Point| functions@>=

static
real
epsilon();

@
@<Define |Point| functions@>=
real
Point::epsilon()
{
#if LDF_REAL_DOUBLE
  return .000000001;
#else
  return .00001;
#endif 
}

@q ** Get Line.@>
@ Get {\bf Line}.
@^\cfunc{Point}{get\_line}@>
Defined in \filename{lines.web}.  Must be defined there, because
|Line| is an incomplete type here.

\initials{LDF 2002.04.12.}  Removed this function to \filename{lines.web}. 
@<Declare |Point| functions@>=
Line
get_line(const Point& pt) const;

@q ** Getting coordinates.@>
@ Getting coordinates.@>
@:??@> ?? Change |get_x|, etc., back to |inline|??

@q *** Get all coordinates.@>
@ Get all coordinates.
\initials{LDF 2002.09.19.}  Added this function.
@:!!@> 
@:??@> ?? \initials{LDF 2002.12.01.}  Can I make the |Focus*| argument |const|?
What is the syntax for a pointer to a |const|, as opposed to a
|const| pointer?  Look up!!   Make sure I change this is
\filename{3DLDF.texi} if I change it here!

@q **** (4) Non-{\bf const} version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_all\_coords}@>

\LOG
\initials{LDF 2002.09.19.}  Added this function.


\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@q ***** (5) Declaration.  @>
@<Declare |Point| functions@>=
valarray <real> 
get_all_coords(char coords = 'w', const bool do_persp = false,
               const bool do_apply = true, Focus* f = 0,
               const unsigned short proj = Projections::persp, real factor = 1);


@q ***** (5) Definition.  @>
@
@<Define |Point| functions@>=
valarray <real> 
Point::get_all_coords(char coords,
                      const bool do_persp,
                      const bool do_apply,
                      Focus* f,
                      const unsigned short proj,
                      real factor)
{
  if (do_apply)
    apply_transform();
  coords = tolower(coords);

  if (coords == 'w')
    return world_coordinates;
  else if (coords == 'v')
    return view_coordinates;
  else if (coords == 'u')
    return user_coordinates;
  else if (coords == 'p')
    {
      if (do_persp)
        {
@q ***** (5) Error handling for the case that |do_persp && f == 0|.  @>
@  Error handling for the case that |do_persp && f == 0|.  Previously,
|default_focus| was used in this case, but I've now gotten rid of 
|default_focus|.
\initials{LDF 2004.06.07.}

\LOG
\initials{LDF 2004.06.07.}  Added this error handling code.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.06.07.}  Figure out a way to signal failure to the caller, so
that |getchar| can be called, depending on 
|scanner_node->run_state.error_stop_mode|.  It's not possible to do this here, because 
no |Scanner_Node| argument is passed to this function, and I don't want to add one.
\ENDTODO 

@<Define |Point| functions@>=

          if (f == static_cast<Focus*>(0))

            {
                cerr << "ERROR! In 'Point::get_all_coords':"
                     << endl << "'do_persp == true', so "
                     << "'Focus* f' may not be 0.\n"
                     << "Returning 'projective_coordinates' as-is "
                     << "and will try to continue." << endl;

                return  projective_coordinates;
            }

@  
@<Define |Point| functions@>=

          project(*f, proj, factor);
        }
      return projective_coordinates;
    }
  else
    {
      cerr << "ERROR! In Point::get_all_coords():\n"
           << "Argument coords has invalid value: " << coords
           << ". Returning world coordinates.\n";
      return world_coordinates;
    }
}



@q **** (4) {\bf const} version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_all\_coords}@>

\LOG
\initials{LDF 2002.09.19.}  Added this function.

\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
valarray <real> 
get_all_coords(char coords = 'w', const bool do_persp = false,
               const bool do_apply = true, Focus* f = 0,
               const unsigned short proj = Projections::persp, 
               real factor = 1) const;


@
@<Define |Point| functions@>=
valarray <real> 
Point::get_all_coords(char coords, const bool do_persp,
                      const bool do_apply, Focus* f,
                      const unsigned short proj, real factor) const
{
    Point p(*this);
    valarray <real> v = p.get_all_coords(coords, do_persp, do_apply, f);
    return v;
}


@q *** (3) Get coord.@>
@*2 Get coord.

\LOG
\initials{LDF 2002.09.14.}  
Added |get_coord|.  Fixing a bug that caused |get_x('p')|, etc., 
to call |project| multiple times when doing |Path::output|.
\ENDLOG 

@q **** (4) Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_coord}@>

The argument |c| refers to either the x, y, z, or w coordinate.
\initials{LDF 2002.10.27.}


\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@q ***** (5) Declaration.  @>

@<Declare |Point| functions@>=
real 
get_coord(char c,
          char coords = 'w',
          const bool do_persp = false,
          const bool do_apply = true,
          Focus* f = 0,
          const unsigned short proj = Projections::persp, real factor = 1);

@q ***** (5) Definition.  @>

@
@<Define |Point| functions@>=
real 
Point::get_coord(char c, char coords,
                 const bool do_persp,
                 const bool do_apply,
                 Focus* f,
                 const unsigned short proj, real factor)
{
  
  if (do_apply)
    apply_transform();

@q ***** (5) Error handling for the case that |do_persp && f == 0|.  @>
@  Error handling for the case that |do_persp && f == 0|.  Previously,
|default_focus| was used in this case, but I'm about to get rid of 
|default_focus|.
\initials{LDF 2004.06.07.}

\LOG
\initials{LDF 2004.06.07.}  Added this error handling code.
\ENDLOG 

@
@<Define |Point| functions@>=
  if(do_persp && f == static_cast<Focus*>(0))
    {
        cerr << "ERROR! In 'Point::get_all_coords':"
             << endl << "'do_persp == true', so "
             << "'Focus* f' may not be 0.\n"
             << "Returning 'projective_coordinates' as-is "
             << "and will try to continue." << endl;

        return  INVALID_REAL;
    }

@
@<Define |Point| functions@>=

  unsigned short ctr;

  c = tolower(c);
  
  if (c == 'x')
    ctr = 0;

  else if (c == 'y')
    ctr = 1;

  else if (c == 'z')
    ctr = 2;

  else if (c == 'w')
    ctr = 3;

  else
    {
      cerr << "ERROR! In Point::get_coord(): "
           << "Invalid c argument: " << c << ".\n"
           << "Using x\n";
      ctr = 0;
    }

  coords = tolower(coords);

  if (coords == 'w')
    return world_coordinates[ctr];
  else if (coords == 'u')
    return user_coordinates[ctr];
  else if (coords == 'p')
    {
      if (do_persp)
        project(*f, proj, factor);
      return projective_coordinates[ctr];
    }
  else if (coords == 'v')
    return view_coordinates[ctr];
  else
    {
      cerr << "ERROR! In Point::get_coord(). Invalid argument char coords: "
        << coords << endl << "Returning INVALID_REAL.\n\n";
      return INVALID_REAL;
    }
}


@q **** (4) const version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_coord}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real 
get_coord(char c, char coords = 'w',
          const bool do_persp = false,
          const bool do_apply = true,
          Focus* f = 0, const unsigned short proj = Projections::persp,
          real factor = 1) const;



@
@<Define |Point| functions@>=
real 
Point::get_coord(char c, char coords,
                 const bool do_persp,
                 const bool do_apply, 
                 Focus* f, const unsigned short proj,
                 real factor) const
{
  Point p(*this);
  return p.get_coord(c, coords, do_persp, do_apply, f, proj, factor);
}


@q *** Get x.@>
@ Get x.

@q **** (4) Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_x}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_x(char coords = 'w', const bool do_persp = false, 
      const bool do_apply = true, 
      Focus* f = 0, const unsigned short proj = Projections::persp,
      real factor = 1);


@
@<Define |Point| functions@>=
real
Point::get_x(char coords, const bool do_persp, const bool do_apply, Focus* f,
             const unsigned short proj, real factor)
{
  return get_coord('x', coords, do_persp, do_apply, f, proj, factor);
}

@q **** (4) const version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_x}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_x(char coords = 'w', const bool do_persp = false,
      const bool do_apply = true, 
      Focus* f = 0, const unsigned short proj = Projections::persp,
      real factor = 1) const;


@
@<Define |Point| functions@>=
real
Point::get_x(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor) const
{
  return get_coord('x', coords, do_persp, do_apply, f, proj, factor);
}

@q *** Get y.@>
@ Get y.

@q **** (4) Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_y}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_y(char coords = 'w', const bool do_persp = false, 
      const bool do_apply = true, 
      Focus* f = 0, const unsigned short proj = Projections::persp,
      real factor = 1);

@
@<Define |Point| functions@>=
real
Point::get_y(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor)
{
  return get_coord('y', coords, do_persp, do_apply, f, proj, factor);
}

@q **** (4) const version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_y}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG

@<Declare |Point| functions@>=
real
get_y(char coords = 'w', const bool do_persp = false,
      const bool do_apply = true,
      Focus* f = 0, const unsigned short proj = Projections::persp,
      real factor = 1) const;


@
@<Define |Point| functions@>=
real
Point::get_y(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor) const
{
  return get_coord('y', coords, do_persp, do_apply, f, proj, factor);
}

@q *** Get z.@>
@ Get z.

@q **** (4) Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_z}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_z(char coords = 'w', const bool do_persp = false, 
      const bool do_apply = true, Focus* f = 0,
      const unsigned short proj = Projections::persp,
      real factor = 1);


@
@<Define |Point| functions@>=
real
Point::get_z(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor)
{
  return get_coord('z', coords, do_persp, do_apply, f, proj, factor);
}

@q **** (4) const version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_z}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_z(char coords = 'w', const bool do_persp = false,
      const bool do_apply = true, Focus* f = 0,
      const unsigned short proj = Projections::persp,
      real factor = 1) const;


@
@<Define |Point| functions@>=
real
Point::get_z(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor) const
{
  return get_coord('z', coords, do_persp, do_apply, f, proj, factor);
}


@q *** Get w.@>
@ Get w.

@q **** (4) Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Point}{get\_w}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_w(char coords = 'w', const bool do_persp = false, 
      const bool do_apply = true, Focus* f = 0,
      const unsigned short proj = Projections::persp,
      real factor = 1);


@
@<Define |Point| functions@>=
real
Point::get_w(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor)
{
  return get_coord('w', coords, do_persp, do_apply, f, proj, factor);
}

@q **** (4) const version.@>
@ {\bf const} version.
@^\cfunc{Point}{get\_w}@>

\LOG
\initials{LDF 2004.06.08.}  @:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  
\ENDLOG 

@<Declare |Point| functions@>=
real
get_w(char coords = 'w', const bool do_persp = false,
      const bool do_apply = true, Focus* f = 0,
      const unsigned short proj = Projections::persp,
      real factor = 1
      ) const;
     
@
@<Define |Point| functions@>=
real
Point::get_w(char coords, const bool do_persp, const bool do_apply,
             Focus* f, const unsigned short proj, real factor) const
{
  return get_coord('w', coords, do_persp, do_apply, f, proj, factor);
}

@q ** Get transform@>
@ Get {\bf transform}.
@^\cfunc{Point}{get\_transform}@>
\LOG 
\initials{LDF 2002.10.27.}  Made this function |const|.
\ENDLOG 
@<Declare |Point| functions@>=
inline
Transform
get_transform() const
{
    return transform;
}

@q ** Get copy.@>
@ Get copy.
\LOG 
\initials{LDF 2002.10.27.}  Made this function |const|.
\ENDLOG 
@<Declare |Point| functions@>=
Shape* 
get_copy() const;

@
@<Define |Point| functions@>=
Shape*
Point::get_copy() const
{
  Point* p = create_new<Point>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q ** Slope.@>
@ Slope.
@^\cfunc{Point}{slope}@>
\initials{LDF 2002.10.27.}  |slope| returns the slope of the {\it trace\/} of
the line from |*this| to |p| on the plane indicated by the |char| arguments
|m| and |n|.  These should be |'x'|, |'y'|, |'z'|, |'X'|, |'Y'|, or |'Z'|.  
\LOG
\initials{LDF 2002.10.27.}  Now using |world_coordinates| directly instead of ``get'' 
functions. 

\initials{LDF 2002.10.27.}  Changed argument |p| from |const Point&| to |Point|.
\ENDLOG 
@<Declare |Point| functions@>=
real
slope(Point p, char m = 'x', char n = 'y') const;

@
@<Define |Point| functions@>=
real
Point::slope(Point p, char m, char n) const
{
  bool DEBUG = false; /* |true|  */@; 
  Point a(*this);

  a.apply_transform();
  p.apply_transform();

  if(a == p)
    {    
      cerr << "ERROR! In Point::slope():\n"
        << "Points are the same. Returning INVALID_REAL\n\n";
      if (DEBUG)
        {
          a.show("a");
          p.show("p");
        }
      return INVALID_REAL;
    }

  m = tolower(m);
  n = tolower(n);

  if (!((m == 'x' || m == 'y' || m == 'z')
      && (n == 'x' || n == 'y' || n == 'z')
      && (m != n)))

    {
      cerr << "ERROR! In Point::slope():\n"
        << "One or both char arguments are invalid or they are the same: " << m
        << ", " << n << endl << "Returning INVALID_REAL\n\n";
      return INVALID_REAL;
    }

  int ctr = m - 'x';

  real a_m_coord = a.world_coordinates[ctr];
  real p_m_coord = p.world_coordinates[ctr];

  ctr = n - 'x';

  real a_n_coord = a.world_coordinates[ctr];
  real p_n_coord = p.world_coordinates[ctr];

@ We often use |slope| in order to find out whether a line has
slope or not, so an error message is out of place here.  A warning
is too, probably, but I'm leaving this in here for now, just in
case I change my mind. 
@<Define |Point| functions@>=
  if (a_m_coord == p_m_coord)
    {
#if 0 
      cerr << "WARNING! In Point::slope():\n"
           << m << " coordinates of points are equal (no slope)!\n"
           << "Returning INVALID_REAL\n\n";
#endif 
      return INVALID_REAL;
    }
   
  return (a_n_coord - p_n_coord) / (a_m_coord - p_m_coord);
}


@q ** (2) Is on segment.@>
@*1 Is on segment.

@q *** (3) Non-const version.@>
@*2 Non-|const| version.
@^\cfunc{Point}{is\_on\_segment}@> 

|is_on_segment| returns a |Bool_Real| with the |bool| indicating
whether |*this| lies on the line segment between |p0| and
|p1|, and a |real| value $t$ representing the distance of |*this|  
on the way from |p0| to |p1|.  If the |bool| is |true|, then 
$0<=t<=1$.  If $t < 0$ or $t > 1$, then |*this| lies on the 
line passing through |p0| and |p1|, but not on the segment.  If
|*this| doesn't lie on the line, $t$ will be |INVALID_REAL|.  
\initials{LDF 2002.10.29.}


To check whether |*this| lies on the line, use
|is_on_line|.  
\initials{LDF 2002.10.29.}  


\LOG
\initials{LDF 2002.10.29.}  
@:BUG FIX@> BUG FIX:  Added code to check whether
the unit vectors |*this - p0| and |p1 - *this| are equal before
calculating |r|.  Before I did this, |true| was returned for |Points|
that weren't on the line segment.

\initials{LDF 2002.10.29.}  
Now using |world_coordinates| directly instead of  
|get_x|, |get_y|, and |get_z|.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Point| functions@>=
Bool_Real
is_on_segment(Point p0, Point p1);

@q **** (4) Definition.@>

@
@<Define |Point| functions@>=
Bool_Real
Point::is_on_segment(Point p0, Point p1)
{
  bool DEBUG = false; /* |true|  */@;

  if (DEBUG)
    cerr << "Entering Point::is_on_segment().\n";

  apply_transform();
  p0.apply_transform();
  p1.apply_transform();


  if (DEBUG)
    {
      show("this");
      p0.show("p0");
      p1.show("p1");
    }
  
  if (*this == INVALID_POINT
      || p0 == INVALID_POINT
      || p1 == INVALID_POINT)
    {
      cerr << "ERROR! In Point::is_on_segment():\n"
           << "One of the Points is invalid! "
           << "Returning false and INVALID_REAL.\n\n"; 
      return pair<bool, real>(false, INVALID_REAL);
    }

  bool b;
  real r;

  if (p0 == p1 && *this == p0)
    {
      cerr << "ERROR! In Point::is_on_segment():\n"
           << "*this and the arguments p0 and p1 are all equal. "
           << "Returning false and INVALID_REAL.\n";
      return pair<bool, real>(false, INVALID_REAL);
    }

  else if (p0 == p1) 
    {
      cerr << "ERROR! In Point::is_on_segment():\n"
           << "Arguments p0 and p1 are equal. "
           << "Returning false and INVALID_REAL.\n";
      return pair<bool, real>(false, INVALID_REAL);
    }
  
  else if (*this == p0)
    {
      return pair<bool, real>(true, 0.0);
    }

  else if (*this == p1)
    {
      return pair<bool, real>(true, 1.0);
    }@/@,
  /* \initials{LDF 2002.10.29.}  Beginning of new code.  */


  Point v0(*this - p0);  
  Point v1(p1 - *this);

  v0.apply_transform();
  v1.apply_transform();

if (DEBUG) 
  {
    v0.show("v0");
    v1.show("v1");
  }


  v0.unit_vector(true);
  v1.unit_vector(true);
  if (DEBUG) 
    {
      v0.show("v0");
      v1.show("v1");
    }



  Point v2(-v1);

  if (DEBUG) 
    {
      v2.show("v2");
    }
  
  if (v0 != v1 && v0 != v2)
    {
      if (DEBUG)
        cerr << "Not on line.\n";
      return pair<bool, real>(false, INVALID_REAL);
    }@/@,
  /* \initials{LDF 2002.10.29.}  End of new code.  */


@ \initials{LDF 2002.10.29.}  Calculate how far |*this| is on the way from |p0|
to |p1|.  

LDF Undated.  The value $t$ can be calculated from either the x,
y, or z-coordinates.  We try them in order and return the first one
that works.  Because of the limited precision with which we are
working, it's possible that the value of $t$ can differ, depending on
what coordinates are used to calculate it.  In general, this will not
be significant, since we'll mainly be needing this function to
determine whether a |Point| is on a line segment; the exact value of
$t$ will usually not be significant.
@<Define |Point| functions@>=
  if(p1.world_coordinates[0] != p0.world_coordinates[0])
    r =  (world_coordinates[0] - p0.world_coordinates[0])
      / (p1.world_coordinates[0] - p0.world_coordinates[0]);

  else if(p1.world_coordinates[1] != p0.world_coordinates[1])
    r = (world_coordinates[1] - p0.world_coordinates[1])
      / (p1.world_coordinates[1] - p0.world_coordinates[1]);

  else if(p1.world_coordinates[2] != p0.world_coordinates[2])
    r = (world_coordinates[2] - p0.world_coordinates[2])
      / (p1.world_coordinates[2] - p0.world_coordinates[2]);

  else
    {
      cerr << "ERROR! In Point::is_on_segment()\n"
        << "Can't calculate t. Returning false and INVALID_REAL.\n\n";

      return pair <bool, real>(false, INVALID_REAL);
    }
  
  if (r >= 0 && r <= 1)
    b = true;
  else
    b = false;
  return pair<bool, real>(b, r);
}

@q *** (3) const version.@>
@*2 |const| version.
@^\cfunc{Point}{is\_on\_segment}@> 

\LOG
\initials{LDF 2002.10.29.}  
Added this function.
\ENDLOG 

@<Declare |Point| functions@>=
Bool_Real
is_on_segment(const Point& p0, const Point& p1) const;

@
@<Define |Point| functions@>=
Bool_Real
Point::is_on_segment(const Point& p0, const Point& p1) const
{
  Point a(*this);
  return a.is_on_segment(p0, p1);
}

@q *** (3) |Path| reference argument.@> 
@*2 {\bf Path} reference argument.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this function declaration.  The function is defined 
in \filename{paths.web}.
\ENDLOG

@<Declare |Point| functions@>=
Bool_Real
is_on_segment(const Path& p) const;

@q ** (2) Is on line.@>
@*1 Is on line.
@^\cfunc{Point}{is\_on\_line}@> 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.10.29.}  
Maybe add a non-|const|
version.  This isn't urgent, though.
\ENDTODO 

\LOG
\initials{LDF 2002.10.29.}  
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
Bool_Real
is_on_line(const Point& p0, const Point& p1) const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
Bool_Real
Point::is_on_line(const Point& p0, const Point& p1) const
{
  Bool_Real br = is_on_segment(p0, p1);
  if (br.second != INVALID_REAL)
    br.first = true;
  return br;
}

@q ** (2) Is on |Plane|.@>
@*1 Is on {\bf Plane}.
@^\cfunc{Point}{is\_on\_plane}@> 
\initials{LDF 2003.06.04.}  

This function returns |true|, if |*this| lies on the
|Plane p|, otherwise |false|.  It must be defined in
\filename{planes.web}, because |Plane| is an incomplete type here. 
\initials{LDF 2003.06.04.}  

\LOG
\initials{LDF 2003.06.04.}  
Added this function.

\initials{LDF 2005.11.02.}
Added optional |real tolerance| argument with default -1.
\ENDLOG

@^\cfunc{Point}{is\_on\_plane}@> 
@<Declare |Point| functions@>=
bool 
is_on_plane(const Plane& p, real tolerance = -1) const;

@q ** (2) Is in triangle.@>
@*1 Is in triangle.
@^\cfunc{Point}{is\_in\_triangle}@> 
\initials{LDF 2003.06.11.}  This function returns |true|, if |*this| lies within
the triangle defined by the three |Point| arguments, otherwise
|false|.  Defined in \filename{paths.web}, because it uses 
|class Path|, which is an incompletely defined type here.

\LOG
\initials{LDF 2003.06.11.}  
Added this function.

\initials{LDF 2003.06.24.}  Removed the argument |test_points|.
\ENDLOG 

@<Declare |Point| functions@>=
bool
is_in_triangle(const Point& p0,
               const Point& p1,
               const Point& p2,
               bool verbose = false) const;


@q * (1) Setting data members.@>
@* Setting data members.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Added this section.
\ENDLOG


@q ** (2) Set |surface_hiding_ctr|.@> 
@*1 Set {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
void
set_surface_hiding_ctr(unsigned long u)
{
   surface_hiding_ctr = u;
}

@q ** (2) Reset |surface_hiding_ctr|.@> 
@*1 Reset {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
unsigned long
reset_surface_hiding_ctr(unsigned long u = 0)
{
   unsigned long old_value = surface_hiding_ctr;
   surface_hiding_ctr = u;
   return old_value;
}

@q ** (2) Get |surface_hiding_ctr|.@> 
@*1 Get {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
unsigned long
get_surface_hiding_ctr(void)
{
   return surface_hiding_ctr;
}

@q ** (2) Set |decomposition_level|.@> 
@*1 Set {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
void
set_decomposition_level(unsigned long u)
{
   decomposition_level = u;
}

@q ** (2) Reset |decomposition_level|.@> 
@*1 Reset {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
unsigned long
reset_decomposition_level(unsigned long u = 0)
{
   unsigned long old_value = decomposition_level;
   decomposition_level = u;
   return old_value;
}

@q ** (2) Get |decomposition_level|.@> 
@*1 Get {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
unsigned long
get_decomposition_level(void)
{
   return decomposition_level;
}




@q ** (2) Push draw color.@>
@*1 Push draw color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now only setting the argument |Color*& c| to 0
if the |bool copy| argument is |false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual
int
push_draw_color(Color*& c, bool copy = true);


@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
int
Point::push_draw_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      {
         d = c;
         c = 0;
      }

   *draw_color_vector += d;

   return 0;

}  /* End of |Point::push_draw_color|  */


@q ** (2) Push fill color.@>
@*1 Push fill color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now only setting the argument |Color*& c| to 0
if the |bool copy| argument is |false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual
int
push_fill_color(Color*& c, bool copy = true);



@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
int
Point::push_fill_color(Color*& c, bool copy)
{
   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      {
         d = c;
         c = 0;
      }

   *fill_color_vector += d;

   return 0;

}  /* End of |Point::push_fill_color|  */


@q ** (2) Push color.@>
@*1 Push color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now only setting the argument |Color*& c| to 0
if the |bool copy| argument is |false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual
int
push_color(Color*& c, bool copy = true);



@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
int
Point::push_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   d = create_new<Color>(c);

   *draw_color_vector += d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      {
         d = c;
         c = 0;
      }


   *fill_color_vector += d;

   return 0;

}  /* End of |Point::push_color|  */




@q ** (2) Push pen.@>
@*1 Push pen.
@^\cfunc{Point}{push\_pen}@>
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Added this function.

\initials{LDF 2005.03.17.}
Changed this function from |set_pen| to |push_pen|.
It no longer sets |Pen* pen|, which I've removed.  Instead, it 
pushes a |Pen*| onto |Pointer_Vector<Pen> pen_vector|.

\initials{LDF 2005.03.18.}
Rewrote this function.  
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual 
int 
push_pen(Pen*& p, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
int 
Point::push_pen(Pen*& p, bool copy)
{
   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      pen_vector = new Pointer_Vector<Pen>;

   Pen* q;

   if (copy == true)
      q = create_new<Pen>(p);

   else
     {
         q = p;
         p = 0;
     }

   *pen_vector += q;

   return 0;

}  /* End of |Point::push_pen| definition.  */

@q ** (2) Push dash_pattern.@>
@*1 Push {\bf Dash\_Pattern}.
@^\cfunc{Point}{push\_dash\_pattern}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual 
int 
push_dash_pattern(Dash_Pattern*& d, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
int 
Point::push_dash_pattern(Dash_Pattern*& d, bool copy)
{
   if (dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
      dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;

   Dash_Pattern* e;

   if (copy == true)
      e = create_new<Dash_Pattern>(d);

   else
     {
         e = d;
         d = 0;
     }

   *dash_pattern_vector += e;

   return 0;

}  /* End of |Point::push_dash_pattern| definition.  */


@q * (1) Functions for checking types.@> 
@* Functions for checking types.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this section.
\ENDLOG

@q ** (2) Is |Point|.@> 
@*1 Is {\bf Point}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_point(void) const
{
   return true;
}

@q ** (2) Is |Nurb|.@> 
@*1 Is {\bf Nurb}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_nurb(void) const
{
   return false;
}

@q ** (2) Is |Path|.@> 
@*1 Is {\bf Path}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_path(void) const
{
   return false;
}

@q ** (2) Is |Polygon|.@> 
@*1 Is {\bf Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_polygon(void) const
{
   return false;
}

@q ** (2) Is |Triangle|.@> 
@*1 Is {\bf Triangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_triangle(void) const
{
   return false;
}

@q ** (2) Is |Rectangle|.@> 
@*1 Is {\bf Rectangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_rectangle(void) const
{
   return false;
}

@q ** (2) Is |Reg_Polygon|.@> 
@*1 Is {\bf Reg\_Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_reg_polygon(void) const
{
   return false;
}

@q ** (2) Is |Ellipse|.@> 
@*1 Is {\bf Ellipse}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_ellipse(void) const
{
   return false;
}

@q ** (2) Is |Ellipse_Slice|.@> 
@*1 Is {\bf Ellipse\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_ellipse_slice(void) const
{
   return false;
}

@q ** (2) Is |Circle|.@> 
@*1 Is {\bf Circle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_circle(void) const
{
   return false;
}

@q ** (2) Is |Circle_Slice|.@> 
@*1 Is {\bf Circle\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_circle_slice(void) const
{
   return false;
}

@q ** (2) Is |Parabola|.@> 
@*1 Is {\bf Parabola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_parabola(void) const
{
   return false;
}


@q ** (2) Is |Hyperbola|.@> 
@*1 Is {\bf Hyperbola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_hyperbola(void) const
{
   return false;
}

@q ** (2) Is |Arc|-type.@> 
@*1 Is {\bf Arc}-type.
\initials{LDF 2007.10.13.}

\LOG
\initials{LDF 2007.10.13.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_arc_type(void) const
{
   return false;
}

@q ** (2) Is |Solid|.@> 
@*1 Is {\bf Solid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_solid(void) const
{
   return false;
}

@q ** (2) Is |Solid_Faced|.@> 
@*1 Is {\bf Solid\_Faced}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_solid_faced(void) const
{
   return false;
}

@q ** (2) Is |Polyhedron|.@> 
@*1 Is {\bf Polyhedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_polyhedron(void) const
{
   return false;
}

@q ** (2) Is |Polyhedron_Slice|.@> 
@*1 Is {\bf Polyhedron\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_polyhedron_slice(void) const
{
   return false;
}

@q ** (2) Is |Cuboid|.@> 
@*1 Is {\bf Cuboid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cuboid(void) const
{
   return false;
}

@q ** (2) Is |Cuboid_Slice|.@> 
@*1 Is {\bf Cuboid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cuboid_slice(void) const
{
   return false;
}

@q ** (2) Is |Tetrahedron|.@> 
@*1 Is {\bf Tetrahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_tetrahedron(void) const
{
   return false;
}

@q ** (2) Is |Octahedron|.@> 
@*1 Is {\bf Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_octahedron(void) const
{
   return false;
}

@q ** (2) Is |Dodecahedron|.@> 
@*1 Is {\bf Dodecahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_dodecahedron(void) const
{
   return false;
}

@q ** (2) Is |Icosahedron|.@> 
@*1 Is {\bf Icosahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_icosahedron(void) const
{
   return false;
}

@q ** (2) Is |Trunc_Octahedron|.@> 
@*1 Is {\bf Trunc\_Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_trunc_octahedron(void) const
{
   return false;
}

@q ** (2) Is |Great_Rhombicosidodecahedron|.@> 
@*1 Is {\bf Great\_Rhombicosidodecahedron}.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_great_rhombicosidodecahedron(void) const
{
   return false;
}

@q ** (2) Is |Helix|.@> 
@*1 Is {\bf Helix}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_helix(void) const
{
   return false;
}

@q ** (2) Is |Helix_Slice|.@> 
@*1 Is {\bf Helix\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_helix_slice(void) const
{
   return false;
}

@q ** (2) Is |Cone|.@> 
@*1 Is {\bf Cone}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cone(void) const
{
   return false;
}

@q ** (2) Is |Cone_Slice|.@> 
@*1 Is {\bf Cone\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cone_slice(void) const
{
   return false;
}

@q ** (2) Is |Cylinder|.@> 
@*1 Is {\bf Cylinder}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cylinder(void) const
{
   return false;
}

@q ** (2) Is |Cylinder_Slice|.@> 
@*1 Is {\bf Cylinder\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_cylinder_slice(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid|.@> 
@*1 Is {\bf Ellipsoid}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_ellipsoid(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid_Slice|.@> 
@*1 Is {\bf Ellipsoid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_ellipsoid_slice(void) const
{
   return false;
}

@q ** (2) Is |Sphere|.@> 
@*1 Is {\bf Sphere}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_sphere(void) const
{
   return false;
}

@q ** (2) Is |Sphere_Slice|.@> 
@*1 Is {\bf Sphere\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_sphere_slice(void) const
{
   return false;
}

@q ** (2) Is |Paraboloid|.@> 
@*1 Is {\bf Paraboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_paraboloid(void) const
{
   return false;
}


@q ** (2) Is |Hyperboloid|.@> 
@*1 Is {\bf Hyperboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=
virtual
inline
bool
is_hyperboloid(void) const
{
   return false;
}

@q * (1) Transformations.@>
@* Transformations.
\initials{LDF Undated.}

@q ** (2) Affine transformations.@>
@*1 Affine transformations.
\initials{LDF Undated.}

@q *** (3) Rotation around the main axes.@>
@*2 Rotation around the main axes.
@^\cfunc{Point}{rotate}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.01.22.}  
Replaced body of function.  |Transform::rotate|
returns a |Transform| representing the rotation only, so I don't need
to use a locally declared |Transform t| in this function.
\ENDLOG 

@<Declare |Point| functions@>=
Transform
rotate(const real x, const real y = 0, const real z = 0);

@ 
@<Define |Point| functions@>= 
Transform 
Point::rotate(const real x, const real y, const real z)
{
  return transform.rotate(x, y, z);
}

@q *** Scale. @> 
@ Scale.
@^\cfunc{Point}{scale}@>
\LOG
\initials{LDF 2003.01.22.}  Replaced body of function.  |Transform::scale|
returns a |Transform| representing the rotation only, so I don't need
to use a locally declared |Transform t| in this function.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
scale(real x, real y = 1, real z = 1);

@ 
@<Define |Point| functions@>= 
Transform
Point::scale(real x, real y, real z)
{
  return transform.scale(x, y, z);
}

@q *** Shear.@> 
@ Shear.
@^\cfunc{Point}{shear}@>
\LOG
\initials{LDF 2003.01.22.}  Replaced body of function.  |Transform::shear|
returns a |Transform| representing the rotation only, so I don't need
to use a locally declared |Transform t| in this function.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
shear(real xy, real xz = 0, real yx = 0, real yz = 0, 
      real zx = 0, real zy = 0);

@ 
@<Define |Point| functions@>= 
Transform
Point::shear(real xy, real xz, real yx, real yz, 
      real zx, real zy)
{
  return transform.shear(xy, xz, yx, yz, zx, zy);
}

@q *** Shift.@>
@ Shift.  

@q **** (4) Point versions.@>
@ {\bf Point} versions.@>

@q ***** (5) Three real arguments. @>
@ Three {\bf real} arguments.
@^\cfunc{Point}{shift}@>
@<Declare |Point| functions@>=
Transform 
shift(real x, real y = 0, real z = 0);

@
@<Define |Point| functions@>=
Transform 
Point::shift(real x, real y, real z)
{
  Transform t;
  if (x != ZERO_REAL || y != ZERO_REAL || z != ZERO_REAL)
    transform *= t.shift(x, y, z);
  return t;
}

@q ***** (5) Point argument. @>
@ {\bf Point} argument.
@^\cfunc{Point}{shift}@>
@<Declare |Point| functions@>=
Transform 
shift(const Point& p);

@
@<Define |Point| functions@>=
Transform 
Point::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}

@q **** (4) {\bf Transform} version.  |Point| argument.@>
@ {\bf Transform} version.  |Point| argument.
@^\cfunc{Transform}{shift}@>
\initials{LDF 2002.04.24.}  Added this function.  It's declared in
\filename{transfor.web}, but must be defined here, because |Point| is   
an incomplete type there. 

@<Define |Transform| functions@>=
Transform 
Transform::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}

@q **** (4) Picture version.  Point argument.@>
@ {\bf Picture} version. |Point| argument.
@^\cfunc{Picture}{shift}@>
\initials{LDF 2002.08.08.}  Added this function.  It's declared in
\filename{pictures.web}, but must be defined here, because |Point| is
an incomplete type there. 
@<Define |Picture| functions@>=
Transform 
Picture::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}


@q *** Shift times.@>
@ Shift times.  



\initials{LDF 2003.01.19.}  Note that |shift_times| will only have an effect 
if it's called {\it after\/} a call to
|shift| and {\it before\/} an operation is applied that causes
|apply_transform| to be called.

\LOG
\initials{LDF 2003.01.19.}  Added this section.
\ENDLOG 

@q **** (4) Three real arguments. @>
@ Three {\bf real} arguments.
@^\cfunc{Point}{shift\_times}@>

\LOG
\initials{LDF 2003.01.19.}  Added this function.

\initials{LDF 2003.01.22.}  Got rid of local |Transform t|.  It wasn't needed.
Now just returning the return value of |transform.shift_times|.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
shift_times(real x, real y = 1, real z = 1);


@
@<Define |Point| functions@>=
Transform
Point::shift_times(real x, real y, real z)
{
  return transform.shift_times(x, y, z);
}

@q **** (4) Point argument. @>
@ {\bf Point} argument.
@^\cfunc{Point}{shift\_times}@>

\LOG
\initials{LDF 2003.01.19.}  Added this function.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
shift_times(const Point& p);

@
@<Define |Point| functions@>=
Transform
Point::shift_times(const Point& p)
{
  return transform.shift_times(p.get_x(), p.get_y(), p.get_z());
}


@q *** (3) Alignment with an axis. @>

@*2 Alignment with an axis.
@^\cfunc{Transform}{align\_with\_axis}@>
Declared in \filename{transfor.web}.  Defined here, because it needs
|Points|. 
\initials{LDF 2002.10.23.}  |align_with_axis| returns the
|Transform| needed to align 
$\overrightarrow{p_0p_1}$ with one of the main axes.
  
\initials{LDF 2003.05.04.}  
@:!! BUG@> BUG: @:!! TO DO@> TO DO:  Try to find out why I sometimes
get erroneous results with\newline
|rotate(Point, Point, real)| 
(formerly |rotate_around|).  I think the problem may be here.


\LOG
\initials{LDF 2002.12.10.}  
Made this function a |friend| in |class Point|.  
Now calling |p0.apply_transform| and |p1.apply_transform| at the beginning of
this function and using |p0.world_coordinates| and\newline
|p1.world_coordinates| directly instead of |get_x|, |get_y|, and |get_z|.  

\initials{LDF 2002.12.10.}  
Now calling |p0.apply_transform| 
and |p1.apply_transform|.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@q **** (4) Definition. @>
@
@<Define |Transform| functions@>= 
Transform
Transform::align_with_axis(Point p0, Point p1,
                           char axis) /* Default is the z-axis. */
{
  bool DEBUG = false; /* |true|  */@;
  if (DEBUG)
        cerr << "Entering Transform::align_with_axis." << endl;

  Point origin_pt(0, 0, 0);

  p0.apply_transform(); 
  p1.apply_transform();

  Transform t;

@ Upper- or lowercase is permitted for |axis|.
\initials{LDF Undated.}
@<Define |Transform| functions@>= 
  axis = tolower(axis);  

  if (axis != 'x' && axis != 'y' && axis != 'z')
    {
      cerr << "ERROR! In Transform::align_with_axis(). "
           << "Invalid \"axis\" argument: "
        << axis << endl << "Returning identity matrix." << endl;
      return t;
    }

  real angle;
  
@ \initials{LDF 2002.10.23.}  Shift |p0| to origin, and shift |p1| 
the same way, so that the relationship between them remains constant.
@<Define |Transform| functions@>= 

  if(p0 != origin_pt)
    {
      if (DEBUG)
        {
          p0.show("p0");
          p1.show("p1");
        }
      t.shift(-p0);
      p1 *= t;
      p1.apply_transform();
      p0.apply_transform();
    }




   @<Normalize point@>  /* \initials{LDF 2002.10.23.}  Transform the |Point| so
                          that it's x, y, and z coordinates are all
                          positive.  See below for the explanation.  */

  if (DEBUG)
    {
      t.show("t outside of  normalization");
    }

  Point proj_on_x_z_plane(p1); /* \initials{LDF 2002.10.23.}  Get the projection
                                  of |p1| on the x-z plane.  */
  proj_on_x_z_plane.shift(0, -p1.world_coordinates[1]);

  if (DEBUG) 
    proj_on_x_z_plane.show("proj_on_x_z_plane");


@ \initials{LDF 2002.10.23.}  If we're aligning with the x or y-axis, rotate
|p1| onto the x-y plane and then to the x-axis.

\LOG
\initials{LDF 2004.05.02.}  Changed |pt_on_x_axis.set(1)| to 
|pt_on_x_axis.set(1, 0, 0)|.  This |Point| constructor now requires
three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.
\ENDLOG 

@<Define |Transform| functions@>= 

  if (axis == 'x' || axis == 'y')
    {
      Point pt_on_x_axis;
      
      pt_on_x_axis.set(1, 0, 0);

      angle = proj_on_x_z_plane.angle(pt_on_x_axis);

      if (DEBUG) 
        cerr << "angle of projection: " << angle << endl;

      if(angle != ZERO_REAL && angle != INVALID_REAL)
        t *= p1.rotate(0, -angle);

      if (DEBUG) 
        p1.show("p1 after rotation to x-y plane");

      angle = p1.angle(pt_on_x_axis);

      if (DEBUG) 
        cerr << "angle to x-axis: " << angle << endl;

      if(angle != ZERO_REAL && angle != INVALID_REAL)
        t *= p1.rotate(0, 0, -angle);

      if (DEBUG) 
        p1.show("p1 after rotation to x-axis");
    }

@ \initials{LDF 2002.10.23.}  If we're aligning with the z-axis, rotate |p1| onto  
the y-z plane and then to the z-axis. 
@<Define |Transform| functions@>= 

  else if (axis == 'z')
    {

      Point pt_on_z_axis;
      
      pt_on_z_axis.set(0, 0, 1);  /* \initials{LDF 2002.10.23.}  This assumes
                                     that |proj_on_x_z_plane.get_z() >= 0|. 
                                     It should be, but if it isn't, the
                                     following error handling code takes 
                                     care of the problem.  */

      if (proj_on_x_z_plane.get_z() < 0)
        {
          cerr << "ERROR! In Transform::align_with_axis():\n"
               << "proj_on_x_z_plane.get_z() < 0\n"
               << "@@<Normalize point@@> should ensure that "
               << "this value is >= 0.\n"
               << "Handling the error, but find out why it happened!" 
               << endl << endl;
          pt_on_z_axis.set(0, 0, -1);
        }


@
\LOG
\initials{LDF 2002.12.10.}  Added the following conditional.  
Trying to fix a bug that occurred while
porting to GNU/Linux.  
\ENDLOG  
@<Define |Transform| functions@>= 
      if (   proj_on_x_z_plane.world_coordinates[0] == ZERO_REAL  
          && proj_on_x_z_plane.world_coordinates[1] == ZERO_REAL)
        angle = ZERO_REAL;
      else
        angle = proj_on_x_z_plane.angle(pt_on_z_axis);

@
@<Define |Transform| functions@>= 


      if (DEBUG) 
        cerr << "angle of projection: " << angle << endl;

      if(angle != ZERO_REAL && angle != INVALID_REAL)
        t *= p1.rotate(0, angle);

      if (DEBUG) 
        p1.show("p1 after rotation to z-y plane");

      p1.apply_transform();

@
\LOG
\initials{LDF 2002.12.10.}  Added the following conditional.  Trying to fix a bug
that occurred while porting to GNU/Linux.  

\initials{LDF 2003.06.13.}  @:BUG FIX@> BUG FIX:  Changed |proj_on_x_z_plane| to
|p1| in the ``|if|'' part of the following conditional.  The
y-coordinate of |proj_on_x_z_plane| is always 0, so |angle| was always
set to 0.  I discovered this bug when I tried rotating a |Point| in
the plane of a |Reg_Polygon| about a line from the center of the
|Reg_Polygon| in the direction of its normal, and the resulting
|Point| was not in the same plane.  
\ENDLOG  
@<Define |Transform| functions@>= 
if (p1.world_coordinates[1] == ZERO_REAL)  
  angle = ZERO_REAL;
else
  angle = p1.angle(pt_on_z_axis);
@
@<Define |Transform| functions@>= 


 if (DEBUG) 
   cerr << "angle to z-axis: " << angle << endl;


      if(angle != ZERO_REAL && angle != INVALID_REAL)
        t *= p1.rotate(-angle);
      
      if (DEBUG) 
        p1.show("p1 after rotation to z-axis");
    }


@ \initials{LDF 2002.10.23.}  If we're aligning with the y-axis, |p1| must be
rotated from the x-axis (where it is now) around the z-axis by
$90^\circ$.  Then it will be on the y-axis.
@<Define |Transform| functions@>= 

  if (axis == 'y')
    {
      t *= p1.rotate(0, 0, 90);

      if (DEBUG) 
        p1.show("p1 after rotation to y-axis");
    }


  if (DEBUG)
    {
      cerr << "p1.magnitude() == " << p1.magnitude() << endl;
      t.show("t at end of align_with_axis()");
    }

  *this *= t;   

  if (DEBUG)
    cerr << "Exiting Transform::align_with_axis." << endl;

  return t;
}

@q **** (4) Normalize point. @>
@*3 Normalize point.  

It makes it easier to determine the correct
direction of rotation toward the x-y or y-z plane if |p1|'s coordinates
are all $>= 0$, so we rotate it in order to make them so.  The only
case that requires more than a rotation around a single axis is the
case that $x_{p1}$, $y_{p1}$, and $z_{p1}$ are all $<0$. 
It would be nice if I could replace this long conditional with a more
elegant construction, but I don't know one.

@<Normalize point@>=
{
 
  if (DEBUG) 
    p1.show("p1 before normalization");

  if (p1.world_coordinates[0] < 0 && p1.world_coordinates[1] >= 0
      && p1.world_coordinates[2] >= 0)  /* x negative, y and z positive. */   
    t *= p1.rotate(0, -90);
  
  else if (p1.world_coordinates[0] >= 0 && p1.world_coordinates[1] < 0
           && p1.world_coordinates[2] >= 0)  /* x positive, y negative, z positive. */
    t *= p1.rotate(90);

  else if (p1.world_coordinates[0] >= 0 && p1.world_coordinates[1] >= 0
           && p1.world_coordinates[2] < 0)  /* x positive, y positive, z negative. */
    t *= p1.rotate(-90);

  else if (p1.world_coordinates[0] < 0 && p1.world_coordinates[1] < 0
           && p1.world_coordinates[2] >= 0)  /* x negative, y negative, z positive. */
    t *= p1.rotate(0, 0, 180);

  else if (p1.world_coordinates[0] < 0 && p1.world_coordinates[1] >= 0
           && p1.world_coordinates[2] < 0)  /* x negative, y positive, z negative. */
      t *= p1.rotate(0, 180);

  else if (p1.world_coordinates[0] >= 0 && p1.world_coordinates[1] < 0
           && p1.world_coordinates[2] < 0)  /* x positive, y negative, z negative. */
      t *= p1.rotate(180);

  else if (p1.world_coordinates[0] < 0 && p1.world_coordinates[1] < 0
           && p1.world_coordinates[2] < 0)  /* All negative. */
    {
      real a = p1.world_coordinates[0];
      t *= p1.rotate(180, 180);
      t *= p1.shift(a);
      t *= p1.rotate(0, 180);
      t *= p1.shift(-a);
    }
  p1.apply_transform();
  if (DEBUG)
    {
      p0.show("p0 after normalization");
      p1.show("p1 after normalization");
      t.show("t after normalization");
    }
}



@q *** (3) Rotation around an arbitrary axis. @>
@*2 Rotation around an arbitrary axis.


@q **** {\bf Point} versions.@>
@ {\bf Point} versions.
\initials{LDF 2002.4.7.}  Added default value for |angle| $\equiv 180$.

@q ***** {\bf Point} arguments.@>
@ {\bf Point} arguments.
@^\cfunc{Point}{rotate}@>
This function first checks to see if |*this| lies on the axis.  It
does this by creating unit vectors in the directions of |p1 - p0| and
|*this - p0|.  If they are equal, or the latter is the former
multiplied by -1, then we don't bother to perform the rotation.
Otherwise, we call |Transform::rotate| (defined below).

\LOG 
\initials{LDF 2002.4.7.}  Added default value for |angle| $\equiv 180$.

\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
rotate(const Point& p0, const Point& p1,
              const real angle = 180);

@ 
@<Define |Point| functions@>= 
Transform
Point::rotate(const Point& p0, const Point& p1,
                     const real angle)
{
  Point a = p1 - p0;
  Point b = *this - p0;
  
  a.unit_vector(true);
  b.unit_vector(true);

  Transform t;

  if (a == b || a == -b)
    {
      cerr << "WARNING! In Point::rotate().\n"
           << "Point to be rotated lies on axis.\n"
           << "Returning identity Transform.\n\n";
      return t;
    }
  return transform.rotate(p0, p1, angle);
}

@q ***** {\bf Path} argument.@>
@ {\bf Path} argument.  
@^\cfunc{Point}{rotate}@>
Defined in \filename{paths.web}, because
|Path| is still an incomplete type in this compilation unit.

\LOG
\initials{LDF 2002.04.07.}  Added default value for |angle| $\equiv 180$.

\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Declare |Point| functions@>=
Transform
rotate(const Path& p,  const real angle = 180);
   
   

@q **** {\bf Transform} version.@>
@ {\bf Transform} version.  Declared in \filename{transfor.web}. 
@^\cfunc{Transform}{rotate}@>
\initials{LDF 2002.09.29.}
@:!! TO DO@> TO DO: 
@:BUGS@>  Possible BUG!!  Actually, the problem
that occurred may just have to do choosing the direction of rotation.
I've changed the place where the problem occurred, so I'll have to
write a routine to test this.

\LOG
\initials{LDF 2002.10.23.}  Changed, so that the direction of
$\overrightarrow{p_0p_1}$ is tested.  If it is parallel to the x or
y-axis, then that axis is used for alignment.  Otherwise, the z-axis
is used.  This may help reduce inaccuracies caused by rotations.
Haven't tested it yet.  @:!! TO DO@> TO DO:  Test this!

\initials{LDF 2002.11.03.}  @:!! TO DO@> TO DO:  See if I can't make |Point|
arguments |const|.  


\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Define |Transform| functions@>= 
Transform
Transform::rotate(Point p0, Point p1, const real angle)
{
  bool DEBUG = false; /* |true|  */@;
  if (DEBUG)
    cerr << "Entering Transform::rotate().\n";
  p0.apply_transform();
  p1.apply_transform();
  Point a = p1 - p0;
  a.unit_vector(true);
  char axis;
  if (a.get_x() == 1 || a.get_x() == -1)
    axis = 'x';
  else if (a.get_y() == 1 || a.get_y() == -1)
    axis = 'y';
  else axis = 'z';

  Transform t;
  t.align_with_axis(p0, p1, axis);
  Transform i = t.inverse();
  if (axis == 'x')
    t.rotate(angle);
  else if (axis == 'y')
    t.rotate(0, angle);
  else
    t.rotate(0, 0, angle);

  t *= i;
  t.clean();
  *this *= t;
  clean();
  return t;
}




@q **** {\bf Picture} version.@>
@ {\bf Picture} version.
@^\cfunc{Picture}{rotate}@>
\initials{LDF 2002.10.20.}  |angle| is in degrees.

\LOG
\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Define |Picture| functions@>=
Transform 
Picture::rotate(const Point& p0, const Point& p1,
                       const real angle)
{
  Transform t;
  t.rotate(p0, p1, angle);
  transform *= t;
  return t;
}

@q ** (2) Projection.@>
@*1 Projection. 
@^\cfunc{Point}{project}@>

\initials{LDF 2002.10.23.}  For stylistic reasons, and for the sake of clean
programming, I believe that the programmer who uses |project|
should ensure that |apply_transform| has been invoked first.
However, |transform| is checked in |project| and |apply_transform|
is invoked, if required, so invoking |apply_transform| explicitly
beforehand is not strictly speaking necessary.  

\LOG
\initials{LDF 2002.09.09.}  
The new version now almost works  Added division of
|projective_coordinates| by the 
value calculated for |w|.  However, it doesn't work when I use
|hex_pattern1|.  Find out why not!!
@:!! TO DO@> TO DO: Add routine for calculating |z|.  Then I can add
sorting routine in |Picture::output|.

\initials{LDF 2002.09.14.}  
I believe I've gotten the new version to work now.  
@:!! LOOK UP@> LOOK UP: Do I need to divide the derived |z| value by
|w|? I don't think it's necessary.  Since the |z| values of all of the
|Points| would be divided by the same amount, their relative positions
would remain the same, since only the relationship ``closer or further
away'' matters, not the exact amounts.

\initials{LDF 2002.09.16.}  
Added |Focus| argument to this function.
Default is |default_focus|, but it was necessary to write a dummy version of
this function in order to make this work, because |default_focus| doesn't
exist at the time that this declaration is compiled.

\initials{LDF 2002.09.18.}  
Changed name of this function from
|persp_transform| to |project| and added |Transform| argument.

\initials{LDF 2002.10.23.} 
Now checking |!transform.is_identity| before calling 
|apply_transform|, just to be sure.  

\initials{LDF 2003.05.09.}  
@:BUG FIX@> BUG FIX:  Added loop, setting
all elements of |projective_coordinates| to 0.  This was done in the
conditionally compiled code for the DEC compiler, but I forgot to do
it for GCC when added the declaration of |temp_coordinates| and
resized it.  It took me about 6--7 hours to find this bug!

\initials{LDF 2003.07.11.}  
Added defaults for |proj| and |factor|.

\initials{LDF 2004.06.07.}  
Removed the version of this function with no |Focus| argument.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
bool 
project(const Focus& f,
        const unsigned short proj = Projections::persp,
        real factor = 1);

@q *** (3) Definition.@>   

@
@<Define |Point| functions@>=
bool
Point::project(const Focus& f, const unsigned short proj, real factor)
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering project().\n";


  if (!transform.is_identity())   
    apply_transform();

#ifdef __GNUC__
  valarray <real> temp_coordinates;
  temp_coordinates.resize(4, 0);
  for (int i = 0; i < 4; ++i) /* LDF 2003.05.09.  Added this loop.  */
    projective_coordinates[i] = 0;
#else 
#ifdef __DECCXX
  valarray <real> temp_coordinates = 
    projective_coordinates = null_coordinates;
#endif 
#endif 

  int i;
  int j;  
  
  /* \initials{LDF 2002.09.18.}  Transform |temp_coordinates| by
     |Focus::transform|. */
  for(i = 0; i < 4; i++)
    {
      for(j = 0; j < 4; j++)
        {
          temp_coordinates[i]
            += world_coordinates[j] * f.get_transform_element(j, i);
        }
    }

@q **** (4) Set |pre_projective_coordinates|.@>   
@ Set |pre_projective_coordinates|.
\initials{LDF 2005.06.30.}

\LOG
\initials{LDF 2005.06.30.}
Added this section.
\ENDLOG

@<Define |Point| functions@>=

  for(i = 0; i < 4; i++)
     {
        pre_projective_coordinates[i] = temp_coordinates[i];
     }


@q **** (4) Parallel projection.@>
@ Parallel projection.\newline  

The projective coordinates are simply taken from the world coordinates. 
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.10.23.}  
Added this section.  

\initials{LDF 2002.12.18.}  
Changed |PARALLEL| to |PARALLEL_X_Y| and added |PARALLEL_X_Z| 
and |PARALLEL_Z_Y|.
\ENDLOG 

@<Define |Point| functions@>=

   if (   proj == Projections::parallel_x_y 
       || proj == Projections::parallel_x_z
       || proj == Projections::parallel_z_y)  
       {
         using namespace Projections;
         if (factor == ZERO_REAL)
           {
             cerr << "ERROR! In Point::project():\n"
                  << "factor == 0.  Multiplying coordinates by 0 doesn't make sense. "
                  << "Using 1 instead.\n\n";
             factor = 1;
           }

         unsigned short horizontal;
         unsigned short vertical;

@q ***** (5)@>  
@         
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.12.18.}  
Explain this!
\ENDTODO 

@<Define |Point| functions@>=

@q ***** (5)@>  
@
@<Define |Point| functions@>=

         if (proj == parallel_x_y || proj == parallel_x_z) 
           horizontal = 0;
         else
           horizontal = 2;

         if (proj == parallel_x_y || proj == parallel_z_y)
           vertical = 1;  
         else
           vertical = 2;
           

         projective_coordinates[0] = world_coordinates[horizontal] * factor; 
         projective_coordinates[1] = world_coordinates[vertical] * factor; 
         projective_coordinates[2] = 0;                             
         projective_coordinates[3] = 1;

         if (DEBUG)
           {
             cerr << "projective_coordinates: (" 
                  << projective_coordinates[0] << ", " 
                  << projective_coordinates[1] << ", " 
                  << projective_coordinates[2] << ", " 
                  << projective_coordinates[3] << ")" << endl << endl;

           }

         
         return true;
       }

  
@q **** (4) Perspective projection.@>
@ Perspective projection.
\initials{LDF Undated.}

@:KLUDGE@> KLUDGE: See below.  
\initials{LDF Undated.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.11.08.}  
Get numbers to output using {\it only\/} decimal notation!
\ENDTODO 

@<Define |Point| functions@>=

  if (temp_coordinates[2] + f.get_distance() == ZERO_REAL)
    {
      cerr << "ERROR! In Point::project():\n"
           << "temp_coordinates[2] == " << temp_coordinates[2]
           << ", f.distance == " << f.get_distance() << endl
           << "Sum == 0. Can't perform division." << endl
           << "Setting projective_coordinates to INVALID_REAL" 
           << " and returning.\n";
      for (i = 0; i < 4; i++)
        projective_coordinates[i] = INVALID_REAL;
      return false;
    }

  else if (temp_coordinates[2] + f.get_distance() < 0)
  {
    cerr << "ERROR! In Point::project():\n"
         << "temp_coordinates[2] == " << temp_coordinates[2]
         << ", f.distance == " << f.get_distance() << endl
         << "Their sum < 0. Point lies behind focus." << endl
         << "Setting projective_coordinates to INVALID_REAL" 
         << " and returning.\n";
      for (i = 0; i < 4; i++)
        projective_coordinates[i] = INVALID_REAL;
      return false;
  }


  real save_z = temp_coordinates[2] / (temp_coordinates[2] + f.get_distance());

  if (DEBUG)
    {
      cerr << "temp_coordinates[2] == " << temp_coordinates[2]
        << endl;
      cerr << "f.get_distance() == " << f.get_distance() << endl;
      cerr << "save_z == " << save_z << endl;
    }


  for(i = 0; i < 4; i++)
    {
      for(j = 0; j < 4; j++)
        {
          projective_coordinates[i]
            += temp_coordinates[j] * f.get_persp_element(j, i);
        }
    }


  real eps = epsilon();

  if (projective_coordinates[3] == ZERO_REAL)
    {
      cerr << "ERROR! In Point::project(): "
           << "projective_coordinates[3] == 0.\n" 
           << "This will cause a floating point error.\n"
           << "Setting projective_coordinates to INVALID_REAL" 
           << " and returning.\n";
      for (i = 0; i < 4; i++)
        projective_coordinates[i] = INVALID_REAL;
      return false;
    }

  for (i = 0; i < 4; i++)
    {
      projective_coordinates[i] /= projective_coordinates[3];

      if (fabs(projective_coordinates[i]) < eps)
        projective_coordinates[i] = 0;
    }

  /*  \initials{LDF 2002.09.14.}  
      Set the |z| value of the perspective coordinates in order to be 
      able to use it for my hidden surface algorith.  */

@

@<Define |Point| functions@>=

  projective_coordinates[2] = (fabs(save_z) > eps) ? save_z : 0;

@
@<Define |Point| functions@>=

  if (DEBUG)
    {
      cerr << "Projective coordinates:\n(";
      for (i = 0; i < 4; i++)
        {
          cerr << projective_coordinates[i];
          if (i < 3)
            cerr << ", ";
        }

      cerr << ")\n";
    }


  for (i = 0; i < 2; i++)    /* \initials{LDF 2002.11.07.}  KLUDGE.  Added this
                                loop.  The value used for comparison
                                is slightly larger than 
                                one that arose while I was testing 
                                the constructor of
                                |Trunc_Octahedron|.  |eps| was too
                                small.  */

    if(fabs(projective_coordinates[i]) <= 10.0e-05)
      projective_coordinates[i] = 0;

  if (DEBUG)
    cerr << "Exiting project().\n";
  return true;

}  /* End of |Point::project| definition.  */


@q ** (2) Applying transformations.@>
@*1 Applying transformations. 
@^\cfunc{Point}{apply\_transform}@>
This version applies the transformation
stored in |Point::transform|. 
@:!!@> !! Add a version that applies a
|Transform| supplied as an argument!! 
\initials{LDF 2002.12.08.}  @: BUG FIX@> BUG FIX:  See below.  
@<Declare |Point| functions@>=
void 
apply_transform();

@ 
@<Define |Point| functions@>=
void
Point::apply_transform()
{
  bool DEBUG = false; /* |true|  */@; 

  if (transform.is_identity())  /* If |transform.matrix| is the
                                   identity matrix, 
                                   we don't need to bother to 
                                   perform the 
                                   matrix multiplication. */
    return;

  int i;
  int j;  
  valarray <real> new_coordinates;


  new_coordinates.resize(4, 0); /* \initials{LDF 2002.12.08.}  BUG FIX.  
                                   For GNU CC.  */



  if (DEBUG)
    {
      cerr << "x == " << world_coordinates[0] << endl;
      cerr << "y == " << world_coordinates[1] << endl;
      cerr << "z == " << world_coordinates[2] << endl;
      cerr << "w == " << world_coordinates[3] << endl;
    }

  for(i = 0; i < 4; i++)
        {
          for(j = 0; j < 4; j++)
            {
              new_coordinates[i]
                += world_coordinates[j] * transform.transform_matrix[j][i];

              if (new_coordinates[i] != ZERO_REAL)
                {
                  if (DEBUG)
                    {
                      cerr << "new_coordinates[" << i << "] == "
                           << new_coordinates[i] << endl;
                    }
                }
          }
        }
  real eps = epsilon();
  for (i = 0; i < 4; i++)
        {
          if (DEBUG)
            {
              cerr << "new_coordinates[" << i << "] == "
                   << new_coordinates[i] << endl;
            }

          world_coordinates[i]
            = ( fabs(new_coordinates[i]) > eps)
              ? new_coordinates[i] : 0;
        }

  transform.reset();
} 


@q ** Set transform to identity. @>
@ Set {\bf transform} to identity.
@^\cfunc{Point}{reset\_transform}@>
@<Declare |Point| functions@>=
void
reset_transform();

@
@<Define |Point| functions@>=
void
Point::reset_transform()
{
  transform.reset();
}


@q * (1) Drawing.@>
@* Drawing.
\initials{LDF Undated.}

@q ** (2) Drawdot.@>
@*1 Drawdot.
@^\cfunc{Point}{drawdot}@>
\initials{LDF Undated.}

|drawdot| copies |*this| and puts the copy onto the |vector shapes|
of the |Picture| argument |picture|.  The data members |drawdot_value|,  
|drawdot_color|, and |pen| are only set on the copy, not on |*this|.
All of the drawing and filling functions behave similarly.
\initials{LDF 2002.10.26.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.05.30.}  
Add code for allocating new
|Color|, if |ddrawdot_color.use_name| is |false|, as in the drawing
and filling functions for |Path| and |Solid|.  
\ENDTODO 

\LOG
\initials{LDF 2003.07.11.}  
Made |ppen| and |drawdot| itself |const|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.21.}  
Changed return value from |void| to |int|.  
Now locking and unlocking |picture.mutex| if Autoconf has defined the
preprocessor variable |HAVE_PTHREAD_H|.

\initials{LDF 2004.06.21.}
Now calling |create_new<Point>(this)| to create |pt| instead of 
calling |create_new<Point>(0)| and setting |*pt = *this| afterwards. 

\initials{LDF 2004.06.21.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory and calling 
|create_new<Color>| for |pt->drawdot_color| if |ddrawdot_color| 
is a non-null pointer.  Otherwise, setting |pt->drawdot_color| to 0.  This is
just for insurance, since it's set to 0 in the |Point| constructor called by
|create_new<Point>|.
This prevents erroneous |withcolor| clauses from being
written to the MetaPost output file.

\initials{LDF 2004.06.21.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory and calling 
|create_new<Pen>| for |pt->pen| if |ppen| 
is a non-null pointer.
Otherwise, setting |pt->pen| to 0.  This is
just for insurance, since it's set to 0 in the |Point| constructor called by
|create_new<Point>|.  
This prevents erroneous |withpen| clauses from being
written to the MetaPost output file.

\initials{LDF 2005.03.17.}
Replaced code for setting |pt->drawdot_color| with 
code for setting |draw_color_vector|.

\initials{LDF 2005.03.17.}
Made the argument |Color* ddrawdot_color| non-|const|.

\initials{LDF 2005.03.17.}
Made the argument |Color* ddrawdot_color| |const| again.
Now calling |pt->push_draw_color| with |true| as the 
|bool copy| argument, if |ddrawdot_color| is non-null.

\initials{LDF 2005.03.17.}
No longer setting |Pen* Point::pen|, which I've removed, if 
the argument |const Pen* ppen| is non-null.  Instead, calling
|pt->pen_vector->push_pen|.

\initials{LDF 2005.03.18.}
Made the |Pen* ppen| argument non-|const|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=
int
drawdot(Picture& picture,
        Color* ddrawdot_color,
        Pen* ppen) const;

@q *** (3) Definition.@>

@ 
@<Define |Point| functions@>=
int 
Point::drawdot(Picture& picture,
               Color* ddrawdot_color,
               Pen* ppen) const
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering drawdot()" << "\n";
#endif /* |DEBUG_COMPILE|  */@; 

    Point* pt = create_new<Point>(this);

    pt->drawdot_value = DRAWDOT_VALUE;  

  if (ddrawdot_color != static_cast<Color*>(0))
    pt->push_draw_color(ddrawdot_color, true);
  
  if (ppen != static_cast<Pen*>(0))
     {
        pt->push_pen(ppen);
     }

@q **** (4) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Point| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In 'Point::drawdot':"
             << "'Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "'Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;


@q **** (4) Add |pt| to |picture|.@>   
@ Add |pt| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Point| functions@>=

    picture += static_cast<Shape*>(pt);


@q **** (4) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Point| functions@>=


#ifdef HAVE_PTHREAD_H  

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In 'Point::drawdot':"
             << "'Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "'Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q **** (4) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Point| functions@>=

#if DEBUG_COMPILE
    if (DEBUG) 
      cerr << "Exiting drawdot(), returning 0." << "\n";
#endif /* |DEBUG_COMPILE|  */@; 

    return 0;
}

@q ** (2) Undrawdot.@>
@*1 Undrawdot.
@^\cfunc{Point}{undrawdot}@>
\initials{LDF Undated.}

\initials{LDF 2002.10.26.}  
|undraw| does not remove a dot from |picture|, but
causes the \MP/ command {\bf undrawdot} to be written to
|out_stream| when |picture| is output.
\initials{LDF 2002.10.26.}  

\LOG
\initials{LDF 2004.05.25.}  Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.


\initials{LDF 2004.06.03.}  Now setting |pt->drawdot_color = 0| instead of
|pt->drawdot_color = Colors::background_color|, since I've gotten rid of 
|Colors::background_color|.

\initials{LDF 2004.06.21.}  
Changed return value from |void| to |int|.  
Now locking and unlocking |picture.mutex| if Autoconf has defined the
preprocessor variable |HAVE_PTHREAD_H|.

\initials{LDF 2004.06.21.}
Now calling |create_new<Point>(this)| to create |pt| instead of 
calling |create_new<Point>(0)| and setting |*pt = *this| afterwards. 

\initials{LDF 2004.06.21.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory and calling 
|create_new<Pen>| for |pt->pen| if |ppen| 
is a non-null pointer.
Otherwise, setting |pt->pen| to 0.  This is
just for insurance, since it's set to 0 in the |Point| constructor called by
|create_new<Point>|.  This prevents erroneous |withpen| clauses from being
written to the MetaPost output file.

\initials{LDF 2004.06.21.}
Now calling |create_new<Point>(this)| to create |pt| instead of 
calling |create_new<Point>(0)| and setting |*pt = *this| afterwards. 

\initials{LDF 2005.03.17.}
Removed code for setting |pt->drawdot_color| to 0.

\initials{LDF 2005.03.17.}
No longer setting |Pen* Point::pen|, which I've removed, if 
the argument |const Pen* ppen| is non-null.  Instead, 
calling |pt->pen_vector->push_pen|.

\initials{LDF 2005.03.18.}
Made the |Pen* ppen| argument non-|const|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=
int 
undrawdot(Picture& picture, Pen* ppen);

@q *** (3) Definition.@>

@ 
@<Define |Point| functions@>=
int
Point::undrawdot(Picture& picture, Pen* ppen) 
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  Point* pt = create_new<Point>(this);
  
  pt->drawdot_value = UNDRAWDOT_VALUE;  


  if (ppen != static_cast<Pen*>(0))
     {
        pt->push_pen(ppen);
     }


#ifdef HAVE_PTHREAD_H  

  int status;

  status = picture.lock();
  
  if (status != 0)
    {
      cerr << "ERROR! In 'Point::undrawdot':"
           << "'Picture::lock' failed. "
           << "Returning 1 and will try to continue."
           << endl;
      return 1;
    }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "'Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

  picture += static_cast<Shape*>(pt);
  

#ifdef HAVE_PTHREAD_H  

  status = picture.unlock();

  if (status != 0)
    {
      cerr << "ERROR! In 'Point::undrawdot':"
           << "'Picture::unlock' failed. "
           << "Returning 1 and will try to continue."
           << endl;
      return 1;
    }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "'Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 
#endif /* |HAVE_PTHREAD_H|  */@; 

  return 0;
}


@q ** (2) Draw.@>
@*1 Draw.
@^\cfunc{Point}{draw}@>

|draw| creates a |Path| with the two |Points| |*this| and the
argument |p|, and the connector |"--"|, calls |Path::draw| for it,
and returns the |Path|.  The latter is a line, i.e., 
|Path::get_line_switch| returns |true| for it.
\initials{LDF 2002.10.26.}  

|draw| must be defined in \filename{paths.web}, because |Path|
is an incomplete type here.
\initials{LDF Undated.}


\LOG
\initials{LDF 2003.01.15.}  
Added the argument |aarrow|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const Color& ddraw_color| to |const Color* ddraw_color|
and |const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2004.11.07.}
Changed the |bool aarrow| argument to |unsigned short| 
and the default from |false| to 0.  
It's not possible to use |Path::NO_ARROW| here, because 
it hasn't been declared yet, but |Path::NO_ARROW == 0|, so I can use
0 explicitly here.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
\ENDLOG 

@<Declare |Point| functions@>=
Path
draw(Picture& picture,
     const Point& p,
     const Color* ddraw_color = 0, 
     const Dash_Pattern* ddashed = 0,
     const Pen* ppen = 0,
     unsigned short aarrow = 0,
     Scanner_Node scanner_node = 0) const;


@q ** (2) Draw arrow.@>
@*1 Draw arrow.
@^\cfunc{Point}{drawarrow}@>

Defined in \filename{paths.web}.
\initials{LDF 2003.01.15.}  

\LOG
\initials{LDF 2003.01.15.}  
Added this function.

\initials{LDF 2003.06.03.}  
Made |drawarrow| |const|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const Color& ddraw_color| to |const Color* ddraw_color|
and |const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
\ENDLOG 

@q *** Declaration.  @>

@<Declare |Point| functions@>=
Path
drawarrow(Picture& picture,
          const Point& p,
          const Color* ddraw_color = 0, 
          const Dash_Pattern* ddashed = 0,
          const Pen* ppen = 0,
          Scanner_Node scanner_node = 0) const;


@q ** (2) Draw double arrow.@>
@*1 Draw double arrow.
@^\cfunc{Point}{drawdblarrow}@>

Defined in \filename{paths.web}.
\initials{LDF 2004.11.07.}

\LOG
\initials{LDF 2004.11.07.}
Added this function declaration.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
\ENDLOG 

@q *** Declaration.  @>

@<Declare |Point| functions@>=
Path
drawdblarrow(Picture& picture,
             const Point& p,
             const Color* ddraw_color = 0, 
             const Dash_Pattern* ddashed = 0,
             const Pen* ppen = 0,
             Scanner_Node scanner_node = 0) const;



@q ** (2) Undraw.@>
@*1 Undraw.
@^\cfunc{Point}{undraw}@>
\initials{LDF Undated.}

This function must be defined in \filename{paths.web}, because it
uses |Path|, which is an incomplete type here.
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.4.8.}  
Added this function.

\initials{LDF 2002.11.03.}  
Changed this function, so that it returns the |Path
pa|, instead of |void|.  

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.07.}  Changed |string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.   
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare |Point| functions@>=
Path
undraw(Picture& picture,
       const Point& pt,
       const Dash_Pattern* ddashed = 0,
       const Pen* ppen = 0,
       Scanner_Node scanner_node = 0);

@q * (1) Showing.@>
@* Showing.

@q ** (2) Show.@>
@*1 Show.
@^\cfunc{Point}{show}@>
\initials{LDF 2002.10.26.}


The arguments:

\BARGS{|const unsigned short proj|} %% The longest argument. 

\ARG{|string text|}\relax
   If |text| is non-empty, (i.e., not |""|),
   it's written to standard output\newline
   (\.{stdout}).
   If it is empty, or |show| is called without any arguments,
   the default is used, namely |"Point:"|.

\ARG{|char coords|}\relax
   One of the characters |'w'|, |'p'|, |'u'|, or |'v'| should be used,
   to indicate which set of
   coordinates should be shown:
   |world_coordinates|, 
   {\it pro\-jec\-tive\_co\-or\-di\-nates},
   |user_coordinates|, or |view_coordinates|, respectively.  
   The latter two exist, but are not currently used.  The
   corresponding uppercase characters can also be used.


\ARG{|const bool do_persp|}\relax
   Only meaningful if the |projective_coordinates| are
   being shown (|coords| argument |'p'|).  If |do_persp == true|, then
   |project| is called on |*this| before |projective_coordinates| are
   shown.  This is usually what one wants.  However, it may sometimes
   be useful to show the contents of {\it pro\-jec\-tive\_co\-or\-di\-nates}, without
   calling |project|, in which case |do_persp| should be |false|.

\ARG{|const bool do_apply|}\relax
   Usually, |apply_transform| should be called on |*this| before
   showing a set of coordinates, so the default for |do_apply| is |true|.  
   However, it may sometimes be useful to show the values of the 
   coordinates without applying |transform|, in which case |do_apply| should 
   be |false|.

\ARG{|Focus* f|}\relax
   Only meaningful if the |projective_coordinates| are
   being shown (|coords| argument |'p'|).  Refers to the |Focus|
   used for projection.  If the default is used, or 0 
   is passed as the argument explicitly, then the global variable |default_focus|
   is used.

\ARG{|const unsigned short proj|}\relax
   Only meaningful if the |projective_coordinates| are
   being shown (|coords| argument |'p'|).  Refers to the projection
   used.  Currently, I've only programmed the perspective and the
   parallel projections.  The default is the perspective projection. 
   
\ARG{|const real factor|}\relax
   Only meaningful if the |projective_coordinates| are
   being shown (|coords| argument |'p'|) and the parallel projection is being used.  
   The x and y
   values in |projective_coordinates| are multiplied by |factor|,
   so it can be used to magnify or shrink the projected image.  The default is
   1 (no magnification or shrinking). 
\EARGS
\initials{LDF 2002.10.26.}


\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.10.26.}
Add case |'a'| for |coords| for showing all of the
sets of coordinates.
\ENDTODO 

\LOG
\initials{LDF 2002.10.26.}
@:!! KLUDGE@> !! KLUDGE:  In the text above, I've had to typeset
``{\it pro\-jec\-tive\_co\-or\-di\-nates}'' using ``\VRB\it§EVRB''
explicitly in a couple of places, in order to get the hyphenation to work.

\initials{LDF 2002.11.12.}  
Added ``\.{\char`\\relax}'' after the arguments to
``\.{\char`\\ARG}'' in the {\TeX} code above in order to suppress a
space at the beginning of the first line of the following indented
paragraph.  I couldn't figure out a way of suppressing the space
within the definition of \.{\char`\\ARG}.

\initials{LDF 2003.04.30.}  
Changed, so that a newline is not output following
|text|.  

\initials{LDF 2004.06.08.}  
@:BUG FIX@> BUG FIX: 
Changed default for |do_persp| from |true| to |false|.  Having it be |true|
failed, because I've gotten rid of the global variable |default_focus|, and
replaced it with a predefined variable defined in |Scanner_Type::create|.  

\initials{LDF 2004.10.27.}
No longer printing ``Point'' to standard error output 
if |text == ""|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=

void 
show(string text = "",
     char coords = 'w',
     const bool do_persp = false, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = Projections::persp,
     const real factor = 1) const;


@q *** (3) Definition.@>
@ 
@<Define |Point| functions@>=
void 
Point::show(string text, 
            char coords, 
            const bool do_persp,
            const bool do_apply, 
            Focus* f, 
            const unsigned short proj,
            const real factor) const
{
    bool DEBUG = false; /* |true|  */@; 

    cerr << text;

    if (text != "")
      cerr  << " ";

    coords = tolower(coords);

    if (coords == 'w')
      ; /* Do nothing.  */
    else if (coords == 'p')
      cerr << "Projective coordinates.\n";
    else if (coords == 'u')
      cerr << "User coordinates.\n";
    else if (coords == 'v')
      cerr << "View coordinates.\n";
    else
      {
          cerr << "WARNING! In |show|: "
            << "Invalid character for coords argument.\n" 
              << "Showing world coordinates.\n";
          coords = 'w';
      }

    if (*this == INVALID_POINT)
      {
          cerr << "INVALID_POINT: (INVALID_REAL, INVALID_REAL, INVALID_REAL)\n";

          return;
      }

  if (DEBUG) 
    transform.show("Transform before apply_transform");
    
  valarray<real> v = get_all_coords(coords, do_persp, do_apply, f, proj, factor);

    cerr << "(" << v[0] << ", " << v[1] << ", "

      << v[2] << ")\n";

if (DEBUG)
  {
    transform.show("Transform after apply_transform");
  }
}


@q ** Show transform.@>
@ Show transform.
@^\cfunc{Point}{show\_transform}@>
@<Declare |Point| functions@>=
void
show_transform(string text = "");

@ 
@<Define |Point| functions@>=
void
Point::show_transform(string text)
{
    if (text == "")
      text = "transform:";

    cerr << text << endl;
    transform.show();
}

@q * (1) Outputting.@>
@* Outputting.

@q ** (2) Output operator@>
@*1 Output operator. 
@^\ofunc{$\ll$}@>

\initials{LDF 2002.10.26.}  
This function is used in |Path::output| for writing
the x and y values of the |projective_coordinates| to |out_stream|.
@:!!@>  All code using this function must
ensure that |apply_transform| and |project| are called {\it first\/}! 
\initials{LDF 2002.10.26.}  

\LOG 
\initials{LDF 2002.09.16.}  
Removed calls to |apply_transform| and 
|project|.  
\ENDLOG 

@<Declare non-member non-template functions for |Point|@>=

ostream& operator<<(ostream& o, Point& p); 

@ 
@<Define non-member non-template functions for |Point|@>=
ostream& 
operator<<(ostream& o, Point& p)
{
  o << "(" << p.get_x('p', false, false)
    << Point::measurement_units << ", "
    <<  p.get_y('p', false, false)
    << Point::measurement_units << ")";
    return o;   
}



@q ** (2) Suppress output.@>
@*1 Suppress output.
@^\cfunc{Point}{suppress\_output}@>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.  It's needed because trying to erase 
a |Shape*| from |elements| in |Picture::output| causes a memory fault.
\ENDLOG 

@<Declare |Point| functions@>=

virtual
void
suppress_output();

@
@<Define |Point| functions@>=
void
Point::suppress_output()
{
  do_output = false;
}

@q ** Unsuppress output.@>
@ Unsuppress output.
@^\cfunc{Point}{unsuppress\_output}@>
\initials{LDF 2002.09.18.}  Added this function.  It's needed because trying to erase 
a |Shape*| from |elements| in |Picture::output| causes a memory fault.
@<Declare |Point| functions@>=
virtual
void
unsuppress_output();

@
@<Define |Point| functions@>=
void
Point::unsuppress_output()
{
  do_output = true;
}

@q ** (2) Extract.@>
@*1 Extract. 
@^\cfunc{Point}{extract}@>
\initials{LDF Undated.}

|extract| is a pure |virtual| function in
|Shape|.  It's called by |Picture::output|.  Each of the
|Shape| pointers on the |vector shapes| in the |Picture| must be
``extracted''.  For |Points|, this means projecting the |Point|
using the |Focus| passed to |extract| as an argument.
If |project| succeeds, |extract| returns a |vector| containing
|this|.  Otherwise, it returns an empty |vector|.
\initials{LDF 2002.10.26.}  

A |vector| is returned rather than |this| by itself because it may
sometimes be useful to return a collection of |Shape| pointers rather
than a single one.  This was formerly the case for |Cuboid|, but at
the present time, no version of |extract| returns a |vector| with
more than one pointer to |Shape|.
\initials{LDF 2002.10.26.}

\LOG 
\initials{LDF 2002.09.17.}  
Added |const Focus& f| argument and error handling
code.  Now, if the |Point| cannot
be projected onto the projection plane using the |Focus f|, it
is not put onto the |vector <Shape*>| |Picture::elements|, and
consequently never reaches |Picture::output| and |Point::output|. 
\ENDLOG 

@q ** (2) Declaration.@> 

@<Declare |Point| functions@>=
vector<Shape*>
extract(const Focus& f, const unsigned short proj, real factor);

@q ** (2) Definition.@> 

@
@<Define |Point| functions@>=
vector<Shape*>
Point::extract(const Focus& f, const unsigned short proj, real factor)
{
  bool DEBUG = false; /* |true| */
  vector<Shape*> v;
  
  /* \initials{LDF 2002.09.16.}  Added this error checking code.
     Check |*this| first, to make sure that
     it can be drawn with the current value of |default_focus|.
   */

  apply_transform();

  if (!project(f, proj, factor))
    {
      if (DEBUG)
        cerr << "WARNING! In Path::extract():\n"
          << "Point on Path cannot be projected. "
            << "Returning empty vector <Shape*>.\n";
      return v;
    }

  
  if (DEBUG)
    {
      cerr << "world_coordinates:      (" << world_coordinates[0]
           << ", " << world_coordinates[1] << ", "
           << world_coordinates[2] << ", " 
           << world_coordinates[3] << ")\n"
           << "projective_coordinates: (" << projective_coordinates[0]
           << ", " << projective_coordinates[1] << ", "
           << projective_coordinates[2] << ", " 
           << projective_coordinates[3] << ")\n";
    }
  v.push_back(this);
  return v;

} /* End of |Point::extract| definition.  */

@q ** (2) Get world extremes.@> 
@*1 Get world extremes.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.04.04.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Declare |Point| functions@>=

virtual 
inline
const valarray<real>& 
get_world_extremes(void) const
{
   return world_extremes;
}

@q ** (2) Get pre-projective extremes.@>
@*1 Get pre-projective extremes.
@^\cfunc{Point}{get\_pre\_projective\_extremes}@>
\initials{LDF 2005.06.30.}

\LOG
\initials{LDF 2005.06.30.}
Added this function.  Any code that calls 
|get_pre_projective_extremes| must ensure that |project| has been 
invoked first.
\ENDLOG

@<Declare |Point| functions@>=

virtual
inline
const valarray <real>&
get_pre_projective_extremes(void) const
{
  return pre_projective_extremes;
}

@q ** (2) Get projective extremes.@>
@*1 Get projective extremes.
@^\cfunc{Point}{get\_projective\_extremes}@>
\initials{LDF 2002.09.18.}  Added this function.  Any code that calls 
|get_projective_extremes| must ensure that |project| has been 
invoked first.

\LOG
\initials{LDF 2005.03.23.}
Changed the return value from |const valarray <real>| to 
|const valarray <real>&|, i.e., I've made it a reference.

\initials{LDF 2005.04.04.}
Changed the name of this function from |get_extremes| to 
|get_projective_extremes|.  Changed all references to it without comment.
\ENDLOG 

@<Declare |Point| functions@>=

virtual
inline
const valarray <real>&
get_projective_extremes(void) const
{
  return projective_extremes;
}


@q ** (2) Get minimum x.@>
@*1 Get minimum x.
@^\cfunc{Point}{get\_minimum\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual
real
get_minimum_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
real
Point::get_minimum_x(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Point::get_minimum_x()" << endl;

  if (DEBUG)
    cerr << "minimum_x == " << projective_extremes[0] << endl;

  if (DEBUG)
    cerr << "Exiting Point::get_minimum_x()" << endl;

  return projective_extremes[0];

}

@q ** (2) Get maximum x.@>
@*1 Get maximum x.
@^\cfunc{Point}{get\_maximum\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=

virtual
real
get_maximum_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Point| functions@>=
real
Point::get_maximum_x(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Point::get_maximum_x()" << endl;

  if (DEBUG)
    cerr << "maximum_x == " << projective_extremes[1] << endl;

  if (DEBUG)
    cerr << "Exiting Point::get_maximum_x()" << endl;

  return projective_extremes[1];
}

@q ** (2) Get mean x.@>
@*1 Get mean x.
@^\cfunc{Point}{get\_mean\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=
virtual
real
get_mean_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Point| functions@>=
real
Point::get_mean_x(const unsigned short s) const
{
  return ((projective_extremes[0] + projective_extremes[1]) / 2);
}

@q ** (2) Get minimum y.@>
@*1 Get minimum y.
@^\cfunc{Point}{get\_minimum\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual
real
get_minimum_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
real
Point::get_minimum_y(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Point::get_minimum_y()" << endl;

  if (DEBUG)
    cerr << "minimum_y == " << projective_extremes[2] << endl;

  if (DEBUG)
    cerr << "Exiting Point::get_minimum_y()" << endl;

  return projective_extremes[2];
}

@q ** (2) Get maximum y.@>
@*1 Get maximum y.
@^\cfunc{Point}{get\_maximum\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=

virtual
real
get_maximum_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Point| functions@>=
real
Point::get_maximum_y(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Point::get_maximum_y()" << endl;

  if (DEBUG)
    cerr << "maximum_y == " << projective_extremes[3] << endl;

  if (DEBUG)
    cerr << "Exiting Point::get_maximum_y()" << endl;

  return projective_extremes[3];
}

@q ** (2) Get mean y.@>
@*1 Get mean y.
@^\cfunc{Point}{get\_mean\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=
virtual
real
get_mean_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Point| functions@>=
real
Point::get_mean_y(const unsigned short s) const
{
  return ((projective_extremes[2] + projective_extremes[3]) / 2);
}




@q ** (2) Get minimum z.@>
@*1 Get minimum z.
@^\cfunc{Point}{get\_minimum\_z}@>

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual
real
get_minimum_z(const unsigned short s 
              = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
real
Point::get_minimum_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";


/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Point::get_minimum_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

    if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return projective_extremes[4];

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return pre_projective_extremes[4];
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Point::get_minimum_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */
   
   
}  /* End of |Point::get_minimum_z| definition.  */

@q ** (2) Get maximum z.@>
@*1 Get maximum z.
@^\cfunc{Point}{get\_maximum\_z}@>

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 


@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
virtual
real
get_maximum_z(const unsigned short s 
              = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
real
Point::get_maximum_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";


/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Point::get_maximum_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

    if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return projective_extremes[5];

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return pre_projective_extremes[5];
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Point::get_maximum_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */
   
   
}  /* End of |Point::get_maximum_z| definition.  */




@q ** (2) Get mean z.@>
@*1 Get mean z.
@^\cfunc{Point}{get\_mean\_z}@>
\initials{LDF 2003.05.16.}  

\LOG
\initials{LDF 2003.05.16.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 

@<Declare |Point| functions@>=
virtual
real
get_mean_z(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@
@<Define |Point| functions@>=
real
Point::get_mean_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";


/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Point::get_mean_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

    if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return ((projective_extremes[4] + projective_extremes[5]) / 2);

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return ((pre_projective_extremes[4] + pre_projective_extremes[5]) / 2);
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Point::get_mean_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */
   
   
}  /* End of |Point::get_mean_z| definition.  */




@q ** (2) Set world extremes.@> 
@*1 Set world extremes.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.04.04.}
Added this function.
\ENDLOG

@<Declare |Point| functions@>=

virtual 
bool 
set_world_extremes(Scanner_Node scanner_node = 0);

@
@<Define |Point| functions@>=

bool 
Point::set_world_extremes(Scanner_Node scanner_node)
{
   return true;
}

@q ** (2) Set pre-projective extremes.@>
@*1 Set pre-projective extremes.
@^\cfunc{Point}{set\_pre\_projective\_extremes}@>
\initials{LDF 2005.06.30.}

This function sets ``extreme'' values
for the pre-projective x, y, and z-coordinates.  
This is, of course, trivial for |Points|, because they only have one 
x, y and z-coordinate. 
So the maxima and minima for each coordinate are always the same.
\initials{LDF 2005.06.30.}

The programmer who uses |set_pre_projective_extremes| must ensure
that |apply_transform| and |project| are invoked
before |set_pre_projective_extremes|!
\initials{LDF 2005.06.30.}

\LOG 
\initials{LDF 2005.06.30.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual
bool
set_pre_projective_extremes(Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
bool
Point::set_pre_projective_extremes(Scanner_Node scanner_node)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
    if (DEBUG)
       {
           cerr_strm << thread_name 
                     << "Entering 'Point::set_pre_projective_extremes'";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */@; 
    
    for (int i = 0; i < 4; i++)
      {
        if (pre_projective_coordinates[i] == INVALID_REAL)
          {
            cerr_strm << thread_name << "ERROR!  "
                      << "In 'Point::set_pre_projective_extremes':"
                      << endl 
                      << "'pre_projective_coordinates[" << i << "]'" 
                      << " == 'INVALID_REAL'.\n"
                      << "Setting every element in 'pre_projective_extremes' "
                      << "to 'INVALID_REAL' and returning false.\n";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");

            for (int j = 0; j < 6; j++)
              pre_projective_extremes[j] = INVALID_REAL;
            return false;

          }  /* |if|  */    

      }  /* |for|  */

    pre_projective_extremes[0] = pre_projective_coordinates[0]; /* min x */
    pre_projective_extremes[1] = pre_projective_coordinates[0]; /* max x */
    pre_projective_extremes[2] = pre_projective_coordinates[1]; /* min y */
    pre_projective_extremes[3] = pre_projective_coordinates[1]; /* max y */
    pre_projective_extremes[4] = pre_projective_coordinates[2]; /* min z */
    pre_projective_extremes[5] = pre_projective_coordinates[2]; /* max z */   

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Exiting 'Point::set_pre_projective_extremes' "
                   << endl 
                   << "successfully with return value 'true'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    return true;

}  /* End of 
      |Point::set_pre_projective_extremes(Scanner_Node scanner_node)|  
      definition.
   */

@q ** (2) Set projective extremes.@>
@*1 Set projective extremes.
@^\cfunc{Point}{set\_projective\_extremes}@>
\initials{LDF Undated.}

This function sets ``extreme'' values
for the x, y, and z-coordinates.  This is, of course, trivial for 
|Points|, because they only have one x, y and z-coordinate. 
So the maxima and minima for each coordinate are always the same.
\initials{LDF Undated.}

The programmer who uses |set_projective_extremes| must ensure
that |apply_transform| and |project| are invoked
before |set_projective_extremes|!
\initials{LDF 2002.10.20.}  

\LOG 
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2002.09.18.}  
Changed the name of this function from
|set_minimum_z| to |set_extremes|.

\initials{LDF 2005.03.23.}
Added optional |Scanner_Node scanner_node| argument
with default 0.

\initials{LDF 2005.04.04.}
Changed the name of this function from |set_extremes| to 
|set_projective_extremes|.  Changed all references to it without comment.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual
bool
set_projective_extremes(Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
bool
Point::set_projective_extremes(Scanner_Node scanner_node)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
       {
           cerr_strm << thread_name 
                     << "Entering 'Point::set_projective_extremes'";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */@;
    
    for (int i = 0; i < 4; i++)
      {
        if (projective_coordinates[i] == INVALID_REAL)
          {
            cerr_strm << thread_name << "ERROR!  In 'Point::set_projective_extremes':"
                      << endl 
                      << "projective_coordinates[" << i << "]" 
                      << " == INVALID_REAL.\n"
                      << "Setting every element in projective_extremes "
                      << "to INVALID_REAL and returning false.\n";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");

            for (int j = 0; j < 6; j++)
              projective_extremes[j] = INVALID_REAL;
            return false;

          }  /* |if|  */    

      }  /* |for|  */

    projective_extremes[0] = projective_coordinates[0]; /* min x */
    projective_extremes[1] = projective_coordinates[0]; /* max x */
    projective_extremes[2] = projective_coordinates[1]; /* min y */
    projective_extremes[3] = projective_coordinates[1]; /* max y */
    projective_extremes[4] = projective_coordinates[2]; /* min z */
    projective_extremes[5] = projective_coordinates[2]; /* max z */   

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "Exiting 'Point::set_projective_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    return true;

}  /* End of 
      |Point::set_projective_extremes(Scanner_Node scanner_node)|  
      definition.
   */

@q ** (2) Enclosing Cuboids Intersect.@>
@*1 Enclosing Cuboids Intersect.
@^\cfunc{Point}{enclosing\_cuboids\_intersect}@>
\initials{LDF 2005.03.23.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.

\initials{LDF 2005.03.31.}
Changed the name of this function from |enclosing_prisms_intersect|
to |enclosing_cuboids_intersect|.

\initials{LDF 2005.04.01.}
Changed the return type of this function from |unsigned short|
to |Unsigned_Byte|.

\initials{LDF 2005.04.04.}
Added optional |Scanner_Node scanner_node| argument with default 0.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual 
Unsigned_Byte
enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=

Unsigned_Byte
Point::enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node)
{

   return 0;
}

@q ** (2) Intersection with |Shape|.@>
@*1 Intersection with |Shape|.
@^\cfunc{Point}{intersection}@>
\initials{LDF 2005.03.23.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=

virtual 
Int_Void_Ptr
intersection(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=

Int_Void_Ptr
Point::intersection(Shape* s, Scanner_Node scanner_node)
{

   Int_Void_Ptr ivp;

   return ivp;
}

@q * (1) Projections intersect.@>  
@* Projections intersect.
@^\cfunc{Point}{projections\_intersect}@>
\initials{LDF 2005.04.11.}

\LOG
\initials{LDF 2005.04.11.}
Added this function.  Currently, it just returns 0 immediately.
\ENDLOG

@q ** (2) Declaration.@>  

@<Declare |Point| functions@>=
virtual 
Unsigned_Byte
projections_intersect(Shape* s,
                      Scanner_Node scanner_node = 0);


@q ** (2) Definition.@>  

@ 
@<Define |Point| functions@>=
Unsigned_Byte
Point::projections_intersect(Shape* s,
                             Scanner_Node scanner_node)
{
   return 0;
}




@q ** (2) Comparison classes.@>
@*1 Comparison classes.
\initials{LDF Undated.}

The function classes in this section are used 
in\newline
|Picture::output| to sort the pointers to |Shape| in 
|vector <Shape*> elements|.  The argument |sort_value|, which should
be one of the constants in |namespace Sorting|, determines which one
is used, or if |elements| shouldn't be sorted.
\initials{LDF 2003.05.16.}   

\item{$\bullet$} If |Sorting::MIN_Z| is passed to |Picture::output|,
|Compare_Minimum_Z| is used for sorting.  The elements are sorted in
descending order of the {\it minimum\/} z-value from their
|projective_extremes|. 

\item{$\bullet$} 
If |Sorting::MAX_Z| is passed to |Picture::output|, |Compare_Maximum_Z|
is used for sorting.  The elements are then sorted in descending order of
the {\it maximum\/} z-value from their |projective_extremes|.

\item{$\bullet$} 
If |Sorting::MEAN_Z| is passed to |Picture::output|, |Compare_Mean_Z|
is used for sorting.  The elements are then sorted in descending order of
of the mean of the minimum and maximum z-values from their
|projective_extremes|. 

In all three of these cases, the |Shapes| that are furthest from the
|Focus| are output first, so that they can be covered, if necessary,
by |Shapes| that are closer.  

\item{$\bullet$} If |Sorting::SUPPRESS_SORT| is passed to
|Picture::output|, |elements| is not sorted, and the |Shapes| are
output in the order in which they were drawn or filled. 


\LOG
\initials{LDF 2004.06.29.}
Changed |SORTING::NO_SORT| to |SORTING::SUPPRESS_SORT| because 
|NO_SORT| is now a macro defined by means of a token declaration in 
\filename{pbsndecl.w}.

\initials{LDF 2005.07.08.}
It didn't work to add an optional template argument |Scanner_Node scanner_node|
or |void* v| with the default 0.  It caused the following error:
``error: `0' is not a valid template argument\hfil\break
error: it must be the address of an object with external linkage''.
\ENDLOG

@q *** (3) Compare minimum z.@>
@*2 Compare minimum z.
\initials{LDF 2003.05.16.}  

@:??@> ??  
I don't believe it's possible to add an argument 
to |operator()|, which is passed to |sort|, so I'm using the 
template argument to indicate the set of coordinates from which the 
minimum z-value should be taken.
\initials{LDF 2005.07.07.}

Unfortunately, 0 and 1 must be used explicitly when declaring objects of 
this type.  I wanted to be able to use |Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE|, but this causes a 
compiler error:  ``error: non-constant `u' cannot be used as 
template argument.''  
@:??@> ?? 
|Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE| are actually declared 
to be |const|, so I don't know why the compiler rejects this code.
\initials{LDF 2005.07.07.}

\LOG
\initials{LDF 2003.05.16.}  
Added this |class|.  

\initials{LDF 2005.07.07.}
Made this class a template class, with an |unsigned short| 
template argument.  Rewrote |Compare_Minimum_Z::operator()| so 
that it tests the value of the template argument.

\initials{LDF 2005.07.07.}
In |Compare_Minimum_Z::operator()|:
Now setting |unsigned short v = Shape::PROJECTIVE_COORDINATES_VALUE| if
the template argument |u| is neither 0 nor 1.

\initials{LDF 2005.07.08.}
Changed the template argument from |unsigned short| to 
|const unsigned short*| and added the default value
|&Shape::PROJECTIVE_COORDINATES_VALUE|.  Now simply passing
|*u| to |get_minimum_z|.

\initials{LDF 2005.07.08.}
Changed the default for the |const unsigned short*| argument from 
|&Shape::PROJECTIVE_COORDINATES_VALUE| to 
|&Shape::PRE_PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q **** (4) Definition.@>   

@<Define comparison classes@>=

template <const unsigned short* u = &Shape::PROJECTIVE_COORDINATES_VALUE>
class 
Compare_Minimum_Z
{
   public:
      int 
      operator() (const Shape* s1, const Shape* s2) const
         {

             return s1->get_minimum_z(*u) > s2->get_minimum_z(*u);
         }

};

@q *** (3) Compare maximum z.@>
@*2 Compare maximum z.
\initials{LDF 2002.09.17.}  

@:??@> ??  
I don't believe it's possible to add an argument 
to |operator()|, which is passed to |sort|, so I'm using the 
template argument to indicate the set of coordinates from which the 
maximum z-value should be taken.
\initials{LDF 2005.07.07.}

Unfortunately, 0 and 1 must be used explicitly when declaring objects of 
this type.  I wanted to be able to use |Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE|, but this causes a 
compiler error:  ``error: non-constant `u' cannot be used as 
template argument.''  
@:??@> ?? 
|Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE| are actually declared 
to be |const|, so I don't know why the compiler rejects this code.
\initials{LDF 2005.07.07.}

\LOG
\initials{LDF 2002.09.17.}  
Added this |class|.  

\initials{LDF 2002.09.21.}  
Changed from ``minimum z'' to ``maximum z''.  This
works for the more common cases.

\initials{LDF 2005.07.07.}
Made this class a template class, with an |unsigned short| 
template argument.  Rewrote |Compare_Minimum_Z::operator()| so 
that it tests the value of the template argument.

\initials{LDF 2005.07.07.}
In |Compare_Maximum_Z::operator()|:
Now setting |unsigned short v = Shape::PROJECTIVE_COORDINATES_VALUE| if
the template argument |u| is neither 0 nor 1.

\initials{LDF 2005.07.08.}
Changed the template argument from |unsigned short u| to 
|const unsigned short* u| and added the default value
|&Shape::PROJECTIVE_COORDINATES_VALUE|.  Now simply passing
|*u| to |get_maximum_z|.

\initials{LDF 2005.07.08.}
Changed the default for the |const unsigned short*| argument from 
|&Shape::PROJECTIVE_COORDINATES_VALUE| to 
|&Shape::PRE_PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q **** (4) Definition.@>   

@<Define comparison classes@>=

template <const unsigned short* u = &Shape::PRE_PROJECTIVE_COORDINATES_VALUE>
class 
Compare_Maximum_Z
{
   public:
      int operator() (const Shape* s1, const Shape* s2) const
         {

             return s1->get_maximum_z(*u) > s2->get_maximum_z(*u);
    }
};

@q *** (3) Compare mean z.@>
@*2 Compare mean z.
\initials{LDF 2002.09.17.}  

@:??@> ??  
I don't believe it's possible to add an argument 
to |operator()|, which is passed to |sort|, so I'm using the 
template argument to indicate the set of coordinates from which the 
maximum z-value should be taken.
\initials{LDF 2005.07.07.}

Unfortunately, 0 and 1 must be used explicitly when declaring objects of 
this type.  I wanted to be able to use |Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE|, but this causes a 
compiler error:  ``error: non-constant `u' cannot be used as 
template argument.''  
@:??@> ?? 
|Shape::PROJECTIVE_COORDINATES_VALUE|
and |Shape::PROJECTIVE_COORDINATES_VALUE| are actually declared 
to be |const|, so I don't know why the compiler rejects this code.
\initials{LDF 2005.07.07.}

\LOG
\initials{LDF 2002.09.17.}  
Added this |class|.  

\initials{LDF 2005.07.07.}
Made this class a template class, with an |unsigned short| 
template argument.  Rewrote |Compare_Minimum_Z::operator()| so 
that it tests the value of the template argument.

\initials{LDF 2005.07.07.}
In |Compare_Mean_Z::operator()|:
Now setting |unsigned short v = Shape::PROJECTIVE_COORDINATES_VALUE| if
the template argument |u| is neither 0 nor 1.

\initials{LDF 2005.07.08.}
Changed the template argument from |unsigned short| to 
|const unsigned short*| and added the default value
|&Shape::PROJECTIVE_COORDINATES_VALUE|.  Now simply passing
|*u| to |get_mean_z|.  Now calling |get_mean_z| instead of 
|get_minimum_z| and |get_maximum_z|.

\initials{LDF 2005.07.08.}
Changed the default for the |const unsigned short*| argument from 
|&Shape::PROJECTIVE_COORDINATES_VALUE| to 
|&Shape::PRE_PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q **** (4) Definition.@>   

@<Define comparison classes@>=

template <const unsigned short* u = &Shape::PRE_PROJECTIVE_COORDINATES_VALUE>
class 
Compare_Mean_Z
{
   public:
      int operator() (const Shape* s1, const Shape* s2) const
         {

             return (s1->get_mean_z(*u) > s2->get_mean_z(*u));
          }
};

@q *** (3) |class Compare_Magnitudes|.@> 
@* {\bf class Compare\_Magnitudes}.
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this section.
\ENDLOG

@<Define comparison classes@>=

class Compare_Magnitudes
{
    public:

       Point base_point;

       @<Declare |Compare_Magnitude| functions@>@;
};

@q **** (4) Constructor.@> 
@*3 Constructor.
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this function.
\ENDLOG 

@<Declare |Compare_Magnitude| functions@>=
Compare_Magnitudes(const Point& p) : base_point(p) {};

@q **** (4) |operator()|.@> 
@*3 {\bf operator()}.
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Compare_Magnitude| functions@>=
int 
operator()(const Point& p0, const Point& p1) const;

@q ***** (5) Definition.@> 
@
@<Define comparison class functions@>=
int 
Compare_Magnitudes::operator()(const Point& p0, const Point& p1) const
{
    return (p0 - base_point).magnitude() < (p1 - base_point).magnitude();
}

@q *** (3) |class Compare_Angles|.@> 
@* {\bf class Compare\_Angles}.
\initials{LDF 2005.11.05.}

\LOG
\initials{LDF 2005.11.05.}
Added this section.
\ENDLOG

@<Define comparison classes@>=

class Compare_Angles
{


    public:

       Point origin;
       Point axis;

       @<Declare |Compare_Angle| functions@>@;

};

@q **** (4) Constructor.@> 
@*5 Constructor.

@q ***** (5) Declaration.@> 

@<Declare |Compare_Angle| functions@>=
Compare_Angles(const Point* org = 0,
               const Point* ax = 0);

@q ***** (5) Definition.@> 
@
@<Define comparison class functions@>=
Compare_Angles::Compare_Angles(const Point* org, 
                               const Point* ax) 
{

    if (org)
       origin = *org;
    else
       origin.set(0, 0, 0);

    if (ax)
       axis = *ax;
    else 
       axis.set(1, 0, 0);

    axis -= origin;

}

@q **** (4) Function call operator (|operator()|).@> 
@*3 Function call operator ({\bf operator()}).
\initials{LDF Undated.}

@q ***** (5) |const Point| reference arguments.@> 
@*4 {\bf const Point} reference arguments.
\initials{LDF Undated.}

\LOG
\initials{LDF 2007.03.09.}
Made non-|const|.  The declaration caused a compiler error on 
somebody else's installation (not on mine):  
``redundant restricts''.
\ENDLOG 

@q ****** (6) Declaration.@> 

@<Declare |Compare_Angle| functions@>=

int 
operator() (const Point& p0, const Point& p1);

@q ****** (6) Definition.@> 
@
@<Define comparison class functions@>=
int 
Compare_Angles::operator() (const Point& p0, const Point& p1)
{
     return   (p0 - origin).angle(axis) 
            < (p1 - origin).angle(axis);
}

@q ***** (5) |const Point*| arguments.@> 
@*4 {\bf const Point*} arguments.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this function.
\ENDLOG

@q ****** (6) Declaration.@> 

@<Declare |Compare_Angle| functions@>=

int 
operator() (const Point* p0, const Point* p1);

@q ****** (6) Definition.@> 
@
@<Define comparison class functions@>=
int 
Compare_Angles::operator() (const Point* p0, const Point* p1)
{
     return   (*p0 - origin).angle(axis) 
            < (*p1 - origin).angle(axis);
}

@q *** (3) |class Compare_Points|.@> 
@* {\bf class Compare\_Points}.
\initials{LDF 2005.12.13.}

\LOG
\initials{LDF 2005.12.13.}
Added this section.
\ENDLOG

@<Define comparison classes@>=

class Compare_Points
{
    public:

       real tolerance;

       @<Declare |Compare_Points| functions@>@;

};

@q **** (4) Constructor.@> 
@*5 Constructor.

@q ***** (5) Declaration.@> 

@<Declare |Compare_Points| functions@>=
Compare_Points(real t = Shape::DEFAULT_TOLERANCE);
               

@q ***** (5) Definition.@> 
@
@<Define comparison class functions@>=
Compare_Points::Compare_Points(real t)

{
   tolerance = t;

}

@q **** (4)@> 
@
\LOG
\initials{LDF 2007.03.09.}
Made non-|const|.  The declaration caused a compiler error on 
somebody else's installation (not on mine):  
``redundant restricts''.
\ENDLOG 

@<Declare |Compare_Points| functions@>=
bool
operator()(const Point& p0, const Point& p1) const;

@
@<Define comparison class functions@>=
bool
Compare_Points::operator()(const Point& p0, const Point& p1) const
{
     real p0_x = p0.get_x();
     real p0_y = p0.get_y();
     real p0_z = p0.get_z();

     real p1_x = p1.get_x();
     real p1_y = p1.get_y();
     real p1_z = p1.get_z();

     if (fabs(p0_x) < tolerance)
        p0_x = 0;

     if (fabs(p0_y) < tolerance)
        p0_y = 0;

     if (fabs(p0_z) < tolerance)
        p0_z = 0;

     if (fabs(p1_x) < tolerance)
        p1_x = 0;

     if (fabs(p1_y) < tolerance)
        p1_y = 0;

     if (fabs(p1_z) < tolerance)
        p1_z = 0;

     Signed_Byte sign_p0_x = (p0_x >= 0) ? 1 : -1;
     Signed_Byte sign_p0_y = (p0_y >= 0) ? 1 : -1;
     Signed_Byte sign_p0_z = (p0_z >= 0) ? 1 : -1;

     Signed_Byte sign_p1_x = (p1_x >= 0) ? 1 : -1;
     Signed_Byte sign_p1_y = (p1_y >= 0) ? 1 : -1;
     Signed_Byte sign_p1_z = (p1_z >= 0) ? 1 : -1;

     if (   sign_p0_x != sign_p1_x
         || sign_p0_y != sign_p1_y
         || sign_p0_z != sign_p1_z)

        return false;


     return    fabs(fabs(p0_x) - fabs(p1_x)) <= tolerance
            && fabs(fabs(p0_y) - fabs(p1_y)) <= tolerance
            && fabs(fabs(p0_z) - fabs(p1_z)) <= tolerance;

}  /* End of |Compare_Points::operator()(const Point& p0, const Point& p1)| 
      definition.  */



@q ** (2) Output.@>
@*1 Output.
@^\cfunc{Point}{output}@>
\initials{LDF 2002.10.26.}  

|output| is a pure |virtual| function in |Shape|.
After the |Shape| pointers on the |vector Picture::shapes| have been
extracted, |output| is called for each of the |Shapes| they point to
(except for the ones, if any, where |project| failed).
|output| writes the \MP/ code to |out_stream|.
\initials{LDF 2002.10.26.}  

\LOG 
\initials{LDF 2002.09.16.}  
Added |Focus| argument |f|.  I want the default to be 
|default_focus|, but I can't put it in the declaration, as I normally do,
because |default_focus| hasn't been defined yet.  I've put it in the
definition, and it seems to work.  Sometimes it doesn't, and I don't
know why, nor do I know why it works this time.  If I run into
problems, this may be the reason.  If necessary, I can make a dummy
version of this function with no argument that calls {\it this\/}
version with |default_focus| as its argument.

\initials{LDF 2002.09.17.}  
Changed the argument |f| from |Focus| to |const
Focus&|.  Removed the invocations of |apply_transform| and
|project| and error handling code to |extract|.

\initials{LDF 2002.10.23.}  
Removed the argument |f|.  Since |extract|
takes care of applying |project|, the\break
|projective_coordinates| are
already set, so all |output| needs to do is write them to
|out_stream| with the proper \MP/ instructions.

\initials{LDF 2004.05.25.}  
Added |Scanner_Node| argument.  Changed 
|out_stream| from a global |ofstream| to an |ofstream*|.  It's now set
using the |Scanner_Node| argument.

\initials{LDF 2004.06.01.}  
Changed the code for handling |pen|, which
is now a |Pen*| rather than a |string|.

\initials{LDF 2004.06.03.}  No longer using 
|Colors::default_color|, since I've gotten rid of it.

\initials{LDF 2004.06.21.}
Now breaking line and indenting in output file before |withcolor| and 
|withpen|.
\ENDLOG 

@q *** Declaration.@>

@<Declare |Point| functions@>=
void 
output(Scanner_Node s);

@q *** (3) Definition.@>

@ 
@<Define |Point| functions@>=
void 
Point::output(Scanner_Node scanner_node) 
{
  bool DEBUG = false; /* |true| */

  if (DEBUG)
    cerr << "Entering Point::output().\n";

  
  Output_Struct* os = scanner_node->out[Run_State::METAPOST];
  
  ofstream* out_stream  = static_cast<ofstream*>(os->stream_ptr);
  
  if (do_output == false)
    {
      if (DEBUG)
        cerr << "In Point::output(): do_output == false. Returning.\n";

      return;
    }

@q **** (4) |drawdot| or |undrawdot|.  @>
@ |drawdot| or |undrawdot|. 

\LOG
\initials{LDF 2004.08.17.}
@:BUG FIX@> BUG FIX: 
Now writing ``{\bf undrawdot}'' to |*out_stream| when 
|(drawdot_value == UNDRAWDOT_VALUE)|.  Formerly, 
``{\bf drawdot}'' was written.
\ENDLOG 
@<Define |Point| functions@>=

  if (drawdot_value == DRAWDOT_VALUE)

    *out_stream << "drawdot ";

  else if (drawdot_value == UNDRAWDOT_VALUE)

    *out_stream << "undrawdot ";

  else  /* Invalid |DRAWDOT_VALUE|.  */      
    {
      cerr << "WARNING! Invalid |drawdot_value|: "
        << drawdot_value << ". Using \"drawdot\"\n";


      if (scanner_node->get_run_state()->error_stop_mode == Run_State::STOPPING)
        {
          cerr << "Type <RETURN> to continue.\n";

          getchar();  /* Don't delete this!  */@;  
        } 

      *out_stream << "drawdot ";

    } /* |else| (invalid |DRAWDOT_VALUE|.)  */@;      

  *out_stream << "(" << projective_coordinates[0]
              << measurement_units
              << ", " << projective_coordinates[1]
              << measurement_units << ")";


@q **** (4) Handle |Color|.  @>
@ Handle |Color|.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.03.17.}
Now outputting |*(draw_color_vector->v[0])|, if 
|draw_color_vector != 0 && draw_color_vector->ctr > 0|.  
Formerly, I output |*drawdot_color|, 
but I've removed |drawdot_color|.
\ENDLOG

@<Define |Point| functions@>=

  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) && draw_color_vector->ctr > 0)
    *out_stream << endl << "   withcolor " << *(draw_color_vector->v[0]);

@q **** (4) Handle |pen_vector|.@>
@ Handle |pen_vector|.

\LOG
\initials{LDF 2005.03.17.}
Now handling |Pointer_Vector<Pen>* Point::pen_vector| instead 
of |Pen* Point::pen|, which I've removed.
\ENDLOG 

@<Define |Point| functions@>=

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
    {

       Pen* pen = pen_vector->v[0]; 
       unsigned short pen_type = pen->get_type();


      *out_stream << endl << "   ";

      if (pen_type == Pen::CIRCLE_PEN)
        {
          *out_stream << "withpen pencircle";
        }
      else if (pen_type == Pen::RAZOR_PEN)
        {
          *out_stream << " withpen penrazor";
        }

      else if (pen_type == Pen::SPECK_PEN)
        {
          *out_stream << " withpen penspeck";
        }

      else if (pen_type == Pen::SQUARE_PEN)
        {
          *out_stream << " withpen pensquare";
        }
      else /* Invalid |pen->type|.  */
        {
          cerr << "ERROR! In Point::output():\n"
               << "Invalid Pen type: " << pen_type
               << endl << "Not specifying pen and will try to "
               << "continue.\n";
          
          if (scanner_node->get_run_state()->error_stop_mode 
              == Run_State::STOPPING)
            {
              cerr << "Type <RETURN> to continue.\n";

              getchar();  /* Don't delete this!  */@;  
            } 


          *out_stream << ";\n";
          return;
          
        } /* |else| (invalid |pen->type|).  */


@q ***** (5) Handle |pen->transform|.@>   
@ Handle |pen->transform|.
\initials{LDF 2004.09.08.}

\LOG
\initials{LDF 2004.09.08.}
@:BUG FIX@> BUG FIX:  Fixed the way the 3DLDF's three-dimensional
transformation matrix is converted to {\MF/}/{\MP/}'s 
two-dimensional one.

\initials{LDF 2005.06.24.}
@:BUG FIX@> BUG FIX:  Now appending |"cm"| to the numbers output 
for the transformation. 
\ENDLOG 

@<Define |Point| functions@>=

      Transform t = pen->get_transform();

      if (!t.is_identity())
        {
         
          *out_stream << " transformed"
                      << endl << "begingroup; save T; transform T;" 

                      << endl << "xxpart T = " 
                      << t.get_element(0, 0) << "cm;"
                      << endl << "xpart T = " 
                      << t.get_element(3, 0) << "cm;"
                      << endl << "xypart T = " 
                      << t.get_element(1, 0) << "cm;"

                      << endl << "yypart T = " 
                      << t.get_element(1, 1) << "cm;"
                      << endl << "ypart T = " 
                      << t.get_element(3, 1) << "cm;"
                      << endl << "yxpart T = " 
                      << t.get_element(0, 1) << "cm;"

                      << endl << "T endgroup" << endl;

        } /* |if (!pen->get_transform().is_identity())|  */@;

    }  /* |if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)|  */



@q **** (4) Finish and exit function.  @>
@ Finish and exit function.

@<Define |Point| functions@>=

  *out_stream << ";\n";

  if (DEBUG)
    cerr << "Exiting Point::output().\n";
  return;
}

@q * (1) Labelling.@>
@* Labelling. 

@q ** (2) Label.@>
@*1 Label. 

@q *** (3) string argument.@> 
@*2 {\bf string} argument. 
@^\cfunc{Point}{label}@>
\initials{LDF 2002.10.27.}

The arguments:
\BARGS{|string position_str|}

\ARG{|string text_str|}\relax
   The text for the label.

\ARG{|string position_str|}\relax
   Indicates the position of the label text relative to the |Point|.
   The same |strings| are permitted as in \MP/.  They are written
   unchecked to |out_stream|, so if an invalid |string| is used,
   it won't cause an error in 3DLDF, but it will in \MP/.  The
   permitted |strings| are: |"top"| (the default), |"bot"|, |"lft"|,
   |"rt"|, |"ulft"| (upper left),  |"llft"| (lower left),
   |"urt"| (upper right),  |"lrt"| (lower right), and |""| for putting
   the label right on top of the |Point|.  The empty string must be
   used explicitly, because |"top"| is the default.

\ARG{|bool dot|}\relax
   If |true|, then {\bf dotlabel} is written to |out_stream| rather
   than {\bf label}.  This argument is mainly for use by the function
   |dotlabel|, which calls |label| with |dot == true|.

\ARG{|Picture& picture|}\relax
   Indicates the |Picture| onto which the |Label| should be placed.  The
   default is |*current_picture.|
\EARGS
\initials{LDF 2002.10.27.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.01.15.}  
Add |pen| argument to |label|
and |dotlabel|.
\ENDTODO 


\LOG 
\initials{LDF 2002.05.14.}  
Changed |text_str| so that it is no longer optional.
It doesn't make any sense to print empty labels, so I've made it a
required argument.

\initials{LDF 2002.11.12.}  
Added ``\.{\char`\\relax}'' after the arguments to
``\.{\char`\\ARG}'' in the {\TeX} code above in order to suppress a
space at the beginning of the first line of the following indented
paragraph.  I couldn't figure out a way of suppressing the space
within the definition of \.{\char`\\ARG}.

\initials{LDF 2003.07.09.}  
Made |text_str|, |position_str|, and |dot| arguments
|const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Now setting |lbl->text_color| to |ttext_color|
and |lbl->dot_color| to |ddot_color|.

\initials{LDF 2005.02.01.}
Added optional argument |Scanner_Node scanner_node| 
with default 0.
Made debugging and error output thread-safe.

\initials{LDF 2005.02.01.}
@:BUG FIX@> BUG FIX:  Now copying |ttext_color| and |ddot_color|.

\initials{LDF 2005.02.01.}
Now allocating memory within a |try| block and 
catching |bad_alloc|.

\initials{LDF 2005.08.14.}
Added optional |Transform* ttransform| argument with default 0.

\initials{LDF 2005.08.14.}
Now setting |lbl->transform = ttransform| if the |Transform* ttransform|
is non-null.  Otherwise, setting |lbl->transform = 0|.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Point| functions@>=

void 
label(Picture& picture,
      const string text_str,
      const string position_str = "top",
      Transform* ttransform = 0,
      Color* ttext_color = 0,
      Color* ddot_color = 0,
      const bool dot = false,
      Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@>   
  
@ 
@<Define |Point| functions@>=
void 
Point::label(Picture& picture,
             const string text_str,
             const string position_str,
             Transform* ttransform,
             Color* ttext_color,
             Color* ddot_color,
             const bool dot,
             Scanner_Node scanner_node) const
{


@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "Entering 'Point::label'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5).@> 

   if (Label::DO_LABELS == false)
     {
#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name << "In 'Point::label':"
                          << endl 
                          << "'Label::DO_LABELS' == 'false'.  "
                          << "Returning.";

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 
 
       return;

     }  /* |if (Label::DO_LABELS == false)|  */

@q ***** (5).@> 

   if (*this == INVALID_POINT)
     {
         cerr_strm << thread_name << "WARNING!  In 'Point::label': "
                   << endl 
                   << "'*this' == 'INVALID_POINT'.  Returning.";
         log_message(cerr_strm);
         cerr_message(cerr_strm, warning_stop_value);
         cerr_strm.str("");

         return;
  
     }  /* |if (*this == INVALID_POINT)|  */

@q ***** (5).@>

@ 

\LOG
\initials{LDF 2005.02.01.}
Added this section.  Now allocating memory within a |try| block and 
catching |bad_alloc|.
\ENDLOG

@<Define |Point| functions@>=

   Label* lbl;

   try 
      {

          lbl = new Label;

          lbl->pt = create_new<Point>(0);
          *lbl->pt = *this;

          if (ttext_color)
             lbl->text_color = create_new<Color>(ttext_color);
          else 
             lbl->text_color = 0;

          if (ddot_color)
             lbl->dot_color = create_new<Color>(ddot_color);
          else 
             lbl->dot_color = 0;
      }


@q ****** (6).@>

   catch (bad_alloc)
      {
          cerr_strm << thread_name << "ERROR!  In 'Point::label':"
                    << endl << "'new Label', 'create_new<Point>', or "
                    << "'create_new<Color>' failed.  "
                    << "Rethrowing 'bad_alloc'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
     
          throw;

      } /* |catch (bad_alloc)|  */


@q ***** (5).@> 

   if(dot == true)
     lbl->dot = true;


   if (ttransform)
   {
       lbl->transform = ttransform;
   }
   else
      lbl->transform = 0;

   lbl->position = position_str;

   if (text_str != "")
     lbl->text = text_str;
   else
     lbl->text = "Pt.";


   picture += lbl; /* \initials{LDF 2002.10.27.}  The |Label| is pushed onto the
                      |vector labels| in |picture|.  */

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "Exiting 'Point::label'";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 


   return;

}  /* |Point::label|  */

@q *** (3) short argument.@> 
@*2 {\bf short} argument. 
@^\cfunc{Point}{label}@>

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.04.01.}
Make non-|const| version of this
function! 

\initials{LDF Undated.}
Make it possible to use |PROJ_VALUES| to use the
values in |projective_coordinates| for the label.  This will require
adding arguments for use by |project|.  
\ENDTODO 


\LOG
\initials{LDF 2003.04.01.}  
Changed this function so that it tests whether
|text_short| is equal to |WORLD_VALUES|, |PROJ_VALUES|, |USER_VALUES|, or
|VIEW_VALUES|, which are |public const static| data members in
|Point|.  If |text_short| is equal to |WORLD_VALUES|,
|*this| is copied and |apply_transform| is called on the copy.  This
is necessary, because this function is |const|.  Then, the updated
values in the |world_coordinates| vector of the copy are used for the
label. 

\initials{LDF 2003.05.06.}  
Added comparison of |text_short| with 
|WORLD_VALUES_X_Y|, |PROJ_VALUES_X_Y|,\newline
|USER_VALUES_X_Y|, or
|VIEW_VALUES_X_Y|, which are used for suppressing the z-coordinate,
when the values from one of the sets of coordinates are used for the
label.  Also, no longer copying |*this|, since |get_x|, |get_y|,
and |get_z| are |const| anyway.

\initials{LDF 2003.05.20.}  
Added ``|WORLD_VALUES_Z|'' case.

\initials{LDF 2003.05.22.}  
@:BUG FIX@> BUG FIX:  The ``|WORLD_VALUES_Z|'' case
started with |if| instead of |else if|.  This caused |s.str| to have
an erroneous five-digit integer following the closing parenthesis,
when |WORLD_VALUES| or |WORLD_VALUES_X_Y| was used.  I don't know why
this should have been the case, but changing |if| to |else if| fixed
the problem.  It probably had something to do with the fact that
|WORLD_VALUES_Z| had the same value as |VIEW_VALUES_X_Y|.  I've fixed
this above today, too.

\initials{LDF 2003.06.06.}  
Changed the case, where |text_short|
$=$ |WORLD_VALUES|
or |text_short| $=$ |WORLD_VALUES_X_Y|: The coordinates surrounded by
parentheses are now printed out using {\TeX}'s math mode, i.e.,
``$(x, y, z)$'' instead of ``($x$, $y$, $z$)''.

\initials{LDF 2003.07.09.}  
Made |text_short|, |position_str|, and |dot| arguments
|const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to the version 
of |Point::label| that's called in this function.

\initials{LDF 2005.08.14.}
Added optional |Transform* ttransform| argument with default 0.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Point| functions@>=
void 
label(Picture& picture,
      const short text_short,
      const string position_str = "top",
      Transform* ttransform = 0,
      Color* ttext_color = 0,
      Color* ddot_color = 0,
      const bool dot = false) const;

@q **** (4) Definition.@>   

@ 
@<Define |Point| functions@>=
void 
Point::label(Picture& picture,
             const short text_short,
             const string position_str,
             Transform* ttransform,
             Color* ttext_color,
             Color* ddot_color,
             const bool dot) const
{
    bool DEBUG = false; /* |true|  */@; 

    stringstream s;
    if (text_short == WORLD_VALUES || text_short == WORLD_VALUES_X_Y)
      {
          if (DEBUG)
            cerr << "It's WORLD_VALUES or WORLD_VALUES_X_Y.\n";
          s << "$(" << get_x() << ", " << get_y();
          if (text_short == WORLD_VALUES)
            s << ", "  << get_z();
          s << ")$";
      }
    
    else if (text_short == WORLD_VALUES_Z)
      {
          if (DEBUG)
            cerr << "It's WORLD_Z.\n";
          s << get_z();
      }
    
    else if (text_short == PROJ_VALUES)
      {
          if (DEBUG)
            cerr << "It's PROJ_VALUES\n";
          cerr << "WARNING! In Point::label():" << endl 
               << "text_short == PROJ_VALUES. "
               << "Haven't programmed this case yet.\n"
               << "Returning.\n\n";
          return;
      }
    else if (text_short == USER_VALUES)
      {
          if (DEBUG)
            cerr << "It's USER_VALUES\n";
          cerr << "WARNING! In Point::label():" << endl 
               << "text_short == USER_VALUES. "
               << "Haven't programmed this case yet.\n"
               << "Returning.\n\n";
          return;

      }
    else if (text_short == VIEW_VALUES)
      {
          if (DEBUG)
            cerr << "It's VIEW_VALUES\n";
          cerr << "WARNING! In Point::label():" << endl 
               << "text_short == VIEW_VALUES. "
               << "Haven't programmed this case yet.\n"
               << "Returning.\n\n";
          return;
      }
    else
      {
          if (DEBUG) 
            cerr << "It's some other value.\n";
          s << text_short;
      }
    if (DEBUG) 
      cerr << "s.str() == " << s.str() << endl;
    label(picture, s.str(), position_str, ttransform, ttext_color, ddot_color, dot); 
    return;

}  /* End of |Point::label| definition.  */

@q ** (2) Dotlabel.@>
@*1 Dotlabel.

@:!! TO DO@> TO DO: Add an optional |pen| argument.  If it's used, use
|drawdot| with the |pen| argument, together with |label|.  When I
do this, I should also add |real| arguments (to both |label| and
|dotlabel|) for shifting the position of the text, and a version
with a |Point| argument for the same purpose.  This is so that the dot
won't cover the text.  
\initials{LDF 2003.07.16.}

@q *** (3) string argument.@> 
@*2 {\bf string} argument. 
@^\cfunc{Point}{dotlabel}@>

\LOG
\initials{LDF 2003.07.09.}  
Made |text_str| and |position_str| arguments
|const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to the version 
of |Point::label| that's called in this function.

\initials{LDF 2005.08.14.}
Added optional |Transform* ttransform| argument with default 0.
\ENDLOG 

@<Declare |Point| functions@>=
void 
dotlabel(Picture& picture,
         const string text_str,
         const string position_str = "top",
         Transform* ttransform = 0,
         Color* ttext_color = 0,
         Color* ddot_color = 0) const;

@
@<Define |Point| functions@>=
void 
Point::dotlabel(Picture& picture,
                const string text_str,
                const string position_str,
                Transform* ttransform,
                Color* ttext_color,
                Color* ddot_color) const
{
  label(picture, text_str, position_str, ttransform, ttext_color, ddot_color, true);
}

@q *** (3) |short| argument.@> 
@*2 {\bf short} argument. 
@^\cfunc{Point}{dotlabel}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.07.09.}  
Made |text_short| and |position_str| arguments
|const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to the version 
of |Point::label| that's called in this function.

\initials{LDF 2005.08.14.}
Added optional |Transform* ttransform| argument with default 0.
\ENDLOG 

@<Declare |Point| functions@>=
void 
dotlabel(Picture& picture,
         const short text_short,
         const string position_str = "top",
         Transform* ttransform = 0,
         Color* ttext_color = 0,
         Color* ddot_color = 0) const;

@
@<Define |Point| functions@>=
void 
Point::dotlabel(Picture& picture,
                const short text_short,
                const string position_str,
                Transform* ttransform,
                Color* ttext_color,
                Color* ddot_color) const
{
  label(picture, text_short, position_str, ttransform, ttext_color, ddot_color, true);
}


@q * (1) |Label| functions.@> 
@* {\bf Label} functions.
\initials{LDF 2005.01.31.}

\LOG
\initials{LDF 2005.01.31.}
Added this section.
\ENDLOG

@q ** (2) Destructor.@> 

@*1 Destructor.
\initials{LDF 2005.01.31.}

\LOG
\initials{LDF 2005.01.31.}
Added this function definition.  This function is declared in
\filename{pictures.web}, but must be defined in this file
(\filename{points.web}), because |Point| is an incompletely defined
type in \filename{pictures.web}.

\initials{LDF 2005.08.14.}
Now deleting |Transform* transform|.

\initials{LDF 2005.12.09.}
Now deleting |Pen* pen|.
\ENDLOG

@<Define |Label| functions@>=
Label::~Label(void)
{

#if 0 
/* START HERE!!  Deleting |pt| causes a problem with |Pictures| and vector-type 
   objects.  I don't think there really is a problem, but glibc produces a warning, 
   and I don't know how to turn it off.
  \initials{LDF 2006.11.09.}  */
#endif 

   delete pt;
   pt = 0;

   delete transform;
   transform = 0;


   delete text_color;
   text_color = 0;

   delete dot_color;
   dot_color = 0;


   delete pen;
   pen = 0;

   return;

}  /* End of |Label::~Label(void)| definition.  */


@q ** (2) Get copy of Label.@>
@*1 Get copy of {\bf Label}.
@^\cfunc{Label}{get\_copy}@>


\LOG
\initials{LDF 2005.01.31.}
Added error handling.  Now allocating memory for 
|lbl->text_color| and copying |text_color|, if the latter is 
non-null.  Doing the same for |dot_color|.

\initials{LDF 2005.08.14.}
Now copying |Transform* transform|.

\initials{LDF 2005.12.09.}
Now copying |Pen* pen|.

\initials{LDF 2006.11.08.}
Now calling |create_new<Point>| with 0 as its argument and then
setting |*lbl->pt = *pt|.  Trying to fix a bug.
\ENDLOG 

@<Define |Label| functions@>=

Label*
Label::get_copy() const 
{
 
   using namespace Scan_Parse;

   Label* lbl = new Label;

   lbl->pt = create_new<Point>(0);
   *lbl->pt = *pt;

   lbl->transform = create_new<Transform>(transform);

   if (text_color)
      lbl->text_color = create_new<Color>(text_color);
   
   if (dot_color)
      lbl->dot_color = create_new<Color>(dot_color);

   if (pen)
      lbl->pen = create_new<Pen>(pen);

   lbl->dot        = dot;
   lbl->text       = text;
   lbl->position    = position;

   return lbl;

}  /* End of |Label::get_copy| definition.  */

@q ** (2) Output Labels.@>
@*1 Output {\bf Labels}.
@^\cfunc{Label}{output}@>
\initials{LDF 2002.10.23.}  Declared in \filename{pictures.web}.  Must be defined
here, because |Point| is an incomplete type there.

\LOG 
\initials{LDF 2002.10.23.}  
Added arguments |proj| and |factor|.

\initials{LDF 2004.05.25.}  
Added |Scanner_Node| argument.  Changed 
|out_stream| from a global |ofstream| to an |ofstream*|.  It's now set
using the |Scanner_Node| argument.

\initials{LDF 2005.01.31.}
Now outputting code for |text_color| and |dot_color|.

\initials{LDF 2005.08.14.}
Now outputting code for transforming the text, if |transform != 0|.

\initials{LDF 2005.12.09.}
Added code for outputting |*pen|, if |dot == true| and |Pen* pen| is non-null.

\initials{2008.12.30.}
@:BUG FIX@> BUG FIX:  Now outputting a newline after the semi-colon.
\ENDLOG 

@<Define |Label| functions@>=
void
Label::output(Scanner_Node s,
              const Focus& f,
              const unsigned short proj,
              real factor,
              const Transform& t)
{

   Output_Struct* os = s->out[Run_State::METAPOST];
   ofstream* out_stream  = static_cast<ofstream*>(os->stream_ptr);


   if (!t.is_identity())
     *pt *= t;

   pt->apply_transform();
   if(!pt->project(f, proj, factor))
     {
       cerr << "WARNING! In Label::output():\n"
            << "Point in Label cannot be projected! "
            << "Not printing Label\n";
       return;
     }  

   *out_stream << "label";
   
   if (position != "")
     *out_stream << "." << position;
   
   *out_stream << "(btex " << text << " etex ";

     if (transform && !transform->is_identity())
        {

          *out_stream << " transformed "
                      << "begingroup; save T; transform T;"
                      << endl  
                      << " xxpart T = " 
                      << transform->get_element(0, 0) << "; "
                      << "xpart T = "                                   
                      << transform->get_element(3, 0) << "; "
                      << "xypart T = "                                 
                      << transform->get_element(1, 0) << "; " 
                      << endl                                                   
                      << " yypart T = "                               
                      << transform->get_element(1, 1) << "; "
                      << "ypart T = "                                   
                      << transform->get_element(3, 1) << "; "
                      << "yxpart T = "                                 
                      << transform->get_element(0, 1) << "; "
                      << "T endgroup ";

        } /* |if (transform && !transform->is_identity())|  */@;


   *out_stream << ", ("
               << pt->get_x('p', false)
               << Point::measurement_units << ", "
               << pt->get_y('p', false)
               << Point::measurement_units << "))";
 

   if (text_color)
      *out_stream << endl << " withcolor " << *text_color;

   *out_stream << ";" << endl;

   if (dot == true)
       {
          *out_stream << "begingroup" << endl 
                      << "interim linecap := rounded;" 
                      << endl
                      << "drawdot (" 
                      << pt->get_x('p', false)
                      << Point::measurement_units << ", "
                      << pt->get_y('p', false)
                      << Point::measurement_units << ")";


            if (pen)
               *out_stream << " withpen " << *pen;
            else 
               *out_stream << " withpen pencircle scaled dotlabeldiam";
          
          if (dot_color)
             *out_stream << " withcolor " << *dot_color;

          *out_stream << ";" << "endgroup;" << endl;
         
      } /* |if (dot == true)|  */

   return;

}  /* End of |Label::output| definition.  */


@q * (1) |Transform_Matrix| operations. @>
@* {\bf Transform\_Matrix} operations.

@q ** (2) Multiplication by a Transform with assignment.@>
@*1 Multiplication by a {\bf Transform} with assignment.@>
@^\cofunc{Point}{*=}@>
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.11.06.}  
@:BUG FIX@> BUG FIX:  This function now returns |t|
instead of |transform|.  This makes it possible to chain expressions
using |operator*=|.
\ENDLOG 

@<Declare |Point| functions@>=

Transform
operator*=(const Transform& t);

@ 
@<Define |Point| functions@>=
Transform
Point::operator*=(const Transform& t)
{
    return (transform *= t);
}  

@q * (1) Vector operations. @>
@* Vector operations.
\initials{LDF 2002.10.27.}  Note that the vector operations don't affect the w
coordinate. 

\LOG 
\initials{LDF 2002.10.27.}     
In the functions |operator+|,|operator+=|, |operator-|, and
|operator-=|:
It doesn't seem worth
it to write non-|const| versions, although I could.
Now using the elements of\break
|p0.world_coordinates|
directly instead of using |get_x|, |get_y|, and |get_z|.  
This is safe, as is calling |apply_transform| on |p|, and saves the
cost of three function calls.



\ENDLOG 

@q ** (2) Vector addition. @>

@*1 Vector addition.
@^\cofunc{Point}{+}@>
\initials{LDF Undated.}

@<Declare |Point| functions@>=

Point 
operator+(Point p) const;


@
@<Define |Point| functions@>=

Point 
Point::operator+(Point p) const
{
    Point a;
    a = *this;
    p.apply_transform();
    a.shift(p.world_coordinates[0], p.world_coordinates[1],
            p.world_coordinates[2]);
    return a;
}

@q ** (2) Vector addition with assignment. @>

@*1 Vector addition with assignment.
@^\cofunc{Point}{+=}@>
\initials{LDF Undated.}

@<Declare |Point| functions@>=

void
operator+=(Point p);

@
@<Define |Point| functions@>=

void 
Point::operator+=(Point p)
{
  p.apply_transform();
  shift(p.world_coordinates[0], p.world_coordinates[1],
        p.world_coordinates[2]);
}


@q ** (2) Vector subtraction. @>

@*1 Vector subtraction.
@^\cofunc{Point}{-}@>
\initials{LDF Undated.}

@<Declare |Point| functions@>=
Point
operator-(Point p) const;

@
@<Define |Point| functions@>=
Point 
Point::operator-(Point p) const
{
    Point a(*this);
    p.apply_transform();
    a.shift(-p.world_coordinates[0], -p.world_coordinates[1],
            -p.world_coordinates[2]);
    return a;
} 

@q ** (2) Vector subtraction with assignment. @>

@*1 Vector subtraction with assignment.
@^\cofunc{Point}{-=}@>
\initials{LDF Undated.}

@<Declare |Point| functions@>=

void
operator-=(Point p);

@
@<Define |Point| functions@>=
void
Point::operator-=(Point p)
{
  p.apply_transform();
  shift(-p.world_coordinates[0], -p.world_coordinates[1],
        -p.world_coordinates[2]);
}

@q ** (2) Vector-scalar multipication with assignment.@>

@*1 Vector-scalar multipication with assignment.
@^\cofunc{Point}{*=}@>
\initials{LDF Undated.}

@:??@> ?? I'm not sure whether multiplication with a scalar is
commutative with transformations.  I doubt it.  Therefore, I apply
|transform| before multiplying.
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.10.27.}
Made argument |r const|.  Changed return value from |Point&| to 
|void|.

\initials{LDF 2003.05.14.}  Changed return value from |void| to |real|.  It now
returns the argument |r|.  This makes it possible to chain invocations
of this function.
\ENDLOG 

@<Declare |Point| functions@>=

real
operator*=(const real r);

@
@<Define |Point| functions@>=

real
Point::operator*=(const real r)
{
  apply_transform();
  for (int i = 0; i < 3; i++)
    world_coordinates[i] *= r;
  return r;
}

@q ** (2) Vector-scalar multipication. @>

@*1 Vector-scalar multipication.

@q *** (3) Member version (Point first).@>
@*2 Member version ({\bf Point} first).
@^\cofunc{Point}{*}@>
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.10.27.}  
Made this function and the argument |r| |const|. 
\ENDLOG 

@<Declare |Point| functions@>=

Point
operator*(const real r) const;

@
@<Define |Point| functions@>=

Point
Point::operator*(const real r) const
{
    Point a(*this);
    a.apply_transform();
    a *= r;
    return a;
}


@q *** (3) Non-member version.  @>

@*2 Non-member version (scalar first).  
@^\ofunc{*}@>
\initials{LDF Undated.}

@<Declare non-member non-template functions for |Point|@>=

Point operator*(const real, const Point& p);

@
@<Define non-member non-template functions for |Point|@>=
Point
operator*(const real r, const Point& p)
{
  return p * r;
}

@q ** (2) Unary minus operator-().@>
@*1 Unary minus.
@^\cofunc{Point}{-}@>
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.10.27.}  
Made this function |const|. 
\ENDLOG 

@<Declare |Point| functions@>=
Point
operator-() const;

@
@<Define |Point| functions@>=
Point
Point::operator-() const
{
    Point a(*this);
    a.apply_transform();
    a *= -1;
    return a;
}


@q ** (2) Vector-scalar division with assignment.@>
@*1 Vector-scalar division with assignment.
@^\cofunc{Point}{/=}@>
\initials{LDF Undated.}

@:??@> ?? I'm not sure whether division with a scalar is
commutative with transformations.  I doubt it.  Therefore, I apply
|transform| before dividing.

\LOG 
\initials{LDF 2002.10.27.}  
Made the argument |r| |const|. 
\ENDLOG 

@<Declare |Point| functions@>=

void
operator/=(const real r);

@
@<Define |Point| functions@>=
void
Point::operator/=(const real r)
{
  apply_transform();
  for (int i = 0; i < 3; i++)
    world_coordinates[i] /= r;
}


@q ** (2) Vector-scalar division.@>
@*1 Vector-scalar division.
@^\cofunc{Point}{/}@>
\initials{LDF Undated.}

\LOG 
\initials{LDF 2002.10.27.}  
Made this function and the argument |r| |const|. 
\ENDLOG 

@<Declare |Point| functions@>=

Point
operator/(const real r) const;

@
@<Define |Point| functions@>=
Point
Point::operator/(const real r) const
{
  Point a(*this);
  a.apply_transform();
  a /= r;
  return a;
}



@q ** (2) Dot product. @>
@*1 Dot product.
@^\cfunc{Point}{dot\_product}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.10.27.}  
Changed this function and argument |p| to |const|.
Now using |world_coordinates| directly instead of |get_x|,
|get_y|, and |get_z|.

\initials{LDF 2003.07.11.}  
Changed, so that if the dot product is less than
|Point::epsilon|, 0 will be returned.
\ENDLOG

@<Declare |Point| functions@>=

real
dot_product(Point p) const;

@
@<Define |Point| functions@>=
real
Point::dot_product(Point p) const
{
  Point a(*this);
  a.apply_transform();
  p.apply_transform();
  real r = (  (a.world_coordinates[0] * p.world_coordinates[0])
             + (a.world_coordinates[1] * p.world_coordinates[1])
             + (a.world_coordinates[2] * p.world_coordinates[2]));
  if (fabs(r) < Point::epsilon())
    r = 0;
  return r;
}

@q ** (2) Cross product. @>
@*1 Cross product.
@^\cfunc{Point}{cross\_product}@>

\LOG
\initials{LDF 2002.10.27.}  
Changed this function and argument |p| to |const|.
Now using |world_coordinates| directly instead of |get_x|,
|get_y|, and |get_z|.
\ENDLOG

@<Declare |Point| functions@>=
Point
cross_product(Point p) const;

@
@<Define |Point| functions@>=
Point
Point::cross_product(Point p) const
{
  Point a(*this);

  a.apply_transform();
  p.apply_transform();

  Point r;

  r.world_coordinates[0] = (a.world_coordinates[1] * p.world_coordinates[2])
    - (a.world_coordinates[2] * p.world_coordinates[1]); // x. 

  r.world_coordinates[1] = (a.world_coordinates[2] * p.world_coordinates[0])
    - (a.world_coordinates[0] * p.world_coordinates[2]); // y. 

  r.world_coordinates[2] = (a.world_coordinates[0] * p.world_coordinates[1])
    - (a.world_coordinates[1] * p.world_coordinates[0]); // z.

  return r;

} /* End of |Point::cross_product| definition.  */    

@q ** (2) Magnitude.@>
@*1 Magnitude. 
@^\cfunc{Point}{magnitude}@>
\initials{LDF 2002.10.27.}  

\setbox0=\vbox{$\sqrt{(x^2 + y^2 + z^2)}$}
\dimen0=\ht0
\advance\dimen0 by 2pt
\setbox0=\hbox{\vrule height \dimen0 depth 3pt width 0cm}

The magnitude of a |Point| is its distance from the
origin and is equal to \copy0
$\sqrt{(x^2 + y^2 + z^2)}$. 

\smallskip
Since |floats| are so large anyway, and since I can
easily redefine |real| to use |double| or |long double|, 
it's not really necessary to use an
algorithm to approximate 
\copy0
$\sqrt{(x^2 + y^2 + z^2)}$ (viz.,
``Pythagorean addition'' in Knuth, 
{\it Metafont: The Program}.) 
@:!!@> (Get reference!!) 
However, it might be nice to use it anyway.

\LOG
\initials{LDF 2002.10.27.}  
Made this function |const|.  Now using
|world_coordinates| directly instead of |get_x|, |get_y|, and |get_z|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
real
magnitude() const;

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
real
Point::magnitude() const
{
  bool DEBUG = false;  /* |true| */
  
  real r;
  real temp;

  Point a(*this);

  a.apply_transform();

  if (   (a.world_coordinates[0] > MAX_REAL_SQRT)
      || (a.world_coordinates[1] > MAX_REAL_SQRT)
      || (a.world_coordinates[2] > MAX_REAL_SQRT))
    {
      cerr << "ERROR: In Point::magnitude().\n"
        << "Point has a coordinate too large for squaring!\n"
          << "Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }


  r = a.world_coordinates[0] * a.world_coordinates[0];
  temp = a.world_coordinates[1] * a.world_coordinates[1];

  if (MAX_REAL - r < temp)
    {
      cerr << "In magnitude().\n";
      cerr << "Point has too great a magnitude!\n";
      @:!!@> 
        /* !! This |show| outputs to |stdout|. It would be nice to
          output it to |stderr| instead. Must write function for
            this. */
        cerr << "Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }

  r += temp;

  temp = a.world_coordinates[2] * a.world_coordinates[2];

  if (MAX_REAL - r < temp)
    {
      cerr << "In magnitude().\n";
      cerr << "Point has too great a magnitude!\n";
      @:!!@> 
        /* !! This |show| outputs to |stdout|. It would be nice to
          output it to |stderr| instead. Must write function for
            this. */
        cerr << "Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }
  
  r += temp;

  return sqrt(r);
}

@q ** Angle between two vectors.@>
@ Angle between two vectors.
@^\cfunc{Point}{angle}@>

\LOG
\initials{LDF 2002.10.27.}  
Made this function |const|.

\initials{LDF 2003.07.27.}  
Made the argument |p| a |const Point&|.  No longer
copying |*this|.  Now using\newline
|dot_product| instead of calculating the
angle ``by hand''.  Simplified the code of the function.
\ENDLOG

@<Declare |Point| functions@>=
real
angle(const Point& p) const;

@
@<Define |Point| functions@>=
real
Point::angle(const Point& p) const
{
  bool DEBUG = false; /* true */ 
  
  real mag = magnitude();
  real p_mag = p.magnitude();

  if (mag == INVALID_REAL)
    {
      cerr << "WARNING! In angle(). magnitude() failed."
        << " Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }
  else if (mag == ZERO_REAL)
    {
      if (DEBUG) 
        cerr << "WARNING! In angle().\n"
             << "*this has magnitude 0.\n"
             << "Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }
  else if (p_mag == INVALID_REAL)
    {
      cerr << "WARNING! In angle(). p.magnitude() failed."
           << " Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }
  else if (p_mag == ZERO_REAL)
    {
      if (DEBUG) 
        cerr << "WARNING! In angle().\n"
             << "p has magnitude 0.\n"
             << "Returning INVALID_REAL.\n";
      return INVALID_REAL;
    }
  else return (180 / PI * acos(dot_product(p) / (mag * p_mag)));
}

@q ** (2) Unit vector.@>
@*1 Unit vector.
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.10.27.}  
Added a second version.  If |assign| is not used,
|unit_vector| can be |const|, so I now have a |const| version with
no argument and a non-|const| one for assignment that should be called
with the argument |true|.
\ENDLOG 

@q ** (2) With assignment.@>
@*1 With assignment.
@^\cfunc{Point}{unit\_vector}@>

This version should only ever be called with |true|
as its argument.  Using |false| will work, unless |*this| is |const|,
in which case it will cause an compilation error.  
\initials{LDF 2002.10.27.}  

If the optional |silent| argument is |true|, warning messages will be suppressed,
otherwise, they will be issued.  The |const| version below can't have
an optional |silent| argument, because that would make a call to this
function with one argument ambiguous.
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.10.27.}  
If |magnitude| fails, |unit_vector| now returns
|INVALID_POINT| instead of |origin|.

\initials{LDF 2003.07.01.}  
Added the |silent| argument to suppress warning
messages.  I kept getting warnings when this function was called from
intersection functions, in cases where it wasn't a problem, that a
|Point| (vector) had 0 magnitude.  

\initials{LDF 2004.11.10.}
Changed the default of the |bool silent| argument to |true|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
Point
unit_vector(const bool assign, const bool silent = true);

@q *** (3) Definition.@> 

@
@<Define |Point| functions@>=
Point
Point::unit_vector(const bool assign, const bool silent)
{

  if (assign == false)  
    {
      if (!silent)
        {
          cerr << "WARNING! In Point::unit_vector():\n"
               << "Don't call this function with false as its argument.\n"
               << "Use unit_vector() without an argument instead.\n"
               << "Calling unit_vector() without an argument.\n\n";

        }
      return unit_vector();
    }
  
  apply_transform();

  real m = magnitude();


  if (m == ZERO_REAL)  /* LDF 2002.04.10.  Added this error handling code for the case where
                                   *this has no magnitude.  */
    {
      if (!silent)
        {
          cerr << "WARNING! In Point::unit_vector().\n"
               << "Point (vector) has no magnitude. Returning INVALID_POINT.\n\n";
        }
      return INVALID_POINT;
    }
  for (int i = 0; i < 3; i++)
    world_coordinates[i] /= m;
  world_coordinates[3] = 1;  /* \initials{LDF 2002.10.27.} Setting the
                                w-coordinate to 1, just to be sure.  */
  return *this;
}

@q ** const (no assignment).@>
@ {\bf const} (no assignment).
@^\cfunc{Point}{unit\_vector}@>
@<Declare |Point| functions@>=
Point
unit_vector() const;

@
@<Define |Point| functions@>=
Point
Point::unit_vector() const
{
  Point a(*this);
  return a.unit_vector(true);
}


@q ** (2) Mediation.@>
@ Mediation.
@^\cfunc{Point}{mediate}@>
\LOG
\initials{LDF 2003.12.09.}  Changed from a non-member to a |const|
member function.
\ENDLOG 
@<Declare |Point| functions@>=
Point 
mediate(Point p, const real r = .5) const;

@
@<Define |Point| functions@>=
Point
Point::mediate(Point p, const real r) const
{
    Point t(*this);
    t *= (1 - r);
    p *= r;
    return(t + p);
}

@q ** (2) Get normal.@>
@*1 Get normal.
@^\cfunc{Point}{get\_normal}@>
|get_normal| must be defined in \filename{paths.web}, because it
uses a |Path| in its definition, which is an incompletely defined type
in this file.

\LOG
\initials{LDF 2003.07.11.}  
Added this declaration.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Point| functions@>=
Point
get_normal(const Point& p, const Point& q) const;

@q ** (2) Get base of perpendicular.@>
@*1 Get base of perpendicular.
\initials{LDF 2004.10.10.}
|get_perpendicular_base| must be  defined in \filename{planes.web} 
because it has a |Plane| argument, and |Plane| is an incompletely 
defined type here.  

\LOG
\initials{LDF 2004.10.10.}
Added this function declaration.

\initials{LDF 2004.10.11.}
Added |const Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2004.10.11.}
Made this function |const|.
\ENDLOG

@<Declare |Point| functions@>=
int
get_perpendicular_base(const Plane& p,
                       Point* base,
                       const Scanner_Node scanner_node = 0) const;

@q ** (2) Reflection in a |Plane|.@>

@*1 Reflection in a {\bf Plane}.
@^\cfunc{Point}{reflect\_in}@>

This function returns the reflection of |*this| in the |Plane a|.

|reflect_in| must be defined in \filename{planes.web}, because it
has a |Plane| argument, and |Plane| is an incompletely defined type
in this file.  
\initials{LDF 2003.09.05.}

\LOG
\initials{LDF 2003.09.05.}  
Added this declaration.

\initials{LDF 2004.10.03.}
Added |const Scanner_Node scanner_node| argument with default 0.  
Changed return type from |Point| to |Shape*|.  Now declaring
this function |virtual|.  Currently, there are no |classes| 
derived from |Point|, though.

\initials{LDF 2004.10.08.}
Changed the name of this function from |reflect| 
to |reflect_in|.

\initials{LDF 2004.10.12.}
Changed arguments and return value.  Following a system update, 
having |Shape*| as the return value no longer worked.
\ENDLOG 

@<Declare |Point| functions@>=
virtual
int
reflect_in(const Plane& p,
           void* v,
           const Scanner_Node scanner_node = 0) const;


@q ** (2) Reflection off of a |Plane|.@>

@*1 Reflection off of a {\bf Plane}.
@^\cfunc{Point}{reflect\_off}@>
\initials{LDF 2004.10.08.}

This function returns the reflection of |*this| off 
of the |Plane a|.
\initials{LDF 2004.10.08.}

|reflect_off| must be defined in \filename{planes.web}, because it
has a |Plane| argument, and |Plane| is an incompletely defined type
in this file.  
\initials{LDF 2004.10.08.}

The argument |void* v| is used to reference the |Point| that 
represents the reflection of |*this| in the |Plane p|.  A pointer 
to |void| must be used because |reflect_off| is a pure virtual 
function in |class Shape|.  If a |Point*| were used for 
this purpose in this function, 
a |Path*| in |Path::reflect_off|, etc., then these functions 
would have different calling conventions and would therefore not
overload |Shape::reflect_off|.
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.10.08.}
Added this declaration.

\initials{LDF 2004.10.11.}
Added |const Point& direction| argument.

\initials{LDF 2004.10.12.}
Added |void* v| argument and changed return value from
|Shape*| to |int|.  Following a system update, 
having |Shape*| as the return value no longer worked.

\initials{LDF 2004.12.06.}
Changed the type of the |direction| argument from |const Point&| to 
|Point|.
\ENDLOG 

@<Declare |Point| functions@>=
virtual
int
reflect_off(const Plane& p,
            Point direction,
            void* v,
            const Scanner_Node scanner_node = 0) const;

@q * (1) Comparison.@>
@* Comparison.

@q ** (2) Equality.@>
@*1 Equality.

@q *** (3) Is Equal.@> 
@*2 Is Equal.


@q **** (4) Non-|const| version.@> 
@*3 Non-{\bf const} version.
@^\cfunc{Point}{is\_equal}@>
\initials{LDF 2007.07.22.}

\LOG
\initials{LDF 2007.07.22.}
Added this function.

\initials{LDF 2007.07.22.}
Made |Point& p| argument non-|const|.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Point| functions@>=
bool
is_equal(Point& p, real tolerance = -1, void* parameter = 0);


@q ***** (5) Definition.@> 
@
@<Define |Point| functions@>=
bool
Point::is_equal(Point& p, real tolerance, void* parameter)
{

@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

  
#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Point::is_equal'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

  unsigned short factor = 10; /* LDF 2002.10.27.  Added.  */

  clean(factor);
  p.clean(factor);

  real eps = epsilon() * factor; /* This currently makes 
    |eps| $\equiv .0001$. */

  real t_x = world_coordinates[0];
  real t_y = world_coordinates[1];
  real t_z = world_coordinates[2];

  real p_x = p.world_coordinates[0];
  real p_y = p.world_coordinates[1];
  real p_z = p.world_coordinates[2];

@ |Points| are frequently compared to |INVALID_POINT|, so 
it's best to suppress debugging output for these comparisons,
because they're probably not the ones we're interested in.  
@<Define |Point| functions@>=
  if ( t_x == INVALID_REAL 
      || t_y == INVALID_REAL 
      || t_z == INVALID_REAL 
      || p_x == INVALID_REAL 
      || p_y == INVALID_REAL 
      || p_z == INVALID_REAL)
    DEBUG = false; 

@ Debugging output.
@<Define |Point| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "`t_x' == " << t_x << endl 
                << "`t_y' == " << t_y << endl 
                << "`t_z' == " << t_z << endl
                << "`p_x' == " << p_x << endl 
                << "`p_y' == " << p_y << endl 
                << "`p_z' == " << p_z;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@ Check whether the coordinates of both |Points| are all 0. 

\LOG
\initials{LDF 2002.10.27.}  
Now that |clean(10)| and |p.clean(10)| are called
above, it's no longer necessary to compare the absolute values of
the coordinates.  I can just compare them with 0 instead.
\ENDLOG 

@<Define |Point| functions@>=
  
  if (t_x == ZERO_REAL && p_x == ZERO_REAL
      && t_y == ZERO_REAL && p_y == ZERO_REAL
      && t_z == ZERO_REAL && p_z == ZERO_REAL)
    {

#if DEBUG_COMPILE
   if (DEBUG)
   {
        cerr_strm << thread_name << 
                  "All coordinates are 0, returning true.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

      return true;

    }  /* |if|  */

@  Get the signs of the coordinates. 

\LOG
\initials{LDF 2002.10.27.}  
As in the previous section, changed so that the
coordinates are compared with 0, instead of using |fabs| and |eps|. 
\ENDLOG 

@<Define |Point| functions@>=

  signed short t_x_sign;
  signed short t_y_sign;
  signed short t_z_sign;

  signed short p_x_sign;
  signed short p_y_sign;
  signed short p_z_sign;

  if (t_x == ZERO_REAL)
    t_x_sign = 0;
  else if (t_x < ZERO_REAL)
    t_x_sign = -1;
  else
    t_x_sign = 1;

  if (t_y == ZERO_REAL)
    t_y_sign = 0;
  else if (t_y < ZERO_REAL)
    t_y_sign = -1;
  else
    t_y_sign = 1;

  if (t_z == ZERO_REAL)
    t_z_sign = 0;
  else if (t_z < ZERO_REAL)
    t_z_sign = -1;
  else
    t_z_sign = 1;

  if (p_x == ZERO_REAL)
    p_x_sign = 0;
  else if (p_x < ZERO_REAL)
    p_x_sign = -1;
  else
    p_x_sign = 1;

  if (p_y == ZERO_REAL)
    p_y_sign = 0;
  else if (p_y < ZERO_REAL)
    p_y_sign = -1;
  else
    p_y_sign = 1;

  if (p_z == ZERO_REAL)
    p_z_sign = 0;
  else if (p_z < ZERO_REAL)
    p_z_sign = -1;
  else
    p_z_sign = 1;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name 
                 << "`t_x_sign' == " << t_x_sign << endl 
                 << "`t_y_sign' == " << t_y_sign << endl 
                 << "`t_z_sign' == " << t_z_sign << endl 
                 << "`p_x_sign' == " << p_x_sign << endl 
                 << "`p_y_sign' == " << p_y_sign << endl 
                 << "`p_z_sign' == " << p_z_sign;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


  if (   (t_x_sign  != p_x_sign)
           || (t_y_sign != p_y_sign)
           || (t_z_sign != p_z_sign))
    {

#if DEBUG_COMPILE
   if (DEBUG)
   {
        cerr_strm << thread_name 
                  << "At least one coordinate pair has signs that differ. "
                  << "Returning false.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


      return false;
    }


@ Get the difference between each pair of x, y, and z-coordinates.
@<Define |Point| functions@>=
   
      t_x = fabs(t_x);
      t_y = fabs(t_y);
      t_z = fabs(t_z);

      p_x = fabs(p_x);
      p_y = fabs(p_y);
      p_z = fabs(p_z);

      real delta_x = fabs(t_x - p_x);
      real delta_y = fabs(t_y - p_y);
      real delta_z = fabs(t_z - p_z);

#if DEBUG_COMPILE
   if (DEBUG)
   {
          cerr_strm << thread_name 
                    << "`delta_x' == " << delta_x << endl 
                    << "`delta_y' == " << delta_y << endl 
                    << "`delta_z' == " << delta_z;

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
      
@ |bool r| is simply the value returned by this function.  
It's only needed for the sake of the debugging code.  Otherwise, it could
just return the result of the following expression.
\initials{LDF 2002.10.27.}
\initials{LDF 2007.07.22.}

@<Define |Point| functions@>=

  bool r;  
  r = (   delta_x < eps
       && delta_y < eps
       && delta_z < eps);

#if DEBUG_COMPILE
   if (DEBUG)
   {
        cerr_strm << thread_name << "`r' == " << r << endl
                  << "Exiting `Point::is_equal";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
 
  return r;
 
@q ****** (6)@> 
 
}  /* End of |Point::is_equal| definition (non-|const| version).  */

@q ***** (5)@> 

@q **** (4) |const| version.@> 
@*3 {\bf const} version.
@^\cfunc{Point}{is\_equal}@>
\initials{LDF 2007.07.22.}

\LOG
\initials{LDF 2007.07.22.}
Added this function.

\initials{LDF 2007.10.06.}
@:BUG FIX@> BUG FIX:  Now declaring |Points| before the call to |Point::is_equal|.
Previously, I used one of the |Point| constructors to create temporary |Points| 
for the object on which |Point::is_equal| was called (within this function) 
and its argument.  However, instead of calling the non-|const| version, 
this version was called, causing endless recursion. 
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Point| functions@>=
bool
is_equal(const Point& p, real tolerance = -1, void* parameter = 0) const;


@q ***** (5) Definition.@> 
@
@<Define |Point| functions@>=
bool
Point::is_equal(const Point& p, real tolerance, void* parameter) const
{
   Point q = *this;
   Point r = p;
   return q.is_equal(r, tolerance, parameter);
}

@q *** (3) Operator.@> 
@*2 Operator.
@^\cofunc{Point}{==}@>
@:!!@> !! I may have to adjust to value of |eps|.  It would be nice to
be able to use |epsilon|, but for other purposes |epsilon| must be
smaller.  Transformations seem to cause fairly large inaccuracies in
the values of the coordinates, so I need greater tolerance in the
functions testing for equality and inequality.

This function could be formulated more succinctly, but I had some
trouble getting it to work properly, so I'm leaving it in its more
verbose form, in case I have to debug it some more.

@q **** (4) Non-|const| version.@>
@*3 Non-{\bf const} version.
@^\cofunc{Point}{==}@>
\initials{LDF Undated.}


\LOG
\initials{LDF Undated.}
Added this function.

\initials{LDF 2002.10.27.}  
Revised this function.  Now using |Point a| and
|Point q|.  Added |factor| and using it as the argument to |clean|
and for calculating |eps|.  Since this function is an operator, it's
not possible to pass |factor| as an argument, unfortunately.  Using
|clean(factor)| makes it possible to compare the coordinates with 0
directly rather than using |fabs| and |eps|.  Also, |operator==|
now uses |world_coordinates| directly rather than |get_x|,
|get_y|, and |get_z|.

\initials{LDF 2003.07.09.}  
Made this function non-|const|, and added |const|
version below.

\initials{LDF 2007.07.22.}
Removed code from this function.  It now calls in |Point::is_equal|, 
which contains the old code, somewhat revised.
\ENDLOG 

@q ***** (5) Declaration.@>  

@<Declare |Point| functions@>=
bool
operator==(Point p);

@q ***** (5) Definition.@> 

@
@<Define |Point| functions@>=
bool
Point::operator==(Point p)
{
    return is_equal(p);

}  /* End of |Point::operator==(Point p)| definition.  */


@q *** (3) |const| version.@>
@*2 {\bf const} version.
@^\cofunc{Point}{==}@>
\initials{LDF 2003.07.09.}  This function merely copies |*this| and calls the
non-|const| version on the copy.  Here, |p| can be a |const Point&|,
because this function does nothing but pass it to non-|const| version,
where it is passed by value.  

\LOG
\initials{LDF 2003.07.09.}  Added this version.  Made the original version
non-|const|.  
\ENDLOG 
@<Declare |Point| functions@>=
bool
operator==(const Point& p) const;

@
@<Define |Point| functions@>=
bool
Point::operator==(const Point& p) const
{
  Point copy(*this);
  return (copy == p);
}





@q ** (2) Inequality.@>
@*1 Inequality.
@^\cofunc{Point}{!=}@>
@<Declare |Point| functions@>=
bool
operator!=(const Point& p) const;

@
@<Define |Point| functions@>=
bool
Point::operator!=(const Point& p) const
{
  return !(*this == p);
}


@q * (1) Intersection.@>
@* Intersection.  
\initials{LDF Undated.}

\initials{LDF 2002.10.27.}  
|intersection_point| takes four |Point|
arguments.  It assumes that the first and second represent one line
segment and the third and fourth another.  It calculates the intersection
point of the two lines, if any, and returns a |Bool_Point|.  If the
intersection point exists and is on both line segments, the |bool| is
|true| and the |Point| is the intersection point.  If the intersection
point exists, but is not on both line segments, the |bool| is |false|
and the |Point| is the intersection point.  If no intersection point
exists, i.e, the line segments are congruent or parallel, then the
|bool| is |false| and the |Point| is |INVALID_POINT|. 


\initials{LDF Undated.}
Note that |intersection_point| had to be defined as a |static| member
function, because |Path::intersection_point| was not able to resolve
the call of this version, when it was not callable as
``|Point::intersection_point|''. I got a compiler error, because
the call of |intersection_point| inside\break
|Path::intersection_point|
with four references to |Points| as arguments was deemed to have ``too many
arguments'' and the references to |Point| couldn't be converted to
|const| references to |Path|.   


@q ** (2) Vector version.@>
@*1 Vector version.
@^\cfunc{Point}{intersection\_point}@>
\initials{LDF 2003.06.29.}  Defined
in \filename{lines.web}, because |Line| is an incomplete type here.

The algorithm used in this function is taken from
Jones, Huw. {\it Computer Graphics Through Key Mathematics},
pp.~208--311.   
See {\bf References} for the complete reference. 

@:!!@> !! 
It may be necessary or desirable to add |try|$\ldots$|catch|
blocks where calculations are performed below, just in case overflow
occurs.

@:!!@> !!  Under Linux, both this function and the version of
|intersection_points| using traces have failed in the same cases,
which involved coplanar lines which had been rotated about the z-axis
or the y and z-axes.  I suspect it has to do with the routines for
sine and cosine, since I've had trouble with rotation in the
constructors for |Polyhedra|.  \initials{LDF 2003.06.29.}  

\LOG
\initials{LDF 2002.04.10.}  
Added this function.  It replaces the old version,
below.

\initials{LDF 2002.04.12.}  
Removed the definition of this function to
\filename{lines.web}, because it requires the use of |Lines|, and
|Line| is an incomplete type here.

\initials{LDF 2003.06.29.}  
Started using this version again.  Bug fixes I've
made elsewhere seem to have made it function.  
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=

static
Bool_Point
intersection_point(const Point& pp0, const Point& pp1, 
                   const Point& qq0, const Point& qq1);

@q ** (2) Trace version.@>
@*1 Trace version. 
@^\cfunc{Point}{intersection\_point}@>
This function finds the intersection point of two lines by finding the
intersection points of the traces of the lines on the major planes.  I
originally wrote it, because the vector version didn't work.  Bug
fixes elsewhere seem to have fixed the problem, so this version isn't
really needed anymore.  
\initials{LDF 2003.06.29.}

The |bool| argument |trace| serves only to distinguish this function
from the vector version.  It doesn't matter whether it's |true| or
|false|.  
\initials{LDF 2003.06.29.}

\LOG
\initials{LDF 2002.10.27.}  
Changed the |const Point&| arguments to |Point|,
because I had to copy them anyway in order to call |apply_transform|
on them.

\initials{LDF 2003.06.29.}  
Added the |bool| argument |trace|, in order to be
able to use both the vector and trace versions.  Previously, the
vector version didn't work, and was commented-out.  Now, bug fixes
elsewhere seem to have made the vector version work.  Both versions,
however, failed under Linux.  See the {\TeX} section for the vector
version, above, for more information.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Point| functions@>=

static
Bool_Point
intersection_point(Point p0, Point p1, Point q0, Point q1, const bool trace);


@q *** (3) Definition.@>
@
@<Define |Point| functions@>=
Bool_Point
Point::intersection_point(Point p0, Point p1, Point q0, Point q1,
                          const bool trace)
{
  bool DEBUG = false; /* |true|  */

  if (DEBUG) 
    {
      cerr << "Entering Point::intersection_point()." << endl;
      p0.show("p0");
      p1.show("p1");
      q0.show("q0");
      q1.show("q1");
    }                     

  Bool_Point bp; /* Return value.  */

@ Apply the transformations, so we have the correct values for x, y,
and z in each of the |Points|.  Then assign them to variables.
@<Define |Point| functions@>=
  p0.apply_transform(); 
  p1.apply_transform();
  q0.apply_transform();
  q1.apply_transform();

  real p0_x = p0.world_coordinates[0];
  real p0_y = p0.world_coordinates[1];
  real p0_z = p0.world_coordinates[2];

  real p1_x = p1.world_coordinates[0];
  real p1_y = p1.world_coordinates[1];
  real p1_z = p1.world_coordinates[2];
  

  real q0_x = q0.world_coordinates[0];
  real q0_y = q0.world_coordinates[1];
  real q0_z = q0.world_coordinates[2];

  real q1_x = q1.world_coordinates[0];
  real q1_y = q1.world_coordinates[1];
  real q1_z = q1.world_coordinates[2];
  
@  Get deltas. 
@<Define |Point| functions@>=
  real delta_x_p = p1_x - p0_x;     
  real delta_y_p = p1_y - p0_y;
  real delta_z_p = p1_z - p0_z;
  
  real delta_x_q = q1_x - q0_x;
  real delta_y_q = q1_y - q0_y;
  real delta_z_q = q1_z - q0_z;

@ Slopes for line $\overrightarrow{p_0p_1}$.
@<Define |Point| functions@>=

    real slope_p_x_y
      = (delta_x_p != ZERO_REAL) ? delta_y_p/delta_x_p : INVALID_REAL;     


    real slope_p_x_z
      = (delta_x_p != ZERO_REAL) ? delta_z_p/delta_x_p : INVALID_REAL; 

    real slope_p_z_y
      = (delta_z_p != ZERO_REAL) ? delta_y_p/delta_z_p : INVALID_REAL;

@ Slopes for line $\overrightarrow{q_0q_1}$.
@<Define |Point| functions@>=
   real slope_q_x_y
      = (delta_x_q != ZERO_REAL) ? delta_y_q/delta_x_q : INVALID_REAL; 

    real slope_q_x_z
      = (delta_x_q != ZERO_REAL) ? delta_z_q/delta_x_q : INVALID_REAL; 

    real slope_q_z_y
      = (delta_z_q != ZERO_REAL) ? delta_y_q/delta_z_q : INVALID_REAL; 
    
@ The traces on the x-y plane. |x_i|, |y_i|, |z_i|, |y_int_p|, and
|y_int_q| are set to |INVALID_REAL| so that I can test for whether the
routines below succeed in setting them correctly.
@<Define |Point| functions@>=

  real x_i = INVALID_REAL;  /* x-coordinate of the intersection point. */
  real y_i = INVALID_REAL;  /* y-coordinate of the intersection point. */
  real z_i = INVALID_REAL;  /* z-coordinate of the intersection point. */


  real y_int_p = INVALID_REAL; /* y-intercept of
                                  $\overrightarrow{p_0p_1}$. */
  real y_int_q = INVALID_REAL; /* y-intercept of
                                  $\overrightarrow{q_0q_1}$. */


  if (slope_p_x_y != INVALID_REAL) /* $\Delta x_p \neq 0$. */  
    {
      y_int_p  = p0_y - (slope_p_x_y * p0_x);
    }

  if (slope_q_x_y != INVALID_REAL) /* $\Delta x_q \neq 0$. */  
    {
      y_int_q  = q0_y - (slope_q_x_y * q0_x);
    }
  
@ \item{$\bullet$} If both of the traces of $\vec{p}$ and $\vec{q}$ in
  the x-y plane are parallel to the y-axis (i.e., $\Delta x = 0$), we
  test  whether $p_x = q_x$. If they are, then we set |x_i| to that
  value.  If they're not, the lines don't intersect, so
  we return |INVALID_POINT|. 
\item{$\bullet$} If the trace of $\vec{p}$ or the trace of $\vec{q}$ in
  the x-y plane is parallel to the y-axis, we set |x_i| to its
  x-value, because in this case, the intersection point must have this
  x-value. 
\item{$\bullet$} If $\Delta x_p \neq 0$ and $\Delta x_q \neq 0$, we
  derive |x_i| using the slope and y-intercept of the lines.
@<Define |Point| functions@>=

  if (y_int_p == INVALID_REAL && y_int_q == INVALID_REAL) /* $\vec{p}_{xz}$ and
                 $\vec{q}_{xz}$ are both parallel to the z-axis. */
    {

      if (p0_x == q0_x) /* They have the same value for $x$. */
        {

          if (DEBUG)
            cerr << "Traces on x-y plane are coincident.\n";

          x_i = p0_x;

          real y_int_p_z = INVALID_REAL;
          real y_int_q_z = INVALID_REAL;

          if (slope_p_z_y != INVALID_REAL)
            y_int_p_z  = p0_y - slope_p_z_y * p0_z;

          if (slope_q_z_y != INVALID_REAL)
            y_int_q_z  = q0_y - slope_q_z_y * q0_z;

          if (slope_p_z_y == INVALID_REAL
              && slope_q_z_y == INVALID_REAL)
            {
              if (DEBUG)
                cerr << "Both traces on z-y plane are vertical\n";
                  
              if (p0_z == q0_z)
                  cerr << "Lines are coincident.\n";
              else
                cerr << "Lines do not intersect.\n";
              cerr << "Returning INVALID_BOOL_POINT.\n\n";
              return INVALID_BOOL_POINT;
            }

          else if (slope_p_z_y == INVALID_REAL)
            {
              if (DEBUG)
                cerr << "The p-trace is vertical\n";

              z_i = p0_z;
              y_i = z_i * slope_q_z_y + y_int_q_z;

              if (DEBUG)
                {
                  cerr << "x_i == " << x_i << endl;
                  cerr << "y_i == " << y_i << endl;
                  cerr << "z_i == " << z_i << endl;
                  cerr << "slope_q_z_y == " << slope_q_z_y << endl;
                  cerr << "y_int_q_z == " << y_int_q_z << endl;
                }
            }
          else if (slope_q_z_y == INVALID_REAL)
            {
              if (DEBUG)
                cerr << "The q-trace is vertical\n";

              z_i = q0_z;
              y_i = z_i * slope_p_z_y + y_int_p_z; 

              if (DEBUG)
                {
                  cerr << "x_i == " << x_i << endl;
                  cerr << "y_i == " << y_i << endl;
                  cerr << "z_i == " << z_i << endl;
                  cerr << "slope_p_z_y == " << slope_p_z_y << endl;
                  cerr << "y_int_p_z == " << y_int_p_z << endl;
                }
            }
          else
            {

              if (DEBUG)
                cerr << "Neither trace is vertical\n";
              
              z_i = (y_int_q_z - y_int_p_z) / (slope_p_z_y - slope_q_z_y);
              y_i = slope_p_z_y * z_i + y_int_p_z;

              if (DEBUG)
                {
                  cerr << "x_i == " << x_i << endl;
                  cerr << "y_i == " << y_i << endl;
                  cerr << "z_i == " << z_i << endl;
                  cerr << "slope_p_z_y == " << slope_p_z_y << endl;
                  cerr << "y_int_p_z == " << y_int_p_z << endl;
                  cerr << "slope_q_z_y == " << slope_q_z_y << endl;
                  cerr << "y_int_q_z == " << y_int_q_z << endl;
                }
            }
        }
      else          /* They don't have the same value for $x$. */
        {

             cerr << "Lines do not intersect:\n";
             cerr << "(" << p0_x << ", " << p0_y << ", " << p0_z
                  << ") -- (" << p1_x << ", " << p1_y << ", " << p1_z
                  << ")\n(" << q0_x << ", " << q0_y << ", " << q0_z
                  << ") -- (" << q1_x << ", " << q1_y << ", " << q1_z
                  << ")\nReturning INVALID_BOOL_POINT.\n";
       
             return INVALID_BOOL_POINT;
        }
    }

  else if (y_int_p == INVALID_REAL) /* $\vec{p}_{xy}$ is parallel to
                                       the y-axis. */
    {  
      x_i = p0_x;
      y_i = slope_q_x_y * x_i + y_int_q;
    }

  else if (y_int_q == INVALID_REAL) /* $\vec{q}_{xy}$ is parallel to
                                       the y-axis. */
    {
      x_i = q0_x;
      y_i = slope_p_x_y * x_i + y_int_p;
    }
@ \initials{LDF 2002.11.12.}  @:!! BUG@> !! BUG:  Occurred when I tried to find
an intersection of two lines in the x-z plane.  This code shouldn't
be reached.  Rotating the objects $90^\circ$ around the x-axis,
putting them into the x-y plane, fixed the problem.  Obviously, the
case that the objects are in the x-z plane already isn't handled
properly. 
@<Define |Point| functions@>=

  else /* Neither $\vec{q_{xy}}$ nor $\vec{q}_{xy}$ is parallel to the
          y-axis. */
    {
      if (DEBUG)  /* \initials{LDF 2002.11.12.}  Start working on finding bug here.  */ 
        {
          cerr << "slope_p_x_y == " << slope_p_x_y << endl;
          cerr << "slope_q_x_y == " << slope_q_x_y << endl;
        }
      
      if (slope_p_x_y != slope_q_x_y)
        {
          x_i = (y_int_q - y_int_p) / (slope_p_x_y - slope_q_x_y);
          y_i = slope_p_x_y * x_i + y_int_p;
        }
    }

@ The trace on the x-z plane.  We don't need to do this if we've
calculated |z_i| above, in the case that the traces on the x-y plane
are coincident.
@<Define |Point| functions@>=

  if (z_i == INVALID_REAL)
    {

      real z_int_p = INVALID_REAL; /* z-intercept of $\overrightarrow{p_0p_1}$. */
      real z_int_q = INVALID_REAL; /* z-intercept of $\overrightarrow{q_0q_1}$. */


      if (slope_p_x_z != INVALID_REAL) /* $\Delta x_p \neq 0$. */  
        {
          z_int_p  = p0_z - (slope_p_x_z * p0_x);
        }


      if (slope_q_x_z != INVALID_REAL) /* $\Delta x_q \neq 0$. */  
        {
          z_int_q  = q0_z - (slope_q_x_z * q0_x);
        }

      if (DEBUG)
        {
          cerr << "z_int_p == " << z_int_p << endl;
          cerr << "z_int_q == " << z_int_q << endl;
        }

@ \initials{LDF 2003.06.24.}  |x_i| will be equal to |INVALID_REAL|, if the
traces of the lines on the x-y plane were colinear.  
\LOG
\initials{LDF 2003.06.24.}  Added this conditional.
\ENDLOG 
@<Define |Point| functions@>=
      if (x_i == INVALID_REAL
          && !(z_int_p == INVALID_REAL || z_int_q == INVALID_REAL)) 
        {
          x_i = (z_int_q - z_int_p) / (slope_p_x_z - slope_q_x_z);
          y_i = p0_y;
        }

@ In the following case, $\vec{p}_{xz}$ and $\vec{q}_{xz}$ are both
parallel to the z-axis.  They have the same value for $x$.  
We've set |x_i| above, so there's no need to do so here again. 
@<Define |Point| functions@>=
      if (z_int_p == INVALID_REAL && z_int_q == INVALID_REAL) 
        {               
          if (p0_x != q0_x) 
            {
          cerr << "Lines do not intersect:\n"
               << "(" << p0_x << ", " << p0_z << ", " << p0_z
               << ") -- (" << p1_x << ", " << p1_z << ", " << p1_z
               << ")\n(" << q0_x << ", " << q0_z << ", " << q0_z
               << ") -- (" << q1_x << ", " << q1_z << q1_z
               << ")\nReturning INVALID_BOOL_POINT.\n";
              return INVALID_BOOL_POINT;
            }
        }
      else if(z_int_p == INVALID_REAL)
        {
          z_i = p0_z;
        }
      else if(z_int_q == INVALID_REAL)
        {
          z_i = q0_z;
        }
      else
        {
          z_i = slope_p_x_z * x_i + z_int_p;
        }
    }

@ \initials{LDF 2002.10.27.}  If |x_i|, |y_i|, and |z_i| are all valid, set
|bp.pt| using those values.  Otherwise, set it to |INVALID_POINT|.  If
this |Point| is on both of the line segments $\overrightarrow{p_0p_1}$
and $\overrightarrow{q_0q_1}$, set |bp.b| to |true|, otherwise set it
to |false|.  
@<Define |Point| functions@>=

  if (DEBUG)
    {
      cerr << "x_i == " << x_i << endl;
      cerr << "y_i == " << y_i << endl;
      cerr << "z_i == " << z_i << endl;
    }

  if(x_i == INVALID_REAL || y_i == INVALID_REAL
     || z_i == INVALID_REAL)
    {
      return INVALID_BOOL_POINT;
      if (DEBUG) 
        cerr << "Returning INVALID_BOOL_POINT.\n";
    }
  else
    {
      bp.pt.set(x_i, y_i, z_i);
      if (DEBUG)
        bp.pt.show("bp.pt");
    }
  

  if (bp.pt.is_on_segment(p0, p1).first == false
      || bp.pt.is_on_segment(q0, q1).first == false)
    bp.b = false;
  else
    bp.b = true;
  

  if (DEBUG)
    {
      cerr << "bp.b == " << bp.b << endl;
      cerr << "Exiting Point::intersection_point().\n";
    }
  
  return bp;

} /* End of |Point::intersection_point| definition.  */

@q * (1) Surface Hiding.@>
@* Surface Hiding.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this section.
\ENDLOG

@q ** (2) Decompose.@> 

@*1 Decompose.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this section.
\ENDLOG

@q *** (3) |Path*| argument.@> 
@*2 {\bf Path*} argument.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this function.  Currently, it returns 0 immediately.

\initials{LDF 2005.01.24.}
Added |unsigned short level| argument with default 0.

\initials{LDF 2005.02.01.}
Changed the return value of this function from |Pointer_Vector<Shape>*|
to |Pointer_Vector<Path>*|.  Removed the |unsigned short level|
argument and the default for the |const Path* p| argument.

\initials{LDF 2005.02.01.}
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.02.01.}
Made |Path*| argument non-|const|.

\initials{LDF 2005.04.04.}
Made the |Path*| argument, and this function itself, |const|.

\initials{LDF 2005.04.05.}
Made the |Path*| argument, and this function itself, non-|const| again.
\ENDLOG

@q **** (4) Declaration.@>   

@<Declare |Point| functions@>=

virtual 
Pointer_Vector<Path>* 
decompose(Path* p, Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>   

@
@<Define |Point| functions@>=
Pointer_Vector<Path>*
Point::decompose(Path* p, Scanner_Node scanner_node)
{
   return 0;
}

@q *** (3) |Shape*| argument.@> 
@*2 {\bf Shape*} argument.
\initials{LDF 2005.04.01.}

\LOG
\initials{LDF 2005.04.01.}
Added this function.  It returns 0 immediately, because |Points| 
cannot be decomposed.  However, it must be defined, because it 
overloads a pure virtual function in |class Shape|.

\initials{LDF 2005.04.04.}
Made the |Shape*| argument, and this function itself, |const|.

\initials{LDF 2005.04.05.}
Made the |Shape*| argument, and this function itself, non-|const| again.
\ENDLOG

@<Declare |Point| functions@>=

virtual 
Pointer_Vector<Shape>* 
decompose(Shape* s, Scanner_Node scanner_node = 0);

@
@<Define |Point| functions@>=
Pointer_Vector<Shape>*
Point::decompose(Shape* s, Scanner_Node scanner_node) 
{
   return 0;
}


@q *** (3) Self-decomposition.@> 
@*2 Self-decomposition.
\initials{LDF 2005.04.10.}

\LOG
\initials{LDF 2005.04.10.}
Added this function.  It returns 0 immediately, because |Points| 
cannot be decomposed.  However, it must be defined, because it 
overloads a pure virtual function in |class Shape|.

\initials{LDF 2005.04.14.}
Changed the arguments of this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Point| functions@>=

virtual
Pointer_Vector<Shape>*
decompose(const unsigned short limit, 
          const bool use_rectangles = false,
          Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>   

@
@<Define |Point| functions@>=
Pointer_Vector<Shape>*
Point::decompose(const unsigned short limit, 
                 const bool use_rectangles,
                 Scanner_Node scanner_node)
{
   return 0;

}  /* End of |Pointer_Vector<Shape>*
              Point::decompose(const unsigned short limit, 
                               const bool use_rectangles,
                               Scanner_Node scanner_node)|
      definition.  */

@q * (1) Picture functions.@>
@* {\bf Picture} functions.
These functions must be defined here, because they use types which
are incompletely defined in \filename{pictures.web}.

@q ** Assignment operator.@>
@ Assignment operator.
!! PORTING
\initials{LDF 2002.12.05.}  Moved here from \filename{pictures.web}.  See that
file for explanation.
@<Define |Picture| functions@>= 
void
Picture::operator=(const Picture& p)
{

    clear();
    transform = p.transform;

    for(vector<Shape*>::const_iterator iter = p.shapes.begin();
        iter != p.shapes.end();
        iter++)
      {
          shapes.push_back((*iter)->get_copy());
      }
    
    Label* lbl;

  for(vector<Label*>::const_iterator iter = p.labels.begin();
      iter != p.labels.end();
      iter++)
    {
      lbl = (*iter)->get_copy();
      labels.push_back(lbl);
    }
}

@q ** (2) Copy constructor. @>
@*1 Copy constructor.
\initials{LDF 2002.12.05.}  

\LOG
\initials{LDF 2002.12.05.}  
Moved here from \filename{pictures.web}.  
See that file for explanation.

\initials{LDF 2004.06.19.}
Now initializing |pthread_cond_init| and |pthread_cond_mutex|.

\initials{LDF 2004.06.29.}
No longer calling |pthread_cond_init|, because I've removed |cond_var|.
\ENDLOG 

@<Define |Picture| functions@>=
Picture::Picture(const Picture& p)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    cerr << "Entering the copy constructor for 'Picture'."
         << endl;
#endif /* |DEBUG_COMPILE|  */@; 

  shapes.clear();
  labels.clear();

  do_labels = true;

#ifdef HAVE_PTHREAD_H 

  int status;

  status = pthread_mutex_init(&inner_mutex, 0);

  if (status != 0)
   {
      cerr << "ERROR! In 'Picture::Picture(const Picture&)':"
           << endl << "'pthread_mutex_init' failed.";
      cerr << "Type <RETURN> to continue.\n"; 
      getchar(); /* Don't delete this!  */ 

   }
 else
   {
#if DEBUG_COMPILE
      if (DEBUG)
          {
             cerr << "In 'Picture::Picture(const Picture&)':"
                  << endl << "'pthread_mutex_init' succeeded!"
                  << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
   }


#endif /* |HAVE_PTHREAD_H|  */@;



  *this = p;


#if DEBUG_COMPILE
  if (DEBUG)
    cerr << "Exiting the copy constructor for 'Picture'."
         << endl;
#endif /* |DEBUG_COMPILE|  */@; 


  return;
  
}  /* End of |Picture::Picture(const Picture& p)| definition.  */

@q ** (2) Combining Pictures.@>
@*1 Combining {\bf Pictures}.
@^\cofunc{Picture}{+=}@>
\initials{LDF 2002.04.17.}  

\LOG
\initials{LDF 2002.04.17.}  
Added this function.

\initials{LDF 2002.10.29.}  
Made |p| |const| and fixed bugs that changed |p| 
(see below).

\initials{LDF 2002.10.29.} 
@:BUG FIX@> BUG FIX:  Now, |p.transform| is
applied to |*(shapes.back())|, previously it was applied to
|**iter|, which was not what I wanted.  

\initials{LDF 2002.10.29.} 
@:BUG FIX@> BUG FIX:  Now, |p.transform| is 
applied to |*(labels.back()->pt)|, previously it was applied
to |*((*iter)->pt)|, which is not what I wanted.  

\initials{LDF 2002.10.29.}  
@:BUG FIX@> BUG FIX: Now, |p.transform.reset| is
no longer called.
\ENDLOG 

@q *** (3) Definition.@> 
 
@<Define |Picture| functions@>= 

void 
Picture::operator+=(const Picture& p)
{
  for(vector<Shape*>::const_iterator iter = p.shapes.begin();
      iter != p.shapes.end();
      iter++)
    {
      shapes.push_back((*iter)->get_copy());
@/@,
      /* \initials{LDF 2002.10.29.}  Normally, |transform| in a |Picture| is 
         applied to its |Shapes| when it's output, however, it must be
         done now for the copies of the |Shapes| from |Picture p| that
         are copied onto |*this|, because |p.transform| is only known within
         |p|;  the |Shapes| don't ``know'' about it.  */@;

      *(shapes.back()) *= p.transform;  
    }

  for(vector<Label*>::const_iterator iter = p.labels.begin();
      iter != p.labels.end();
      iter++)
    {
      labels.push_back((*iter)->get_copy());
      @/@,
      *(labels.back()->pt) *= p.transform;
    }
}  

@q ** (2) Clear Picture.@>
@*1 Clear {\bf Picture}.
@^\cfunc{Picture}{clear}@>

@q *** Definition.@>

@<Define |Picture| functions@>= 
void
Picture::clear(void)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true|  */ 
#endif /* |DEBUG_COMPILE|  */@; 

#if DEBUG_COMPILE
  if (DEBUG) 
    cerr << "Entering Picture::clear().\n";
#endif /* |DEBUG_COMPILE|  */@; 

  transform.reset();

  if (shapes.size() <= 0 && labels.size() <= 0)
    return;

  for (vector<Shape*>::iterator iter = shapes.begin();
       iter != shapes.end();
       iter++)
    {
      (*iter)->clear();
      delete (*iter);
      *iter = 0;  
    }

@ 
\LOG
\initials{LDF 2005.02.01.}
Removed call to |delete (*iter)->pt|.  |Label::pt| is now deleted in
|~Label|, which I've added.
\ENDLOG

@<Define |Picture| functions@>= 

  for (vector<Label*>::iterator iter = labels.begin();
       iter != labels.end();
       iter++)
    {

      delete *iter;
      *iter = 0;
    }

@
@<Define |Picture| functions@>= 

  shapes.clear();
  labels.clear();


#if DEBUG_COMPILE
   if (DEBUG) 
      cerr << "Exiting Picture::clear().\n";
#endif /* |DEBUG_COMPILE|  */@;   

}


@q ** (2) Output.@> 
@*1 Output.
\initials{LDF 2005.04.09.}

\LOG
\initials{LDF 2005.04.09.}
Moved the definition of |Picture::output| to \filename{pctfncs0.web}.
\ENDLOG

@q * (0) class Focus.@>
@** {\bf class Focus}.

@q * Focus class definition.@>
@* {\bf Focus} class definition.

\LOG
\initials{LDF 2002.09.18.}  
Made |Focus| a |class| (it was formerly a |struct|). 
Added |char axis| data member.  It indicates the axis
to which |position| should be transformed to when it's put in standard
position.  This determines which plane the image is projected onto.
If |axis == 'z'| (the default), the image is projected onto the x-y
plane, if |axis == 'x'|, the z-y plane, if |'y'|, the x-z plane.

\initials{LDF Undated.}
At this time, I'm not adding the routines that will do this, which
will entail changing |transform| and possibly |persp|, I'm just adding
|axis|.  I must also add a function for changing axis without changing
any of the other data members.
@:!! TO DO@> TO DO: Add these routines!!

\initials{LDF 2002.09.14.}  
Added |Transform persp|.  It's needed
because I need to get the |z| value of the\newline
|world_coordinates| after the
transformation that puts the |Focus| into standard position, but
before the perspective transformation is performed.  This |z|
value can be used in an algorithm for surfaces hiding.  If this were
not the case, I could combine the transformations, because matrix
multiplication is associative (it is not, however, commutative, except
with special matrices).

\initials{LDF 2002.09.11.}  
Added |class Focus| and the following constructors:
The default constructor with no arguments, the one with two |Point|
arguments and a |real argument|, and the one with seven |real|
arguments.

\initials{LDF 2004.06.07.}  
Added |bool on_free_store|, so I can declare
|create_new<Focus>|.

\initials{LDF 2007.09.19.}
Added the |static unsigned short| constants |FOCUS_AXES| 
and |MAIN_AXES|.

\initials{LDF 2007.09.19.}
Added |Point normal|.
\ENDLOG 

@f Focus int

@<Define |class Focus|@>=

class Focus
{
  Point position;
  Point direction;
  Point up;
  Point normal;
  real distance;
  real angle;
  char axis;
  Transform transform;
  Transform persp;

 public:

  static const unsigned short FOCUS_AXES;
  static const unsigned short MAIN_AXES;

  @<Declare |Focus| functions@>@;

};

@q * (1) Initialize |static| |Focus| data members.@>
@* Initialize |static| {\bf Focus} data members.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

@<Initialize |static| |Focus| data members@>=

   const unsigned short Focus::FOCUS_AXES = 1;
   const unsigned short Focus::MAIN_AXES  = 2;

@q * (1) |Focus| functions.@>
@* {\bf Focus} functions.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

@q ** (2) Constructors and setting functions.@>
@*1 Constructors and setting functions.
\initials{LDF 2002.09.22.}  @:!! TO DO@> TO DO: Check |magnitude| of 
|direction - position| and make sure it's non-zero!!

\initials{LDF 2002.10.13.}  
The effect of using an
|angle != 0| is similar to that of rotating a camera about an axis
through its aperture and perpendicular to the surface of the lens. Because
this is possible, it is necessary to indicate the upward direction of
a projection.  The |Point| |up| does this.  It
is determined in the constructors and setting functions by
the vector |direction - position| and |angle|.   
|up| is first set to $(0, 1, 0)$ if |axis == 'x'| or 
|axis == 'z'|, or $(1, 0, 0)$ if |axis == 'y'|.  
If |angle != 0|, |up| and |transform| are then rotated
by |-angle|.  Then, |up| is transformed by the inverse of |transform|,
in order to put it in the correct location with respect to |position|.
This location is ``above'' |position| by definition.

\initials{LDF 2002.10.13.}  Changed all of the constructors and setting functions
except for the default constructor and the first non-default
constructor.  Now, all the others use the latter to create a |Focus|
locally and use |Focus::operator=|, which I've defined today, to
assign to |*this|.  This eases maintenance and cuts down on the
potential for error through inconsistencies in the different
constructors and setting functions.

@q *** (3) Default constructor. (No arguments).@>
@*2 Default constructor. (No arguments).
@^\cfunc{Focus}{Focus}@>
@<Declare |Focus| functions@>=
Focus() {}

@q *** (3) Constructor and setting function with |real| arguments.@>
@*2 Constructor and setting function with {\bf real} arguments.  
The first three |real| arguments are for the
coordinates of the center of projection (the focus in the narrowest
sense) (|position|), the fourth through the sixth are for the
coordinates of the direction of view (|direction|), 
|dist| is for the distance of |position| to the projection plane
(|distance|), |ang| is for the angle of rotation around the axis
$\overrightarrow{pd}$ where $p$ stands for |position| and $d$ for
|direction| (|angle|), and the |char| argument |ax| indicates the axis
with which $\overrightarrow{pd}$ is to be aligned, and around which
|up| is to be rotated (|axis|).

\LOG
\initials{LDF 2003.07.04.}  
Now calling |persp.set_element| instead of
accessing the elements of |persp| directly.  The latter is no longer
possible, because |Focus| is no longer a |friend| of |Transform|.  

\initials{LDF 2007.09.17.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.

\initials{LDF 2007.09.17.}
Moved the definition of this function from this file (\filename{points.web}) 
to \filename{paths.web}, because it now requires the use of the types |Path| and |Plane|.

\initials{LDF 2007.09.17.}
Added the optional |real tolerance| argument with the default $.0001$.

\initials{LDF 2007.09.17.}
Changed the way |Point up| is set.
@:!!@> !! This change will change the meaning of existing 
user code!
\par
\item{1.}  Take the point $P$ such that $P = (0, 1, 0)$.  That is, $P$ is 
the point that represents a unit vector in the direction 
of the y-axis.
\smallskip
%
\item{2.}  Shift $P$ to the |position| of the |Focus|.
\smallskip
\item{3.}  Find the |Plane| $q$ of the |Path| |position|---|direction|---$P$.
\smallskip
\item{4.}  Find the point $N$ such that $N$ is a normal to $q$.
\smallskip
\item{5.}  Set the point $R$ equal to $P$ and rotate $R$ about the axis 
$N$---|position| to make it perpendicular to the line 
|position|---|direction|.
\par
I believe this should result in |position|---|up| being 
the vector perpendicular to the line |position|---|direction| 
with the maximum y-component, since R is both perpendicular to 
|position|---|direction| and lies in the plane $q$.

\initials{LDF 2007.09.17.}
Removed code from this function.  Now calling the version of |Focus::set| 
with |real| arguments instead.

\initials{LDF 2007.09.19.}
Moved the definition of this function from \filename{paths.web}
back to this file (\filename{points.web}).  It no longer needs to be 
defined elsewhere, because it now justs calls the version of |Focus::set|
with |real| arguments.
\ENDLOG 

@q **** (4) Constructor.@>
@*3 Constructor.
@^\cfunc{Focus}{Focus}@>

@q ***** (5) Declaration.  @>

@<Declare |Focus| functions@>=
Focus(const real pos_x, const real pos_y, const real pos_z, 
      const real dir_x, const real dir_y, const real dir_z,
      const real dist, const real ang = 0, char ax = 'z',
      real tolerance = .0001,
      Scanner_Node scanner_node = 0);


@q ***** (5) Definition.  @>
@
@<Define |Focus| functions@>=
Focus::Focus(const real pos_x, const real pos_y, const real pos_z, 
             const real dir_x, const real dir_y, const real dir_z,
             const real dist,  const real ang, char ax,
             real tolerance,
             Scanner_Node scanner_node)
     : distance(dist), angle(ang), axis(ax)
{
   
    set(pos_x, pos_y, pos_z, dir_x, dir_y, dir_z, dist, ang, ax, tolerance,
        scanner_node);

    return;

} /* End of |Focus::Focus| (constructor with |real| arguments)  */

@q **** (4) Setting function.@>
@*3 Setting function.
@^\cfunc{Focus}{set}@>
\initials{LDF 2002.09.17.}  

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2007.09.17.}
Moved the definition of this function from this file (\filename{points.web}) 
to \filename{paths.web}, because it now requires the use of the types |Path| and |Plane|.
I've rewritten it to correspond to the constructor with |real| arguments.

\initials{LDF 2007.09.17.}
Added the optional |real tolerance| argument with the default $.0001$
and the optional |Scanner_Node scanner_node| argument with the default 0.

\initials{LDF 2007.09.17.}
Changed the way |Point up| is set.
@:!!@> !! This change will change the meaning of existing 
user code!

\initials{LDF 2007.09.19.}
Moved the definition of this function back to this file (\filename{points.web}) 
from \filename{paths.web}.  It no longer needs to be defined there, because 
it now calls the version of |Focus::set| that takes |real*| arguments.  
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Focus| functions@>=
void
set(const real pos_x, const real pos_y, const real pos_z, 
      const real dir_x, const real dir_y, const real dir_z,
      const real dist, const real ang = 0.0, char ax = 'z', 
      real tolerance = .0001,
      Scanner_Node scanner_node = 0);


@q ***** (5) Definition.  @>
@
@<Define |Focus| functions@>=
void
Focus::set(real pos_x, real pos_y, real pos_z, 
             real dir_x, real dir_y, real dir_z,
             real dist,  real ang, char ax,
             real tolerance,
             Scanner_Node scanner_node)
{

   set(&pos_x, &pos_y, &pos_z, &dir_x, &dir_y, &dir_z,
       &dist, &ang, ax, tolerance, scanner_node);

   return;

}  /* End of |Focus::set| definition (version with |real| arguments)  */


@q *** (3) Setting function with |real*| arguments.@>
@*2 Setting function with {\bf real*} arguments.
\initials{LDF 2007.09.19.}

This function must be defined in \filename{paths.web}.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this declaration.
\ENDLOG

@<Declare |Focus| functions@>=
void
set(real* pos_x, real* pos_y = 0, real* pos_z = 0, 
    real* dir_x = 0, real* dir_y = 0, real* dir_z = 0,
    real* dist = 0, real* ang = 0, char ax = 'z', 
    real tolerance = .0001,
    Scanner_Node scanner_node = 0);

@q *** (3) Point arguments.@>
@*2 {\bf Point} arguments.

@q **** (4) Constructor.@>
@*3 Constructor.
@^\cfunc{Focus}{Focus}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2007.09.17.}
Now calling |Focus::set| instead of creating a |Focus| locally 
and assigning to |*this| from it.
\ENDLOG 

@q ***** (5) Declaration.@>

@<Declare |Focus| functions@>=
Focus(const Point& pos, const Point& dir,
      const real dist,  const real ang = 0.0, char ax = 'z');


@q ***** (5) Definition.@>
@
@<Define |Focus| functions@>=
Focus::Focus(const Point& pos, const Point& dir,
             const real dist,  const real ang, char ax)
{
  set(pos.get_x(), pos.get_y(), pos.get_z(),
      dir.get_x(), dir.get_y(), dir.get_z(), dist, ang, ax);
}


@q **** (4) Setting function.@>
@*3 Setting function.
@^\cfunc{Focus}{set}@>
\initials{LDF 2002.09.17.}  

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2007.09.17.}
Now calling the version of |set| with |real| arguments.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Focus| functions@>=
void
set(const Point& pos, const Point& dir, const real dist, 
    const real ang = 0.0, char ax = 'z');

@q ***** (5) Definition.@>
@
@<Define |Focus| functions@>=
void
Focus::set(const Point& pos, const Point& dir, const real dist,
           const real ang, char ax)
     
{

  set(pos.get_x(), pos.get_y(), pos.get_z(),
      dir.get_x(), dir.get_y(), dir.get_z(), dist, ang, ax);

}

@q *** (3) |Point*| and |real*| arguments.@>
@*2 {\bf Point*} and {\bf real*} arguments.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

@q **** (4) Setting function.@>
@*3 Setting function.
@^\cfunc{Focus}{set}@>
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Focus| functions@>=
void
set(Point* pos, Point* dir = 0, real* dist = 0, 
    real* ang = 0, char ax = 'z');

@q ***** (5) Definition.@>
@
@<Define |Focus| functions@>=
void
Focus::set(Point* pos, Point* dir, real* dist,
           real* ang, char ax)
     
{

@q ****** (6)@>

   real* pos_x = 0;
   real* pos_y = 0;
   real* pos_z = 0;

   real* dir_x = 0;
   real* dir_y = 0;
   real* dir_z = 0;

   real temp_pos_x;
   real temp_pos_y;
   real temp_pos_z;

   real temp_dir_x;
   real temp_dir_y;
   real temp_dir_z;


   if (pos)
   {
      temp_pos_x = pos->get_x();
      temp_pos_y = pos->get_y();
      temp_pos_z = pos->get_z();

      pos_x = &temp_pos_x;
      pos_y = &temp_pos_y;
      pos_z = &temp_pos_z;
      
   }

   if (dir)
   {
      temp_dir_x = dir->get_x();
      temp_dir_y = dir->get_y();
      temp_dir_z = dir->get_z();

      dir_x = &temp_dir_x;
      dir_y = &temp_dir_y;
      dir_z = &temp_dir_z;
      
   }

   set(pos_x, pos_y, pos_z,
       dir_x, dir_y, dir_z, dist, ang, ax);

@q ****** (6)@>

   return;

}  /* End of |Focus::set| definition 
      (version with |Point*| and |real*| arguments)  */



@q ** (2) Pseudo-constructor for dynamic allocation. @>
@*1 Pseudo-constructor for dynamic allocation. 

\LOG
\initials{LDF 2004.06.07.}  
Added this section.
\ENDLOG 

@q *** (3) Pointer argument. @>
@*2 Pointer argument. 

\LOG
\initials{LDF 2004.06.07.}  
Added this declaration.

\initials{LDF 2004.10.11.}
@:BUG FIX@> BUG FIX: 
Changed |Pen| to |Focus| in the section name and the declaration.

\initials{LDF 2004.10.11.}
Added default argument of 0 for |Scanner_Node scanner_node|.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare non-member template functions for |Focus|@>=
Focus* 
create_new(const Focus* f, Scanner_Node scanner_node = 0);

@q *** (3) Reference argument. @>
@*2 Reference argument. 

\LOG
\initials{LDF 2004.06.07.}  
Added this declaration.

\initials{LDF 2004.10.11.}
@:BUG FIX@> BUG FIX: 
Changed |Pen| to |Focus| in the section name and the declaration.

\initials{LDF 2004.10.11.}
Added default argument of 0 for |Scanner_Node scanner_node|.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare non-member template functions for |Focus|@>=
Focus* 
create_new(const Focus& f, Scanner_Node scanner_node = 0);

@q ** (2) Assignment.@>
@*1 Assignment.@>

\LOG
\initials{LDF 2002.10.13.}  
Added this function.  Now using it in all but the
first of the non-default constructors.  This saves on duplicating code
and reduces the probability of bugs that might arise from
inconsistencies among the constructors and setting functions.

\initials{LDF 2007.09.19.}
Now assigning to |normal| from |f.normal|.
\ENDLOG 

@<Declare |Focus| functions@>=
const Focus&
operator=(const Focus&);

@
@<Define |Focus| functions@>=
const Focus&
Focus::operator=(const Focus& f)
{
  if (this == &f)  /* \initials{LDF 2002.10.13.}  Prevent self-assignment.  */
    return *this;

  position = f.position;
  direction = f.direction;
  up = f.up;
  normal = f.normal;
  distance = f.distance;
  angle = f.angle;
  axis = f.axis;
  transform = f.transform;
  persp = f.persp;
  return *this;
}

@q ** (2) Reset angle.@>
@*1 Reset angle.
@^\cfunc{Focus}{reset\_angle}@>
\initials{LDF 2002.10.12.}  

\LOG
\initials{LDF 2002.10.12.}  
Added this function.

\initials{LDF 2007.09.17.}
Rewrote this function.  Now calling |Focus::set|. 

\initials{LDF 2007.09.19.}
Now calling the version of |Focus::set| that takes |Pointer*| and |real*| arguments.
Made |real ang| argument non-|const|.
\ENDLOG 

@<Declare |Focus| functions@>=
void
reset_angle(real ang);

@
@<Define |Focus| functions@>=
void
Focus::reset_angle(real ang)
{
   
    set(static_cast<Point*>(0), 0, 0, &ang);

    return;

}  /* End of |Focus::reset_angle| definition.  */

@q ** (2) Transformations.@>
@*1  Transformations.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

@q *** (3) Rotate.@>
@*2 Rotate.
\initials{LDF 2007.09.02.}


@q **** (4) |real| arguments.@>
@*3 {\bf real} arguments.
@^\cfunc{Focus}{rotate}@>
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

Rotation can be about the ``axes'' of the |Focus| or 
about the main axes.  The former is the default.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.02.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Focus| functions@>=
int
rotate(const real angle_x, 
       const real angle_y = 0, 
       const real angle_z = 0, 
       const unsigned short axes = FOCUS_AXES,
       real tolerance = .0001,
       Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>
@
@<Define |Focus| functions@>=
int
Focus::rotate(const real angle_x, 
              const real angle_y, 
              const real angle_z, 
              const unsigned short axes,
              real tolerance,
              Scanner_Node scanner_node)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>


#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Focus::rotate' with `real' arguments.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   if (tolerance < 0)
      tolerance = .0001;
   
#if 0 
   cerr << "axes == " << axes << endl
        << "`angle_x' == " << angle_x 
        << endl 
        << "`angle_y' == " << angle_y 
        << endl 
        << "`angle_z' == " << angle_z 
        << endl;
#endif 

@q ****** (6) Check value of |axes| argument.@>
@ Check value of |axes| argument.  If it's not Set to |Focus::FOCUS_AXES|
or Set to |Focus::MAIN_AXES|, issue a warning and set it to the former 
value.
\initials{LDF 2007.09.19.}

@<Define |Focus| functions@>=

   if (!(axes == Focus::FOCUS_AXES || axes == Focus::MAIN_AXES))
   {
       cerr_strm << thread_name << "WARNING!  In `Focus::rotate':"
                 << endl 
                 << "Invalid value for `axes' argument:  " << axes 
                 << endl 
                 << "Will use focus axes.  Continuing.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, warning_stop_value);
       cerr_strm.str("");

   }  /* |if| (Invalid value for |axes| argument)  */


   Transform t;

@q ****** (6) Rotation about the |Focus| axes (default).@>
@ Rotation about the |Focus| axes (default).

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
@:??@> ?? Do I need to shift |transform| by |(0, 0, distance)| before 
multiplying it by |t.inverse()| and then shift it back?  Check this.
\ENDTODO 

@<Define |Focus| functions@>=

   if (axes == Focus::FOCUS_AXES)
   {

#if 0 
       cerr << "Rotating about focus axes." << endl;
#endif 

@q ******* (7)@>

       if (fabs(angle_x) > tolerance)
       {

#if 0 
           position.show("position before rotation about x-axis:");
           normal.show("normal before rotation:");

           direction.show("direction before rotation about x-axis:");
           up.show("up before rotation about x-axis:");

           cerr << endl;
#endif 

           t *= up *= direction.rotate(normal, position, angle_x);

           transform.shift(0, 0, distance);

           transform *= t.inverse();

           transform.shift(0, 0, -distance);

#if 0 
           position.show("position after rotation about x-axis:");
           normal.show("normal after rotation:");

           direction.show("direction after rotation about x-axis:");
           up.show("up after rotation about x-axis:");
#endif 

       }  /* |if (fabs(angle_x) > tolerance)|  */


@q ******* (7)@>

       if (fabs(angle_y) > tolerance)
       {
           t.reset();
 
#if 0 
           position.show("position before rotation about y-axis:");
           normal.show("normal before rotation:");

           direction.show("direction before rotation about y-axis:");
           up.show("up before rotation about y-axis:");

           (up - position).unit_vector().show(
              "up - position before rotation about y-axis (unit vector):");

           cerr << "(up - position).angle(direction - position)"
                << " before rotation about y-axis: "
                << (up - position).angle(direction - position)
                << endl << endl;
 
#endif 

           t *= normal *= direction.rotate(up, position, angle_y);

           transform.shift(0, 0, distance);

           transform *= t.inverse();

           transform.shift(0, 0, -distance);

#if 0 
           position.show("position after rotation about y-axis:");
           normal.show("normal after rotation:");

           direction.show("direction after rotation about y-axis:");
           up.show("up after rotation about y-axis:");

           (up - position).unit_vector().show(
              "up - position after rotation about y-axis (unit vector):");

           cerr << "(up - position).angle(direction - position)"
                << " after rotation about y-axis: "
                << (up - position).angle(direction - position)
                << endl;
#endif 
           
       }  /* |if (fabs(angle_y) > tolerance)|  */


@q ******* (7)@>

       if (fabs(angle_z) > tolerance)
       {
           t.reset();
 
#if 0 
           position.show("position before rotation about z-axis:");
           normal.show("normal before rotation:");

           direction.show("direction before rotation about z-axis:");
           up.show("up before rotation about z-axis:");

           (up - position).unit_vector().show(
              "up - position before rotation about z-axis (unit vector):");

           cerr << "(up - position).angle(direction - position)"
                << " before rotation about z-axis: "
                << (up - position).angle(direction - position)
                << endl << endl;
#endif 
           
           t *= normal *= up.rotate(position, direction, angle_z);

           transform.shift(0, 0, distance);

           transform *= t.inverse();

           transform.shift(0, 0, -distance);

#if 0 
           position.show("position after rotation about z-axis:");
           normal.show("normal after rotation:");

           direction.show("direction after rotation about z-axis:");
           up.show("up after rotation about z-axis:");

           (up - position).unit_vector().show(
              "up - position after rotation about z-axis (unit vector):");

           cerr << "(up - position).angle(direction - position)"
                << " after rotation about z-axis: "
                << (up - position).angle(direction - position)
                << endl;
#endif       
     
       }  /* |if (fabs(angle_z) > tolerance)|  */

@q ******* (7)@>

   }  /* |if (axes == Focus::FOCUS_AXES)|  */

@q ****** (6) Rotation about the main axes.@>
@ Rotation about the |Focus| main axes.
\initials{LDF 2007.09.19.}

@<Define |Focus| functions@>=

   else if (axes == Focus::MAIN_AXES)
   {

#if 0 
       cerr << "Rotating about main axes." << endl;
#endif 

@q ******* (7)@>

       if (   fabs(angle_x) > tolerance 
           || fabs(angle_y) > tolerance 
           || fabs(angle_z) > tolerance)
       {


#if 0 
           position.show("position before rotation about main axes:");
           normal.show("normal before rotation:");

           direction.show("direction before rotation about main axes:");
           up.show("up before rotation about main axes:");

           cerr << endl;
#endif 

           t *= up *= direction *= normal 
             *= position.rotate(angle_x, angle_y, angle_z);

           transform.shift(0, 0, distance);

           transform *= t.inverse();

           transform.shift(0, 0, -distance);

#if 0 
           position.show("position after rotation about main axes:");
           normal.show("normal after rotation:");

           direction.show("direction after rotation about main axes:");
           up.show("up after rotation about main axes:");
#endif 

       }  /* |if|  */

@q ******* (7)@>

   }  /* |if (axes == Focus::MAIN_AXES)|  */

@q ****** (6) ERROR!  Invalid value for |axes| argument.@>
@ ERROR!  Invalid value for |axes| argument.
\initials{LDF 2007.09.19.}

This can't happen, since this case is caught above.

@<Define |Focus| functions@>=

   else
   {
       cerr_strm << thread_name << "ERROR!  In `Focus::rotate':"
                 << endl 
                 << "Invalid value for `axes' argument:  " << axes
                 << endl 
                 << "Not rotating `*this'.  "
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |else|  (Invalid value for |axes| argument)  */

@q ****** (6)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Exiting `Focus::rotate' with `real' arguments "
                << "successfully with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

}  /* End of |Focus::rotate| definition.  */


@q ** (2) Reflect off.@>
@*1 Reflect off.
@^\cfunc{Focus}{reflect\_off}@>
\initials{LDF 2005.01.18.}

\LOG
\initials{LDF 2005.01.18.}
Added this function.  It contains a dummy definition.  
It simply returns 1, indicating failure.  If it doesn't exist, 
this causes an error in the template function 
|Scan_Parse::reflect_off_func| in \filename{scanprse.web}.
\ENDLOG

@<Declare |Focus| functions@>=
int
reflect_off(const Plane& p,
            Point direction,
            void* v,
            const Scanner_Node scanner_node = 0) const;

@
@<Define |Focus| functions@>=
int
Focus::reflect_off(const Plane& p,
                   Point direction,
                   void* v,
                   const Scanner_Node scanner_node) const
{
   return 1;
}

@q ** (2) Show.@>
@*1 Show.
@^\cfunc{Focus}{show}@>

\LOG 
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2003.07.09.}  Made the arguments |const|.  
\ENDLOG 

@<Declare |Focus| functions@>=
void
show(const string text_str = "Focus:", const bool show_transforms = false) const;

@
@<Define |Focus| functions@>=
void
Focus::show(const string text_str, const bool show_transforms) const
{
  cerr << text_str << endl;
  position.show("position:");
  direction.show("direction:");
  up.show("up:");
  cerr << "distance == " << distance << ". "
       << "axis == " << axis << endl;
  cerr << "angle == " << angle << endl;
  
  if (show_transforms == true)
    {
      transform.show("transform:");
      persp.show("persp:");
    }
  return;
}

@q ** (2) Returning elements and information.@>
@*1 Returning elements and information.
\initials{LDF 2002.09.18.}  Added this section.  The functions in this section
are now necessary, since I've made |Focus| a |class| (it was formerly
a |struct|), and the data members |private|.

@q *** (3) Get position.@>
@*2 Get position.
@^\cfunc{Focus}{get\_position}@>
\initials{LDF 2002.09.18.}  
@q Focus::get_position  @>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.
\ENDLOG 

@<Declare |Focus| functions@>=
inline
const Point& 
get_position(void) const {return position;}

@q *** (3) Get direction.@>
@*2 Get direction.
@^\cfunc{Focus}{get\_direction}@>
\initials{LDF 2003.07.09.}  
@q Focus::get_direction  @>

\LOG
\initials{LDF 2003.07.09.}  
Added this function.
\ENDLOG

@<Declare |Focus| functions@>=
inline
const Point& 
get_direction(void) const {return direction;}


@q *** (3) Get distance.@>
@*2 Get distance.
@^\cfunc{Focus}{get\_distance}@>
\initials{LDF 2002.09.18.}  
@q Focus::get_distance  @>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.
\ENDLOG 

@<Declare |Focus| functions@>=
inline
const real& 
get_distance(void) const 
{
   return distance;
}

@q *** (3) Get up.@>
@*2 Get up.
@^\cfunc{Focus}{get\_up}@>
\initials{LDF 2002.09.18.}  
@q Focus::get_up  @>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.
\ENDLOG 

@<Declare |Focus| functions@>=
inline
const Point& 
get_up(void) const {return up;}


@q *** (3) Get transform.@>
@*2 Get transform.
@^\cfunc{Focus}{get\_transform}@>
\initials{LDF 2002.09.18.}  
@q Focus::get_transform  @>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.
\ENDLOG 

@q **** (4) Definition.@> 

@<Declare |Focus| functions@>=

inline
const Transform&
get_transform(void) const 
{
   return transform;
}

@q *** (3) Get transform element.@>
@*2 Get transform element.
@^\cfunc{Focus}{get\_transform\_element}@>
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.18.}  
Added this function.

\initials{LDF 2003.07.04.}  
Made non-inline.  It now calls
|Transform::get_element| instead of accessing\newline
|transform.matrix|
directly.  This is no longer possible, because |Focus| is no longer a
|friend| of |Transform|.

\initials{LDF 2003.07.09.}  
Changed the |const unsigned int| arguments to |const
unsigned short|.   
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Focus| functions@>=

real
get_transform_element(const unsigned short row,
                      const unsigned short column) const;

@q **** (4) Definition.@> 

@
@<Define |Focus| functions@>=
real
Focus::get_transform_element(const unsigned short row,
                             const unsigned short column) const
{
  return transform.get_element(row, column);
}

@q *** (3) Get persp.@>
@*2 Get persp.
@^\cfunc{Focus}{get\_persp}@>
\initials{LDF 2002.09.18.}  
@q Focus::get_persp  @>

\LOG
\initials{LDF 2002.09.18.}  
Added this function.
\ENDLOG 

@<Declare |Focus| functions@>=
inline
const Transform&
get_persp(void) const 
{
   return persp;
}

@q *** (3) Get persp element.@>
@*2 Get persp element.
@^\cfunc{Focus}{get\_persp\_element}@>
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.18.}  
Added this function.

\initials{LDF 2003.07.04.}  
Made non-inline.  It now calls
|Transform::get_element| instead of accessing\newline
|transform.matrix| directly.  This is no longer possible, because
|Focus| is no longer a |friend| of |Transform|.

\initials{LDF 2003.07.09.}  
Changed the |const unsigned int| arguments to |const
unsigned short|.   
\ENDLOG

@<Declare |Focus| functions@>=
real
get_persp_element(const unsigned short row, const unsigned short column) const;

@
@<Define |Focus| functions@>=
real
Focus::get_persp_element(const unsigned short row,
                         const unsigned short column) const
{
  return persp.get_element(row, column);
}

@q *** (3) Get normal.@>
@*2 Get normal.
@^\cfunc{Focus}{get\_normal}@>
\initials{LDF 2007.09.19.}

This function must be defined in \filename{paths.web}, because it
uses a |Path| in its definition, which is an incompletely defined type
in this file.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.

\initials{LDF 2007.09.19.}
Made this function |inline|.  
It now returns the data member |Point normal|, which I've just added.
Formerly, the normal was found by calling |Point::get_normal| on |position| 
with |up| and |direction| as its arguments.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Focus| functions@>=
inline
Point
get_normal(void) const
{
   return normal;
}

@q * (1) Declare global |Focus| variables.@>
@ Declare global |Focus| variables.
\initials{LDF Undated.}

@<Declarations for the header file@>=

extern Focus default_focus;

@q * (0) struct Focus_Options.@>
@** {\bf struct focus\_options}.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this |struct| declaration.
\ENDLOG

@f Focus_Options int

@<Declare |struct Focus_Options|@>=

struct Focus_Options
{
   unsigned short axes;
   real tolerance;

   @<Declare |Focus_Options| functions@>@;

};

@q * (1) |Focus_Options| functions.@>
@* {\bf focus\_options} functions.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section.
\ENDLOG

@q ** (2) Default constructor.@>
@*1 Default constructor.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.

\initials{LDF 2007.09.24.}
Now setting |axes| to 0.
\ENDLOG

@<Declare |Focus_Options| functions@>=

Focus_Options(void)
{
   axes = 0;
   tolerance = -1;
}

@q ** (2) Clear.@>
@*1 Clear.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.
\ENDLOG


@<Declare |Focus_Options| functions@>=
int
clear(void);

@
@<Define |Focus_Options| functions@>=
int
Focus_Options::clear(void)
{
   axes = 0;
   tolerance = -1;
}

@q * (1) Putting Point and Focus together.@>
@* Putting {\bf Point} and {\bf Focus} together.

@q ** (2) This is what's compiled.@>
@ This is what's compiled.

\LOG
\initials{LDF 2004.10.11.}
Now including 
|@<Declare non-member template functions for |Focus|@>|. 
\ENDLOG 

@c
@<Include files@>@;
@<Define |class Point|@>@;
@<Declare non-member template functions for |Point|@>@;
@<Define |Point| constructors@>@;
@<Define |class Focus|@>@;
@<Declare |struct Focus_Options|@>@;
@<Initialize |static| |Focus| data members@>@;
@<Define comparison classes@>@;
@<Define |static Point| data members@>@;
@<Type definitions@>@;
@<Global constants@>@;
@<Define |Transform| functions@>@;
@<Define |Point| functions@>@;
@<Define non-member non-template functions for |Point|@>@;
@<Define |Bool_Point| functions@>@;
@<Define |Bool_Point_Quadruple| functions@>@;
@<Define |Bool_Real_Point| functions@>@;
@<Define |Focus| functions@>@;
@<Define |Focus_Options| functions@>@;
@<Define |Label| functions@>@;
@<Define |Picture| functions@>@;
@<Define comparison class functions@>@;

@q **  This is what's written to \filename{points.h}. @>
@ This is what's written to \filename{points.h}. 

\LOG
\initials{LDF 2004.10.11.}
@:BUG FIX@> BUG FIX: 
Now including 
|@<Declare non-member template functions for |Focus|@>|.
\ENDLOG 

@(points.h@>=

@<Define |class Point|@>@;
@<Define |class Focus|@>@;
@<Declare |struct Focus_Options|@>@;
@<Define comparison classes@>@;
@<Declare non-member template functions for |Point|@>@;
@<Declare non-member non-template functions for |Point|@>@;
@<Declare non-member template functions for |Focus|@>@;
@<Type definitions@>@;
@<Declarations for the header file@>@;
 

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q mode:CWEB @>


@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-ctangle-on-file:"points.web" @>
@q run-cweb-on-file:"points.web" @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>

  
