@q pctfncs0.web @>
 
@q * (1) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing.  @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc.  @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA@>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html.@>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>

@q * (0) Picture functions.@>
@** {\bf Picture} functions\quad ({\tt pctfncs0\PERIOD web}).\hfil
\initials{LDF 2005.04.09.}

\LOG
\initials{LDF 2005.04.09.}
Added this file.
\ENDLOG

@q * (1) Include files.@>
@ Include files.
\initials{LDF 2005.04.09.}

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++" 
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++"
#include "glyphs.h++"
#include "scanprse.h++"   

@q * (1) Picture functions.@>
@* Picture functions.
\initials{LDF 2005.04.09.}

@q ** (2) Output.@>
@*1 Output.
@^\cfunc{Picture}{output}@>
\initials{LDF Undated.}

The arguments:

\item{$\bullet$} |sort_value| is used to determine how to sort
the |Shapes|.  The values to be used are found in 
|namespace Sorting|.  |Sorting::SUPPRESS_SORT| is used if they shouldn't be
sorted, because we will have already drawn them in the order we want
them rendered.  |Sorting::MAX_Z| is used for sorting them according to
their maximum z-coordinate for ``furthest-first'' output.  
|Sorting::MIN_Z| is used for sorting them according to
their maximum z-coordinate for ``nearest-last'' output.  So far, no
other types of sorting have been defined.

The simple painter's algorithm implemented here for surface
hiding fails for |Shapes| where one |Shape| is partly in front of and
partly behind another.  For these cases, it will be necessary to find
the intersection points and divide the |Shapes| into parts. 
@:!! TO DO@> TO DO: Implement a routine for dividing up |Shapes|.
This will not be done soon!

|do_warnings|:
Sometimes we'll want use the |min_x_proj|, |max_x_proj|, etc.,
arguments to cut off parts of the image, or we'll deliberately place
the |Focus| where it won't be able to ``see'' part of the image.  In
these cases, it will be annoying to see the warnings.

\LOG
\initials{LDF 2002.09.21.}  
Added the arguments |do_sort| and |do_warnings|.

\initials{LDF 2003.05.16.}  
Changed |bool do_sort| to |const unsigned short
sort_value|.  About to add |namespace Sorting| with constants for
different ways of sorting, i.e., ``no sort'', ``nearest-last'', or
``furthest-first''. 

\initials{LDF 2004.05.25.} 
Added |Scanner_Node| argument.  Changed 
|out_stream| from a global |ofstream| to an |ofstream*|.  It's now set
using the |Scanner_Node| argument.

\initials{LDF 2004.06.07.}  
Got rid of the version of this function that 
didn't take a |Focus| argument, because I've gotten rid of |default_focus|.  
I may replace |default_focus| with a predefined variable defined in
|Scanner_Type::create|.   

\initials{LDF 2004.06.29.}
Changed |SORTING::NO_SORT| to |SORTING::SUPPRESS_SORT| because 
|NO_SORT| is now a macro defined by means of a token declaration in 
\filename{pbsndecl.w}.

\initials{LDF 2005.03.14.}
Added the optional argument 
|const unsigned short surface_hiding_value| with default 1.

\initials{LDF 2005.04.09.}
Moved this definition from \filename{points.web} to this file 
(\filename{pctfncs0.web}).
\ENDLOG

@q *** (3) Definition.  @>

@<Define |Picture| functions@>=
void
Picture::output(Scanner_Node scanner_node,
                unsigned int output_command_arg,
                const Focus& f,
                const unsigned short projection,
                real factor,
                const unsigned short sort_value,
                const bool do_warnings,
                const real min_x_proj,
                const real max_x_proj,
                const real min_y_proj,
                const real max_y_proj,
                const real min_z_proj,
                const real max_z_proj,
                const unsigned short surface_hiding_value)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = true; /* |false| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

  using namespace Sorting;

  bool local_do_metafont = 
     (metafont_output && (   output_command_arg & Scan_Parse::ENDCHAR_COMMAND
                          || output_command_arg & Scan_Parse::METAFONT_OUTPUT_COMMAND))
     ? true : false;

  bool local_do_metapost = 
     (metapost_output && (   output_command_arg & Scan_Parse::ENDFIG_COMMAND
                          || output_command_arg & Scan_Parse::METAPOST_OUTPUT_COMMAND))
     ? true : false;

#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr << "Here I am 9." << endl; 

          cerr_strm << thread_name 
                    << "Entering `Picture::output(Scanner_Node, const Focus& ...)'."
                    << endl  
                    << "min_x_proj == " << min_x_proj << endl
                    << "max_x_proj == " << max_x_proj << endl
                    << "min_y_proj == " << min_y_proj << endl
                    << "max_y_proj == " << max_y_proj << endl
                    << "surface_hiding_value == " << surface_hiding_value
                    << endl 
                    << "`output_command_arg' == " << output_command_arg
                    << endl
                    << "`local_do_metafont' == " << local_do_metafont << endl 
                    << "`local_do_metapost' == " << local_do_metapost << endl;

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

      }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4).  @>
 
@ Check whether the |vector| |shapes| has anything in it.  
If it doesn't, return.
\initials{LDF Undated.}

@<Define |Picture| functions@>= 

  if (shapes.size() <= 0 && labels.size() <= 0)
    {
#if DEBUG_COMPILE
   if (DEBUG) 
      {
         cerr_strm << thread_name << "Picture is empty. Returning.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

   return;

    } 

@q **** (4).  @>

@ \initials{LDF 2002.09.17.} 
Some |Shapes| may consist of other |Shapes|, and not have an
|output| function of their own, so we must extract their
contents recursively until we get to |Shapes| that have one.  So
far, only |Point|, |Path|, and |Solid| have |output| functions, and all
other |Shapes| reduce to |Paths| or |Solids|.  

\initials{LDF 2002.09.17.} 
|extract| checks that all of the |Points| contained in the
|Shape| can be projected with the |Focus| that is being used.  If any
of them cannot be, then |extract| returns an empty
|vector| of |Shapes|.  This means that any |Shape| must be entirely
projectable; partial |Shapes| will not be output.  

\LOG
\initials{LDF 2003.01.05.}  
Modified the {\TeX} text above to account for the
fact that I've added |Solid|.

\initials{LDF 2003.01.05.}  
@: BUG FIX@> BUG FIX:  Moved the code that causes
|transform| to be applied to the elements of |shapes|.  This is now
done {\it before\/} the |extremes| are set.  The way it was before
didn't work properly, because |extract| used the untransformed
values to decide whether a |Shape| was projectable.  In order to do
this, I had to make |apply_transform| a |Shape| function.
\ENDLOG 

@q **** (4).  @>

@<Define |Picture| functions@>= 
 
   vector<Shape*> v;
   vector<Shape*> elements;

   bool do_transform = !transform.is_identity();

#if DEBUG_COMPILE
    if (DEBUG)
      {
        if (do_transform)
          {
            cerr << "Applying transform.\n";
            transform.show("transform:");
          }
        else 
          cerr << "Not applying transform.\n";
      }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4).  @>

  for (vector<Shape*>::iterator iter = shapes.begin();
       iter != shapes.end();
       ++iter)
    {

@q ***** (5).@> 

      if (do_transform)
        {
          (**iter) *= transform;
        }

      v = (**iter).extract(f, projection, factor);

      for(vector<Shape*>::iterator i = v.begin();
          i != v.end();
          ++i)
        {
          elements.push_back(*i);
        } 

@q ***** (5).@> 

    }  /* Outer |for|  */

@q **** (4) @>   

@ Set the extremes for the |Shape| and handle the error if
it returns |false|.  
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.09.18.}  
Changed the error handling code below.
Formerly, |get_minimum_z| was invoked, but this is 
unnecessary, since |set_projective_extremes| returns |false| if
something goes wrong with setting the extreme values for 
the |Shape|.  

\initials{LDF 2005.04.04.}
@:BUG FIX@> BUG FIX:  Now declaring |valarray<real> extremes| correctly.
Previously, the arguments to the constructor caused a |valarray<real>| with
no elements to be constructed.
\ENDLOG 

@<Define |Picture| functions@>= 

  {  /* Beginning of group.  */@;

     valarray <real> extremes(6);
  
@q ***** (5).@> 

     for(vector<Shape*>::iterator iter = elements.begin();
         iter != elements.end();
         ++iter)
        {

#if DEBUG_COMPILE
            if (DEBUG)
               {
                   cerr_strm << thread_name << "About to set projective extremes.";

                   log_message(cerr_strm);
                   cerr_message(cerr_strm);
                   cerr_strm.str(""); 
               }

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6).@> 

@ Error handling.
\initials{LDF 2004.06.08.}

\LOG
\initials{LDF 2004.06.08.}  
Now stopping if 
|scanner_node->get_run_state()->error_stop_mode == Run_State::ERRORSTOP|.  
This is possible now because |scanner_node| is passed to this function 
as an argument.
\ENDLOG 

@<Define |Picture| functions@>= 

        if (!(**iter).set_projective_extremes())
          {
              cerr_strm << thread_name << "ERROR!  In `Picture::output':"
                        << endl 
                        << "set_projective_extremes returned `false'. "
                        << "Suppressing output for this `Shape*'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              (**iter).suppress_output();

          } /* |if (!(**iter).set_projective_extremes())|  */@;

@q ****** (6).@> 
@ 
\LOG
\initials{LDF 2002.09.18.}  
Added this routine.  It checks for whether the values in 
the |valarray <real> projective_extremes| in the |Shape| fall within the limits 
given by the |min_x_proj|, |max_x_proj|, |min_y_proj|, and |max_x_proj| arguments 
to this function (|Picture::output|).  (Note that |min_z_proj| and
|max_z_proj| are currently not checked.)  If they don't, the |Shape*| is removed 
from |elements|.  Note that the projected z-coordinates are not currently 
checked, but they are used for ordering the |Shapes| for output (furthest away
first).

\initials{LDF 2005.06.30.}
Using the projected z-coordinates for ordering the |Shapes| for output 
doesn't work.  I'm about to try to use the unprojected coordinates 
instead.
\ENDLOG 

@<Define |Picture| functions@>= 

   extremes.resize(6, 0);
   extremes = (**iter).get_projective_extremes();

@q ****** (6).@> 

   if (   extremes[0] < min_x_proj || extremes[1] > max_x_proj 
       || extremes[2] < min_y_proj || extremes[3] > max_y_proj) 

      {
          if (do_warnings == true)
             {
                 cerr_strm << thread_name << "WARNING!  `In Picture::output':"
                           << endl 
                           << "`Shape' lies outside the limits for this "
                           << "invocation of output."
                           << endl 
                           << "Suppressing output for this `Shape*':"
                           << endl 

                           << "`extremes[0]' == " << extremes[0]
                           << endl 

                           << "`min_x_proj' == " << min_x_proj
                           << endl 

                           << "`extremes[1]' == " << extremes[1]
                           << endl 

                           << "`max_x_proj' == " << max_x_proj
                           << endl 

                           << "`extremes[2]' == " << extremes[2]
                           << endl 

                           << "`min_y_proj' == " << min_y_proj
                           << endl 

                           << "`extremes[3]' == " << extremes[3]
                           << endl 

                           << "`max_y_proj' == " << max_y_proj;

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");

             }

          (**iter).suppress_output();

      }  /* |if|  */

@q ****** (6).@> 

    } /* |for| */

@q ***** (5).@> 

 } /* End of group.  */

@q **** (4) @>   

@ Sorting can be performed in different ways,
depending on the |sort_value| argument.  This is explained in
|@<Define comparison classes@>|. 
\initials{LDF 2003.05.16.}  

It's necessary to make sure that sorting is only performed 
if |elements| is non-empty.  It could be empty now, if the 
error handling code above has removed all of the elements because 
|set_projective_extremes| returned |false| for all of them.  
We can't just return, because there might still be |Labels| on the 
|Picture|.
\initials{LDF 2002.09.18.}  

@<Define |Picture| functions@>= 

   if (elements.size() > 0)
      {

@q ***** (5) Sort.@> 
@ Sort.
\initials{LDF Undated.}

@<Define |Picture| functions@>=

          if (sort_value == MIN_Z)
            sort(elements.begin(), elements.end(), 
                 Compare_Minimum_Z<>());
          else if (sort_value == MAX_Z)
            sort(elements.begin(), elements.end(), Compare_Maximum_Z<>());
          else if (sort_value == MEAN_Z)
            sort(elements.begin(), elements.end(), Compare_Mean_Z<>());

#if DEBUG_COMPILE
         if (DEBUG)
            {
                if (sort_value == MIN_Z)
                  cerr_strm << thread_name << " *** MIN_Z sort. ***\n";
                else if (sort_value == MAX_Z)
                  cerr_strm << thread_name << " *** MAX_Z sort. ***\n";
                else if (sort_value == MEAN_Z)
                  cerr_strm << thread_name << " *** MEAN_Z sort. ***\n";

                for (vector<Shape*>::iterator iter = elements.begin();
                     iter != elements.end();
                     ++iter)
                  {
                    cerr_strm << "Min z: "  << (**iter).get_minimum_z() << endl
                         << "Max z: "  << (**iter).get_maximum_z() << endl
                         << "Mean z: "  << (**iter).get_mean_z() << endl << endl;
                  }
                cerr_strm << "**** End of result of sort.";

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Perform surface hiding.@> 
@ Perform surface hiding.
\initials{LDF 2005.03.14.}

\LOG
\initials{LDF 2005.03.14.}
Added this section.

\initials{LDF 2005.04.04.}
Got this to work for |Polygons|.  It still needs work.

\initials{LDF 2005.04.05.}
Fixed the loop that iterates over |shape_list|.  It seems to work now, 
but I will have to test it.

\initials{LDF 2005.04.08.}
Eliminated unused variables.
\ENDLOG

@<Define |Picture| functions@>=

   if (surface_hiding_value > 0)
   {  

/* !! START HERE.  LDF 2005.04.20.  Try to get surface hiding to work for
      more than two objects.  */@; 

#if DEBUG_COMPILE
   DEBUG = true; /* |false| */
#endif /* |DEBUG_COMPILE|  */@;

Shape* curr_shape = 0;
      Shape* next_shape = 0;

      int status;

      Int_Void_Ptr ivp;

      list<Shape*> shape_list;

      Pointer_Vector<Shape>* pv;

      bool decomposed_curr_shape_flag;

@q ****** (6).@> 
@
\LOG
\initials{LDF 2005.04.09.}
@:BUG FIX@> BUG FIX:  No longer clearing |elements|.  
It will be needed if this function is called on |*this| again.
\ENDLOG 

@<Define |Picture| functions@>=

      {  /* Beginning of group.  */

          unsigned long u = 0;

          for (vector<Shape*>::iterator iter = elements.begin();
               iter != elements.end();
               ++iter)
             {
                (**iter).set_surface_hiding_ctr(++u);
                shape_list.push_back(*iter); 
             }

      }  /* End of group.  */

      list<Shape*>::iterator curr_position;
      list<Shape*>::iterator next_position;
      list<Shape*>::iterator temp_position;

@q ****** (6).@> 

@ Outer loop.
\initials{LDF 2005.04.04.}

@<Define |Picture| functions@>=

     {

   /* !! START HERE.  LDF 2005.04.18.  Find out why surface hiding 
      fails for three objects.  */@; 

        unsigned outer_loop_ctr = 0;
        unsigned inner_loop_ctr = 0;

        unsigned int decomposition_ctr = 1;

      for (curr_position = shape_list.begin();
           curr_position != shape_list.end();
           ++curr_position)
         {

            ++outer_loop_ctr;

            decomposed_curr_shape_flag = false;

            curr_shape = *curr_position;

#if DEBUG_COMPILE
            if (DEBUG)
               {
                  cerr << "Outer loop:  iteration " << outer_loop_ctr 
                       << endl
                       << "`curr_shape->surface_hiding_ctr' == "
                       << curr_shape->get_surface_hiding_ctr() << endl;
               }  
#endif /* |DEBUG_COMPILE|  */@;

            next_position = curr_position;
            ++next_position;

@q ******* (7) Inner loop.@> 

@ Inner loop.
\initials{LDF 2005.04.04.}
 
@<Define |Picture| functions@>=

            inner_loop_ctr = 0;
           
            for (;next_position != shape_list.end(); ++next_position)
              {

                 ++inner_loop_ctr;
                 
                 next_shape = *next_position;
                 
#if DEBUG_COMPILE
                 if (DEBUG)
                    {
                       cerr << "Inner loop:  iteration " << inner_loop_ctr 
                            << endl
                            << "`next_shape->surface_hiding_ctr' == "
                            << next_shape->get_surface_hiding_ctr() << endl;
                    }  
#endif /* |DEBUG_COMPILE|  */@; 

                 if (next_shape->get_surface_hiding_ctr() <= decomposition_ctr)
                    continue;

                 status = curr_shape->enclosing_cuboids_intersect(next_shape);

@q ******** (8) @> 

                  if (status == 0)
                     {

#if DEBUG_COMPILE
                         if (DEBUG)
                            {
                                cerr << "`status' == 0.  "
                                     << "Enclosing cuboids don't intersect." 
                                     << endl 
                                     << "Leaving `next_shape' on `shape_list'."
                                     << endl;
                            }
#endif /* |DEBUG_COMPILE|  */@; 

                        continue;

                     }
@q ******** (8) @> 

                  else /* |status > 0|  */
                     {

#if DEBUG_COMPILE
                         if (DEBUG)
                            {
                                cerr << "`status' != 0.  Calling `intersection'."
                                     << endl;
                            }
#endif /* |DEBUG_COMPILE|  */@; 
 
                         ivp = curr_shape->intersection(next_shape, scanner_node); 

@q ********* (9) @> 

                         if (ivp.v == static_cast<void*>(0))
                            {

#if DEBUG_COMPILE
                               if (DEBUG)
                                  {
                                      cerr << "`ivp.v' == 0."
                                           << endl 
                                           << "Leaving `next_shape' on `shape_list'."
                                           << endl;

                                  }
#endif /* |DEBUG_COMPILE|  */@; 
 
                                continue;

                            }  /* |if (ivp.v == 0)|  */

@q ********* (9) @>      
                    
                         else  /* |ivp.v != 0|  */
                            {
                                pv = curr_shape->decompose(next_shape, scanner_node);

@q ********** (10) @>

                                if (   pv == static_cast<Pointer_Vector<Shape>*>(0)  
                                    || pv->ctr <= 0)
                                   {
#if DEBUG_COMPILE
                                       if (DEBUG)
                                          {
                                              cerr << "`pv' == 0 || `pv->ctr' == 0."
                                                   << endl 
                                                   << "Leaving `next_shape' on "
                                                   << "`shape_list'."
                                                   << endl;
                                          }
#endif /* |DEBUG_COMPILE|  */@; 
 
                                       continue;

                                   }  /* |if (pv == 0 || pv->ctr <= 0)|  */

@q ********** (10) @>

                                else  /* |pv != 0 && pv->ctr > 0|  */
                                    {
                                        decomposed_curr_shape_flag = true;
                                        ++decomposition_ctr;

#if DEBUG_COMPILE
                                            if (DEBUG)
                                              {                                   
                                                  cerr << "Decomposed `Shapes'." 
                                                       << endl;
                                              }
#endif /* |DEBUG_COMPILE|  */@;

@q *********** (11)@>
@
\LOG
\initials{LDF 2005.04.14.}
Now erasing |curr_shape| from |shape_list|.
I think this is correct, but so far I haven't noticed 
any difference in the visual results.

\initials{LDF 2005.04.15.}
@:BUG FIX@> BUG FIX:  Now deleting |curr_shape| and setting it to 0, 
if its |surface_hiding_ctr > 1|, i.e., if it wasn't one of the 
original pointers to |Shape| on |elements.|

\initials{LDF 2005.04.18.}
@:BUG FIX@> BUG FIX:  Now using |Shape::decomposition_level| 
to determine whether |curr_shape| should be deleted.
\ENDLOG 

@<Define |Picture| functions@>=

if (curr_shape->get_decomposition_level() > 0)
                                  {
                                      delete curr_shape;
                                      curr_shape = 0;
                                  }

                               temp_position = curr_position;
                               ++temp_position;
                               shape_list.erase(curr_position);
                               curr_position = temp_position;

@q *********** (11)@>
@

\LOG
\initials{LDF 2005.04.18.}
Added this section.
@:BUG FIX@> BUG FIX:  Now using |Shape::decomposition_level| 
to determine whether |next_shape| should be deleted.
\ENDLOG

@<Define |Picture| functions@>=

                                if (next_shape->get_decomposition_level() > 0)
                                   {
                                       delete next_shape;
                                       next_shape = 0;
                                   }

                                temp_position = next_position;
                                ++temp_position;
                                shape_list.erase(next_position);
                                next_position = temp_position;

                                 for (vector<Shape*>::iterator iter 
                                         = pv->v.begin();
                                     iter != pv->v.end();
                                     ++iter) 
                                    {
                                    
                                        shape_list.insert(next_position++, 
                                                          *iter);
                                        continue;

                                    }  /* |for|  */                           

                                    }    /* |else| (|pv != 0 && pv->ctr > 0|)  */

@q ********** (10) @>

                            }  /* |else| (|ivp.v != 0|)  */

@q ********* (9) @>       
                         
                     }  /* |else| (|status > 0|)  */

@q ******** (8) @> 

              }  /* Inner |for|.  */

@q ******* (7) @> 

         }  /* Outer |for|.  */

   }  /* End of group.  */

@q ****** (6).@> 
@
@<Define |Picture| functions@>=

@q ****** (6) Sort |shape_list|.@> 

@ Sort |shape_list|.
\initials{LDF 2005.04.04.}

@<Define |Picture| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`shape_list.size' == " << shape_list.size() << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

   for (list<Shape*>::iterator iter = shape_list.begin();
        iter != shape_list.end();
        ++iter)
      {
         (**iter).extract(f, projection, factor);
         (**iter).set_projective_extremes();
      }

#if DEBUG_COMPILE
   if (DEBUG)
     {
         if (sort_value == MIN_Z)
            {

               cerr << "Sorting by `MIN_Z'." << endl;
            }
       
         else if (sort_value == MAX_Z)
           {
               cerr << "Sorting by `MAX_Z'." << endl;
           }

         else if (sort_value == MEAN_Z)
            {
               cerr << "Sorting by `MEAN_Z'." << endl;
            }
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    if (sort_value == MIN_Z)
       {
          shape_list.sort(
             Compare_Minimum_Z<>());
       }
   
    else if (sort_value == MAX_Z)
      {
          shape_list.sort(Compare_Maximum_Z<>());
      }

    else if (sort_value == MEAN_Z)
       {
          shape_list.sort(Compare_Mean_Z<>());
       }

@q ****** (6)@> 
@
\LOG
\initials{LDF 2005.04.14.}
Added this section.
\ENDLOG

@<Define |Picture| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Picture::output':"
                  << endl 
                  << "Testing whether projections intersect.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   curr_position = shape_list.begin();
   next_position = shape_list.begin();
   ++next_position;

while (next_position != shape_list.end())

      {

@q ******* (7) @> 

          curr_shape = *curr_position;
          next_shape = *next_position;

          status = curr_shape->projections_intersect(next_shape);

#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                      cerr_strm << thread_name << "In `Picture::output':"
                                << endl << "`projections_intersect' "
                                << "returned " << status << ".";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");    
                   }           
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) @> 

          if (status == 2)
             {
                 
             }  /* |if (status == 2)| */

@q ******* (7) @> 

          else if (status == 1)
             {
                
#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                      curr_shape->show("curr_shape:", 'p', false, false);
                      next_shape->show("next_shape:", 'p', false, false);
                   }

#endif /* |DEBUG_COMPILE|  */@; 
 
             }  /* |if (status == 1)| */

@q ******* (7) @> 

          else if (status == 0)
             ;  /* Do nothing  */

@q ******* (7) @> 

         ++curr_position;
         ++next_position;

      }  /* |while|  */

@q ****** (6) Output |shape_list|.@> 

@ Output |shape_list|.
\initials{LDF 2005.04.04.}

@<Define |Picture| functions@>=

#if DEBUG_COMPILE
   valarray<real> temp_valarray(0.0, 6);
#endif /* |DEBUG_COMPILE|  */@;

   for (list<Shape*>::iterator iter = shape_list.begin();
        iter != shape_list.end();
        ++iter)
   {



#if DEBUG_COMPILE
         if (DEBUG)
            {
                temp_valarray = (**iter).get_projective_extremes();

                cerr << "projective extremes: (";
                for (int i = 0; i < 6; ++i)
                   cerr << temp_valarray[i] << ", ";

                cerr << ")" << endl;

#if 0 
                (**iter).show("**iter:", 'p', false, false);
#endif 
            }
#endif /* |DEBUG_COMPILE|  */@; 
 
        cerr << "Here I am 7." << endl;

         (**iter).output(scanner_node, output_command_arg);

        cerr << "Here I am 8." << endl;

         (**iter).unsuppress_output(); 

   }  /* |for|  */

@q ****** (6).@> 
@
\LOG
\initials{LDF 2005.04.18.}
Added this section.  Now deleting all pointers to |Shape| |s| on 
|shape_list|, where |s->decomposition_level > 0|, 
and then clearing |shape_list|.
\ENDLOG

@<Define |Picture| functions@>=

   for (list<Shape*>::iterator iter = shape_list.begin();
        iter != shape_list.end();
        ++iter)
      {
         if ((**iter).get_decomposition_level() > 0)
            {
               delete *iter;
            }       

      }  /* |for|  */

   shape_list.clear();

@q ****** (6)@> 

   }  /* |if (surface_hiding_value > 0)|  */

@q ***** (5) |surface_hiding_value == 0|.  Output.@> 
@ |surface_hiding_value == 0|.  Output.
\initials{LDF Undated.}

@<Define |Picture| functions@>=

   else  /* |surface_hiding_value == 0|  */
      {

          for(vector<Shape*>::iterator iter = elements.begin();
              iter != elements.end();
              ++iter)
             {
                 (**iter).output(scanner_node, output_command_arg);

@q ****** (6).@> 

@ With a different |Focus| or different limiting
values for the projection, this |Shape| might
be projectable, so we reset |do_output|
to |true|.  If it can't be projected the
next time, |suppress_output| will be 
invoked again.
\initials{LDF 2002.09.18.}

@<Define |Picture| functions@>=

                 (**iter).unsuppress_output(); 

@q ****** (6).@> 

             }  /* |for|  */

@q ***** (5).@> 

   }  /* |else|  */

  } /* |if (elements.size() > 0)|  */

@q **** (4) Output the labels.  @>   

@ Output the labels.  
It is necessary to output the labels last because they might otherwise
be drawn over by |fill| or |filldraw| commands. 
\initials{LDF Undated.} 

I'm not bothering to sort the labels so that the ones
behind can be hidden by the ones in front.  Labels should all be
visible and are not put into perspective, so they shouldn't overlay
one another.
\initials{LDF 2002.09.17.}  

Added following conditional. Sometimes it's irritating
to have the labels when a |Picture| is copied and transformed, and
both the original and the transformed versions are output. 
\initials{LDF 2002.04.25.}  

@<Define |Picture| functions@>= 

  if (do_labels == true)
  {

@q ***** (5).@> 

      for(vector<Label*>::iterator i = labels.begin();
          i != labels.end();
          ++i)
        {

@q ****** (6).@> 
@ This code applies |transform| to the |Point| |Label::pt|.
\initials{LDF 2002.04.25.}  

\LOG
\initials{LDF 2002.09.17.}  
Simplified the following code.
Formerly, there was a conditional here that 
chose which version of |Label::output| to call. 
I've removed the version without a |Transform| argument
and invoke |Transform::is_identity| in
|Label::output(const Focus&, const Transform&)|. 
\ENDLOG 

@<Define |Picture| functions@>= 

          (**i).output(scanner_node, output_command_arg, f, projection, factor, transform); 

@q ****** (6).@> 

        } /* |for|  */

@q ***** (5).@> 

  }  /* |if (do_labels == true) | */

@q **** (4) @>   
@
\LOG
\initials{LDF 2002.04.25.}  
Added following line.  This fixes a bug.  If I
don't reset |transform| to identity, it will be applied again
each time I output a |Picture|, which is not what I want. 
\ENDLOG 

@<Define |Picture| functions@>= 

   transform.reset();

@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Exiting `Picture::output'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

}  /* End of |Picture::output| definition.  */

@q * (1) |Point::output| definition.  @>
@ |Point::output| definition.
\initials{LDF 2022.04.15.}

\LOG
\initials{LDF 2022.04.15.}
Moved this function definition from \filename{points.web} to this file (\filename{pctfncs0.web}).
This was needed because it now refers to |namespace Scan_Parse|.
\ENDLOG 

@<Define |Point| functions@>=
void 
Point::output(Scanner_Node scanner_node, unsigned int output_command_arg) 
{
  bool DEBUG = true; /* |false| */

  bool local_do_metafont = 
     (metafont_output && (   output_command_arg & Scan_Parse::ENDCHAR_COMMAND
                          || output_command_arg & Scan_Parse::METAFONT_OUTPUT_COMMAND))
     ? true : false;

  bool local_do_metapost = 
     (metapost_output && (   output_command_arg & Scan_Parse::ENDFIG_COMMAND
                          || output_command_arg & Scan_Parse::METAPOST_OUTPUT_COMMAND))
     ? true : false;

  if (DEBUG)
  {
      cerr << "Entering Point::output." << endl;

      cerr << "output_command_arg == " << output_command_arg << endl;
      cerr << "local_do_metafont == " << local_do_metafont << endl;
      cerr << "local_do_metapost == " << local_do_metapost << endl;


  }

  if (!(local_do_metafont || local_do_metapost))
  {
      cerr << "WARNING!  In `Point::output':  Returning." << endl;

      return;
  }

  Output_Struct* os_mf = 0;
  Output_Struct* os_mp = 0;

  ofstream* out_stream_mf  = 0;
  ofstream* out_stream_mp  = 0;

  if (local_do_metafont) 
  {
     os_mf = scanner_node->out[Run_State::METAFONT_RS];
     out_stream_mf  = static_cast<ofstream*>(os_mf->stream_ptr);
  }
  if (local_do_metapost) 
  {
     os_mp = scanner_node->out[Run_State::METAPOST_RS];
     out_stream_mp  = static_cast<ofstream*>(os_mp->stream_ptr);
  }

@q **** (4) |drawdot| or |undrawdot|.  @>
@ |drawdot| or |undrawdot|. 

\LOG
\initials{LDF 2004.08.17.}
@:BUG FIX@> BUG FIX: 
Now writing ``{\bf undrawdot}'' to |*out_stream| when 
|(drawdot_value == UNDRAWDOT_VALUE)|.  Formerly, 
``{\bf drawdot}'' was written.
\ENDLOG 
@<Define |Point| functions@>=

  if (drawdot_value == DRAWDOT_VALUE)
  {

#if 0 
       cerr << "Here I am 10." << endl; 

       cerr << "local_do_metafont == " << local_do_metafont << endl;

       cerr << "(out_stream_mf == 0) == " << (out_stream_mf == 0) << endl;
#endif 


       if (local_do_metafont)
          *out_stream_mf << "drawdot ";
 
       if (local_do_metapost)
          *out_stream_mp << "drawdot ";
  }

  else if (drawdot_value == UNDRAWDOT_VALUE)
  {
    if (local_do_metafont)
       *out_stream_mf << "undrawdot ";

    if (local_do_metapost)
       *out_stream_mp << "undrawdot ";

  }

  else  /* Invalid |DRAWDOT_VALUE|.  */      
  {
      cerr << "WARNING! Invalid |drawdot_value|: "
        << drawdot_value << ". Using \"drawdot\"\n";

      if (scanner_node->get_run_state()->error_stop_mode == Run_State::STOPPING)
        {
          cerr << "In `Point::output':  Type <RETURN> to continue.\n";

          getchar();  /* Don't delete this!  */@;  
        } 

      if (local_do_metafont)
         *out_stream_mf << "drawdot ";

      if (local_do_metapost)
         *out_stream_mp << "drawdot ";

  } /* |else| (invalid |DRAWDOT_VALUE|.)  */@;      

  if (local_do_metafont)
     *out_stream_mf << "(" << projective_coordinates[0]
                    << measurement_units
                    << ", " << projective_coordinates[1]
                    << measurement_units << ")";

  if (local_do_metapost)
     *out_stream_mp << "(" << projective_coordinates[0]
                    << measurement_units
                    << ", " << projective_coordinates[1]
                    << measurement_units << ")";

@q **** (4) Handle |Color|.  @>
@ Handle |Color|.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.03.17.}
Now outputting |*(draw_color_vector->v[0])|, if 
|draw_color_vector != 0 && draw_color_vector->ctr > 0|.  
Formerly, I output |*drawdot_color|, 
but I've removed |drawdot_color|.
\ENDLOG

@<Define |Point| functions@>=

  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) && draw_color_vector->ctr > 0)
  {
    if (local_do_metafont)
    ; /* Do nothing */

    if (local_do_metapost)
       *out_stream_mp << endl << "   withcolor " << *(draw_color_vector->v[0]);
  }

@q **** (4) Handle |pen_vector|.@>
@ Handle |pen_vector|.

\LOG
\initials{LDF 2005.03.17.}
Now handling |Pointer_Vector<Pen>* Point::pen_vector| instead 
of |Pen* Point::pen|, which I've removed.
\ENDLOG 

@<Define |Point| functions@>=

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
    {

       Pen* pen = pen_vector->v[0]; 
       unsigned short pen_type = pen->get_type();
 
       if (local_do_metafont)
          *out_stream_mf << endl << "   ";
     
      if (local_do_metapost) 
         *out_stream_mp << endl << "   ";

      if (pen_type == Pen::CIRCLE_PEN)
        {
          if (local_do_metafont)
             *out_stream_mf << "withpen pencircle";
 
          if (local_do_metapost)
             *out_stream_mp << "withpen pencircle";

        }
      else if (pen_type == Pen::RAZOR_PEN)
        {
          if (local_do_metafont)
             *out_stream_mf << " withpen penrazor";
      
          if (local_do_metapost)
             *out_stream_mp << " withpen penrazor";
        }

      else if (pen_type == Pen::SPECK_PEN)
        {
          if (local_do_metafont)
             *out_stream_mf << " withpen penspeck";
   
          if (local_do_metapost)
             *out_stream_mp << " withpen penspeck";
        }

      else if (pen_type == Pen::SQUARE_PEN)
        {
          if (local_do_metafont)
             *out_stream_mf << " withpen pensquare";
          if (local_do_metapost)
             *out_stream_mp << " withpen pensquare";
        }
      else /* Invalid |pen->type|.  */
        {
          cerr << "ERROR! In Point::output():\n"
               << "Invalid Pen type: " << pen_type
               << endl << "Not specifying pen and will try to "
               << "continue.\n";
          
          if (scanner_node->get_run_state()->error_stop_mode 
              == Run_State::STOPPING)
            {
              cerr << "In `Point::output':  Type <RETURN> to continue.\n";

              getchar();  /* Don't delete this!  */@;  
            } 

          if (local_do_metafont)
             *out_stream_mf << ";\n";
    
          if (local_do_metapost)
             *out_stream_mp << ";\n";

          return;
          
        } /* |else| (invalid |pen->type|).  */

@q ***** (5) Handle |pen->transform|.@>   
@ Handle |pen->transform|.
\initials{LDF 2004.09.08.}

\LOG
\initials{LDF 2004.09.08.}
@:BUG FIX@> BUG FIX:  Fixed the way the 3DLDF's three-dimensional
transformation matrix is converted to {\MF/}/{\MP/}'s 
two-dimensional one.

\initials{LDF 2005.06.24.}
@:BUG FIX@> BUG FIX:  Now appending |"cm"| to the numbers output 
for the transformation. 

\initials{LDF 2021.12.15.}
@:BUG FIX@> BUG FIX:  Removed the conditional |if (!t.is_identity())|:
This failed when the |Pen| was scaled by |(1cm, 1cm, 1cm)|.
\ENDLOG 

@<Define |Point| functions@>=

      Transform t = pen->get_transform();

      if (local_do_metafont)
         *out_stream_mf << " transformed"
                        << endl << "begingroup; save T; transform T;" 

                        << endl << "xxpart T = " 
                        << t.get_element(0, 0) << "cm;"
                        << endl << "xpart T = " 
                        << t.get_element(3, 0) << "cm;"
                        << endl << "xypart T = " 
                        << t.get_element(1, 0) << "cm;"

                        << endl << "yypart T = " 
                        << t.get_element(1, 1) << "cm;"
                        << endl << "ypart T = " 
                        << t.get_element(3, 1) << "cm;"
                        << endl << "yxpart T = " 
                        << t.get_element(0, 1) << "cm;"

                        << endl << "T endgroup" << endl;

      if (local_do_metapost)
         *out_stream_mp << " transformed"
                        << endl << "begingroup; save T; transform T;" 

                        << endl << "xxpart T = " 
                        << t.get_element(0, 0) << "cm;"
                        << endl << "xpart T = " 
                        << t.get_element(3, 0) << "cm;"
                        << endl << "xypart T = " 
                        << t.get_element(1, 0) << "cm;"

                        << endl << "yypart T = " 
                        << t.get_element(1, 1) << "cm;"
                        << endl << "ypart T = " 
                        << t.get_element(3, 1) << "cm;"
                        << endl << "yxpart T = " 
                        << t.get_element(0, 1) << "cm;"

                        << endl << "T endgroup" << endl;

    }  /* |if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)|  */

@q **** (4) Finish and exit function.  @>
@ Finish and exit function.

@<Define |Point| functions@>=

  if (local_do_metafont)
     *out_stream_mf << ";\n" << flush;
  
  if (local_do_metapost)
     *out_stream_mp << ";\n" << flush;

#if DEBUG_COMPILE
  if (DEBUG)
  { 
     cerr << "Exiting Point::output." << endl;
  }  
#endif /* |DEBUG_COMPILE|  */@; 

  return;

} /* End of |Point::output| definition  */

@q * (1) |Label::output| definition.  @>
@ |Label::output| definition.
@^\cfunc{Label}{output}@>

This function is declared in \filename{pictures.web}.  It must be defined here because 
|Point| is an incomplete type in that file and because it refers to 
|namespace Scan_Parse|.
\initials{LDF 2022.04.15.}

\LOG 
\initials{LDF 2002.10.23.}  
Added arguments |proj| and |factor|.

\initials{LDF 2004.05.25.}  
Added |Scanner_Node| argument.  Changed 
|out_stream| from a global |ofstream| to an |ofstream*|.  It's now set
using the |Scanner_Node| argument.

\initials{LDF 2005.01.31.}
Now outputting code for |text_color| and |dot_color|.

\initials{LDF 2005.08.14.}
Now outputting code for transforming the text, if |transform != 0|.

\initials{LDF 2005.12.09.}
Added code for outputting |*pen|, if |dot == true| and |Pen* pen| is non-null.

\initials{2008.12.30.}
@:BUG FIX@> BUG FIX:  Now outputting a newline after the semi-colon.

\initials{LDF 2022.04.15.}
Moved this function definition from \filename{points.web} to this file (\filename{pctfncs0.web})
because it now refers to |namespace Scan_Parse|.
\ENDLOG 

@<Define |Label| functions@>=
void
Label::output(Scanner_Node s,
              unsigned int output_command_arg,
              const Focus& f,
              const unsigned short proj,
              real factor,
              const Transform& t)
{
@q ** (2) @>

  bool local_do_metafont = 
     (metafont_output && (   output_command_arg & Scan_Parse::ENDCHAR_COMMAND
                          || output_command_arg & Scan_Parse::METAFONT_OUTPUT_COMMAND))
     ? true : false;

  bool local_do_metapost = 
     (metapost_output && (   output_command_arg & Scan_Parse::ENDFIG_COMMAND
                          || output_command_arg & Scan_Parse::METAPOST_OUTPUT_COMMAND))
     ? true : false;

   Output_Struct* os_mf;
   Output_Struct* os_mp;

   ofstream* out_stream_mf  = 0;
   ofstream* out_stream_mp  = 0;

   if (local_do_metafont)
   {
      os_mf = s->out[Run_State::METAFONT_RS];
      out_stream_mf  = static_cast<ofstream*>(os_mf->stream_ptr);
   }
   if (metapost_output)
   {
      os_mp = s->out[Run_State::METAPOST_RS];
      out_stream_mp  = static_cast<ofstream*>(os_mp->stream_ptr);
   }
   
   if (!t.is_identity())
     *pt *= t;

   pt->apply_transform();
   if(!pt->project(f, proj, factor))
     {
       cerr << "WARNING! In Label::output():\n"
            << "Point in Label cannot be projected! "
            << "Not printing Label\n";
       return;
     }  

   if (local_do_metafont)
      *out_stream_mf << "makelabel";
   
   if (metapost_output)
      *out_stream_mp << "label";
   
   if (position != "")
   {
     *out_stream_mf << "." << position;
     *out_stream_mp << "." << position;
   }
   
   if (local_do_metafont)
   {
      *out_stream_mf << "(\"" << text << "\"";
   }
   if (metapost_output)
      *out_stream_mp << "(btex " << text << " etex ";

     if (transform && !transform->is_identity())
     {

        if (local_do_metafont)
           *out_stream_mf << " transformed "
                          << "begingroup; save T; transform T;"
                          << endl  
                          << " xxpart T = " 
                          << transform->get_element(0, 0) << "; "
                          << "xpart T = "                                   
                          << transform->get_element(3, 0) << "; "
                          << "xypart T = "                                 
                          << transform->get_element(1, 0) << "; " 
                          << endl                                                   
                          << " yypart T = "                               
                          << transform->get_element(1, 1) << "; "
                          << "ypart T = "                                   
                          << transform->get_element(3, 1) << "; "
                          << "yxpart T = "                                 
                          << transform->get_element(0, 1) << "; "
                          << "T endgroup ";

        if (metapost_output)
           *out_stream_mp << " transformed "
                          << "begingroup; save T; transform T;"
                          << endl  
                          << " xxpart T = " 
                          << transform->get_element(0, 0) << "; "
                          << "xpart T = "                                   
                          << transform->get_element(3, 0) << "; "
                          << "xypart T = "                                 
                          << transform->get_element(1, 0) << "; " 
                          << endl                                                   
                          << " yypart T = "                               
                          << transform->get_element(1, 1) << "; "
                          << "ypart T = "                                   
                          << transform->get_element(3, 1) << "; "
                          << "yxpart T = "                                 
                          << transform->get_element(0, 1) << "; "
                          << "T endgroup ";

     } /* |if (transform && !transform->is_identity())|  */@;

   *out_stream_mf << ", ("
               << pt->get_x('p', false)
               << Point::measurement_units << ", "
               << pt->get_y('p', false)
               << Point::measurement_units << "))";

   *out_stream_mp << ", ("
               << pt->get_x('p', false)
               << Point::measurement_units << ", "
               << pt->get_y('p', false)
               << Point::measurement_units << "))";

   if (text_color && metapost_output)
      *out_stream_mp << endl << " withcolor " << *text_color;

   *out_stream_mf << ";" << endl;
   *out_stream_mp << ";" << endl;

   if (dot == true)
   {
      *out_stream_mf << "begingroup" << endl; 
      *out_stream_mp << "begingroup" << endl; 

      if (metapost_output)
         *out_stream_mp << "interim linecap := rounded;";

      *out_stream_mf << endl
                     << "drawdot (" 
                     << pt->get_x('p', false)
                     << Point::measurement_units << ", "
                     << pt->get_y('p', false)
                     << Point::measurement_units << ")";

      *out_stream_mp << endl
                     << "drawdot (" 
                     << pt->get_x('p', false)
                     << Point::measurement_units << ", "
                     << pt->get_y('p', false)
                     << Point::measurement_units << ")";

        if (pen)
        {
           *out_stream_mf << " withpen " << *pen;
           *out_stream_mp << " withpen " << *pen;
        }
        else if (!local_do_metafont)
        {
           *out_stream_mf << " withpen pencircle scaled dotlabeldiam";
           *out_stream_mp << " withpen pencircle scaled dotlabeldiam";
        }
        else if (local_do_metafont)
        {
           *out_stream_mf << " withpen pencircle scaled 3pt";
           *out_stream_mp << " withpen pencircle scaled 3pt";
        }
      
      if (metapost_output && dot_color)
         *out_stream_mp << " withcolor " << *dot_color;

      *out_stream_mf << ";" << "endgroup;" << endl;
      *out_stream_mp << ";" << "endgroup;" << endl;
     
   } /* |if (dot == true)|  */

@q ** (2) @>

   return;

}  /* End of |Label::output| definition.  */

@q * (1) |Path::output| definition.  @>
@ |Path::output| definition.
\initials{LDF 2022.04.15.}

\LOG
\initials{LDF 2022.04.15.}
Moved this function definition from \filename{paths.web} to this file (\filename{pctfncs0.web}).
This was needed because it now refers to |namespace Scan_Parse|.
\ENDLOG 

@q ** (2) @>


@<Define |Path| functions@>=
void
Path::output(Scanner_Node scanner_node, unsigned int output_command_arg)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG) 
      {
          cerr_strm << thread_name << "Entering `Path::output'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

  bool local_do_metafont = 
     (metafont_output && (   output_command_arg & Scan_Parse::ENDCHAR_COMMAND
                          || output_command_arg & Scan_Parse::METAFONT_OUTPUT_COMMAND))
     ? true : false;

  bool local_do_metapost = 
     (metapost_output && (   output_command_arg & Scan_Parse::ENDFIG_COMMAND
                          || output_command_arg & Scan_Parse::METAPOST_OUTPUT_COMMAND))
     ? true : false;

   if (!(local_do_metafont || local_do_metapost))
   {
       cerr << "In `Path::output':  `local_do_metafont' and `local_do_metapost' are both `false'."
            << endl 
            << "Not outputting.  Exiting function with void return value."
            << endl;
      
       return;
   }

@q **** (4) @>

   Output_Struct* os_mf;
   Output_Struct* os_mp;

   ofstream* out_stream_mf  = 0;
   ofstream* out_stream_mp  = 0;

   if (local_do_metafont)
   {
      os_mf = scanner_node->out[Run_State::METAFONT_RS];
      out_stream_mf  = static_cast<ofstream*>(os_mf->stream_ptr);
   }
   if (local_do_metapost)
   {
      os_mp = scanner_node->out[Run_State::METAPOST_RS];
      out_stream_mp  = static_cast<ofstream*>(os_mp->stream_ptr);
   }

   if (do_output == false)
   {

#if DEBUG_COMPILE
      if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "In `Path::output': "
                    << "`do_output' == `false'. Returning.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 
  
      return;

   } /* |if (do_output == false)|  */

@q **** (4) @>   
@  
\LOG
\initials{LDF 2002.09.27.}  
Added this error handling code.  If the |Path|
is empty, don't output it.  
This code should never be reached, because the case of a |Path|
containing no |Points| should be caught in |Path::draw| and the
other drawing and filling commands. 
If it should reach |set_projective_extremes| and |Picture::output|, which
also shouldn't be possible, they would  catch it, too.  
\ENDLOG 

@<Define |Path| functions@>=

  if (points.size() == 0)
    {
        cerr_strm << thread_name << "WARNING!  In `Path::output':"
                  << endl 
                  << "`*this' doesn't contain any Points."
                  << endl 
                  << "This code should never be reached, " 
                  << "but it may be possible to recover.";
         
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return;
    }  /* |if (points.size() == 0)|  */

@q **** (4) @>   
@
@<Define |Path| functions@>=

  vector <Point*>::iterator point_iter = points.begin();

  vector <Connector_Type*>::iterator connector_type_iter = connector_type_vector.begin();

@q **** (4) Draw.@>
@ Draw.

\LOG
\initials{LDF 2004.11.07.}
Revised the code that checks the value of |arrow|.
\ENDLOG 

@<Define |Path| functions@>=

    if (fill_draw_value == DRAW_VALUE) 
    {
@q ***** (5) @>

#if DEBUG_COMPILE

        if (DEBUG)
        {
            cerr_strm << thread_name 
                      << "In `Path::output':  Drawing.";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

         
        status = sub_output_draw(scanner_node, 
                                 out_stream_mf, 
                                 out_stream_mp, 
                                 output_command_arg);
        if (status != 0)
        {
              cerr_strm << thread_name 
                        << "ERROR!  In `Path::output':  "
                        << "`sub_output_draw' failed, returning "
                        << status << "."
                        << "Exiting function.";
  
              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");
           
              return;

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `Path::output':  "
                       << "`sub_output_draw' succeeded.";
  
             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");
        }        
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

    } /* |if (fill_draw_value == DRAW_VALUE)|  */

@q **** (4) Fill.@>

@ Fill.

@<Define |Path| functions@>=

    else if (fill_draw_value == FILL_VALUE) 
      {
#if DEBUG_COMPILE
        if (DEBUG)
          {
              cerr_strm << thread_name 
                        << "In `Path::output':  "
                        << "Filling.";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 

          if (local_do_metafont)
          {
             *out_stream_mf << "fill " << **point_iter++;
             output_path(out_stream_mf);
          }

          if (local_do_metapost)
          {
             *out_stream_mp << "fill " << **point_iter++;
             output_path(out_stream_mp);
          }

          if (   local_do_metapost && fill_color_vector != static_cast<Pointer_Vector<Color>*>(0)
              && fill_color_vector->ctr > 0)
            *out_stream_mp << " withcolor " << *(fill_color_vector->v[0]);

        if (local_do_metafont)
           *out_stream_mf << ";" << endl << flush;
        if (local_do_metapost)
           *out_stream_mp << ";" << endl << flush;

    }  /* |else if (fill_draw_value == FILL_VALUE) |  */

@q **** (4) Filldraw.@>

@ Filldraw.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.03.14.}
Modified this code to handle the case that 
|draw_color_vector != 0 && draw_color_vector.size() > 0|.
\ENDLOG 

@<Define |Path| functions@>=

    else if (fill_draw_value == FILLDRAW_VALUE) 
    {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  "
                         << "Filldrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 
      
@q ***** (5).@> 
  
@
\LOG
Now setting defaults for |*fill_color|, if |fill_color == 0|.
\ENDLOG 

@<Define |Path| functions@>=

              if (local_do_metafont)
              {
                 *out_stream_mf << "fill " << **point_iter++;
                 output_path(out_stream_mf);
              }

              if (local_do_metapost)
              {
                 *out_stream_mp << "fill " << **point_iter++;
                 output_path(out_stream_mp);
              }

              Id_Map_Entry_Node entry;
              void* v = 0;

@q ***** (5) @>

              if (local_do_metapost)
              {
@q ****** (6) @>

                  Color* temp_color;

                  if (   fill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                      && fill_color_vector->ctr > 0)
                  {
                    temp_color = fill_color_vector->v[0];
                  }
                  else 
                     temp_color = 0;
            
                  if (temp_color == static_cast<Color*>(0))
                  {
                      entry = scanner_node->lookup("background_color");
              
                      if (entry != static_cast<Id_Map_Entry_Node>(0))
                         v = entry->get_object();         

                      if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                          && v != static_cast<void*>(0))
                      {
                         temp_color = static_cast<Color*>(v);
                      }
                      else 
                         temp_color = const_cast<Color*>(&Colors::white);

                  }  /* |if (temp_color == 0)|  */

                  void* v = 0;

              }  /* |if (local_do_metapost)| */

@q ***** (5) @>
@
@<Define |Path| functions@>=

              if (local_do_metafont)
                 output_path(out_stream_mf);
              if (local_do_metapost)
                 output_path(out_stream_mp);

              v = 0;

@q ***** (5) @>
@
@<Define |Path| functions@>=


              status = sub_output_draw(scanner_node, 
                                       out_stream_mf, 
                                       out_stream_mp, 
                                       output_command_arg);

              if (status != 0)
              {
                    cerr_strm << thread_name 
                              << "ERROR!  In `Path::output':  "
                              << "`sub_output_draw' failed, returning "
                              << status << "."
                              << "Exiting function.";
  
                    log_message(cerr_strm);
                    cerr_message(cerr_strm, error_stop_value);
                    cerr_strm.str("");
                 
                    return;

              }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
              else if (DEBUG)
              {
                  cerr_strm << thread_name 
                            << "In `Path::output':  "
                            << "`sub_output_draw' succeeded.";
  
                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
              }        
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5).@> 

    } /* |else if (fill_draw_value == FILLDRAW_VALUE)|  */

@q **** (4) Undraw.@>
@ Undraw.
@<Define |Path| functions@>=

    else if (fill_draw_value == UNDRAW_VALUE) 
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  "
                         << "Undrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           } 
#endif /* |DEBUG_COMPILE| */@;

          if (local_do_metafont)
          {
             *out_stream_mf << "undraw " << **point_iter++;
             output_path(out_stream_mf);
          }

          if (local_do_metapost)
          {
             *out_stream_mp << "undraw " << **point_iter++;
             output_path(out_stream_mp);
          }

          if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
          {

             if (local_do_metafont)
                *out_stream_mf << endl << "withpen " << *(pen_vector->v[0]);
             if (local_do_metapost)
                *out_stream_mp << endl << "withpen " << *(pen_vector->v[0]);

          } /* |if (pen_vector != 0 && pen_vector->ctr > 0)|  */

          if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
              && dash_pattern_vector->ctr > 0)
            {
                if (local_do_metapost)
                   *out_stream_mp << endl << *(dash_pattern_vector->v[0]);

            } /* |if (dash_pattern_vector != 0 && dash_pattern_vector->ctr > 0)|  */

         if (local_do_metafont)
            *out_stream_mf << ";\n" << flush;
         if (local_do_metapost)
            *out_stream_mp << ";\n" << flush;

  } /* |else if (fill_draw_value == UNDRAW_VALUE)|  */

@q **** (4) Unfill.@>
@ Unfill.
@<Define |Path| functions@>=

    else if (fill_draw_value == UNFILL_VALUE) 
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  " 
                         << "Unfilling.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 
   
          if (local_do_metafont)     
          {
             *out_stream_mf << "unfill " << **point_iter++;
             output_path(out_stream_mf);
             *out_stream_mf << ";\n" << flush;
          }
          if (local_do_metapost)
          {
             *out_stream_mp << "unfill " << **point_iter++;
             output_path(out_stream_mp);
             *out_stream_mp << ";\n" << flush;
          }

      }  /* |else if (fill_draw_value == UNFILL_VALUE)|  */

@q **** (4) Unfilldraw.@>
@ Unfilldraw.

\LOG
\initials{LDF 2003.03.25.}  
Changed this section, so that the outline of the
|Path| is drawn, if |draw_color != Colors::background_color|.  

\initials{LDF 2004.06.07.}
Changed |if (draw_color == Colors::background_color)| to 
|if (draw_color == 0)| below, because I've gotten rid of
|Colors::background_color|.
\ENDLOG 

@<Define |Path| functions@>=

    else if (fill_draw_value == UNFILLDRAW_VALUE)
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name << "In `Path::output':  "
                         << "Unfilldrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5).@> 

          if (   draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
              || draw_color_vector->v.size() == 0)
            {

                *out_stream_mf << "unfilldraw " << **point_iter++;

                if (local_do_metafont)
                {
                   *out_stream_mf << "unfilldraw " << **point_iter++;
                   output_path(out_stream_mf);
                }
                if (local_do_metapost)
                {
                   *out_stream_mp << "unfilldraw " << **point_iter++;
                   output_path(out_stream_mp);
                }

                if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
                {

                   if (local_do_metafont)
                      *out_stream_mf << endl << "withpen " << *(pen_vector->v[0]);
                   if (local_do_metapost)
                      *out_stream_mp << endl << "withpen " << *(pen_vector->v[0]);

                } /* |if (pen_vector != 0 && pen_vector->ctr > 0)|  */

                
                if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                    && dash_pattern_vector->ctr > 0)
                  {
                      if (local_do_metapost)
                         *out_stream_mp << endl << *(dash_pattern_vector->v[0]);

                  } /* |if (dash_pattern_vector != 0 && dash_pattern_vector->ctr > 0)|  */

                if (local_do_metafont)                
                   *out_stream_mf << ";\n" << flush;
                if (local_do_metapost)
                   *out_stream_mp << ";\n" << flush;
            }

@q ***** (5).@> 
@
\LOG
\initials{LDF 2005.03.14.}
Now calling |Path::sub_output_draw|.
\ENDLOG 

@<Define |Path| functions@>=

          else  /* |   draw_color_vector != 0 
                    && draw_color_vector->v.size() != 0|  */
            {
@q ****** (6) @>
                if (local_do_metafont)
                   *out_stream_mf << "unfill " << **point_iter;
                if (local_do_metapost)
                   *out_stream_mp << "unfill " << **point_iter;

                   **point_iter++;

                if (local_do_metafont)
                {
                   output_path(out_stream_mf);
                   *out_stream_mf << ";" << endl << flush;
                }
                if (local_do_metapost)
                {
                   output_path(out_stream_mp);
                   *out_stream_mp << ";" << endl << flush;
                }

                status = sub_output_draw(scanner_node, 
                                         out_stream_mf, 
                                         out_stream_mp, 
                                         output_command_arg);

@q ******* (7) @>

                if (status != 0)
                {
                      cerr_strm << thread_name 
                                << "ERROR!  In `Path::output':  "
                                << "`sub_output_draw' failed, returning "
                                << status << "."
                                << "Exiting function.";
  
                      log_message(cerr_strm);
                      cerr_message(cerr_strm, error_stop_value);
                      cerr_strm.str("");
                   
                      return;

                }  /* |if (status != 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
                else if (DEBUG)
                {
                    cerr_strm << thread_name 
                              << "In `Path::output':  "
                              << "`sub_output_draw' succeeded.";
  
                    log_message(cerr_strm);
                    cerr_message(cerr_strm);
                    cerr_strm.str("");
                }        
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) @>

            }    /* |else| (|   draw_color_vector != 0 
                             && draw_color_vector->v.size() != 0|)  */

      } /* End of |UNFILLDRAW_VALUE| case.  */

@q **** (4) Invalid |fill_draw_value|:  Signal an error and return.@>
@ Invalid |fill_draw_value|:  Signal an error and return.
\initials{LDF 2005.03.13.}

\LOG
\initials{LDF 2004.11.07.}
Revised the code that checks the value of |arrow|.

\initials{LDF 2005.03.13.}
Now signalling an error and returning.  Previously, |*this| was drawn.  
\ENDLOG 

@<Define |Path| functions@>=

    else 
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Path::output':"
                    << endl 
                    << "Invalid `fill_draw_value':  "
                    << fill_draw_value << "."
                    << endl << "Not drawing or filling `Path'.  "
                    << "Exiting function.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return;

      }  /* |else| (Invalid |fill_draw_value|)  */

@q **** (4) Return.@>
@ Return.

@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG) 
      {
          cerr_strm << thread_name << "Exiting `Path::output'.";
 
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

    return;

} /* End of |Path::output(Scanner_Node scanner_node)| definition.  */

@q * (1) |Path::sub_output_draw|.  @>
@ |Path::sub_output_draw|.  

\LOG
\initials{LDF 2022.04.15.}
Moved this function definition from \filename{paths.web} to this file (\filename{pctfncs0.web}).
This was necessary because it now refers to |Scan_Parse::ENDCHAR_COMMAND| and 
|Scan_Parse::ENDFIG_COMMAND|.
\ENDLOG 

@<Define |Path| functions@>=
int
Path::sub_output_draw(Scanner_Node scanner_node, 
                      ofstream* out_stream_mf, 
                      ofstream* out_stream_mp, 
                      unsigned int output_command_arg)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  bool local_do_metafont = 
     (  metafont_output && out_stream_mf != 0 
      && (   output_command_arg & Scan_Parse::ENDCHAR_COMMAND
          || output_command_arg & Scan_Parse::METAFONT_OUTPUT_COMMAND))
     ? true : false;

  bool local_do_metapost = 
     (   metapost_output && out_stream_mp != 0 
      && (   output_command_arg & Scan_Parse::ENDFIG_COMMAND
          || output_command_arg & Scan_Parse::METAPOST_OUTPUT_COMMAND))
     ? true : false;

   if (!(local_do_metafont || local_do_metapost))
   {
      return 0;
   }

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;

@q ***** (5).@> 
@
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Entering `Path::sub_output_draw'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    vector<string>::const_iterator connector_iter;
    vector<Connector_Type*>::const_iterator connector_type_iter;

    string connector_string;

@q ***** (5).@>

@
\LOG
\initials{LDF 2005.03.18.}
Now testing that |*this| is of a type consisting of straight lines,
i.e., |POLYGON|, |TRIANGLE|, |RECTANGLE|, or |REG_POLYGON|.
This code won't work for curved |Paths| yet.

\initials{LDF 2005.03.18.}
Added code for handling |pen_vector| and |dash_pattern_vector|.

\initials{LDF 2005.03.19.}
Changed this conditional, so that |draw_color_vector->ctr|, 
|pen_vector->ctr|, or |dash_pattern_vector->ctr| must 
be greater than 1.  Previously, they had to be greater than 0.

\initials{LDF 2005.04.05.}
Added code for suppressing output if the type of the current 
|Pen| is |Pen::NULL_PEN|.
\ENDLOG 

@<Define |Path| functions@>=

        if (    (   shape_type == POLYGON_TYPE 
                 || shape_type == TRIANGLE_TYPE 
                 || shape_type == RECTANGLE_TYPE 
                 || shape_type == REG_POLYGON_TYPE)
             && (  (    draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                    && draw_color_vector->ctr > 1)
                 || (   pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
                     && pen_vector->ctr > 1)
                 || (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                     && dash_pattern_vector->ctr > 1))
           )

        {
#if DEBUG_COMPILE
               if (DEBUG)
                 {
                     cerr_strm << thread_name 
                               << "In `Path::sub_output_draw':"
                               << endl 
                               << "`At least one vector is non-empty.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str("");   
                 }         
#endif /* |DEBUG_COMPILE|  */@; 
  
               vector<Color*>::const_iterator color_iter;
               vector<Pen*>::const_iterator pen_iter;
               vector<Dash_Pattern*>::const_iterator dash_pattern_iter;

               bool do_colors;
               bool do_pens;
               bool do_dash_patterns;

@q ****** (6).@> 

              if (local_do_metafont)
                 do_colors = false;
              else
              {             
                  status = adjust_draw_color_vector();

                  if (status == 0)
                  {
                      color_iter = draw_color_vector->v.begin();
                      do_colors = true;
                  }
                  else
                     do_colors = false;
              }

@q ****** (6).@> 

               status = adjust_pen_vector();

               if (status == 0)
                  {
                     pen_iter = pen_vector->v.begin();
                     do_pens = true;
                  }
               else
                  do_pens = false;

               status = adjust_dash_pattern_vector();

               if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                   && dash_pattern_vector->ctr > 0)
               {
                   dash_pattern_iter = dash_pattern_vector->v.begin();
                   do_dash_patterns = true;
               }
               else
                  do_dash_patterns = false;

               adjust_connectors();
             
               connector_type_iter = connector_type_vector.begin();

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr << "`do_pens' == " << do_pens
                           << endl;

                      if (do_pens && pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
                         cerr << "`pen_vector->v.size' == " 
                              << pen_vector->v.size()
                              << endl;

                      cerr << "`do_dash_patterns' == " << do_dash_patterns
                           << endl;

                      if (do_dash_patterns && dash_pattern_vector 
                             != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
                         cerr << "`dash_pattern_vector->v.size' == " 
                              << dash_pattern_vector->v.size()
                              << endl;
                  }            
#endif /* |DEBUG_COMPILE|  */@;

@q ****** (6) Draw the first segment.@> 

@ Draw the first segment.  
If |points.size() == 1| no connector is used in the {\bf draw} command, 
and this functions returns after writing it to |*out_stream_mf| and/or |*out_stream_mp|.
In addition, the first segment also requires special handling if |arrow == DOUBLE_ARROW|. 
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

@q ******* (7) @> 

               if (   (arrow == DOUBLE_ARROW && points.size() == 1)
                   && (   !do_pens 
                       || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))  
               {

                  if (local_do_metafont)
                     *out_stream_mf << "drawarrow " << *points[0];
                  if (local_do_metapost)
                     *out_stream_mp << "drawarrow " << *points[0];

                  if (local_do_metapost && do_colors)
                     *out_stream_mp << "withcolor " << **color_iter;

                  if (do_pens)
                  {
                     if (local_do_metafont)
                        *out_stream_mf << " withpen " << **pen_iter;
                     if (local_do_metapost)
                        *out_stream_mp << " withpen " << **pen_iter;
                  }


                  if (do_dash_patterns)
                  {
                     if (local_do_metapost)
                        *out_stream_mp << **dash_pattern_iter;

                  }

                   if (local_do_metafont)
                      *out_stream_mf << ";" << endl << flush;
                   if (local_do_metapost)
                      *out_stream_mp << ";" << endl << flush;

                   return 0; 

                  }

@q ******* (7).@> 

               else if (   (arrow == DOUBLE_ARROW && points.size() > 1)
                        && (   !do_pens 
                            || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))

               {
                   if (local_do_metafont)
                      *out_stream_mf << "drawarrow " << *points[1] 
                                  << **connector_type_iter << *points[0]; 
                                     
                   if (local_do_metapost)
                      *out_stream_mp << "drawarrow " << *points[1] 
                                     << **connector_type_iter << *points[0]; 

                   if (local_do_metapost && do_colors)
                      *out_stream_mp << endl << "withcolor " << **color_iter;

                   if (do_pens)
                   {
                      if (local_do_metafont)
                         *out_stream_mf << endl << "withpen " << **pen_iter;
                      if (local_do_metapost)
                         *out_stream_mp << endl << "withpen " << **pen_iter;
                   }


                   if (do_dash_patterns)
                   {
                      if (local_do_metapost)
                         *out_stream_mp << endl << **dash_pattern_iter;
                   }

                   if (local_do_metafont)
                      *out_stream_mf << ";" << endl << flush;
                   if (local_do_metapost)
                      *out_stream_mp << ";" << endl << flush;

               }  

@q ******* (7).@>              

               else if (   (arrow != DOUBLE_ARROW && points.size() == 1)
                        && (   !do_pens 
                            || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))  
                  {
                      if (local_do_metafont)
                         *out_stream_mf << "draw " 
                                        << *points[0];
                      if (local_do_metapost)
                         *out_stream_mp << "draw " 
                                        << *points[0];

                      if (local_do_metapost && do_colors)
                         *out_stream_mp << " withcolor " << **color_iter;

                      if (do_pens)
                      {
                         if (local_do_metafont)
                            *out_stream_mf << " withpen " << **pen_iter;
                         if (local_do_metapost)
                            *out_stream_mp << " withpen " << **pen_iter;
                      }


                      if (do_dash_patterns)
                      {
                         if (local_do_metapost)
                            *out_stream_mp << **dash_pattern_iter;
                      }

                       if (local_do_metafont)
                          *out_stream_mf << ";" << endl << flush;
                       if (local_do_metapost)
                          *out_stream_mp << ";" << endl << flush;

                       return 0;
                  }  

@q ******* (7) @> 

               else if (   !do_pens 
                        || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

               {
                    if (local_do_metafont)
                       *out_stream_mf << "draw " << *points[0] 
                                      << *connector_type_iter << *points[1];
                    if (local_do_metapost)
                       *out_stream_mp << "draw " << *points[0] 
                                      << *connector_type_iter << *points[1];

                   if (local_do_metapost && do_colors)
                      *out_stream_mp << endl << "withcolor " << **color_iter;

                   if (do_pens)
                   {
                      if (local_do_metafont)
                         *out_stream_mf << endl << "withpen " << **pen_iter;
                      if (local_do_metapost)
                         *out_stream_mp << endl << "withpen " << **pen_iter;
                   }

                   if (do_dash_patterns && local_do_metapost)
                   {
                      *out_stream_mp << endl << **dash_pattern_iter;
                   }

                   if (local_do_metafont)
                       *out_stream_mf << ";" << endl << flush;
                   if (local_do_metapost)
                       *out_stream_mp << ";" << endl << flush;

               }  

@q ****** (6) Draw the middle segments.@> 

@ Draw the middle segments.
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

               int i = 1;
               int j = points.size() - 2;
               int k;

               if (cycle_switch)
                  {
                     ++j;
                     k = 0;
                  }
               else
                  k = j + 1;

@q ******* (7) @> 

               for (; i < j; ++i)
               {
                     
                      ++connector_iter;
                      ++connector_type_iter;

                      if (do_colors)
                         ++color_iter;

                      if (do_pens)
                         ++pen_iter;
   
                      if (do_dash_patterns) 
                        ++dash_pattern_iter;
                     
                      if (   !do_pens 
                          || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

                         {
                             if (local_do_metafont)
                                *out_stream_mf << "draw " << *points[i]   
                                               << *connector_type_iter << *points[i + 1];
                             if (local_do_metapost)
                                *out_stream_mp << "draw " << *points[i]   
                                               << *connector_type_iter << *points[i + 1];

                             if (local_do_metapost && do_colors)
                                *out_stream_mp << endl << "withcolor " << **color_iter;

                             if (do_pens)
                             {
                                if (local_do_metafont)
                                   *out_stream_mf << endl << " withpen " << **pen_iter;
                                if (local_do_metapost)
                                   *out_stream_mp << endl << " withpen " << **pen_iter;
                             }


                             if (local_do_metapost && do_dash_patterns)
                                *out_stream_mp << endl << **dash_pattern_iter;

                             if (local_do_metafont)
                                 *out_stream_mf << ";" << endl << flush;
                             if (local_do_metapost)
                                 *out_stream_mp << ";" << endl << flush;
                         }
@q ******** (8) @> 

               }  /* |for|  */

@q ******* (7) @> 

@q ****** (6) Draw the last segment.@> 

@ Draw the last segment.  
This requires special handling because |arrow| could be equal to 
|SINGLE_ARROW| or |DOUBLE_ARROW|. 
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

               ++connector_iter;
               ++connector_type_iter;

               if (do_colors)
                  ++color_iter;

               if (do_pens)
                  ++pen_iter;
   
               if (do_dash_patterns) 
                 ++dash_pattern_iter;

               if (   !do_pens 
                   || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

                  {

                      if (arrow == NO_ARROW)
                      {
                         if (local_do_metafont)
                            *out_stream_mf << "draw ";
                         if (local_do_metapost)
                            *out_stream_mp << "draw ";
                      }
                      else
                      {
                         if (local_do_metafont)
                            *out_stream_mf << "draw ";  /* {\MF} doesn't have arrows!  
                                                        \initials{LDF 2022.04.16.}  */

                         if (local_do_metapost)
                            *out_stream_mp << "drawarrow ";                         
                      }
                       
                      if (local_do_metafont)
                         *out_stream_mf << *points[j] 
                                        << *connector_type_iter << *points[k];
                      if (local_do_metapost)
                         *out_stream_mp << *points[j] 
                                        << *connector_type_iter << *points[k];


                       if (local_do_metapost && do_colors)
                          *out_stream_mp << endl << "withcolor " << **color_iter;

                       if (do_pens)
                       {
                          if (local_do_metafont)
                             *out_stream_mf << endl << "withpen " << **pen_iter;
                          if (local_do_metapost)
                             *out_stream_mp << endl << "withpen " << **pen_iter;
                       }


                       if (local_do_metapost && do_dash_patterns)
                          *out_stream_mp << endl << **dash_pattern_iter;
 
                       if (local_do_metafont)
                          *out_stream_mf << ";" << endl << flush;
                       if (local_do_metapost)
                          *out_stream_mp << ";" << endl << flush;
                  }

@q ****** (6).@> 
               
        }  /*  |if|  */

@q ***** (5).@>   
@
\LOG
\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now setting |connector_iter = connectors.begin|.

\initials{LDF 2005.04.05.}
Added code for suppressing output if the type of the current 
|Pen| is |Pen::NULL_PEN|.
\ENDLOG 

@<Define |Path| functions@>=

        else if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
                 || pen_vector->ctr == 0 
                 || pen_vector->v[0]->get_type() != Pen::NULL_PEN)  
                
                 /*  Not dividing |Path|.  */
           {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
                         cerr << "`pen_vector' == 0." << endl;

                      else 
                         cerr << "`pen_vector->ctr' == " << pen_vector->ctr
                              << endl 
                              << "`pen_vector->v[0]->get_type' == "
                              << pen_vector->v[0]->get_type() << endl;

                  }
#endif /* |DEBUG_COMPILE|  */@; 
 
               vector<Point*>::const_iterator point_iter = points.begin();

               if (connector_type_vector.size() == 0)
               {
                   connector_type_vector.push_back(create_new<Connector_Type>(0));
                   connector_type_vector.back()->type0 = Connector_Type::PLAIN_TYPE;
                   connector_type_vector.back()->type1 = Connector_Type::CT_NULL_TYPE;
                   connector_type_vector.back()->connector_string = "--";
                   connector_type_vector.back()->pt0 = 0;
                   connector_type_vector.back()->pt1 = 0;
               }
                  
               connector_type_iter = connector_type_vector.begin();

#if DEBUG_COMPILE
               if (DEBUG)
                 {
                     cerr_strm << thread_name << "In `Path::sub_output_draw':"
                               << endl 
                               << "Not drawing segments individually.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str("");   
                 }         
#endif /* |DEBUG_COMPILE|  */@; 

               if (local_do_metafont)
               {
                   *out_stream_mf << "draw " << **point_iter;
               }

               if (local_do_metapost)
               {
                   if (arrow == SINGLE_ARROW)
                   {
                     *out_stream_mp << "drawarrow " << **point_iter;
                   }
                   else if (arrow == DOUBLE_ARROW)
                   {
                     *out_stream_mp << "drawdblarrow " << **point_iter;
                   }
                   else
                   {
                     *out_stream_mp << "draw " << **point_iter;
                   }
              }

              **point_iter++; 

               if (local_do_metafont)
                  output_path(out_stream_mf);
               if (local_do_metapost)
                  output_path(out_stream_mp);

               if (   local_do_metapost && draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                   && draw_color_vector->ctr > 0)
                  *out_stream_mp << endl << "withcolor " << *(draw_color_vector->v[0]) << " ";

               if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
               {
                  if (local_do_metafont)
                     *out_stream_mf << endl << "withpen " << *(pen_vector->v[0]) << " ";
                  if (local_do_metapost)
                    *out_stream_mp << endl << "withpen " << *(pen_vector->v[0]) << " ";
 
               }

               if (   local_do_metapost 
                   && dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                   && dash_pattern_vector->ctr > 0)
               {
                  *out_stream_mp << endl << *(dash_pattern_vector->v[0]);
               }


               if (local_do_metafont)
                  *out_stream_mf << ";" << endl << flush;
               if (local_do_metapost)
                  *out_stream_mp << ";" << endl << flush;


           }  /*  |else if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
                            || pen_vector->ctr == 0 
                            || pen_vector->v[0]->get_type() != Pen::NULL_PEN)| 
                  (Not dividing |Path|.)  */

@q ***** (5).@>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Exiting `Path::sub_output_draw' successfully with return value 0.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

}  /* End of |sub_output_draw| definition.  */



@q * (1) Putting Picture functions together.@>
@* Putting {\bf Picture} functions together.
\initials{LDF 2005.04.09.}

This is what's compiled.
\initials{LDF 2005.04.09.}

@c
@<Include files@>@;

@<Define |Picture| functions@>@;@/
@<Define |Point| functions@>@;@/
@<Define |Label| functions@>@;@/
@<Define |Path| functions@>@;@/

@ This is what's written to \filename{pctfncs0.h}.
\initials{LDF 2005.04.09.}

@(pctfncs0.h@>=
@q Nothing.  @>@;

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
