@q rhtchdrn.web @>
@q Created by Laurence D. Finston (LDF) Mon Oct 22 17:08:00 CEST 2007 @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Rhombic_Triacontahedron.@>
@** {\bf Rhombic\_Triacontahedron}.

Wikipedia link:\hfil\break 
{\tt http://en.wikipedia.org/wiki/Rhombic\_triacontahedron}\hfil\break 
\initials{LDF 2007.10.24.}

\LOG
\initials{LDF 2007.10.22.}
Created this file.  
\ENDLOG

\immediate\write\functexifile{File:  rhtchdrn.web^^J}

@q * (1) Include files.@>
@ Include files.
\initials{LDF 2007.10.22.}

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"
#include "solids.h++"
#include "solfaced.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
 
@q * (1)  {\bf Rhombic\_Triacontahedron} Class definition.@>
@* {\bf Rhombic\_Triacontahedron} class definition.

\LOG
\initials{LDF 2007.10.22.}
Added this |class| declaration.

\initials{LDF 2007.10.24.}
Added the |static const real| data members |rhombus_angle_0| and 
|rhombus_angle_1|.
\ENDLOG

@f Rhombic_Triacontahedron Polyhedron

@<Declare |class Rhombic_Triacontahedron|@>=

class Rhombic_Triacontahedron : public Polyhedron
{
   protected:
      static const real dihedral_angle;   /* In degrees  */

      static const real rhombus_angle_0;
      static const real rhombus_angle_1;

      real rhombus_side_length; 

   public:
      @<Declare |Rhombic_Triacontahedron| functions@>@;
};

@q * (1) Define static const Rhombic_Triacontahedron data members.@>
@* Define {\bf static const Rhombic\_Triacontahedron} data members.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.24.}
Now setting |dihedral_angle| to correct value (144).

\initials{LDF 2007.10.24.}
Now setting |rhombus_angle_0| and |rhombus_angle_1| to 
$63^\circ 28'$ and $116^\circ 34'$, respectively.
\ENDLOG 

@q 63 deg. 28'          @>
@q 63.43333333333333335 @>

@q 116 deg. 34'         @>
@q 116.5666666666666667 @>

@<Define |static const Rhombic_Triacontahedron| data members@>=
const real Rhombic_Triacontahedron::dihedral_angle = 144;

const real Rhombic_Triacontahedron::rhombus_angle_0 = 63 + (28.0 / 60.0);
const real Rhombic_Triacontahedron::rhombus_angle_1 = 116 + (34.0 / 60.0);

@q * (1) |Rhombic_Triacontahedron| functions.@>
@* {\bf Rhombic\_Triacontahedron} functions.
\initials{LDF 2007.10.22.}

@q ** (2) Constructors and setting functions.@>
@*1 Constructors and setting functions.

@q *** (3) Default constructor. (No arguments.)@>
@*2 Default constructor. (No arguments.)
@^\cfunc{Rhombic\_Triacontahedron}{Rhombic\_Triacontahedron}@>
\cfunctexi{Rhombic\_Triacontahedron}{Rhombic\_Triacontahedron}
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.

\initials{LDF 2007.10.24.}
Now setting |faces|, |vertices| and |edges| to correct values.
\ENDLOG 

@<Declare |Rhombic_Triacontahedron| functions@>=
Rhombic_Triacontahedron(void);

@
@<Define |Rhombic_Triacontahedron| functions@>=
Rhombic_Triacontahedron::Rhombic_Triacontahedron(void)
{

   shape_type = RHOMBIC_TRIACONTAHEDRON_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   do_output     = true;
   faces    = 30;          /* from |Solid_Faced|.  */
   vertices = 32;
   edges    = 60;

   center = INVALID_POINT;  /* from |Polyhedron|.  */
   number_of_polygon_types = 1;
   face_radius = edge_radius = vertex_radius = INVALID_REAL;

}

@q ** (2) Destructor.@>
@*1 Destructor.
\initials{LDF 2007.10.24.}

\LOG
\initials{LDF 2007.10.24.}
Added this function.
\ENDLOG 

@<Declare |Rhombic_Triacontahedron| functions@>=
virtual
~Rhombic_Triacontahedron(void);

@
@<Define |Rhombic_Triacontahedron| functions@>=
Rhombic_Triacontahedron::~Rhombic_Triacontahedron(void)
{

    return;

}

@q ** (2) Get copy.@>
@* Get copy.
@^\cfunc{Rhombic\_Triacontahedron}{get\_copy}@>
\cfunctexi{Rhombic\_Triacontahedron}{get\_copy}
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.
\ENDLOG

@<Declare |Rhombic_Triacontahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Rhombic_Triacontahedron| functions@>=
Shape*
Rhombic_Triacontahedron::get_copy() const
{
  Rhombic_Triacontahedron* p = create_new<Rhombic_Triacontahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q ** (2) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this section.
\ENDLOG

@q *** (3) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Rhombic_Triacontahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return RHOMBIC_TRIACONTAHEDRON_TYPE;
}

@q *** (3) Is |Rhombic_Triacontahedron|.@> 
@*1 Is {\bf Rhombic\_Triacontahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Rhombic_Triacontahedron| functions@>=
virtual
inline
bool
is_rhombic_triacontahedron(void) const 
{
   return true;
}

@q *** (3) Get rhombus.@>
@*2 Get rhombus. 
@^\cfunc{Rhombic\_Triacontahedron}{get\_rhombus}@>
\cfunctexi{Rhombic\_Triacontahedron}{get\_rhombus}
\initials{LDF 2007.10.26.}

\LOG
\initials{LDF 2007.10.26.}
Added this function.  
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Rhombic_Triacontahedron| functions@>=
static
Polygon*
get_rhombus(real rhombus_side_length,
            Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>
@ 
@<Define |Rhombic_Triacontahedron| functions@>=
Polygon*
Rhombic_Triacontahedron::get_rhombus(real rhombus_side_length,
                                     Scanner_Node scanner_node)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5) Error handling.@>

@ Error handling.
\initials{LDF 2007.10.26.}

@<Define |Rhombic_Triacontahedron| functions@>=

   if (rhombus_side_length <= 0)
   {

        cerr_mutex.lock(); 
        cerr_strm << thread_name 
                  << "ERROR!  In `Rhombic_Triacontahedron::get_rhombus':"
                  << endl 
                  << "`rhombus_side_length' ==  " << rhombus_side_length
                  << " (<= 0)"
                  << endl 
                  << "Can't create `Polygon'.  "
                  << "Exiting function unsuccessfully with return value 0."
                  << endl;
         cerr_mutex.unlock(); 
      
         return 0;

   }  /* |if (rhombus_side_length <= 0)|  */

@q ***** (5) Declarations.@>
@ Declarations.
\initials{LDF 2007.10.24.}
@<Define |Rhombic_Triacontahedron| functions@>=

   Point p[5];      /* Points on rhombus for scratch use  */

   Polygon* rhombus = create_new<Polygon>(0); 

/* 63 deg. 28'                     */
/* (/ 26 60.0) 0.43333333333333335 */
/* 63.43333333333333335            */

/* 116 deg. 34'                    */
/* (/ 34 60.0)                     */
/* 116.5666666666666667            */

    p[0].set(0, 0, 0);
    p[4].set(rhombus_side_length, 0, 0);
    p[1] = p[4];
    p[1].rotate(0, rhombus_angle_0 / 2);
    p[3] = p[4];
    p[3].rotate(0, -rhombus_angle_0 / 2);
    p[2] = p[0];
    p[2].rotate(p[1], p[3]);

    rhombus->set("--", true, &p[0], &p[1], &p[2], &p[3], static_cast<Point*>(0));

    return rhombus; 

}  /* End of |Rhombic_Triacontahedron::get_rhombus| definition.  */

@q *** (3)@>

@q ** (2) Net and tabs.@>
@*1 Net and tabs.
\initials{LDF 2007.10.22.}

@q *** (3) Get net.@>
@*2 Get net. 
@^\cfunc{Rhombic\_Triacontahedron}{get\_net}@>
\cfunctexi{Rhombic\_Triacontahedron}{get\_net}
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.  

\initials{LDF 2007.10.26.}
Now drawing full net.  Passing a value of |true| for |do_half| does not 
yet have any effect.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Rhombic_Triacontahedron| functions@>=
static
Pointer_Vector<Polygon>*
get_net(real rhombus_side_length,
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@q **** (4) Definition.@>
@ 
@<Define |Rhombic_Triacontahedron| functions@>=
Pointer_Vector<Polygon>*
Rhombic_Triacontahedron::get_net(real rhombus_side_length,
                                 bool do_half,
                                 Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5) @>
@
@<Define |Rhombic_Triacontahedron| functions@>=

@q ***** (5) @>
#if DEBUG_COMPILE
   if (DEBUG)
   {
        cerr_mutex.lock(); 
        cerr_strm << thread_name 
                  << "Entering `Rhombic_Triacontahedron::get_net'."
                  << endl;
        cerr_mutex.unlock(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ***** (5)@>
@
@<Define |Rhombic_Triacontahedron| functions@>=

   if (rhombus_side_length <= 0)
   {

@q ****** (6) Error handling.@>

@ Error handling.
\initials{LDF 2007.10.24.}

@<Define |Rhombic_Triacontahedron| functions@>=

      if (!(scanner_node && scanner_node->polyhedron_options))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In `Rhombic_Triacontahedron::get_net':"
                    << endl 
                    << "`rhombus_side_length' ==  " << rhombus_side_length
                    << " (<= 0)"
                    << endl 
                    << "and `scanner_node' and/or "
                    << "`scanner_node->polyhedron_options' is null."
                    << endl 
                    << "Exiting function unsuccessfully with return value 0.";
      
         return 0;

      }  /* |if|  */

@q ****** (6)@>

      else
      {
         rhombus_side_length 
            = scanner_node->polyhedron_options->rhombus_0_side_length;
      }

      delete scanner_node->polyhedron_options;
      scanner_node->polyhedron_options = 0;
       
   }  /* |if (rhombus_side_length <= 0)|  */

@q ***** (5) WARNING!  Passing a value of |true| for |do_half| has no effect.@>
@ WARNING!  Passing a value of |true| for |do_half| has no effect.
\initials{LDF 2007.10.26.}

@<Define |Rhombic_Triacontahedron| functions@>=

    if (do_half)
    {
        cerr_strm << thread_name 
                  << "WARNING!  In `Rhombic_Triacontahedron::get_net':"
                  << endl 
                  << "`do_half' == `true'.  This currently has no effect."
                  << endl 
                  << "Continuing.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");

    }  /* |if (do_half)|  */

@q ***** (5) Set other options here, if added.  @>

@q ***** (5) Declarations.@>
@ Declarations.
\initials{LDF 2007.10.24.}
@<Define |Rhombic_Triacontahedron| functions@>=

   Pointer_Vector<Polygon>* pv = new Pointer_Vector<Polygon>;

   Point p[16];      /* Points on rhombuses for scratch use  */
   Point c[30];      /* Centers  */

   Polygon rhombus[30]; /* Rhombuses */

   Transform t[2];

/* 63 deg. 28'                     */
/* (/ 26 60.0) 0.43333333333333335 */
/* 63.43333333333333335            */

/* 116 deg. 34'                    */
/* (/ 34 60.0)                     */
/* 116.5666666666666667            */

@q ***** (5) Rhombuses.@>
@ Rhombuses.
\initials{LDF 2007.10.24.}

@<Define |Rhombic_Triacontahedron| functions@>=

@q ****** (6) Rhombus 0.@>

   p[0].set(0, 0, 0);
   p[4].set(rhombus_side_length, 0, 0);
   p[1] = p[4];
   p[1].rotate(0, rhombus_angle_0 / 2);
   p[3] = p[4];
   p[3].rotate(0, -rhombus_angle_0 / 2);
   p[2] = p[0];
   p[2].rotate(p[1], p[3]);

   rhombus[0].set("--", true, &p[0], &p[1], &p[2], &p[3], static_cast<Point*>(0));

   *pv += create_new<Polygon>(rhombus[0]);

@q ****** (6) Rhombus 1.@>

   rhombus[1] = rhombus[0];
   rhombus[1].rotate(p[0], p[1]);

   *pv += create_new<Polygon>(rhombus[1]);

@q ****** (6) Rhombus 2.@>

   rhombus[2] = rhombus[0];
   rhombus[2].rotate(p[0], p[3]);

   *pv += create_new<Polygon>(rhombus[2]);

@q ****** (6)@>

@q ****** (6) Rhombus 3.@>

   rhombus[3] = rhombus[0];
   rhombus[3].rotate(p[3], p[2]);

   *pv += create_new<Polygon>(rhombus[3]);

@q ****** (6) Rhombuses 4, 5, and 6.@>

   rhombus[4] = rhombus[0];
   rhombus[5] = rhombus[2];

   t[0].reset();

   p[4] = rhombus[3].get_point(0);

   t[0].shift(p[4] - p[0]);

   rhombus[4] *= rhombus[5] *= t[0];
   
   *pv += create_new<Polygon>(rhombus[4]);
   *pv += create_new<Polygon>(rhombus[5]);

@q ****** (6) Rhombuses 7, 8 and 9  @>

   rhombus[6] = rhombus[0];
   rhombus[7] = rhombus[1];
   rhombus[8] = rhombus[2];
   rhombus[9] = rhombus[3];

   t[0].reset();

   p[0] = rhombus[2].get_point(1);
   p[1] = rhombus[4].get_point(1);

   t[0].shift(p[1] - p[0]);

   rhombus[6] *= rhombus[7] *= rhombus[8] *= rhombus[9] *= t[0];
   
   *pv += create_new<Polygon>(rhombus[6]);
   *pv += create_new<Polygon>(rhombus[7]);
   *pv += create_new<Polygon>(rhombus[8]);
   *pv += create_new<Polygon>(rhombus[9]);

@q ****** (6) Rhombuses 10, 11, 12, 13, 14 and 15  @>

   rhombus[10] = rhombus[4];
   rhombus[11] = rhombus[5];
   rhombus[12] = rhombus[6];
   rhombus[13] = rhombus[7];
   rhombus[14] = rhombus[8];
   rhombus[15] = rhombus[9];

   p[0] = rhombus[4].get_point(0);
   p[1] = rhombus[9].get_point(0);

   t[0].reset();
   t[0].shift(p[1] - p[0]);

   for (int i = 10; i < 16; ++i)
   {
       rhombus[i] *= t[0];
       *pv += create_new<Polygon>(rhombus[i]); 
   }

@q ****** (6) Rhombuses 16, 17, 18, 19, 20 and 21  @>

   rhombus[16] = rhombus[4];
   rhombus[17] = rhombus[5];
   rhombus[18] = rhombus[6];
   rhombus[19] = rhombus[7];
   rhombus[20] = rhombus[8];
   rhombus[21] = rhombus[9];

   p[0] = rhombus[4].get_point(0);
   p[1] = rhombus[15].get_point(0);

   t[0].reset();
   t[0].shift(p[1] - p[0]);

   for (int i = 16; i < 22; ++i)
   {
       rhombus[i] *= t[0];
       *pv += create_new<Polygon>(rhombus[i]); 
   }

@q ****** (6) Rhombuses 22, 23, 24, 25, 26, 27, 28 and 29  @>

   rhombus[22] = rhombus[4];
   rhombus[23] = rhombus[5];
   rhombus[24] = rhombus[6];
   rhombus[25] = rhombus[7];
   rhombus[26] = rhombus[8];
   rhombus[27] = rhombus[9];
   rhombus[28] = rhombus[10];
   rhombus[29] = rhombus[11];

   p[0] = rhombus[4].get_point(0);
   p[1] = rhombus[21].get_point(0);

   t[0].reset();
   t[0].shift(p[1] - p[0]);

   for (int i = 22; i < 30; ++i)
   {
       rhombus[i] *= t[0];
       *pv += create_new<Polygon>(rhombus[i]); 
   }

@q ***** (5)@>

   return pv;

}  /* End of |Rhombic_Triacontahedron::get_net| definition.  */

@q *** (3) Get tabs.@>
@*2 Get tabs. 
@^\cfunc{Rhombic\_Triacontahedron}{get\_tabs}@>
\cfunctexi{Rhombic\_Triacontahedron}{get\_tabs}
\initials{LDF 2007.10.22.}

@q **** (4) Version with multiple arguments.@>
@*3 Version with multiple arguments.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.

\initials{LDF 2007.10.24.}
Added |real rhombus_side_length| argument.

\initials{LDF 2007.10.31.}
Finished this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Rhombic_Triacontahedron| functions@>=
static
void*
get_tabs(real rhombus_side_length,
         bool do_half = false,
         bool do_stitch_lines = true,
         unsigned short stitch_divisions = 5,
         void* parameter = 0);

@q ***** (5) Definition.@>
@ 
@<Define |Rhombic_Triacontahedron| functions@>=
void*
Rhombic_Triacontahedron::get_tabs(real rhombus_side_length,
                                  bool do_half,
                                  bool do_stitch_lines,
                                  unsigned short stitch_divisions,
                                  void* parameter)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6) Declarations and Initializations.@>
@ Declarations and Initializations.
\initials{LDF 2007.10.29.}

@<Define |Rhombic_Triacontahedron| functions@>=

   real angle = 110;

   Point p[164];

   Path tab;
   Path stitch_line;

   Pointer_Vector<Polygon>* nv = get_net(rhombus_side_length,
                                         do_half,
                                         scanner_node);

   Pointer_Vector<Path>* tv = new Pointer_Vector<Path>;

   Pointer_Vector<Path>* sv = 0;

   if (do_stitch_lines)
      sv = new Pointer_Vector<Path>;

   Bool_Point bp;

   Transform t0;
   Transform t1;   

@q ****** (6) Tabs and stitch lines for first column.  @>

@q ******* (7) Tab rhombus 0, points 1 -- 2, outer  @>

   p[0] = nv->v[0]->get_point(0);
   p[1] = nv->v[0]->get_point(1);
   p[2] = nv->v[0]->get_point(2);
   p[3] = nv->v[0]->get_point(3);

   p[4] = p[1].mediate(p[2], .125);

   p[5] = p[2].mediate(p[1], .125);

   p[6] = p[4];
   p[6].shift(0, 1);

   p[7] = p[1];
   p[7].rotate(p[4], p[6], -angle);

   p[8] = p[5];
   p[8].shift(0, 1);

   p[9] = p[2];
   p[9].rotate(p[8], p[5], -angle);

   tab.set("--", true, &p[4], &p[7], &p[9], &p[5], static_cast<Point*>(0));

   *tv += create_new<Path>(tab);

@q ******** (8) Stitch line, rhombus 0, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      p[10] = p[4].mediate(p[5]);     
      p[11] = p[7].mediate(p[9]);     
      p[12] = p[10].mediate(p[11]);

      p[13] = (p[4] - p[5]).unit_vector();
      p[13].shift(p[12]);

      bp = Point::intersection_point(p[12], p[13], p[4], p[7]);
      p[14] = bp.pt;

      bp = Point::intersection_point(p[12], p[13], p[5], p[9]);
      p[15] = bp.pt;    

      stitch_line += "--";
      stitch_line += p[14];

     if (stitch_divisions > 1)
     {
         real r = 1.0 / stitch_divisions;

         for (real n =  r; n < 1.0; n += r)
         {
             stitch_line += p[14].mediate(p[15], n);
         }

     }  /* |if (stitch_divisions > 1)|  */

      stitch_line += p[15];

     *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 1, points 1 -- 2, outer  @>

   p[20] = nv->v[1]->get_point(0);
   p[21] = nv->v[1]->get_point(1);
   p[22] = nv->v[1]->get_point(2);
   p[23] = nv->v[1]->get_point(3);

   t0.reset();
   t0.rotate(p[20], p[21]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 1, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 1, points 2 -- 3, outer  @>

   t0.reset();
   t0.rotate(p[22], p[20]);

   tab *= t0;

   p[26] = tab.get_point(0);

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 1, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 1, points 3 -- 0, outer  @>

   t0.reset();
   t0.rotate(p[23], p[21]);

   tab *= t0;

   p[26] = tab.get_point(0);

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 1, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 2, points 0 -- 1, outer  @>

   for (int i = 0; i < 4; ++i)
      p[30 + i] = nv->v[2]->get_point(i);

   t0.reset();
   t0.rotate(p[20], p[21]);
   t0.rotate(p[20], p[32]);
   t0.rotate(p[20], p[31]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 2, points 0 -- 1, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 2, points 1 -- 2, outer  @>

   t0.reset();
   t0.rotate(p[31], p[33]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 2, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 2, points 2 -- 3, outer  @>

   t0.reset();
   t0.rotate(p[30], p[32]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 2, points 2 -- 3, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 3, points 1 -- 2, outer  @>

   for (int i = 0; i < 4; ++i)
      p[40 + i] = nv->v[3]->get_point(i);

   p[44] = p[32].mediate(p[40]);

   t0.reset();
   t0.rotate(p[44], p[43]);

   t1 = t0;

   t0.rotate(p[40], p[42]);
   t0.rotate(p[41], p[43]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 3, points 1 -- 2, outer@>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 3, points 3 -- 0, inner  @>

   t0.inverse(true);
   t0 *= t1;
   t0.rotate(p[43], p[40]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 3, points 3 -- 0, inner @>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 4, points 2 -- 3, outer  @>

   t0.reset(); 
   t1.reset();

   for (int i = 0; i < 4; ++i)
      p[50 + i] = nv->v[4]->get_point(i);

   t0.rotate(p[40], p[41]);
   t0.rotate(p[51], p[53]);
   t0.rotate(p[52], p[53]);

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 4, points 2 -- 3, outer @>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 5, points 0 -- 1, outer  @>

   for (int i = 0; i < 4; ++i)
      p[60 + i] = nv->v[5]->get_point(i);

   t0.reset(); 
   t0.rotate(p[51], p[53]); 
   t0.rotate(p[60], p[62]); 
   t0.rotate(p[60], p[61]); 

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 5, points 0 -- 1, outer @>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 5, points 1 -- 2, outer  @>

   t0.reset(); 
   t0.rotate(p[61], p[63]); 

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 5, points 1 -- 2, outer @>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ******* (7) Tab rhombus 5, points 2 -- 3, outer  @>

   t0.reset(); 
   t0.rotate(p[60], p[62]); 

   tab *= t0;

   *tv += create_new<Path>(tab);
  
@q ******** (8) Stitch line, rhombus 5, points 2 -- 3, outer @>

   if (do_stitch_lines)
   {

      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ****** (6) Tabs and stitch lines for second column.  @>

   for (int i = 0; i < 4; ++i)
   {
      p[70 + i] = nv->v[6]->get_point(i);
      p[80 + i] = nv->v[7]->get_point(i);
      p[90 + i] = nv->v[11]->get_point(i);
   }

@q ******* (7) Tabs  @>

   t0.reset(); 
   t0.shift(p[71] - p[21]);

   tab = *tv->v[0];  /* Rhombus 6, 1 -- 2  */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[1];  /* Rhombus 7  */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[2];

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[3];

   t1.reset();
   t1.rotate(p[80], p[83]);

   tab *= t0;
   tab *= t1;

   *tv += create_new<Path>(tab);

   tab = *tv->v[4];  /* Rhombus 8  */

   tab *= t0;

   t1.reset();
   t1.rotate(p[70], p[51]);

   tab *= t1;

   *tv += create_new<Path>(tab);

   tab = *tv->v[6];

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[7];  /* Rhombus 9  */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[8];  

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[9];  /* Rhombus 10  */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[10];  /* Rhombus 11  */

   tab *= t0;

   t1.reset();
   t1.rotate(p[90], p[91]);
   tab *= t1;

   *tv += create_new<Path>(tab);

   tab = *tv->v[11];  

   tab *= t0;
   t1.reset();
   t1.rotate(p[92], p[91]);
   tab *= t1;

   *tv += create_new<Path>(tab);

   tab = *tv->v[12];  

   tab *= t0;

   *tv += create_new<Path>(tab);

@q ******** (8) Stitch lines  @>

   if (do_stitch_lines)
   {
      stitch_line = *sv->v[0];
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[1];  /* Rhombus 7  */
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[2]; 
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[3]; 
  
      t1.reset();
      t1.rotate(p[80], p[83]);

      stitch_line *= t0;
      stitch_line *= t1;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[4]; /* Rhombus 8  */
  
      stitch_line *= t0;

      t1.reset();
      t1.rotate(p[70], p[51]);

      stitch_line *= t1;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[6]; 
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[7]; /* Rhombus 9  */
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[8]; 
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[9]; /* Rhombus 10  */
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[10]; /* Rhombus 11  */
  
      stitch_line *= t0;

      t1.reset();
      t1.rotate(p[90], p[91]);
      stitch_line *= t1;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[11]; 
  
      stitch_line *= t0;

      t1.reset();
      t1.rotate(p[92], p[91]);
      stitch_line *= t1;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[12]; 
  
      stitch_line *= t0;

      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)|  */

@q ****** (6) Tabs and stitch lines for third column.  @>

   for (int i = 0; i < 4; ++i)
   {
      p[100 + i] = nv->v[12]->get_point(i);
   }

@q ******* (7) Tabs  @>

   t0.reset(); 
   t0.shift(p[101] - p[71]);

   tab = *tv->v[13];  /* Rhombus 12 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[14];  /* Rhombus 13 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[15];

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[16];

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[17];  /* Rhombus 14 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[18];  

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[19];  /* Rhombus 15 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[20];  

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[21];  /* Rhombus 16 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[22];  /* Rhombus 17 */

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[23];  

   tab *= t0;

   *tv += create_new<Path>(tab);

   tab = *tv->v[24];  

   tab *= t0;

   *tv += create_new<Path>(tab);

@q ******** (8) Stitch lines for third column  @>

   if (do_stitch_lines)
   {
      stitch_line = *sv->v[13];  /* Rhombus 12 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[14];  /* Rhombus 13 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[15];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[16];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[17];  /* Rhombus 14 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[18];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[19];  /* Rhombus 15 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[20];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[21];  /* Rhombus 16 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[22];  /* Rhombus 17 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[23];
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[24];
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

   }  /* |if (do_stitch_lines)| (Third column)  */

@q ****** (6) Tabs and stitch lines for fourth column.  @>

   for (int i = 0; i < 4; ++i)
   {
      p[110 + i] = nv->v[18]->get_point(i);
   }

@q ******* (7) Tabs  @>

   t0.reset(); 
   t0.shift(p[112] - p[102]);

   tab = *tv->v[25];  /* Rhombus 18 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[26];  /* Rhombus 19 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[27];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[28];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[29];  /* Rhombus 20 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[30];
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[31];  /* Rhombus 21 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[32];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[33];  /* Rhombus 22 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[34];  /* Rhombus 23 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[35];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[36];  
   tab *= t0;
   *tv += create_new<Path>(tab);

#if 0 
   tab = *tv->v[24];  
   tab *= t0;
   *tv += create_new<Path>(tab);
#endif 

@q ******** (8) Stitch lines for fourth column  @>

   if (do_stitch_lines)
   {

      stitch_line = *sv->v[25];  /* Rhombus 18 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[26];  /* Rhombus 19 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[27];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[28];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[29];  /* Rhombus 20 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[30];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[31];  /* Rhombus 21 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[32];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[33];  /* Rhombus 22 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[34];  /* Rhombus 23 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[35];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[36];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

#if 0 

      stitch_line = *sv->v[15];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);
#endif 

   }  /* |if (do_stitch_lines)| (Fourth column)  */

@q ****** (6) Tabs and stitch lines for fifth column.  @>

   for (int i = 0; i < 4; ++i)
   {
      p[120 + i] = nv->v[24]->get_point(i);
      p[130 + i] = nv->v[25]->get_point(i);
      p[140 + i] = nv->v[27]->get_point(i);
      p[150 + i] = nv->v[28]->get_point(i);
      p[160 + i] = nv->v[29]->get_point(i);
   }

@q ******* (7) Tabs  @>

   t0.reset(); 
   t0.shift(p[122] - p[112]);

   tab = *tv->v[37];  /* Rhombus 24 */

   tab *= t0;
   t1.reset();
   t1.rotate(p[121], p[122]);
   tab *= t1;

   *tv += create_new<Path>(tab);

   tab = *tv->v[38];  /* Rhombus 25 */
   tab *= t0;
   t1.reset();
   t1.rotate(p[131], p[132]);
   tab *= t1;
   *tv += create_new<Path>(tab);

   tab = *tv->v[39];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[40];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[41];  /* Rhombus 26 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[42];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[43];  /* Rhombus 27 */
   tab *= t0;
   t1.reset();
   t1.rotate(p[141], p[142]);
   tab *= t1;
   *tv += create_new<Path>(tab);

   tab = *tv->v[44];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[45];  /* Rhombus 28 */
   tab *= t0;
   t1.reset();
   t1.rotate(p[152], p[153]);
   tab *= t1;
   *tv += create_new<Path>(tab);

   tab = *tv->v[57];  
   t1.reset();
   t1.rotate(p[150], p[152]);
   tab *= t1;
   *tv += create_new<Path>(tab);

   tab = *tv->v[46];  /* Rhombus 29 */
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[47];  
   tab *= t0;
   *tv += create_new<Path>(tab);

   tab = *tv->v[48];  
   tab *= t0;
   t1.reset();
   t1.rotate(p[162], p[163]);
   tab *= t1;
   *tv += create_new<Path>(tab);

#if 0
   tab = *tv->v[24];  
   tab *= t0;
   *tv += create_new<Path>(tab);
#endif 

@q ******** (8) Stitch lines for fifth column  @>

   if (do_stitch_lines)
   {

      stitch_line = *sv->v[37];  /* Rhombus 24 */
      stitch_line *= t0;

      t1.reset();
      t1.rotate(p[121], p[122]);
      stitch_line *= t1;

      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[38];  /* Rhombus 25 */
      stitch_line *= t0;
      t1.reset();
      t1.rotate(p[131], p[132]);
      stitch_line *= t1;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[39];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[40];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[41];  /* Rhombus 26 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[42];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[43];  /* Rhombus 27 */
      stitch_line *= t0;
      t1.reset();
      t1.rotate(p[141], p[142]);
      stitch_line *= t1;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[44];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[45];  /* Rhombus 28 */
      stitch_line *= t0;
      t1.reset();
      t1.rotate(p[152], p[153]);
      stitch_line *= t1;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[57];  
      t1.reset();
      t1.rotate(p[150], p[152]);
      stitch_line *= t1;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[46];  /* Rhombus 29 */
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[47];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);

      stitch_line = *sv->v[48];  
      stitch_line *= t0;
      t1.reset();
      t1.rotate(p[162], p[163]);
      stitch_line *= t1;
      *sv += create_new<Path>(stitch_line);

#if 0 
      stitch_line = *sv->v[15];  
      stitch_line *= t0;
      *sv += create_new<Path>(stitch_line);
#endif 

   }  /* |if (do_stitch_lines)| (Fifth column)  */

@q ****** (6) Finish and return  @>

   delete nv;

   if (do_stitch_lines)
   {  
       *tv += *sv;
   }

   return static_cast<void*>(tv);  

@q ****** (6)@>

}  /* End of |Rhombic_Triacontahedron::get_tabs| definition.  */

@q **** (4) Version with required |void*| argument only.@>
@*3 Version with required {\bf void*} argument only.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@>

@<Declare |Rhombic_Triacontahedron| functions@>=
static
void*
get_tabs(void* parameter);

@q ***** (5) Definition.@>
@ 
@<Define |Rhombic_Triacontahedron| functions@>=
void*
Rhombic_Triacontahedron::get_tabs(void* parameter)
{
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>
@
@<Define |Rhombic_Triacontahedron| functions@>=

   real rhombus_side_length        = 4;
   bool do_half                    = false;
   bool do_stitch_lines            = true;
   unsigned short stitch_divisions = 5;

   if (scanner_node && scanner_node->polyhedron_options)
   {
       rhombus_side_length = scanner_node->polyhedron_options->rhombus_0_side_length;
       do_half             = scanner_node->polyhedron_options->do_half;
       do_stitch_lines     = scanner_node->polyhedron_options->do_stitch_lines;
       stitch_divisions    = scanner_node->polyhedron_options->stitch_divisions;

       delete scanner_node->polyhedron_options;
       scanner_node->polyhedron_options = 0;
       
   }  /* |if|  */

@q ****** (6)@>
@
@<Define |Rhombic_Triacontahedron| functions@>=

   return get_tabs(rhombus_side_length,
                   do_half,
                   do_stitch_lines,
                   stitch_divisions,
                   parameter);

}  /* End of |Rhombic_Triacontahedron::get_tabs| definition.  */

@q * (1) Putting |class Rhombic_Triacontahedron| together.@>
@ Putting {\bf class Rhombic\_Triacontahedron} together.

\immediate\write\functexifile{^^JEnd of file:  rhtchdrn.web^^J}

@ This is what's compiled.
@c
@<Include files@>@;
@<Declare |class Rhombic_Triacontahedron|@>@;
@<Define |static const Rhombic_Triacontahedron| data members@>@;
@<Define |Rhombic_Triacontahedron| functions@>@;

@ This is what's written to \filename{rhtchdrn.h}. 
@(rhtchdrn.h@>=
@<Declare |class Rhombic_Triacontahedron|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>

