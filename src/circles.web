@q circles.web @>
                       
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,            @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at:     @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@** Circle\quad ({\tt circles\PERIOD web}).\hfil 

It won't be possible to make circles recede to the
central vanishing point.  @:!!@> !! Get quote from book!!

\LOG
\initials{LDF 2003.11.12.}  Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.01.}  Put the version control identifiers back
into the release versions, because I've put them in their own RCS repository.
\ENDLOG

@f Circle Shape  

@q * Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"   
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++" 
#include "ellipses.h++" 
  
@q * (1) Circle class definition.@>
@* {\bf Circle} class definition.

\LOG
\initials{LDF 2004.10.18.}
Added |friend| declaration for |Path::is_circular|.
\ENDLOG 

@<Define |class Circle|@>=
class Circle : public Ellipse
{

  friend bool Path::is_circular(Scanner_Node scanner_node) const; 

  real radius;

 public:
  @<Declare |Circle| functions@>@;
};

@q * (1) Constructors and setting functions.@>
@* Constructors and setting functions.@>

@q ** (2) Default constructor.  No arguments.@>
@*1 Default constructor. No arguments.
@^\cfunc{Circle}{Circle}@>

\LOG
\initials{LDF 2004.06.18.}  
Now setting |dash_pattern| and |pen| to 0.

\initials{LDF 2005.01.24.}
Now setting |shape_type = CIRCLE_TYPE|.

\initials{LDF 2005.03.18.}
Now setting |pen_vector| and |dash_pattern_vector| to 0 rather than
|pen| and |dash_pattern|, which I've removed.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare |Circle| functions@>=
Circle(void);

@q *** (3) Definition.  @>

@
@<Define |Circle| functions@>= 
Circle::Circle(void)
{

   shape_type = CIRCLE_TYPE;

   surface_hiding_ctr = 0;

   decomposition_level = 0;

   line_switch = false;
   cycle_switch = true;    
   dash_pattern_vector = 0;
   pen_vector = 0; 
}

@q ** (2) Center, diameters and angles. @>
@*1 Center, diameters and angles.
\initials{LDF Undated.}

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Circle}{Circle}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.06.18.}  
Now setting |dash_pattern| and |pen| to 0.

\initials{LDF 2005.01.24.}
Now setting |shape_type = CIRCLE_TYPE|.

\initials{LDF 2005.03.18.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.
Formerly, I set |pen| and |dash_pattern| to 0, but I've removed them.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Circle| functions@>=
Circle(const Point& ccenter,
       const real ddiameter,
       const real angle_x = 0,
       const real angle_y = 0,
       const real angle_z = 0,
       const unsigned short nnumber_of_points = DEFAULT_NUMBER_OF_POINTS);

@q **** (4) Definition.  @>

@
@<Define |Circle| functions@>= 
Circle::Circle(const Point& ccenter, const real ddiameter, const real angle_x,
              const real angle_y, const real angle_z, 
              const unsigned short nnumber_of_points)
     : radius(ddiameter / 2)

{
   shape_type = CIRCLE_TYPE;
   surface_hiding_ctr = 0;

   decomposition_level = 0;

   line_switch = false;
   cycle_switch = true;
   pen_vector = 0; 
   dash_pattern_vector = 0;
   center = ccenter;
   center.apply_transform();

   axis_h = axis_v = ddiameter;
  
   number_of_points = nnumber_of_points;

   Ellipse e(center, axis_h, axis_v, angle_x, angle_y, angle_z,
             number_of_points);
   *this = e;

}

@q ** (2) @>

@q *** (3) Setting function.@>
@*2 Setting function.
@^\cfunc{Circle}{set}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.05.06.}  
Added the argument
|nnumber_of_points|.  Without it, this setting function didn't match
the constructor above. 
\ENDLOG 

@<Declare |Circle| functions@>=

void
set(const Point& ccenter, const real ddiameter, const real angle_x = 0,
    const real angle_y = 0, const real angle_z = 0,
    const unsigned short nnumber_of_points = DEFAULT_NUMBER_OF_POINTS);

@
@<Define |Circle| functions@>= 
void
Circle::set(const Point& ccenter, const real ddiameter, const real angle_x,
            const real angle_y, const real angle_z, 
            const unsigned short nnumber_of_points) 

{
  Circle c(ccenter, ddiameter, angle_x, angle_y, angle_z, nnumber_of_points);
  *this = c;
  return;
}

@q * (1) Pseudo-constructor for dynamic allocation.@>
@* Pseudo-constructor for dynamic allocation.

@q ** (2) Pointer argument.@>
@*1 Pointer argument.
@^\cfunc{Circle}{create\_new\_circle}@>

\LOG
\initials{LDF 2003.07.27.}  
Made non-inline.  Made argument |p| |const Circle*|. 

\initials{LDF 2003.08.10.}  
Removed redefinition of the default argument |const
Circle* p = 0| from the definition.  The DEC compiler complained, 
but GCC didn't.

\initials{LDF 2003.12.30.}  
Replaced |Circle::create_new_circle|
with a specialization of |template <class C> C* create_new| for
|Circle|. 

\initials{LDF 2003.12.30.}  
Changed the argument.  It's now a |const Circle*|. 

\initials{LDF 2003.12.30.}  
Removed default argument ``0'', because
this caused a compiler error when using the DEC \CPLUSPLUS/ compiler.
Apparently, it suffices to declare a default argument in the template
declaration. 

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Circle|@>=
Circle* 
create_new(const Circle* c, Scanner_Node scanner_node);

@q ** (2) Reference argument.@>
@*1 Reference argument.

\LOG
\initials{LDF 2003.07.27.}  
Made non-inline.

\initials{LDF 2003.12.30.}  
Replaced |Circle::create_new_circle|
with a specialization of |template <class C> C* create_new| for
|Circle|. 

\initials{LDF 2003.12.30.}  
Changed argument from |Circle| to |const Circle&|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare non-member template functions for |Circle|@>=
Circle* 
create_new(const Circle& c, Scanner_Node scanner_node);

@q * Destructor. @>
@* Destructor. 
\initials{LDF 2002.10.09.}  Removed the destructor.  |Path::~Path| or
|Path::clear|\newline
should be used instead, unless I add dynamically
allocated data members to |Circle| (rather than |Ellipse| 
or |Path|).

@q * (1) Assignment.@>

@* Assignment.@>

@q ** (2) Circle argument.@>

@*1 {\bf Circle} argument.@>
@^\cofunc{Circle}{=}@>
This function returns a reference to |*this|, which can be used for
further assignment. 

\LOG
\initials{LDF 2002.11.10.}  
Changed and simplified this function.  It now uses 
|Ellipse::operator=|.
\ENDLOG 

@<Declare |Circle| functions@>=
Circle&
operator=(const Circle& c);

@
@<Define |Circle| functions@>= 
Circle&
Circle::operator=(const Circle& c)
{
  radius = c.radius;
  Ellipse::operator=(c);
  return *this;
}

@q ** (2) Ellipse argument.@>
@*1 {\bf Ellipse} argument.@>
@^\cofunc{Circle}{=}@>
This function returns a reference to |*this|, which can be used for
further assignment. 

If |e.axis_v != e.axis_h|, it's quite possible that the
difference is negligible, and the result of 
imprecision resulting from
the representation of floating point numbers, or calculations
performed on them.
Therefore, we compare the absolute value
of their difference with |Point::epsilon| instead of checking
whether they're equal.  \initials{LDF 2003.08.14.}

It's also possible that one of them has an integer value,
i.e., it has only zeroes following the
decimal point, and the other deviates by a small amount.  In this
case, we want to set |radius| to half of the former, because it's
probably the correct value.  So, if |e_axis_v == floor(e_axis_v)|, we
set |radius| to |e_axis_v / 2|.  Otherwise, we set |radius| to 
|e_axis_h| without further ado.  If |e_axis_h == floor(e_axis_h)|, so
much the better, and if it isn't, neither it nor |e_axis_v| has an
integer value, so it doesn't matter which one we use to set |radius|. 
\initials{LDF 2003.08.14.}

\LOG
\initials{LDF 2002.11.10.}  Changed and simplified this function.  It now uses 
|Ellipse::operator=|.

\initials{LDF 2003.08.14.}  Added code for handling the case that |e.axis_v| and 
|e.axis_h| differ by a small amount, possible due to imprecision (see below).
\ENDLOG 

@q *** Declaration.  @>

@<Declare |Circle| functions@>=
Circle&
operator=(const Ellipse& e);

@q *** Definition.  @>

@
@<Define |Circle| functions@>= 
Circle&
Circle::operator=(const Ellipse& e)
{
  real e_axis_v = e.get_axis_v();
  real e_axis_h = e.get_axis_h();
  if (e_axis_v != e_axis_h)
    {
      if (fabs(e_axis_v - e_axis_h) > Point::epsilon())
        {
          cerr << "ERROR! In Circle::operator=(Ellipse).\n"
               << "Ellipse has unequal axes. "
               << "Can't perform assignment. Returning.\n\n";
          return *this;
        }
      else if (e_axis_v == floor(e_axis_v))
        radius = e_axis_v / 2.0;
      else 
        radius = e_axis_h / 2.0;
    }
  else
      radius = e.get_axis_v() / 2.0;

  Ellipse::operator=(e);

  return *this;
}

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Circle}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Circle| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Circle| functions@>=
Shape*
Circle::get_copy() const
{
  Circle* p = create_new<Circle>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q * (1) Transformations.@> 

@* Transformations. 

\LOG
\initials{LDF 2004.11.07.}
Added this section.
\ENDLOG 

@q ** (2) Performing a transformation. @>
@*1 Performing a transformation.

@q *** (3) Do transform. @>
@*2 Do transform.
@^\cofunc{Circle}{do\_transform}@>
\initials{LDF 2004.11.07.}
This function performs a transformation on |*this|.  

If |check == true|, |is_circular| is called on |*this| following
the transformation.
If the latter causes |*this| to
become non-circular, |radius| is set to
|INVALID_REAL| and a warning is issued to |stderr|.  
However, |center| is not set to |INVALID_POINT|.  It may
no longer really be the center of the (non-circular) |Circle|, 
but may have some use for the programmer and/or user.

If |check == true|, and the transformation does not cause |*this| to
become non-circular, |radius| is recalculated.

\LOG
\initials{LDF 2004.11.07.}
Added this function.  I could probably do without it, because
|Circle::is_circular|, unlike |Ellipse::is_elliptical|, doesn't
need to perform any transformations.  However, it may be convenient to
be able to call this function on a |Circle| by means of an |Ellipse*|.

\initials{LDF 2004.11.12.}
Turned off the warning that was issued when a transformation made
|*this| non-circular.
\ENDLOG

@q **** (4) Declaration. @>

@<Declare |Circle| functions@>=
virtual
Transform
do_transform(const Transform& t, bool check = false);

@
@<Define |Circle| functions@>=
Transform
Circle::do_transform(const Transform& t, bool check)
{

    bool DEBUG = false; /* true */ 

    center *= Path::operator*=(t);
   
    real old_radius = radius;

   if (check)
     {
         if (is_circular())
           {
               Point c = get_center();
               radius = (get_point(0) - c).magnitude();
           
           }  /* |if (is_circular())|  */
 
       else
         {
#if 0 
           cerr << "WARNING! In Circle::do_transform(const Transform&):\n"
                << "This transformation has made *this non-circular!"
                 << endl;
#endif 

           radius = INVALID_REAL;
         }

     }  /* |if (check)|  */

   return t;

}  /* End of |Circle::do_transform| definition.  */

@q *** (3) Multiplication with assignment operator.@>
@*2 Multiplication with assignment operator.
@^\cofunc{Circle}{*=}@>
\initials{LDF 2004.11.07.}

\LOG
\initials{LDF 2004.11.07.}
Added this function.
\ENDLOG 

@<Declare |Circle| functions@>=
virtual
Transform
operator*=(const Transform& t);

@
@<Define |Circle| functions@>=
Transform
Circle::operator*=(const Transform& t)
{
  return do_transform(t, true);
}

@q ** (2) Standardize.@> 
@*1 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.  It currently has a dummy definition.

\initials{LDF 2005.11.27.}
Changed return type from |Transform| to |Transform*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Circle| functions@>=
virtual
Transform*
standardize(Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Circle| functions@>=
Transform*
Circle::standardize(Scanner_Node scanner_node) const
{
    Transform* t = 0;

    return t;
}

@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Circle}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Circle| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.
Following a system update, 
having |Shape*| as the return value no longer worked.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Circle| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Circle| functions@>=
int
Circle::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Circle* circle_reflection = static_cast<Circle*>(v);  

@q *** (3) If |circle_reflection == static_cast<Circle*>(0)|, try to allocate memory @>
@q *** (3) on the free store for it.                                                 @> 

@ If |circle_reflection == static_cast<Circle*>(0)|, try to allocate memory 
on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Circle| functions@>=

 if (circle_reflection == static_cast<Circle*>(0))
 {
  try
     {
       circle_reflection = create_new<Circle>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Circle| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Circle| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Point::reflect_in()':" 
                 << endl
                 << "`create_new<Circle>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (circle_reflection == static_cast<Circle*>(0))|  */

@q *** (3) Call |Ellipse::reflect_in|.@> 

@ Call |Ellipse::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>=

  Ellipse ellipse_reflection;

  int status;

  try
     {
       status = Ellipse::reflect_in(p,
                            static_cast<void*>(&ellipse_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Ellipse::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Ellipse::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Circle::reflect_in():'"
                 << endl 
                 << "`Ellipse::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `circle_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete circle_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Ellipse::reflect_in| returned 1.@> 

@ Error handling:  |Ellipse::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Circle| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Circle::reflect_in():'"
                << endl 
                << "`Ellipse::reflect_in()' failed and returned 1."
                << endl << "Deleting `circle_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete circle_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Ellipse::reflect_in| succeeded.@> 

@ |Ellipse::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Circle::reflect_in()':"
                  << endl << "`Ellipse::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   circle_reflection->Ellipse::operator=(
                            ellipse_reflection);

@q *** (3) Set other data members of |*circle_reflection|.@> 

@ Set other data members of |*circle_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>=

  circle_reflection->radius  = radius; 

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Circle| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Circle::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Circle::reflect_in| definition.  */

@q * (1) Returning elements and information.@>
@* Returning elements and information.

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Circle| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return CIRCLE_TYPE;
}

@q ** (2) Is |Circle|.@> 
@*1 Is {\bf Circle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Circle| functions@>=
virtual
inline
bool
is_circle(void) const 
{
   return true;
}

@q ** (2) Is circular.@>
@*1 Is circular.

@q *** (3) |Path| version.@> 
@*2 {\bf Path} version.
@^\cfunc{Path}{is\_circular}@>
\initials{LDF 2004.10.16.}

\LOG
\initials{LDF 2004.10.16.}
Added this function.  It is declared in \filename{paths.web}.
It must be defined in this file (\filename{circles.web}), 
because it uses a |Circle|, which is an incompletely defined 
type in \filename{paths.web}.
\ENDLOG

@q **** (4) Definition.@> 
  
@
@<Define |Path| functions@>=
bool
Path::is_circular(Scanner_Node scanner_node) const
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q ***** (5) Error handling:  |*this| is non-planar.@> 

@ Error handling:  |*this| is non-planar.
\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  if (!is_planar())
    {

#if DEBUG_COMPILE
     if (DEBUG)
       {
           cerr_strm << thread_name << "In Path::is_circular(): "
                     << endl 
                     << "`*this' is non-planar. Returning false.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */ 
           
        return false;

    } /* |if (!is_planar())|  */

@q ***** (5) Error handling:  |points.size() % 4 != 0|.@> 

@ Error handling:  |points.size() % 4 != 0|.
Of course, a |Path| which fulfills this condition might 
still be circular.  However, it would be harder to test this.

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.10.16.}
Rewrite this function so that it can test arbitrary |Paths|.
\ENDTODO 

\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  if (points.size() % 4 != 0)
     {
#if DEBUG_COMPILE
       if (DEBUG)
         {
             cerr_strm << thread_name << "In Path::is_circular(): "
                       << endl 
                       << "`points.size()' % 4 != 0. Returning false.";

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */ 
           
        return false;
        
     } /* |if (points.size() % 4 != 0)|  */

@q ***** (5) Create a |Circle| using the |Points| on |points| @> 
@q ***** (5) and test whether it's circular.                  @> 

@ Create a |Circle| using the |Points| on |points|
and test whether it's circular.
\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

@q ***** (5) Create an |Circle| using the |Points| on |points| @> 
@q ***** (5) and test whether it's circular.                  @> 

@ Create an |Circle| using the |Points| on |points|
and test whether it's circular.
\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  Circle c;

  c.number_of_points = points.size();

  for (vector<Point*>::const_iterator iter = points.begin();
       iter != points.end();
       iter++)
     {
        c += **iter;

     } /* |for|  */

  for (vector<Connector_Type*>::const_iterator iter = connector_type_vector.begin();
       iter != connector_type_vector.end(); 
       iter++)
  {
     c += *iter;

  } /* |for|  */

  Point p0 = get_point(0);
  Point p_half = get_point(points.size() / 2);

  c.center = p0.mediate(p_half);

  return c.is_circular();

} /* End of |Path::is_circular| definition.  */

@q *** (3) |Circle| version.@> 
@*2 {\bf Circle} version.

@^\cfunc{Circle}{is\_circular}@>

This function tests whether |*this| is circular.  
Operations such as |scale| and |shear| can cause |Circles| 
to become non-circular. 
\initials{LDF 2003.07.25.}

|is_circular| first tests whether |*this| is planar using
|is_planar|.  If it's not, |false| is returned.  Otherwise, the
|Point p| is set to |*(points[0])|, and |Point c = get_center| is 
is subtracted from |p|.  |p.magnitude| is then stored in 
|real mag0|.  \initials{LDF 2003.07.25.}

Then, |p| is set to each of the other |Points| on the |Circle| in
turn, |c| is subtracted from |p|, and |p.magnitude| is stored in
|real mag|.  If the absolute value of the difference |mag - mag0| is
greater than |Point::epsilon|, |is_circular| immediated returns
|false|.  If |fabs(mag - mag0) <= Point::epsilon| for all of the
|Points *(points[n])| for $n > 0$, |is_circular| returns |true|.  
\initials{LDF 2003.07.25.}

\LOG
\initials{LDF 2003.07.25.}  
Added this function.

\initials{LDF 2009.09.16.}
Added the optional |Scanner_Node scanner_node| argument.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Circle| functions@>=
bool
is_circular(Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 

@
@<Define |Circle| functions@>=
bool
Circle::is_circular(Scanner_Node scanner_node) const
{
@q ***** (5) @>

#if DEBUG_COMPILE

         bool DEBUG = false; /* |true| */ 

   if (DEBUG)
     {
         cerr << "Entering Circle::is_circular().\n";

     }
#endif /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   if (!is_planar())
   {
#if DEBUG_COMPILE
       if (DEBUG)
       cerr << "In Circle::is_circular(): "
            << "*this is non-planar. Returning false."
            << endl << endl;

#endif /* |DEBUG_COMPILE|  */ 

       return false;
   }

@q ***** (5) @>

    Point p;
    Point c = get_center();
    real mag0;
    real mag;
  vector<Point*>::const_iterator iter = points.begin();

    p = **iter++ - c;
    mag0 = p.magnitude();

    for (int i = 1; iter != points.end(); ++iter)
      {
          p = **iter - c;
          mag = p.magnitude();
          if (fabs(mag - mag0) > Point::epsilon())
            {
#if DEBUG_COMPILE

                if (DEBUG)
                  cerr << "Point " << i << " doesn't lie on Circle.\n"
                       << "Exiting Circle::is_circular().\n"
                       << "Returning false.\n";

#endif /* |DEBUG_COMPILE|  */ 

                return false;
            }
          ++i;
      }

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "Exiting Circle::is_circular(). Returning true." << endl;
     }
#endif /* |DEBUG_COMPILE|  */ 
 
    return true;

}  /* |Circle::is_circular|  */

@q ** (2) Is whatever.@>
@*1 Is whatever.
@^\cfunc{Circle}{is\_whatever}@>

\LOG
\initials{LDF 2004.09.08.}
Added this function.
\ENDLOG 

@<Declare |Circle| functions@>=
inline
virtual
bool
is_whatever(void) const
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
       cerr_mutex.lock(); 
       cerr << "Entering `Circle::is_whatever()'." << endl;
       cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return is_circular();
}

@q ** (2) Get radius.@>
@ Get radius.
@^\cfunc{Circle}{get\_radius}@>
\LOG
\initials{LDF 2002.05.10.}  Added this function.
\ENDLOG 
@<Declare |Circle| functions@>=
inline 
real
get_radius()
{
    return radius;
}

@q ** (2) Get diameter.@>
@ Get diameter.
@^\cfunc{Circle}{get\_diameter}@>
\initials{LDF 2002.05.10.}  Added this function.
@<Declare |Circle| functions@>=
inline 
real
get_diameter()
{
    return (2 * radius);
}

@q ** (2) Get circumference.@>
@ Get circumference.
@^\cfunc{Circle}{get\_circumference}@>

\LOG
\initials{LDF 2009.09.16.}
Added this function.
\ENDLOG 
 
@<Declare |Circle| functions@>=
real
get_circumference(Scanner_Node scanner_node = 0);

@
@<Define |Circle| functions@>=
real
Circle::get_circumference(Scanner_Node scanner_node)
{
    return is_circular(scanner_node) ? (2 * PI * radius) : INVALID_REAL;
      
}

@q ** (2) Get arc_length.@>
@ Get arc_length.
@^\cfunc{Circle}{get\_arc_length}@>
\initials{LDF 2021.6.28.}

\LOG
\initials{LDF 2021.6.28.}
Added this function.
\ENDLOG 
 
@q *** (3) Declaration @>

@<Declare |Circle| functions@>=
real
get_arc_length(real angle, Scanner_Node scanner_node = 0);

@q **** (4) Definition @>
@
@<Define |Circle| functions@>=
real
Circle::get_arc_length(real angle, Scanner_Node scanner_node)
{
@q ***** (5) @>

   bool DEBUG = false; /* |true| */

   real arc_length = 0.0;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Entering `Circle::get_arc_length'." << endl 
           << "`angle' == " << angle
           << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Circle| functions@>=

   if (angle == 0.0)
   {
      cerr << "WARNING!  In `Circle::get_arc_length':" << endl 
           << "Argument `real angle' == 0:  Can't calculate arc length."
           << endl
           << "Exiting function unsuccessfully with return value 0."
           << endl;

      return 0.0;

   } 

@q ***** (5) @>
@
@<Define |Circle| functions@>=

   if (!is_circular())
   {
      cerr << "WARNING!  In `Circle::get_arc_length':" << endl 
           << "`Circle::is_circular' returned `false':" << endl
           << "`Circle' isn't circular.  Can't calculate arc length."
           << endl
           << "Exiting function unsuccessfully with return value 0."
           << endl;

      return 0.0;

   } 

@q ***** (5) @>
@
@<Define |Circle| functions@>=

   if (angle < 0.0)
   {
      cerr << "WARNING!  In `Circle::get_arc_length':" 
           << endl 
           << "Argument `real angle' < 0:  Converting to absolute value (i.e., " << -angle << ")."
           << endl;

#if LDF_REAL_FLOAT
      angle = fabsf(angle);
#elif LDF_REAL_DOUBLE
      angle = fabs(angle);
#else /* Default.  */
      angle = fabsf(angle);
#endif

   } 

@q ***** (5) @>
@
@<Define |Circle| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
      cerr << "In `Circle::get_arc_length':" << endl 
           << "`Circle::is_circular' returned `true':" 
           << endl
           << "`Circle' is circular."
           << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Circle| functions@>=

   arc_length = (2 * PI * radius * angle) / 360.0;
      
@q ***** (5) @>

  return arc_length;    

}  /* End of |Circle::get_arc_length| definition */


@q * (1) Locations.@>
@* Locations.
\initials{LDF 2007.08.26.}

\LOG
\initials{LDF 2007.08.26.}
Added this section.
\ENDLOG

@q ** (2) Location of a |Point| with respect to a |Circle|.@>
@*1 Location of a {\bf Point} with respect to a {\bf Circle}.
@^\cfunc{Circle}{location}@>
\initials{LDF 2007.08.26.}

The return values are as follows:
\BRVS{-1}

\RV{0}\relax   The |Point| argument $P$ lies on the perimeter of the |Circle|. 

\RV{-1}\relax  $P$ lies outside the |Circle|.

\RV{1}\relax   $P$ lies inside the perimeter of the |Circle|.

\RV{-2}\relax  $P$ is not in the same plane as the |Circle|.  

\RV{-3}\relax  The |Circle| is non-circular.

\ERVS

\LOG
\initials{LDF 2007.08.26.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Circle| functions@>=
virtual 
signed short
location(const Point& p, 
         real tolerance = -1, 
         Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@>
@
@<Define |Circle| functions@>=
signed short
Circle::location(const Point& p, 
                 real tolerance,
                 Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (!is_circular())
    {
          cerr_strm << thread_name << "ERROR! In `Circle::location':"
                    << endl 
                    << "Circle is non-circular. Returning -3.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return -3;

    }  /* |if (!is_circular())|  */

@q **** (4)@>

    if (tolerance < 0)
       tolerance = .0001;

    if (!p.is_on_plane(get_plane(), tolerance))
    {
        cerr_strm << thread_name << "WARNING! In `Circle::location':"
               << endl 
              << "Point doesn't lie in plane of the circle."
              << endl 
              << "Returning -2.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");

        return -2;

    }  /* |if|  */

@q **** (4)@>

    real mag = (p - center).magnitude();

    if (fabs(mag - radius) < tolerance)
       return 0;
    else if (mag < radius)
       return 1;
    else 
       return -1;

@q **** (4)@>

}  /* End of |Circle::location| definition.  */

@q * (1) Intersections. @>
@* Intersections.

Neither GCC nor the DEC compiler could resolve a call
to |intersection_points| with |Point| arguments to
|Ellipse::intersection_points|, after a |Circle| version with a 
|Circle| argument had been declared.  
@:!! TO DO@> TO DO: 
I didn't think this would
happen, so I should probably review the rules governing resolution of
calls to functions on objects of derived classes.  \initials{LDF 2003.07.09.}  

Therefore, I've added |Circle| versions of this function, 
with |Point| and |Path|
arguments, that simply call the |Ellipse| versions, and return their
return values.  This solves the problem.  \initials{LDF 2003.07.09.}

The program executed correctly under Linux, after I recompiled with
GCC.  However, under Tru65, the program caused a ``Memory fault''
error.  After I removed the object files, and recompiled (with the DEC
compiler), the problem disappeared.  \initials{LDF 2003.07.09.}

\initials{LDF 2003.07.18.}  @:!! TO DO@> TO DO:  Add
|Circle::intersection_points(const Ellipse&)| and\newline 
|Ellipse::intersection_points(const Circle&)|.

@q ** (2) |Point| arguments.@>
@*1 {\bf Point} argument.
@^\cfunc{Circle}{intersection\_points}@>

\LOG
\initials{LDF 2003.07.09.}  
Added this function.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Circle| functions@>=
virtual 
Bool_Point_Pair
intersection_points(const Point& pt0, const Point& pt1) const;   

@q *** (3) Definition.@>
@
@<Define |Circle| functions@>=
Bool_Point_Pair
Circle::intersection_points(const Point& pt0, const Point& pt1) const   
{
    return Ellipse::intersection_points(pt0, pt1);
}

@q ** (2) Path argument.@>
@*1 {\bf Path} argument.  
@^\cfunc{Circle}{intersection\_points}@>

\LOG
\initials{LDF 2003.07.09.}  
Added this function.
\ENDLOG 

@<Declare |Circle| functions@>=
virtual
Bool_Point_Pair
intersection_points(const Path& p, Scanner_Node scanner_node = 0) const;

@
@<Define |Circle| functions@>=
Bool_Point_Pair
Circle::intersection_points(const Path& p, Scanner_Node scanner_node) const
{
  return Ellipse::intersection_points(p);
}

@q ** (2) |Circle| argument.@>
@*1 {\bf Circle} argument.
@^\cfunc{Circle}{intersection\_points}@>

\initials{LDF 2004.09.08.}
DO NOT change return type of this function to |Bool_Point_Pair|!
It's true that two non-congruent circles can intersect at 
two points at most.  However, using |Bool_Point_Quadruple| as the
return value makes it possible to use this function in the template
function |Scan_Parse::intersection_points_ellipse_like|.

\LOG
\initials{LDF 2003.07.20.}  
Wrote the definition of this function.  Tested all
cases.  It should probably be tested more thoroughly. 

\initials{LDF 2003.08.14.}  
Made |verbose| argument non-|const|.
Setting |verbose| to |true| if |VERBOSE_GLOBAL| is
|true|.  Added |VERBOSE_GLOBAL| to \filename{pspglb.web} today.

\initials{LDF 2003.08.27.}  
Removed the declaration |real c_radius = c.radius|,
since |c_radius| was never used.

\initials{LDF 2004.11.06.}
Replaced the |bool verbose| argument with 
|Scanner_Node scanner_node = 0|.
Made error and debugging output thread-safe.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Circle| functions@>=
virtual 
Bool_Point_Quadruple
intersection_points(const Circle& c, 
                    Scanner_Node scanner_node = 0) const;  
  
@
@<Define |Circle| functions@>=

Bool_Point_Quadruple
Circle::intersection_points(const Circle& c,
                            Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@> 

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */
   if (DEBUG)
      {
          bool DEBUG = false; /* |true| */
      }
#endif /* |DEBUG_COMPILE|  */ 

  using namespace Scan_Parse;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;

@q **** (4).@> 

#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name << "Entering "
                    << "`Circle::intersection_points(const Circle& ...)'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str();
      }
#endif /* |DEBUG_COMPILE|  */ 

  Bool_Point_Quadruple bpq = INVALID_BOOL_POINT_QUADRUPLE;

  Plane this_plane = get_plane();
  Plane c_plane = c.get_plane();

@q **** (4) |Circles| are non-coplanar.           @> 
@q **** (4) Call |Ellipse::intersection_points|.@> 

@ |Circles| are non-coplanar.  Call 
|Ellipse::intersection_points|. 
\initials{LDF 2004.11.06.}

\LOG
\initials{LDF 2005.11.03.}
Now casting |Circle c| to |Ellipse|.  This became necessary because I've added a 
|Scanner_Node scanner_node| argument to the version of |Ellipse::intersection_points|
that takes a |const Path& p| argument.
\ENDLOG 

@<Define |Circle| functions@>=

/* !! START HERE.  LDF 2004.10.25.  I think this function doesn't work 
   quite right.  The following conditional doesn't catch the case of 
   parallel planes.  */@; 

  if (!(this_plane.normal == c_plane.normal
        || this_plane.normal == -c_plane.normal))
    {

#if DEBUG_COMPILE
       if (DEBUG)
         {
             cerr_strm << thread_name 
                       << "In `Circle::intersection_points(const Circle& ...)':"
                       << endl 
                       << "Circles are non-coplanar. "
                       << "Calling `Ellipse::intersection_points()'.";

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str();
         } 
#endif /* |DEBUG_COMPILE|  */ 

      bpq = Ellipse::intersection_points(static_cast<Ellipse>(c), scanner_node);

#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "Exiting `Circle::intersection_points(const Circle&)'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str();
      }
#endif /* |DEBUG_COMPILE|  */ 

      return bpq;

    }  /* |if (!(   this_plane.normal == c_plane.normal
                 || this_plane.normal == -c_plane.normal))|  */

@q **** (4) |Circles| are coplanar.@> 

@ |Circles| are coplanar.
\initials{LDF 2004.11.06.}

@<Define |Circle| functions@>=

  else  /* |(   this_plane.normal == c_plane.normal
             || this_plane.normal == -c_plane.normal)|  */
    {

#if DEBUG_COMPILE
        if (DEBUG)
          {
             cerr_strm << thread_name 
                       << "In `Circle::intersection_points(const Circle& ...)':"
                       << endl
                       << "Circles are coplanar.";

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str();
          }
#endif /* |DEBUG_COMPILE|  */ 

      real dist = (c.center - center).magnitude();

#if DEBUG_COMPILE
      if (DEBUG)
         {
            cerr_strm << thread_name 
                      << "In `Circle::intersection_points(const Circle& ...)':"
                      << endl
                      << "dist == " << dist << ".";
            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str();
         }
#endif /* |DEBUG_COMPILE|  */ 

@q ***** (5) Circles have the same center.@> 

@ Circles have the same center.
\initials{LDF 2004.11.06.}     

@<Define |Circle| functions@>=

      if (dist == ZERO_REAL)
        {
#if DEBUG_COMPILE
           if (DEBUG)
              {
                 cerr_strm << thread_name 
                           << "In `Circle::intersection_points(const Circle& ...)':"
                           << endl
                           << "Circles have the same center.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm);
                 cerr_strm.str(); 
              }
#endif /* |DEBUG_COMPILE|  */ 

@q ****** (6) |radius == c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.@> 

@ |radius == c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.
\initials{LDF 2004.11.06.}     

@<Define |Circle| functions@>=

          if (radius == c.radius)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                  { 

                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl                          
                               << "Circles are congruent. "
                               << "Returning `INVALID_BOOL_POINT_QUADRUPLE'."; 

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();      
                  }
#endif /* |DEBUG_COMPILE|  */ 

              return INVALID_BOOL_POINT_QUADRUPLE;

            } /* |if (radius == c.radius)|  */

@q ****** (6) |radius > c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.@> 

@ |radius > c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.
\initials{LDF 2004.11.06.}     

@<Define |Circle| functions@>=

          else if (radius > c.radius)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl
                               << "`*this' surrounds `c'. No intersections."
                               << endl 
                               << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();     
                  }
#endif /* |DEBUG_COMPILE|  */ 

               return INVALID_BOOL_POINT_QUADRUPLE;

            }  /* |else if (radius > c.radius)|  */

@q ****** (6) |radius < c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.@> 

@ |radius < c.radius|.  Return |INVALID_BOOL_POINT_QUADRUPLE|.
\initials{LDF 2004.11.06.}     

@<Define |Circle| functions@>=

          else if (radius < c.radius)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl
                               << "`c' surrounds `*this'. No intersections."
                               << endl 
                               << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();     
                  }
#endif /* |DEBUG_COMPILE|  */ 

               return INVALID_BOOL_POINT_QUADRUPLE;

            }  /* |else if (radius < c.radius)|  */

@q ****** (6).@> 

        } /* |if (dist == ZERO_REAL)| */
      
@q ***** (5) |dist > (radius + c.radius)|.@> 

@ |dist > (radius + c.radius)|.
\initials{LDF 2004.11.06.}

@<Define |Circle| functions@>=

      else if (dist > (radius + c.radius))
        {
  
#if DEBUG_COMPILE
   if (DEBUG)
      {
           cerr_strm << thread_name 
                     << "In `Circle::intersection_points(const Circle& ...)':"
                     << endl
                     << "`*this' and `c' lie outside of each other. "
                     << "No intersections." << endl 
                     << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str();
      }
#endif /* |DEBUG_COMPILE|  */ 

          return INVALID_BOOL_POINT_QUADRUPLE;

        }  /* |else if (dist > (radius + c.radius))|  */

@q ***** (5) |dist == (radius + c.radius)|.@> 

@ |dist == (radius + c.radius)|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

      else if (dist == (radius + c.radius))
        {
#if DEBUG_COMPILE
          if (DEBUG)
            cerr << "this and c have a tangent on the outside "
                 << "(one intersection point).\n";
#endif /* |DEBUG_COMPILE|  */@; 

          bpq.first.pt.set(c.center - center);
          bpq.first.pt.unit_vector(true);
          bpq.first.pt *= radius;
          bpq.first.pt.shift(center);
          bpq.first.b = true;

#if DEBUG_COMPILE
          if (DEBUG)
             {
                cerr_strm << thread_name 
                          << "Exiting `Circle::intersection_points("
                          << "const Circle&)'.";

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str();
             }      
#endif /* |DEBUG_COMPILE|  */ 

          return bpq;

        } /* |else if (dist == (radius + c.radius))|  */

@q ***** (5) |dist == max(radius, c.radius) - min(radius, c.radius)|.@> 

@ |dist == max(radius, c.radius) - min(radius, c.radius)|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

      else if (dist == max(radius, c.radius) - min(radius, c.radius))
        {

#if DEBUG_COMPILE
           if (DEBUG)
              {
                 cerr_strm << thread_name 
                           << "In `Circle::intersection_points(const Circle& ...)':"
                           << endl
                           << "`*this' and `c' have a tangent on the inside "
                           << "(one intersection point).";
                 log_message(cerr_strm);
                 cerr_message(cerr_strm);
                 cerr_strm.str(); 
              }
#endif /* |DEBUG_COMPILE|  */ 

@q ****** (6) |radius > c.radius|.@> 

@ |radius > c.radius|.
\initials{LDF 2004.11.06.}

@<Define |Circle| functions@>=

          if (radius > c.radius)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl
                               << "`c' lies within `*this'.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();     
                  }           
#endif /* |DEBUG_COMPILE|  */ 

              bpq.first.pt.set(c.center - center);

            } /* |if (radius > c.radius)|  */

@q ****** (6) |radius < c.radius|.@> 

@ |radius < c.radius|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=
          else
            {

#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr_strm << thread_name 
                   << "In `Circle::intersection_points(const Circle& ...)':"
                   << endl
                   << "`*this' lies within `c'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str();
      }
#endif /* |DEBUG_COMPILE|  */ 

              bpq.first.pt.set(center - c.center);

            } /* |else|  */

@q ****** (6).@> 

              bpq.first.pt.unit_vector(true);
              bpq.first.pt *= radius;
              bpq.first.pt.shift(center);
              bpq.first.b = true;

#if DEBUG_COMPILE
              if (DEBUG)
                 {
                     cerr_strm << thread_name << "Exiting "
                               << "`Circle::intersection_points(const Circle&).";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();       
                 }
#endif /* |DEBUG_COMPILE|  */ 

              return bpq;

        } /* |else if (   dist 
                       == max(radius, c.radius) - min(radius, c.radius))|  */

@q ***** (5) |dist < (radius + c.radius)|.@> 

@ |dist < (radius + c.radius)|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

      else if (dist < (radius + c.radius))
        {

@q ****** (6) |dist > max(radius, c.radius) - min(radius, c.radius)|.@> 

@ |dist > max(radius, c.radius) - min(radius, c.radius)|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

         if (dist > max(radius, c.radius) - min(radius, c.radius))
           {

#if DEBUG_COMPILE
                 if (DEBUG)
                    {
                       cerr_strm << thread_name 
                                 << "In `Circle::intersection_points"
                                 << "(const Circle& ...)':"
                                 << endl
                                 << "`*this' and `c' have 2 "
                                 << "intersection points.";

                        log_message(cerr_strm);
                        cerr_message(cerr_strm);
                        cerr_strm.str();         
                    }           
#endif /* |DEBUG_COMPILE|  */ 

             real a = radius;
             real bb = c.radius * c.radius;

             real beta = 2 * atan(sqrt((bb - ((dist - a) * (dist - a))) / 
                                         (((dist + a) * (dist + a)) - bb)));
             beta *= 180 / PI;

#if DEBUG_COMPILE
               if (DEBUG)
                  {        
                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl
                               << "`beta' == " << beta << ".";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str(); 
                  }
#endif /* |DEBUG_COMPILE|  */ 

             Point P(c.center - center);
             P.unit_vector(true);
             P *= radius;
             P.shift(center);
             Point normal = get_normal();
             normal.shift(center);

             bpq.first.b = true;
             bpq.first.pt = P;
             bpq.first.pt.rotate(center, normal, beta);

             bpq.second.b = true;
             bpq.second.pt = P;
             bpq.second.pt.rotate(center, normal, -beta);

#if DEBUG_COMPILE
             if (DEBUG)
                {
                   cerr_strm << thread_name 
                             << "Exiting `Circle::intersection_points"
                             << "(const Circle&)'.";

                   log_message(cerr_strm);
                   cerr_message(cerr_strm);
                   cerr_strm.str();   
                }
#endif /* |DEBUG_COMPILE|  */ 

             return bpq;

           } /* |if (  dist > max(radius, c.radius) 
                     - min(radius, c.radius))|  */

@q ****** (6) |radius > c.radius|.@> 

@ |radius > c.radius|.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

         else if (radius > c.radius)
           {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                     cerr_strm << thread_name 
                               << "In `Circle::intersection_points"
                               << "(const Circle& ...)':"
                               << endl                       
                               << "`c' lies completely within `*this', but they "
                               << "have different centers "
                               << "(no intersections)." << endl 
                               << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str();    
                  }
#endif /* |DEBUG_COMPILE|  */ 

               return INVALID_BOOL_POINT_QUADRUPLE;
    
           } /* |else if (radius > c.radius)|  */

@q ****** (6) The |Circles| have different centers.@> 

@ The |Circles| have different centers.
\initials{LDF 2004.11.07.}

@<Define |Circle| functions@>=

         else
           {

#if DEBUG_COMPILE
               if (DEBUG)     
                  {
                      cerr_strm << thread_name 
                                << "In `Circle::intersection_points"
                                << "(const Circle& ...)':"
                                << endl          
                                << "`*this' lies within `c', different centers "
                                << "(no intersections)." << endl 
                                << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str();
                  }      
#endif /* |DEBUG_COMPILE|  */ 

          return INVALID_BOOL_POINT_QUADRUPLE;

           } /* |else|  */
 
@q ****** (6).@> 

       } /* |else if (dist < (radius + c.radius))|  */

@q ***** (5) .@> 

      else
        {
            cerr_strm << thread_name 
                      << "ERROR! In `Circle::intersection_points"
                      << "(const Circle&)':"
                      << endl 
                      << "This case is unaccounted for." << endl 
                      << "Returning `INVALID_BOOL_POINT_QUADRUPLE'.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str();

          return INVALID_BOOL_POINT_QUADRUPLE;

        } /* |else|  */

@q ***** (5) .@> 

    }  /* |else| (|(   this_plane.normal == c_plane.normal
                    || this_plane.normal == -c_plane.normal)|)  */

    return bpq;

@q **** (4).@> 

}  /* End of |Circle::intersection_points| definition.  */

@q * (1) Showing.@>
@* Showing.
@^\cfunc{Circle}{show}@>
No significant changes.

\LOG
\initials{LDF 2010.12.17.}
Added this function.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Circle| functions@>=

virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1) const;

@
@<Define |Circle| functions@>=
void 
Circle::show(string text, char coords,
              const bool do_persp, const bool do_apply,
              Focus* f, const unsigned short proj,
              const real factor) const

{
   if (text == "")
     text = "Circle:";

   Ellipse::show(text, coords, do_persp, do_apply,
                 f, proj, factor);

   cerr << "radius:  " << radius << endl;

   return;

}  /* End of |Circle::show| definition.  */

@q * (1) Reg_Polygon functions.@>
@* {\bf Reg\_Polygon} functions.
\initials{LDF 2003.06.13.}  The functions in this section are declared in
\filename{polygons.web}.  They must be defined here, because |Circle|
is an incomplete type there.

\LOG
\initials{LDF 2003.06.13.}  
Added this section.  
\ENDLOG 

@q ** (2) Enclosed circle.@>
@*1 Enclosed circle.
@^\cfunc{Reg\_Polygon}{in\_circle}@>

\LOG
\initials{LDF 2003.06.13.}  
Added this function.

\initials{LDF 2003.12.09.}  
Changed call to |Point::mediate| below.  It's now a member function.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@q *** (3) Definition.@> 

@<Define |Reg_Polygon| functions@>=
Circle
Reg_Polygon::in_circle() const
{
    Circle c;
    Point origin_pt(0, 0, 0);

    if (!is_planar())
      {
          cerr << "ERROR! In Reg_Polygon::in_circle():\n"
               << "Reg_Polygon is non-planar.\n"
               << "Returning empty Circle." << endl << endl;
          return c;
      }

    if (points.size() < 3)
      {
          cerr << "ERROR! In `Reg_Polygon::in_circle()':\n"
               << "`Reg_Polygon' has fewer than 3 Points.\n"
               << "Returning empty `Circle'." << endl << endl;
          return c;
      }
    Point mid_pt = points[0]->mediate(*points[1]);
    mid_pt -= center;
    real r = mid_pt.magnitude();
    c.set(origin_pt, 2 * r);
    
    Point normal = get_normal();
    normal.shift(center);
    
    Transform t;
    t.align_with_axis(center, normal, 'y');
    c *= t.inverse();

    return c;
}

@q ** (2) Draw enclosed circle.@>
@*1 Draw enclosed circle.
@^\cfunc{Reg\_Polygon}{draw\_in\_circle}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.05.26.}  
Made |Picture& picture| the first 
argument.  Removed the other version, where |picture| was the first
argument, and which called this version.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |const string ddashed| argument to 
|const Dash_Pattern* ddashed|.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@q *** (3) Definition.@> 

@<Define |Reg_Polygon| functions@>=
Circle
Reg_Polygon::draw_in_circle(Picture& picture, 
                            Pointer_Vector<Color>* ddraw_color_vector,
                            Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                            Pointer_Vector<Pen>* ppen_vector) const
{
  Circle c = in_circle();
  c.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
  return c;
}

@q ** (2) Surrounding circle.@>
@*1 Surrounding circle.
@^\cfunc{Reg\_Polygon}{out\_circle}@>
\initials{LDF 2003.06.13.}  

\LOG
\initials{LDF 2003.06.13.}  
Added this function.

\initials{LDF 2004.06.07.}  
Changed |const string ddashed| argument to 
|const Dash_Pattern* ddashed|.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Reg_Polygon| functions@>=
Circle
Reg_Polygon::out_circle(void) const
{
    Circle c;
    Point origin_pt(0, 0, 0);
    if (!is_planar())
      {
          cerr << "ERROR! In Reg_Polygon::out_circle():\n"
            << "Reg_Polygon is non-planar.\n"
              << "Returning empty Circle." << endl << endl;
          return c;
      }
    if (points.size() < 3)
      {
          cerr << "ERROR! In Reg_Polygon::out_circle():\n"
            << "Reg_Polygon has less than 3 Points.\n"
              << "Returning empty Circle." << endl << endl;
          return c;
      }
    Point normal = get_normal();
    normal.shift(center);

    c.set(origin_pt, 2 * radius);

    Transform t;
    t.align_with_axis(center, normal, 'y');
    c *= t.inverse();
    return c;
}

@q ** (2) Draw surrounding circle.@>
@*1 Draw surrounding circle.
@^\cfunc{Reg\_Polygon}{draw\_out\_circle}@>
\initials{LDF 2003.06.13.}  

\LOG
\initials{LDF 2003.06.13.}  
Added this function.

\initials{LDF 2004.05.26.}  
Made |Picture& picture| the first 
argument.  Removed the other version, where |picture| was the first
argument, and which called this version.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Reg_Polygon| functions@>=
Circle
Reg_Polygon::draw_out_circle(Picture& picture,
                             Pointer_Vector<Color>* ddraw_color_vector,
                             Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                             Pointer_Vector<Pen>* ppen_vector) const
{
  Circle c = out_circle();
  c.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
  return c;
}

@q * (1) Putting Circle together. @>
@* Putting {\bf Circle} together.

This is what's compiled.
@c
@<Include files@>@;
@<Define |class Circle|@>@;
@<Define |Circle| functions@>@;
@<Define |Path| functions@>@;
@<Define |Reg_Polygon| functions@>@;
@<Declare non-member template functions for |Circle|@>@;

@ This is what's written to \filename{circles.h}.
@(circles.h@>=
@<Define |class Circle|@>@;
@<Declare non-member template functions for |Circle|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 70))    @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q mode:abbrev @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
