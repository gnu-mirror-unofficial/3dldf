@q ***** (5) @>

   if (where_option.field == STARS_COMMON_NAME && where_option.relation == EQUAL)
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       { 
          cerr << "where_option.field == STARS_COMMON_NAME && where_option.relation == EQUAL" << endl;
       }              
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) @>

       if (common_name == where_option.comparison_string)
       {
@q ******* (7) @>

#if DEBUG_COMPILE
          if (DEBUG)
          { 
             cerr << "`common_name' == \"" << common_name 
                  << "\" == `where_option.comparison_string' == \"" << where_option.comparison_string << "\""
                  << endl
                  << "Pushing `this' onto a vector."
                  << endl;
          }                
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) @>

          if (where_option.conjunction == 0 || where_option.conjunction == AND)
          {
#if DEBUG_COMPILE
             if (DEBUG)
             { 
                cerr << "where_option.conjunction == 0 || where_option.conjunction == AND"
                     << endl 
                     << "Pushing `this' onto `a_star_vector'."
                     << endl;
             }                    
#endif /* |DEBUG_COMPILE|  */@; 

             a_star_vector.push_back(this);
          }

@q ******* (7) @>

          else if (where_option.conjunction == OR)
          {
#if DEBUG_COMPILE
             if (DEBUG)
             { 
                cerr << "where_option.conjunction == OR"
                     << endl 
                     << "Pushing `this' onto `b_star_vector'."
                     << endl;
             }                    
#endif /* |DEBUG_COMPILE|  */@; 

             b_star_vector.push_back(this);
          }

@q ******* (7) @>

          else 
          {
#if DEBUG_COMPILE
             if (DEBUG)
             { 
                cerr << "WARNING!  `where_option.conjunction' has invalid value:  " 
                     << where_option.conjunction << endl 
                     << "`name_map[where_option.conjunction]' == " << name_map[where_option.conjunction]
                     << endl
                     << "This case hasn't been accounted for." << endl 
                     << "Not pushing `this' onto a vector.  Continuing."
                     << endl;
             }                    
#endif /* |DEBUG_COMPILE|  */@; 

          }

       }  /* |if (common_name == where_option.comparison_string)|  */

@q ****** (6) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       { 
          cerr << "`common_name' == \"" << common_name 
               << "\" != `where_option.comparison_string' == \"" << where_option.comparison_string << "\""
               << endl
               << "Not pushing `this' onto a vector."
               << endl;
       }              
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) @>

   } /* |if| */

@q * (0)@>

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 70))    @>

@q Local Variables: @>
@q mode:CWEB  @>
@q eval:(outline-minor-mode t)  @>
@q abbrev-file-name:"~/.abbrev_defs" @>
@q eval:(read-abbrev-file)  @>
@q End: @>
