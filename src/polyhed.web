@q polyhed.web @>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Polyhedra.@>
@** Polyhedra\quad ({\tt polyhedra\PERIOD web}).\hfil
\initials{LDF 2002.11.12.} 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF Undated.}
Set |center| for |Dodecahedron|, |Icosahedron|,
and |Trunc_Octahedron|.  Find out how to set it for 
|Tetrahedron|.  

\initials{LDF 2002.11.12.} 
Add assignment operators for |Polyhedra|!  The
individual types will need there own, but they can call
|Polyhedron::operator=|. 
\ENDTODO 

\LOG
\initials{LDF 2002.09.26.}  
Created this file.

\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  
Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"  
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"
#include "solids.h++"
#include "solfaced.h++"
 
@q * (1) Polyhedron class definition.@>
@* {\bf Polyhedron} class definition.
\initials{LDF 2002.10.06.}  |Polyhedron| is meant to be used only as a base
class, so there's no need for constructors or setting functions.

@:!! TO DO@> TO DO:  \initials{LDF 2003.08.15.}  If I add any functions, I should
add an explanation to ``{\tt @@node Polyhedron Getstart}'' in
\filename{DOCUMENTATION/gssolfig.texi} about abstract or non-abstract
base classes.

\LOG
\initials{LDF 2002.11.08.}  Got rid of pure |virtual| function 
|Polyhedron::get_net|.  I've made it |static| in the classes derived
from |Polyhedron|, which makes more sense.  |virtual| functions must
be non-|static|.
\ENDLOG 

@f Polyhedron Reg_Polygon
@<Declare |class Polyhedron|@>=
class Polyhedron : public Solid_Faced
{
  protected:
  unsigned short number_of_polygon_types;
  real face_radius;
  real edge_radius;
  real vertex_radius;
 public:
  @<Declare |Polyhedron| functions@>@;
};

@q * (1) Is |Polyhedron|.@> 
@* Is {\bf Polyhedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Polyhedron| functions@>=
virtual
inline
bool
is_polyhedron(void) const 
{
   return true;
}

@q ** (2) Size.@> 
@*1 Is {\bf Polyhedron}.
\initials{LDF 2005.12.20.}

\LOG
\initials{LDF 2005.12.20.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Polyhedron| functions@>=
virtual
unsigned short
size(void) const;

@q *** (3) Definition.@> 

@
@<Define |Polyhedron| functions@>=
unsigned short
Polyhedron::size(void) const 
{
   return reg_polygons.size() + rectangles.size();
}

@q ** (2) Reflection in a |Plane|.@> 
@*1 Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Polyhedron}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Polyhedron| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.  Following a system update, having |Shape*| 
as the return value no longer worked.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Polyhedron| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Polyhedron| functions@>=
int
Polyhedron::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Polyhedron* polyhedron_reflection = static_cast<Polyhedron*>(v);  

@q *** (3) If |polyhedron_reflection == 0|, try to allocate memory @>
@q *** (3) on the free store for it.                           @> 

@ If |polyhedron_reflection == 0|, try to allocate memory 
on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Polyhedron| functions@>=

 if (polyhedron_reflection == static_cast<Polyhedron*>(0))
 {
  try
     {
       polyhedron_reflection = create_new<Polyhedron>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Polyhedron| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Polyhedron| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Polyhedron::reflect_in()':" 
                 << endl
                 << "`create_new<Polyhedron>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (polyhedron_reflection == 0)|  */

@q *** (3) Call |Solid_Faced::reflect_in|.@> 

@ Call |Solid_Faced::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>=

  Solid_Faced solid_faced_reflection;

  int status;

  try
     {
       status = Solid_Faced::reflect_in(p,
                            static_cast<void*>(&solid_faced_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Solid_Faced::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Solid_Faced::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Polyhedron::reflect_in():'"
                 << endl 
                 << "`Solid_Faced::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `polyhedron_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete polyhedron_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Solid_Faced::reflect_in| returned 1.@> 

@ Error handling:  |Solid_Faced::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Polyhedron| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Polyhedron::reflect_in():'"
                << endl 
                << "`Solid_Faced::reflect_in()' failed and returned 1."
                << endl << "Deleting `polyhedron_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete polyhedron_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Solid_Faced::reflect_in| succeeded.@> 

@ |Solid_Faced::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Polyhedron::reflect_in()':"
                  << endl << "`Solid_Faced::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   polyhedron_reflection->Solid_Faced::operator=(
                            solid_faced_reflection);

@q *** (3) Set other data members of |*polyhedron_reflection|.@> 

@ Set other data members of |*polyhedron_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>=

  polyhedron_reflection->number_of_polygon_types = number_of_polygon_types; 
  polyhedron_reflection->face_radius             = face_radius; 
  polyhedron_reflection->edge_radius             = edge_radius; 
  polyhedron_reflection->vertex_radius           = vertex_radius; 

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Polyhedron| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Polyhedron::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Polyhedron::reflect_in| definition.  */

@q * (1) Intersection.@>  
@* Intersection.
\initials{LDF 2003.04.09.}  

\LOG
\initials{LDF 2003.04.09.}  
Added this section.
\ENDLOG 

@q ** (2) Intersection of a |Polyhedron| and a linear |Path|.@> 
@*1 Intersection of a {\bf Polyhedron} and a linear {\bf Path}.
@^\cfunc{Polyhedron}{intersection\_points}@> 
\initials{LDF 2006.01.20.}

\LOG
\initials{LDF 2006.01.20.}
Added this function.

\initials{LDF 2006.01.23.}
Changed return value from |Pointer_Vector<Point>*| 
to |Pointer_Vector<Bool_Point>*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Polyhedron| functions@>=
Pointer_Vector<Bool_Point>*
intersection_points(Path* q, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 
@
@<Define |Polyhedron| functions@>=
Pointer_Vector<Bool_Point>*
Polyhedron::intersection_points(Path* q, Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4)@> 

#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "Entering `Polyhedron::intersection_points(Path*, Scanner_Node)'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

      }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Error handling:  |Path* q| is null or |*q| is non-linear.@>

@ Error handling:  |Path* q| is null or |*q| is non-linear.
\initials{LDF 2006.01.20.}

@<Define |Polyhedron| functions@>=
   
   if (!(q && q->is_linear()))
      {
          cerr_strm << thread_name 
                    << "ERROR!  In `Polyhedron::intersection_points(Path*, Scanner_Node)':"
                    << endl 
                    << "`Path* q' is null or `*q' is non-linear."
                    << "Exiting function unsuccessfully with return value 0.";
                    
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete q;
          q = 0;

          return 0;

      }  /* |if (!(q && q->is_linear()))|  */

@q **** (4)@> 
@
@<Define |Polyhedron| functions@>=

   vector<Point> v;

   Bool_Point_Pair bpp;

@q **** (4)@> 

   for (vector<Reg_Polygon*>::const_iterator iter = reg_polygons.begin();
        iter != reg_polygons.end();
        ++iter)
      {
          bpp = (**iter).intersection_points(*q, scanner_node, true);

          if (bpp.first.pt != INVALID_POINT)
             v.push_back(bpp.first.pt);

          if (bpp.second.pt != INVALID_POINT)
             v.push_back(bpp.second.pt);

      }  /* |for|  */

@q **** (4)@> 

    vector<Point>::iterator v_iter;
    vector<Point>::iterator dups_iter;

    Compare_Magnitudes cmp_mag(ORIGIN);
    Compare_Points cmp_pts;

    sort(v.begin(), v.end(), cmp_mag);

    dups_iter = unique(v.begin(), v.end(), cmp_pts);
    v.erase(dups_iter, v.end());

@q **** (4)@> 

   Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;
 
   Bool_Point* bp = 0; 

   for (vector<Point>::iterator iter = v.begin();
        iter != v.end();
        ++iter)
      {
       
          bp = new Bool_Point;
          bp->pt = *iter;
          bp->b  = bp->pt.is_on_segment(*q).first;
          *bpv += bp;
      }

   return bpv;

}  /* End of |Polyhedron::intersection_points(Path*, [etc.])| definition.  */

@q ** (2) Intersection of a |Polyhedron| and a |Plane|.@> 
@*1 Intersection of a {\bf Polyhedron} and a {\bf Plane}.
@^\cfunc{Polyhedron}{intersection\_points}@> 
\initials{LDF 2006.01.20.}

\LOG
\initials{LDF 2006.01.20.}
Added this function.
\ENDLOG 

@<Declare |Polyhedron| functions@>=
virtual
Polygon*
intersection(const Plane& q,
             bool suppress_warnings = false,
             Scanner_Node scanner_node = 0) const;

@
@<Define |Polyhedron| functions@>=
Polygon*
Polyhedron::intersection(const Plane& q,
                         bool suppress_warnings,
                         Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@> 

    bool DEBUG = false; /* |true| */

    using namespace Scan_Parse;

    stringstream cerr_strm;

    bool error_stop_value   = true;
    bool warning_stop_value = true;
    string thread_name      = "";

    if (scanner_node)
       scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

#if DEBUG_COMPILE
    if (DEBUG)
    {
        cerr_mutex.lock(); 
        cerr << thread_name << "Entering `Polyhedron::intersection'."
             << endl;
        cerr_mutex.unlock(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q **** (4)@> 
@
\LOG
\initials{LDF 2006.01.23.}
Changed |Pointer_Vector<Point>* bpv| to |Pointer_Vector<Bool_Point>* bpv|.
\ENDLOG

@<Define |Polyhedron| functions@>=

    Line L;
    Bool_Point bp;
    Pointer_Vector<Point>* pv = new Pointer_Vector<Point>;
    Point curr_pt;
    Pointer_Vector<Bool_Point>* bpv = 0;

    Point p[4];
    Path ppath;

@q **** (4)@> 
@
@<Define |Polyhedron| functions@>=

    for (vector<Reg_Polygon*>::const_iterator iter = reg_polygons.begin();
         iter != reg_polygons.end();
         ++iter)
       {
           L = (**iter).get_plane().intersection_line(q, scanner_node, true);
           if (L == INVALID_LINE)
              continue;
           else 
              ppath = L.get_path();

           bpv = intersection_points(&ppath, scanner_node);                  
           if (!bpv || bpv->ctr <= 0)
              continue;

           else  /* |bpv != 0 && bpv->ctr > 0|  */
              {

                  for (int i = 0; i < 4; ++i)   /* First inner |for|  */
                     {

                          for (vector<Bool_Point*>::const_iterator b_iter = bpv->v.begin();
                               b_iter != bpv->v.end();
                               ++b_iter)     /* Second inner |for|  */
                             {
                                 if ((**b_iter).pt != INVALID_POINT)
                                    {

                                        *pv += create_new<Point>((**b_iter).pt);
                                    }

                             } /* End of second inner |for|  */

}  /* End of first inner |for|  */

             }  /* |else| (|bpv != 0|)  */

          delete bpv;
          bpv = 0;  

       }  /* Outer |for|  */   

@q **** (4)@> 

    if (pv->ctr == 0)
       {
           if (!suppress_warnings)
              {
                  cerr_strm << thread_name 
                            << "WARNING!  In `Polyhedron::intersection(const Plane&, [etc.])':"
                            << endl 
                            << "`Plane' doesn't intersect `Polyhedron'.  Exiting function "
                            << "with return value 0.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, warning_stop_value);
                  cerr_strm.str("");

              }  /* |if (!suppress_warnings)|  */
               
           delete pv;
           pv = 0;
   
           return 0;

       }  /* |if (pv->ctr == 0)|  */     

@q **** (4)@> 

    Polygon* poly = static_cast<Polygon*>(Polygon::disentangle(
                                                      static_cast<void*>(pv), 
                                                      static_cast<void*>(scanner_node),
                                                      suppress_warnings));

#if DEBUG_COMPILE
    if (DEBUG)
    {
        cerr_mutex.lock(); 
        cerr << thread_name << "Exiting `Polyhedron::intersection' "
             << "with return value `poly'."
             << endl;
        cerr_mutex.unlock(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    return poly;

@q **** (4)@> 

}  /* End of |Polyhedron::intersection(const Plane& p, [etc.])| 
      definition.  */

@q ** (2) Intersection of a |Polyhedron| and a |Reg_Polygon|.@> 
@*1 Intersection of a {\bf Polyhedron} and a {\bf Reg\_Polygon}.
@^\cfunc{Polyhedron}{intersection\_points}@> 
\initials{LDF 2003.04.09.}  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.04.15.}  
This function doesn't work yet.  
\ENDTODO 

\LOG
\initials{LDF 2003.04.09.}  
Added this function.

\initials{LDF 2003.04.15.}  
Commented-out this function, since I need to get
|Reg_Polygon::intersection_points| working first.  
\ENDLOG 

@<Declare |Polyhedron| functions@>=

#if 0 
virtual
vector<Point> 
intersection_points(const Reg_Polygon& r) const;
#endif 

@
@<Define |Polyhedron| functions@>=
#if 0 
vector<Point> 
Polyhedron::intersection_points(const Reg_Polygon& r) const
{
  vector<Point> v;
  vector<Point> w;
  for (vector<Reg_Polygon*>::const_iterator iter0 = reg_polygons.begin();
       iter0 != reg_polygons.end();
       ++iter0)
    {
      for (vector<Reg_Polygon*>::const_iterator iter1 = iter0 + 1;
           iter1 != reg_polygons.end();
           ++iter1)
        {
          v = (**iter0).intersection_points(**iter1);
          cerr << "v.size() == " << v.size() << endl;
          for (vector<Point>::iterator pt_iter = v.begin();
               pt_iter != v.end();
               ++pt_iter)
            w.push_back(*pt_iter);
        }
    }
  return w;
}
#endif 

@q * (0) Regular Platonic Polyhedra.@>
@** Regular Platonic Polyhedra.

@q * (0) Tetrahedron.@>
@** {\bf Tetrahedron}.
\LOG
\initials{LDF 2002.11.12.}  Added this section.
\ENDLOG 

@q * (1) {\bf Tetrahedron} Class definition.@>
@* {\bf Tetrahedron} class definition.
\LOG
\initials{LDF 2002.11.12.}  Added this section.
\ENDLOG 
@f Tetrahedron Polyhedron
@<Declare |class Tetrahedron|@>=

class Tetrahedron : public Polyhedron
{
 protected:
  static const real dihedral_angle; /* In radians!  */
  real triangle_radius; 
 public:
  @<Declare |Tetrahedron| functions@>@;
};

@q * Define static const Tetrahedron data members.@>
@ Define {\bf static const Tetrahedron} data members.
\LOG
\initials{LDF 2002.11.12.}  Added this section.
\ENDLOG 
@<Define |static const Tetrahedron| data members@>=
const real Tetrahedron::dihedral_angle = PI * (70 + 32/60.0) / 180.0;

@q * Constructors and setting functions.@>
@ Constructors and setting functions.

@q ** Default constructor. (No arguments.)@>
@ Default constructor. (No arguments.)
@^\cfunc{Tetrahedron}{Tetrahedron}@>

\LOG
\initials{LDF 2002.11.12.}  
Added this function.

\initials{LDF 2005.01.24.}
Now setting |shape_type = TETRAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Tetrahedron| functions@>=
Tetrahedron(void);

@
@<Define |Tetrahedron| functions@>=
Tetrahedron::Tetrahedron(void)
{
  shape_type = TETRAHEDRON_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;
  do_output     = true;
  faces    = 4;          /* from |Solid_Faced|.  */
  vertices = 4;
  edges    = 6;

  center = INVALID_POINT;  /* from |Polyhedron|.  */
  number_of_polygon_types = 1;
  face_radius = edge_radius = vertex_radius = INVALID_REAL;
  triangle_radius = INVALID_REAL;  /* From |Tetrahedron|.  */
}

@q ** (2) Center, diameter of triangle, and angles. @>
@*1 Center, diameter of triangle, and angles.

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Tetrahedron}{Tetrahedron}@>
\initials{LDF 2002.11.12.}

\LOG
\initials{LDF 2002.11.12.}  
Added this function.

\initials{LDF 2003.04.27.} 
Got this function to work, at least in a rudimentary way.

\initials{LDF 2003.08.12.}  
Rewrote this function.  It now works properly.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = TETRAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Tetrahedron| functions@>=
Tetrahedron(const Point& p, const real diameter_of_triangle,
             real angle_x = 0, real angle_y = 0, real angle_z = 0);

@q **** Definition.@>
@
@<Define |Tetrahedron| functions@>=
Tetrahedron::Tetrahedron(const Point& p,
                           const real triangle_diameter,
                           real angle_x, real angle_y,
                           real angle_z)
{
  bool DEBUG = false; /* true */ 

  shape_type = TETRAHEDRON_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;
  do_output     = true;

  faces    = 4;  /* from |Solid_Faced|.  */
  vertices = 4;
  edges    = 6;

  number_of_polygon_types = 1;

  Point origin_pt(0, 0, 0);

#if 0 
  /*  !! TO DO.  TO DO:  Must calculate these!  */
  face_radius = 0;
  edge_radius = 0;
  vertex_radius = 0;
#endif 

  triangle_radius = triangle_diameter / 2.0;

  reg_polygons = get_net(triangle_diameter);

  real angle = 180 - (dihedral_angle * 180/PI);

  Point pts[11];

  int i;
  for (i = 0; i < 3; ++i)
      pts[i] = reg_polygons[0]->get_point(i);

  reg_polygons[1]->rotate(pts[0], pts[1], angle); 
  reg_polygons[2]->rotate(pts[2], pts[0], angle); 
  reg_polygons[3]->rotate(pts[1], pts[2], -angle); 
  
#if 0 
  for (i = 0; i < 3; ++i)
    pts[i].label(i, "");
#endif 

  for (i = 3; i < 7; ++i)
    {
      pts[i] = reg_polygons[i-3]->get_center();
#if 0 
      pts[i].label(i, "");
#endif 
    }
  pts[7] = reg_polygons[3]->get_point(0);

#if 0  
  pts[7].label(7, "");
#endif 

  pts[8] = pts[0].mediate(pts[1]);
  pts[9] = pts[1].mediate(pts[2]);
  pts[10] = pts[2].mediate(pts[0]);

#if 0 
  for (i = 8; i < 11; i++)
    pts[i].label(i);
#endif 

  using namespace Colors;

#if 0 
  pts[0].draw(pts[6], &blue);
  pts[1].draw(pts[5], &red);
  pts[2].draw(pts[4], &green);
  pts[3].draw(pts[7], &orange);
#endif 

@ |center| is the intersection point of the line segments from the
vertices of |*(reg_polygons[0])| to the centers of the opposite faces.   
|distance| is the distance along one of these line segments to the
intersection point divided by the length of the entire line segment.
\initials{LDF 2003.08.12.}   

Since this ratio should be the same for all |Tetrahedra|, there's no
need to recalculate it each time a |Tetrahedron| is constructed.  In
addition, intersections can't always be found, because of inaccuracies 
caused by rotating the triangles.  
\initials{LDF 2003.08.12.}   

Therefore, I've calculated distance using the commented-out code below, and 
now simply use the value I found.
\initials{LDF 2003.08.12.}

@<Define |Tetrahedron| functions@>=

  real distance = 0.74997889995574951171875;

#if 0 
  Point P0 = Point::intersection_point(pts[0], pts[6], pts[1],
                            pts[5]).pt;
  P0.show("P0 = 0, 6, 1, 5:");
  Point::intersection_point(pts[0], pts[6], pts[2],
                            pts[4]).pt.show("0, 6, 2, 4:");
  Point::intersection_point(pts[0], pts[6], pts[3],
                            pts[7]).pt.show("0, 6, 3, 7:");
  Point::intersection_point(pts[1], pts[5], pts[2],
                            pts[4]).pt.show("1, 5, 2, 4:");
  Point::intersection_point(pts[1], pts[5], pts[3],
                            pts[7]).pt.show("1, 5, 3, 7:");
  Point::intersection_point(pts[2], pts[4], pts[3],
                            pts[7]).pt.show("2, 4, 3, 7:");
  Point P1 = pts[5] - pts[1];
  Point P2 = P0 - pts[1];
  P1.show("P1");
  cerr << "  P1.magnitude() == " <<   P1.magnitude() << endl;
  P2.show("P2");
  cerr << "P2.magnitude() == " << P2.magnitude() << endl;
  distance = (P2.magnitude() / P1.magnitude());
  cerr.precision(25);
  cerr << "distance == " << distance << endl;
  cerr.precision(6);
#endif 

@
@<Define |Tetrahedron| functions@>=

  center = pts[1].mediate(pts[5], distance);

  for (i = 0; i < 4; ++i)
    reg_polygons[i]->shift(-center);

  center.shift(-center);

  if (angle_x != ZERO_REAL || angle_y != ZERO_REAL || angle_z != ZERO_REAL)
    {
      for(i = 0; i < 4; ++i)
        reg_polygons[i]->rotate(angle_x, angle_y, angle_z);
    }
  
  if (p != origin_pt)
    {
      center = p;
      for(i = 0; i < 4; ++i)
        reg_polygons[i]->shift(p);

    }
  return;
}

@q *** Setting function.@>
@ Setting function.
@^\cfunc{Tetrahedron}{set}@>
\initials{LDF 2002.11.12.}  @:!!@> !! This works, but it fails to
assign to the 
data members of |Tetrahedron| that are defined in its own |class|
declaration.  That's because neither |Tetrahedron| nor |Polyhedron|
has an assignment operator yet.  @:!! TO DO@> TO DO:  Write assignment
operators for |Polyhedra|!
\LOG
\initials{LDF 2002.11.12.}  Added this function.
\ENDLOG 
@<Declare |Tetrahedron| functions@>=
void
set(const Point& p, const real diameter_of_triangle,
    real angle_x = 0, real angle_y = 0, real angle_z = 0);

@
@<Define |Tetrahedron| functions@>=
void
Tetrahedron::set(const Point& p,
                 const real triangle_diameter,
                 real angle_x, real angle_y,
                 real angle_z)
{
  Tetrahedron t(p, triangle_diameter, angle_x, angle_y, angle_z);
  *this = t;
  return;
}

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Tetrahedron}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Tetrahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Tetrahedron| functions@>=
Shape*
Tetrahedron::get_copy() const
{
  Tetrahedron* p = create_new<Tetrahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Tetrahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return TETRAHEDRON_TYPE;
}

@q ** (2) Is |Tetrahedron|.@> 
@*1 Is {\bf Tetrahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Tetrahedron| functions@>=
virtual
inline
bool
is_tetrahedron(void) const 
{
   return true;
}

@q * (1) Get net.@>
@* Get net. 
@^\cfunc{Tetrahedron}{get\_net}@>
\initials{LDF 2002.11.12.}  Unlike the |get_net| functions for some of the
other |Polyhedra|, this function has no ``|bool do_half|'' argument.
It doesn't pay for a |Tetrahedron|.

\LOG
\initials{LDF 2002.11.12.}  
Added this function.

\initials{LDF 2003.08.12.}  
Removed |center_0| argument.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.12.20.}
Added the optional |bool do_half| argument with the default |false|
and the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

@<Declare |Tetrahedron| functions@>=
static
vector<Reg_Polygon*>
get_net(const real triangle_diameter, bool do_half = false, Scanner_Node scanner_node = 0);

@ 
@<Define |Tetrahedron| functions@>=
vector<Reg_Polygon*>
Tetrahedron::get_net(const real triangle_diameter, 
                     bool do_half, 
                     Scanner_Node scanner_node)
{
  vector <Reg_Polygon*> triangles;

  Point origin_pt(0, 0, 0);

  int i;  
  for(i = 0; i < 4; i++)
    triangles.push_back(create_new<Reg_Polygon>(0));

  triangles[0]->set(origin_pt, 3, triangle_diameter, 0, 180);

  triangles[1]->set(origin_pt, 3, triangle_diameter);

  Point pts[6];

  for (i = 0; i < 3; ++i)
    {
      pts[i] = triangles[0]->get_point(i);
    }

  for (i = 3; i < 6; ++i)
    {
      pts[i] = triangles[1]->get_point(i - 3);
    }

  *triangles[2] = *triangles[3] = *triangles[1];

  triangles[1]->shift(pts[0] - pts[4]);
  triangles[2]->shift(pts[0] - pts[5]);
  triangles[3]->shift(pts[2] - pts[4]);
   
  return triangles;
}

@q * (1) Draw net.@>
@* Draw net.
@^\cfunc{Tetrahedron}{draw\_net}@>
\initials{LDF 2002.11.12.}  As of this date it's necessary to rotate the
triangles into the x-y plane, because |Point::intersection_point|
has a bug that I discovered when I tried to call it on |Points| in the
x-z plane.  It's not so terrible, because as of this date it's
necessary to put the |Picture| in the x-y plane in order to use the
parallel projection.  The latter currently only works for the x-y
plane.  @:!! TO DO@> TO DO:  Fix the bug and get parallel projection
onto other major planes to work!

\LOG
\initials{LDF 2002.11.12.}  Added this function.

\initials{LDF 2004.05.26.}  Added |Picture& picture| argument.

\initials{LDF 2004.06.03.}  No longer using 
|Colors::default_color|, since I've gotten rid of it.
\ENDLOG 

@q ** Declaration.  @>

@<Declare |Tetrahedron| functions@>=
static
void
draw_net(Picture& picture,
         const real triangle_diameter,
         bool make_tabs = true);

@q ** Definition.  @>

@ 
@<Define |Tetrahedron| functions@>=
void
Tetrahedron::draw_net(Picture& picture,
                      const real triangle_diameter,
                      bool make_tabs)
{
  vector <Reg_Polygon*> v = get_net(triangle_diameter);

  int i;
  for (i = 0; i < 4; i++)
    {
      v[i]->rotate(90);
      v[i]->draw(picture);
      v[i]->get_center().label(picture, i, "");
    }
  
  if (!make_tabs)
    return;

Point pts[32];

  pts[0] = v[2]->get_point(1);
  pts[1] = v[2]->get_point(2);
  pts[2] = v[1]->get_point(2);
  pts[3] = v[1]->get_point(0);
  pts[4] = v[3]->get_point(0);
  pts[5] = v[3]->get_point(1);
  
  pts[6] = pts[0].mediate(pts[5], .075);
  pts[7] = pts[5].mediate(pts[0], .075);

  pts[8] = pts[6];
  pts[9] = pts[7];

  pts[8] *= pts[9].shift(0, 0, 1);

  pts[10] = pts[0];
  pts[11] = pts[5];

  pts[10].rotate(pts[6], pts[8], -110);
  pts[11].rotate(pts[7], pts[9], 110);

pts[10] = pts[6].mediate(pts[10], 1.5);
  pts[11] = pts[7].mediate(pts[11], 1.5);

#if 0 
  for (i = 0; i < 8; i++)
    pts[i].dotlabel(i);

  pts[10].dotlabel(10);
  pts[11].dotlabel(11);
#endif 

  Path p[6];

  p[0].set("--", true, &pts[6], &pts[10], &pts[11], &pts[7], static_cast<Point*>(0));

  p[0].draw(picture);

pts[12] = pts[6].mediate(pts[7]);
  pts[13] = pts[10].mediate(pts[11]);

#if 0 
  pts[12].dotlabel(12); 
  pts[13].dotlabel(13); 
#endif 

  p[1].set(pts[12], pts[13]);

#if 0 
  p[1].draw_help(Colors::help_color);
#endif 

  pts[14] = pts[12].mediate(pts[13]);

#if 0 
  pts[14].dotlabel(14); 
#endif 

  pts[15] = pts[6].mediate(pts[7], .25);

#if 0 
  pts[15].dotlabel(15); 
#endif 

  pts[16] = pts[14];
  pts[16].shift(pts[15] - pts[12]);

#if 0 
  pts[16].dotlabel(16); 
#endif 

  Bool_Point bp = Point::intersection_point(pts[14], pts[16],
                                            pts[6], pts[10]);

  pts[17] = bp.pt;
#if 0 
  pts[17].dotlabel(17); 
#endif 
  bp = Point::intersection_point(pts[14], pts[16],
                                             pts[7], pts[11]);
  pts[18] = bp.pt;

#if 0 
  pts[18].dotlabel(18); 
#endif 

  p[2].set(pts[17], pts[18]);

#if 0 
  p[2].draw_help(Colors::help_color);
#endif 

  Pen q;
  Transform s;
  s.scale(.05, .05, .05);
  
  q *= s;

  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[17].mediate(pts[18], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  pts[20] = pts[17];
  pts[21] = pts[18];

  p[3] = p[0];

  Transform t;
  t.shift(pts[4] - pts[5]);
  t.rotate(pts[4], pts[5]);

  pts[20] *= pts[21] *= p[3] *= t;

  p[3].draw(picture);
  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[20].mediate(pts[21], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  t.reset();
  t.rotate(pts[4], pts[1]);

  pts[20] *= pts[21] *= p[3] *= t;
  
  p[3].draw(picture);
  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[20].mediate(pts[21], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  pts[20] = pts[17];
  pts[21] = pts[18];
  p[3] = p[0];

  pts[20] *= pts[21] *= p[3] *= t;
  
  p[3].draw(picture);
  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[20].mediate(pts[21], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  t.reset();

  pts[22] = v[2]->get_center();
  pts[23] = pts[22];
  pts[23].shift(0, 0, 1);

  t.rotate(pts[22], pts[23], 120);

  pts[20] = pts[17];
  pts[21] = pts[18];
  p[3] = p[0];

  pts[20] *= pts[21] *= p[3] *= t;
  
  p[3].draw(picture);
  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[20].mediate(pts[21], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  t.rotate(pts[4], pts[1]);
  t.rotate(pts[0], pts[2]);

  pts[20] = pts[17];
  pts[21] = pts[18];
  p[3] = p[0];

  pts[20] *= pts[21] *= p[3] *= t;
  
  p[3].draw(picture);
  for (i = 1; i < 16; ++i)
    {
      pts[19] = pts[20].mediate(pts[21], i /16.0);
      pts[19].drawdot(picture, 0, &q);
    }

  return;

}

@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Tetrahedron}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Tetrahedron| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Tetrahedron| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Tetrahedron| functions@>=
int
Tetrahedron::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Tetrahedron* tetrahedron_reflection = static_cast<Tetrahedron*>(v);  

@q *** (3) If |tetrahedron_reflection == 0|, try to allocate memory @>
@q *** (3) on the free store for it.                           @> 

@ If |tetrahedron_reflection == 0|, try to allocate memory 
on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Tetrahedron| functions@>=

 if (tetrahedron_reflection == static_cast<Tetrahedron*>(0))
 {
  try
     {
       tetrahedron_reflection = create_new<Tetrahedron>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Tetrahedron| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Tetrahedron| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Tetrahedron::reflect_in()':" 
                 << endl
                 << "`create_new<Tetrahedron>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (tetrahedron_reflection == 0)|  */

@q *** (3) Call |Polyhedron::reflect_in|.@> 

@ Call |Polyhedron::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>=

  Polyhedron polyhedron_reflection;

  int status;

  try
     {
       status = Polyhedron::reflect_in(p,
                            static_cast<void*>(&polyhedron_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Tetrahedron::reflect_in():'"
                 << endl 
                 << "`Polyhedron::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `tetrahedron_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete tetrahedron_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Polyhedron::reflect_in| returned 1.@> 

@ Error handling:  |Polyhedron::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Tetrahedron| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Tetrahedron::reflect_in():'"
                << endl 
                << "`Polyhedron::reflect_in()' failed and returned 1."
                << endl << "Deleting `tetrahedron_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete tetrahedron_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Polyhedron::reflect_in| succeeded.@> 

@ |Polyhedron::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Tetrahedron::reflect_in()':"
                  << endl << "`Polyhedron::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   tetrahedron_reflection->Polyhedron::operator=(
                            polyhedron_reflection);

@q *** (3) Set other data members of |*tetrahedron_reflection|.@> 

@ Set other data members of |*tetrahedron_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>=

   tetrahedron_reflection->triangle_radius = triangle_radius; 

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Tetrahedron| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Tetrahedron::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Tetrahedron::reflect_in| definition.  */

@q * (0) Octahedron.@>
@** {\bf Octahedron}.
\initials{LDF 2004.10.08.}

\LOG
\initials{LDF 2004.10.08.}
Added this section.
\ENDLOG

@q * (1)  {\bf Octahedron} Class definition.@>
@* {\bf Octahedron} class definition.
\initials{LDF 2004.10.08.}

\LOG
\initials{LDF 2004.10.08.}
Added this class definition.
\ENDLOG

@f Octahedron Polyhedron

@<Declare |class Octahedron|@>=

class Octahedron : public Polyhedron
{
 protected:
  static const real dihedral_angle; /* In radians!  */
  real triangle_radius; 
 public:
  @<Declare |Octahedron| functions@>@;
};

@q * (1) Define static const Octahedron data members.@>
@* Define {\bf static const Octahedron} data members.

\LOG
\initials{LDF 2004.10.08.}
Added this section.
\ENDLOG

@<Define |static const Octahedron| data members@>=
const real Octahedron::dihedral_angle = PI/180.0 * (109.0 + 28.0/60.0);

@q * (1) Constructors and setting functions.@>
@*1 Constructors and setting functions.
\initials{LDF 2004.10.08.}

@q ** (2) Default constructor. (No arguments.)@>
@*2 Default constructor. (No arguments.)
@^\cfunc{Octahedron}{Octahedron}@>
\initials{LDF 2004.10.08.}

\LOG
\initials{LDF 2004.10.08.}
Added this function.

\initials{LDF 2005.01.24.}
Now setting |shape_type = OCTAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Octahedron| functions@>=
Octahedron(void);

@q *** (3) Definition.@> 

@
@<Define |Octahedron| functions@>=
Octahedron::Octahedron(void)
{

  shape_type = OCTAHEDRON_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;
  do_output     = true;
  faces    = 8;          /* from |Solid_Faced|.  */
  vertices = 6;
  edges    = 12;

  center = INVALID_POINT;  /* from |Polyhedron|.  */
  number_of_polygon_types = 1;
  face_radius = edge_radius = vertex_radius = INVALID_REAL;

  triangle_radius = INVALID_REAL;  /* From |Octahedron|.  */

} /* End of |Octahedron::Octahedron(void)| definition.  */

@q ** (2) Center, diameter of triangles, and angles. @>
@*1 Center, diameter of triangles, and angles.

\LOG
\initials{LDF 2004.10.08.}
Added this section.
\ENDLOG

@q *** (3) Constructor.@>
@*2 Constructor.

\LOG
\initials{LDF 2004.10.08.}
Added this function.

\initials{LDF 2004.10.20.}
Finished writing this function.

\initials{LDF 2005.01.24.}
Now setting |shape_type = OCTAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Octahedron| functions@>=
Octahedron(const Point& ccenter,
           const real triangle_diameter,
           real angle_x = 0,
           real angle_y = 0,
           real angle_z = 0,
           Scanner_Node scanner_node = 0);

@q **** (4) Definition.@> 

@
@<Define |Octahedron| functions@>=
Octahedron::Octahedron(const Point& ccenter,
                       const real triangle_diameter,
                       real angle_x,
                       real angle_y,
                       real angle_z,
                       Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;
  
  stringstream cerr_strm;
    
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);
@q ***** (5).@> 

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering non-default `Octahedron' constructor.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

    shape_type = OCTAHEDRON_TYPE;
    surface_hiding_ctr = 0;
    decomposition_level = 0;

    do_output     = true;

    faces    = 8;  /* from |Solid_Faced|.  */
    vertices = 6;
    edges    = 12;

    number_of_polygon_types = 1;

#if 0 
/*  !! TO DO.  TO DO:  Must calculate these!  */
    face_radius = 0;
    edge_radius = 0;
    vertex_radius = 0;
#endif 

    Point origin_pt(0, 0, 0);

    triangle_radius = triangle_diameter / 2.0;

    reg_polygons = get_net(triangle_diameter, true);

   real angle = 180 - (dihedral_angle * 180.0/PI);

@q ***** (5) @>   
@
@<Define |Octahedron| functions@>=

    int i = 0;
    int j = 0;

    Point pts[4][3];

    for (i = 0; i < 4; ++i)
      {
         for (j = 0; j < 3; ++j)
           {

             pts[i][j] = reg_polygons[i]->get_point(j);

           }  /* |for| (|j|) */ 

      } /* |for| (|i|) */

reg_polygons[1]->rotate(pts[0][2], pts[0][1], -angle);

   reg_polygons[3]->rotate(pts[2][2], pts[2][1], -angle);

   *reg_polygons[2] *= reg_polygons[3]->rotate(pts[2][0], pts[0][1], -angle);

    for (i = 1; i < 4; ++i)
      {
         for (j = 0; j < 3; ++j)
           {

             pts[i][j] = reg_polygons[i]->get_point(j);

           }  /* |for| (|j|) */ 

      } /* |for| (|i|) */

Point q[9];

   q[0] = pts[0][0].mediate(pts[0][2]);
   q[1] = pts[1][0].mediate(pts[1][2]);
   q[2] = pts[2][0].mediate(pts[2][2]);
   q[3] = pts[3][0].mediate(pts[3][1]);

   Transform t;

   t.align_with_axis(q[0], q[3], 'z');

   for (i = 0; i < 4; ++i)   

           q[i] *= *reg_polygons[i] *= t;

   t.reset();

   t.align_with_axis(q[1], q[2], 'x');

   for (i = 0; i < 4; ++i)   
      q[i] *= *reg_polygons[i] *= t;

@q ***** (5) Try to create four more |Reg_Polygons|.@> 

@ Try to create four more |Reg_Polygons|.
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=

   for (i = 0; i < 4; ++i)   
      {
         try 
           {
               reg_polygons.push_back(
                   create_new<Reg_Polygon>(reg_polygons[i]));
               q[i + 4] = q[i];
           } /* |try|  */

@q ****** (6) Error handling:  |create_new<Reg_Polygon>| failed.@> 

@ Error handling:  |create_new<Reg_Polygon>| failed.
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=
         catch (bad_alloc)
           {
               cerr_strm << thread_name 
                         << "ERROR! In non-default `Octahedron' constructor:"
                         << endl << "`create_new<Reg_Polygon>()' failed."
                         << "Calling `clear()' and rethrowing `bad_alloc'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");

               clear();
               
               throw;

           } /* |catch (bad_alloc)|  */

@q ****** (6) |create_new<Reg_Polygon>| succeeded.@> 

@ |create_new<Reg_Polygon>| succeeded.
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=

      } /* |for|  */

@q ***** (5) Rotate the second group of four |Reg_Polygons| @>
@q ***** (5) about the x-axis.@>  

@ Rotate the second group of four |Reg_Polygons| 
about the x-axis.
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=
    t.reset();

    t.rotate(180);

    for (i = 4; i < 8; i++)
      q[i] *= *reg_polygons[i] *= t;

    q[8] = q[1].mediate(q[2]);

@q ***** (5) Shift the |Reg_Polygons| so that the |Octahedron| @>  
@q ***** (5) is centered about the origin.                     @> 

@ Shift the |Reg_Polygons| so that the |Octahedron| is centered 
about the origin.                      
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=

    for (i = 0; i < 8; i++)
       q[i] *= reg_polygons[i]->shift(-q[8]);

@q ***** (5) Rotate the |Reg_Polygons| about the main axes, if necessary.@>  

@ Rotate the |Reg_Polygons| about the main axes, if necessary.
\initials{LDF 2004.10.20.}

@<Define |Octahedron| functions@>=

   if (angle_x || angle_y || angle_z)
     rotate(angle_x, angle_y, angle_z);

@q ***** (5) Shift |*this| so that |center == ccenter|, if necessary.@>

@ Shift |*this| so that |center == ccenter|, if necessary.
\initials{LDF 2004.10.20.}

\LOG
\initials{LDF 2004.10.22.}
@:BUG FIX@> BUG FIX: 
Added this section.  
I haven't tested the code it contains yet. 
\ENDLOG

@<Define |Octahedron| functions@>=

Point origin(0, 0, 0);

if (ccenter != origin)
{
shift(ccenter);
center = ccenter;
}

else
center = origin;

#if 0 

/* This may be needed for debugging.  LDF 2004.10.20.  */
q[8].set(0, 0, 0);

#endif 

@q ***** (5).@> 

#if DEBUG_COMPILE
if (DEBUG)
{
cerr_strm << thread_name 
<< "Exiting non-default "
<< "`Octahedron' constructor.";

log_message(cerr_strm);
cerr_message(cerr_strm);
cerr_strm.str("");

}
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Exit function successfully returning |void|.@> 
@ Exit function successfully returning |void|.      
\initials{LDF 2004.10.08.}

@<Define |Octahedron| functions@>=

return;

} /* End of non-default `Octahedron'' constructor definition.  */

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Octahedron}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Octahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Octahedron| functions@>=
Shape*
Octahedron::get_copy() const
{
  Octahedron* p = create_new<Octahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Octahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return OCTAHEDRON_TYPE;
}

@q ** (2) Is |Octahedron|.@> 
@*1 Is {\bf Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Octahedron| functions@>=
virtual
inline
bool
is_octahedron(void) const 
{
   return true;
}

@q * (1) Get net.@>  
@* Get net. 
@^\cfunc{Octahedron}{get\_net}@>

\LOG
\initials{LDF 2004.10.08.}
Added this function.

\initials{LDF 2005.12.20.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG

@<Declare |Octahedron| functions@>=
static
vector<Reg_Polygon*>
get_net(const real triangle_diameter, 
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@ 
@<Define |Octahedron| functions@>=
vector<Reg_Polygon*>
Octahedron::get_net(const real triangle_diameter, 
                    bool do_half,
                    Scanner_Node scanner_node)
{
bool DEBUG = false; /* |true| */@; 
vector<Reg_Polygon*> triangles;

Point origin_pt(0, 0, 0);

int i;

for (i = 0; i < 4; ++i)
triangles.push_back(create_new<Reg_Polygon>(0));

triangles[0]->set(origin_pt, 3, triangle_diameter, 0, 180); 
Point pts[4];
pts[0] = triangles[0]->get_point(0);
pts[1] = triangles[0]->get_point(1);
pts[2] = triangles[0]->get_point(2);

*triangles[1] = *triangles[0];
*triangles[2] = *triangles[0];
*triangles[3] = *triangles[0];

triangles[1]->rotate(pts[1], pts[2]);
triangles[2]->rotate(pts[0], pts[1]);

triangles[3]->shift(pts[1] - pts[2]);

return triangles;

}  /* End of |Octahedron::get_net| definition.  */

@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.12.03.}
@^\cfunc{Octahedron}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Octahedron| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.12.03.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.12.03.}

\LOG
\initials{LDF 2004.12.03.}
Added this function.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Octahedron| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Octahedron| functions@>=
int
Octahedron::reflect_in(const Plane& p, 
                       void* v,
                       const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Octahedron* octahedron_reflection = static_cast<Octahedron*>(v);  

@q *** (3) If |octahedron_reflection == 0|, try to allocate memory @>
@q *** (3) on the free store for it.                               @> 

@ If |octahedron_reflection == 0|, try to allocate memory 
on the free store for it.                            
\initials{LDF 2004.12.03.}

@<Define |Octahedron| functions@>=

 if (octahedron_reflection == static_cast<Octahedron*>(0))
 {
  try
     {
       octahedron_reflection = create_new<Octahedron>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Octahedron| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Octahedron| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.12.03.}

@<Define |Octahedron| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Octahedron::reflect_in()':" 
                 << endl
                 << "`create_new<Octahedron>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (octahedron_reflection == 0)|  */

@q *** (3) Call |Polyhedron::reflect_in|.@> 

@ Call |Polyhedron::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Octahedron| functions@>=

  Polyhedron polyhedron_reflection;

  int status;

  try
     {
       status = Polyhedron::reflect_in(p,
                            static_cast<void*>(&polyhedron_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Octahedron| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Octahedron::reflect_in():'"
                 << endl 
                 << "`Polyhedron::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `octahedron_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete octahedron_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Polyhedron::reflect_in| returned 1.@> 

@ Error handling:  |Polyhedron::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Octahedron| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Octahedron::reflect_in():'"
                << endl 
                << "`Polyhedron::reflect_in()' failed and returned 1."
                << endl << "Deleting `octahedron_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete octahedron_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Polyhedron::reflect_in| succeeded.@> 

@ |Polyhedron::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Octahedron| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Octahedron::reflect_in()':"
                  << endl << "`Polyhedron::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   octahedron_reflection->Polyhedron::operator=(
                            polyhedron_reflection);

@q *** (3) Set other data members of |*octahedron_reflection|.@> 

@ Set other data members of |*octahedron_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Octahedron| functions@>=

   octahedron_reflection->triangle_radius = triangle_radius; 

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Octahedron| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Octahedron::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Octahedron::reflect_in| definition.  */

@q * (0) Icosahedron.@>

@** {\bf Icosahedron}.

@q * (1) {\bf Icosahedron} Class definition.@>

@* {\bf Icosahedron} class definition.
@<Declare |class Icosahedron|@>=

class Icosahedron : public Polyhedron
{
 protected:
  static const real dihedral_angle; /* In radians!  */
  real triangle_radius;
 public:
  @<Declare |Icosahedron| functions@>@;
};

@q * (1) Define static const Icosahedron data members.@>

@*1 Define {\bf static const Icosahedron} data members.

@<Define |static const Icosahedron| data members@>=
const real Icosahedron::dihedral_angle = PI - asin(2.0/3.0);  

@q * (1) Constructors and setting functions.@>
@*1 Constructors and setting functions.

@q ** (2) Default constructor. (No arguments.)@>
@*2 Default constructor. (No arguments.)
@^\cfunc{Icosahedron}{Icosahedron}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.01.24.}
Now setting |shape_type = ICOSAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG

@<Declare |Icosahedron| functions@>=

Icosahedron(void);

@
@<Define |Icosahedron| functions@>=
Icosahedron::Icosahedron(void)
{
  shape_type = ICOSAHEDRON_TYPE;
  surface_hiding_ctr = 0; 
  decomposition_level = 0;
  do_output     = true;
  faces    = 20;          /* from |Solid_Faced|.  */
  vertices = 12;
  edges    = 30;

  center = INVALID_POINT;  /* from |Polyhedron|.  */
  number_of_polygon_types = 1;
  face_radius = edge_radius = vertex_radius = INVALID_REAL;
  triangle_radius = INVALID_REAL;
}

@q ** (2) Center, diameter of triangle, and angles. @>
@*1 Center, diameter of triangle, and angles.

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Icosahedron}{Icosahedron}@>

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.12.18.}  
Must fix this constructor.  There's a
problem with rotation.  I've already done so for the |Dodecahedron|
constructor. 
\ENDTODO 

\LOG
\initials{LDF 2002.10.16.}
Defined this function.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = ICOSAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Icosahedron| functions@>=
Icosahedron(const Point& p, const real diameter_of_triangle,
             real angle_x = 0, real angle_y = 0, real angle_z = 0);

@
@<Define |Icosahedron| functions@>=
Icosahedron::Icosahedron(const Point& p,
                           const real triangle_diameter,
                           real angle_x, real angle_y,
                           real angle_z)
{
    bool DEBUG = false; /* |true| */
    if (DEBUG)
      cerr << "Entering Icosahedron::Icosahedron().\n";

    shape_type = ICOSAHEDRON_TYPE;
    surface_hiding_ctr = 0;
    decomposition_level = 0;
    do_output     = true;

    faces    = 20;  /* from |Solid_Faced|.  */
    vertices = 12;
    edges    = 30;

    number_of_polygon_types = 1;
#if 0 
/*  !! TO DO.  TO DO:  Must calculate these!  */
    face_radius = 0;
    edge_radius = 0;
    vertex_radius = 0;
#endif 

    Point origin_pt(0, 0, 0);

    triangle_radius = triangle_diameter / 2.0;

    int i;
    reg_polygons.push_back(create_new<Reg_Polygon>(0));
    reg_polygons.front()->set(origin_pt, 3, triangle_diameter);

    Point pts[7];

    for (i = 0; i < 3; ++i)
      pts[i] = reg_polygons.front()->get_point(i);

    for (i = 1; i < 6; ++i)
      {
        reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons.front()));
      }
    
    reg_polygons[1]->shift(pts[2] - pts[1]);
    reg_polygons[2]->shift(pts[1] - pts[2]);
    reg_polygons[3]->shift(pts[0] - pts[2]);
    reg_polygons[4]->shift(pts[0] - pts[1]);

#if 0 
    if (DEBUG) 
      origin_pt.label("O", ""); 
#endif 

    reg_polygons[5]->rotate(0, 180);
    reg_polygons[5]->shift(pts[1] - reg_polygons[5]->get_point(0));

    for (i = 6; i < 10; ++i)
      {
        reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[5]));
      }

    reg_polygons[6]->shift(pts[2] - pts[1]);
    reg_polygons[7]->shift(pts[1] - pts[0]);
    reg_polygons[8]->shift(pts[2] - pts[0]);

    reg_polygons[9]->shift(pts[2] - pts[0]);
    reg_polygons[9]->shift(pts[2] - pts[1]);

    pts[3] = reg_polygons[2]->get_point(1);
    pts[4] = reg_polygons[2]->get_point(0);
    pts[5] = reg_polygons[1]->get_point(2);
    pts[6] = reg_polygons[1]->get_point(0);

    real angle = 180.0 - (dihedral_angle * 180.0/PI);

    *reg_polygons[9] *= *reg_polygons[8] *= reg_polygons[7]->rotate(pts[3], pts[5], -angle);

    *reg_polygons[3] *= reg_polygons[4]->rotate(pts[4], pts[6], angle);

    *reg_polygons[2] *= reg_polygons[7]->rotate(pts[1], pts[4], -angle);

    *reg_polygons[7] *= *reg_polygons[2] *= *reg_polygons[3]
      *= reg_polygons[5]->rotate(pts[1], pts[0], -angle);

    *reg_polygons[1] *= reg_polygons[9]->rotate(pts[2], pts[6], angle);

    *reg_polygons[9] *= *reg_polygons[1] *= *reg_polygons[6]
      *= reg_polygons[4]->rotate(pts[2], pts[0], angle);

    for (i = 10; i < 20; ++i)
      {
        reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[i - 10]));
        reg_polygons.back()->rotate(180);
        reg_polygons.back()->shift(0, 12);
      }

#if 0 
    if (DEBUG)
      {
        reg_polygons[4]->dotlabel(); 
        reg_polygons[19]->dotlabel(); 
      }
#endif 
    
    real y_shift = reg_polygons[4]->get_point(0).get_y()
                 - reg_polygons[19]->get_point(0).get_y();
    
    for (i = 10; i < 20; ++i)
      reg_polygons[i]->shift(0, y_shift);

    center = reg_polygons[0]->get_center().mediate(reg_polygons[10]->get_center()); 
    
    for (i = 0; i < 20; ++i)
      reg_polygons[i]->shift(-center);
    
    center = origin_pt;

    if (angle_x != ZERO_REAL || angle_y != ZERO_REAL || angle_z != ZERO_REAL)
      for(vector<Reg_Polygon*>::iterator iter = reg_polygons.begin();
          iter != reg_polygons.end(); ++iter)
        (**iter).rotate(angle_x, angle_y, angle_z);

    if (p != origin_pt)
      {
        for(vector<Reg_Polygon*>::iterator iter = reg_polygons.begin();
            iter != reg_polygons.end(); ++iter)
          {
            (**iter).shift(p - center);
          }
        center = p;
      }

    if (DEBUG)
      {
          cerr << "Exiting Icosahedron::Icosahedron().\n";
      }
    return;
}

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Icosahedron}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Icosahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Icosahedron| functions@>=
Shape*
Icosahedron::get_copy() const
{
  Icosahedron* p = create_new<Icosahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Icosahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return ICOSAHEDRON_TYPE;
}

@q ** (2) Is |Icosahedron|.@> 
@*1 Is {\bf Icosahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Icosahedron| functions@>=
virtual
inline
bool
is_icosahedron(void) const 
{
   return true;
}

@q * (1) Get net.@>  
@* Get net. 
@^\cfunc{Icosahedron}{get\_net}@>

\LOG
\initials{LDF 2002.11.10.}
@:BUG FIX@> BUG FIX:  Removed erroneous code that
created 6 extra triangles.

\initials{LDF 2003.08.12.}  
Removed |center_0| argument.

\initials{LDF 2003.08.27.}  
Added |size_t triangles_size| and added |size_t i| to
a |for| loop, where it's compared to |triangles_size|.  This occurs in
debugging code.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.12.20.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

@<Declare |Icosahedron| functions@>=
static
vector<Reg_Polygon*>
get_net(const real triangle_diameter, 
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@ 
@<Define |Icosahedron| functions@>=
vector<Reg_Polygon*>
Icosahedron::get_net(const real triangle_diameter, 
                     bool do_half,
                     Scanner_Node scanner_node)
{
  bool DEBUG = false; /* |true| */@; 
  vector<Reg_Polygon*> triangles;

  Point origin_pt(0, 0, 0);

  int i;

  for (i = 0; i < 10; ++i)
    triangles.push_back(create_new<Reg_Polygon>(0));

  @,@/ /* The bottom left triangle.  */
  triangles[0]->set(origin_pt, 3, triangle_diameter, 0, 180); 
  Point pts[4];
  pts[0] = triangles[0]->get_point(0);
  pts[1] = triangles[0]->get_point(1);
  pts[2] = triangles[0]->get_point(2);

  *triangles[1] = *triangles[0];
  triangles[1]->rotate(0, 180);

  triangles[1]->shift(pts[2] - triangles[1]->get_point(1));

  pts[3] = triangles[1]->get_point(0);

  *triangles[2] = *triangles[0];
  triangles[2]->shift(pts[3] - pts[2]);

  *triangles[3] = *triangles[1];
  triangles[3]->shift(pts[3] - pts[2]);

    for (i = 0; i < 4; ++i)
      {
        *triangles[4 + i] = *triangles[i];
        triangles[4 + i]->shift(pts[1] - pts[2]);
      } 
  
#if 0 
  if (DEBUG)
    for (i = 0; i < 4; ++i)
      pts[i].dotlabel(i);
#endif 
   
  if (do_half == true)
    {
      *triangles[8] = *triangles[4];
      *triangles[9] = *triangles[5];
      *triangles[8] *= triangles[9]->shift(pts[1] - pts[2]);

      for (i = 0; i < 10; ++i)
        {
          for (int j = 0; j < 3; j++)
            if (triangles[i]->get_point(j).get_y() != ZERO_REAL)
              {
                cerr << "ERROR! In Icosahedron::get_net():\n"
                  << "y-coordinate != 0!\n"
                    << "You'd better fix this!\n\n";
              }
        }
      return triangles;
    }

  /* Do the second half.  */

  if (DEBUG)
    cerr << "Doing the second half.\n";

  for (i = 0; i < 10; ++i)
    triangles.push_back(create_new<Reg_Polygon>(0));

  for (int j = 8; j <= 16; j += 4)
    for (i = 0; i < 4; ++i)
      {
        *triangles[j + i] = *triangles[j - 4 + i];
        triangles[j + i]->shift(pts[1] - pts[2]);
      } 

#if 0 
  if (DEBUG)
    {
        size_t triangles_size = triangles.size();
      for(size_t i = 0; i < triangles_size; ++i)
        if (triangles[i]->size() > 0)
          triangles[i]->get_center().label(i, ""); 
    }
#endif 

  for (i = 0; i < 20; ++i)
    {
      for (int j = 0; j < 3; j++)
        if (triangles[i]->get_point(j).get_y() != ZERO_REAL)
          {
            cerr << "ERROR! In Icosahedron::get_net():\n"
              << "y-coordinate != 0!\n"
                << "You'd better fix this!\n\n";
          }
    }
  return triangles;
}

@q * (1) Draw net.@>  
@* Draw net. 
@^\cfunc{Icosahedron}{draw\_net}@>
@:!! TO DO@> TO DO:  Add parallel projections onto planes other than
the x-y plane.
\LOG
\initials{LDF 2002.11.10.}  Added this function.  |portrait| works, unlike
|Dodecahedron::draw_net()polyhed.web| (as of this date). 

\initials{LDF 2003.08.12.}  
Changed, so that net is drawn in x-z plane.

\initials{LDF 2003.08.12.}  
This function now returns before the code for making the 
tabs can be executed, because it doesn't work yet.  

\initials{LDF 2004.05.26.}  
Added |Picture& picture| argument.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
Write code for tabs.
\initials{LDF Undated.}
\ENDTODO 

@q ** Declaration.  @>  

@<Declare |Icosahedron| functions@>=
static
void
draw_net(Picture& picture,
         const real triangle_diameter,
         bool portrait = true,
         bool make_tabs = true);

@q ** Definition.  @>  

@ 
@<Define |Icosahedron| functions@>=
void
Icosahedron::draw_net(Picture& picture,
                      const real triangle_diameter,
                      bool portrait,
                      bool make_tabs)
{ 
  vector <Reg_Polygon*> v = get_net(triangle_diameter);

  int i = 0;
  for (vector <Reg_Polygon*>::iterator iter = v.begin();
       iter != v.end(); ++iter)
    {
      if (portrait)
        (**iter).rotate(0, 90); 

      (**iter).get_center().label(picture, i++, "");
      (**iter).draw(picture);
    }
  
  return; /* Delete, when I start writing code for tabs.  
             \initials{LDF 2003.08.12.}  */

  if (!make_tabs)
    return;

  Path p[11];
  Point pts[11];

#if 0 
  v[0]->dotlabel(); 
#endif 

  pts[0] = v[0]->get_point(0);
  pts[1] = v[0]->get_point(1);
  pts[2] = v[0]->get_point(2);

  pts[3] = pts[0].mediate(pts[1], .1);
  pts[4] = pts[1].mediate(pts[0], .1);

#if 0 
  pts[3].dotlabel(2); 
  pts[4].dotlabel(3); 

#endif 

  pts[5] = pts[0].mediate(pts[3], .1);
  pts[6] = pts[1].mediate(pts[4], .1);

  pts[7] = pts[3];
  pts[7].shift(0, 0, 1);

  pts[8] = pts[4];
  pts[8].shift(0, 0, 1);

  pts[5].rotate(pts[3], pts[7], 90);

  pts[6].rotate(pts[8], pts[4], 90);

#if 0 
  pts[5].dotlabel(4); 
  pts[6].dotlabel(5); 
#endif 

  pts[9] = pts[5].mediate(pts[6], .1);
        
  pts[10] = pts[6].mediate(pts[5], .1);

#if 0 
  pts[9].dotlabel(8); 
  pts[10].dotlabel(9); 
#endif 

  p[0].set("--", true, &pts[3], &pts[9], &pts[10], &pts[4], static_cast<Point*>(0));

  p[1] = p[2] = p[3] = p[4] = p[5] = p[0];

  p[1].shift(v[4]->get_point(1) - pts[1]);
  p[2].shift(v[8]->get_point(1) - pts[1]);
  p[3].shift(v[12]->get_point(1) - pts[1]);
  p[4].shift(v[16]->get_point(1) - pts[1]);
  p[5].shift(v[18]->get_point(1) - pts[1]);

  p[6] = p[0];
  p[6].rotate(0, 0, 240);

  p[6].rotate(pts[0], pts[2]);

#if 0 
  v[3]->dotlabel(); 
#endif 

  p[7] = p[8] = p[9] = p[10] = p[6];

  p[6].shift(v[3]->get_point(0) - pts[2]);
  
  p[7].shift(v[7]->get_point(0) - pts[2]);

  p[8].shift(v[11]->get_point(0) - pts[2]);

  p[9].shift(v[15]->get_point(0) - pts[2]);

  p[10].shift(v[19  ]->get_point(0) - pts[2]);

  for (i = 0; i < 11; i++)
    p[i].draw(picture);

  return;
}

@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Icosahedron}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Icosahedron| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.  Following a system update, having |Shape*| 
as the return value no longer worked.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Icosahedron| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Icosahedron| functions@>=
int
Icosahedron::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Icosahedron* icosahedron_reflection = static_cast<Icosahedron*>(v);  

@q *** (3) If |icosahedron_reflection == 0|, try to allocate memory @>
@q *** (3) on the free store for it.                           @> 

@ If |icosahedron_reflection == 0|, try to allocate memory 
on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Icosahedron| functions@>=

 if (icosahedron_reflection == static_cast<Icosahedron*>(0))
 {
  try
     {
       icosahedron_reflection = create_new<Icosahedron>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Icosahedron| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Icosahedron| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Icosahedron::reflect_in()':" 
                 << endl
                 << "`create_new<Icosahedron>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (icosahedron_reflection == 0)|  */

@q *** (3) Call |Polyhedron::reflect_in|.@> 

@ Call |Polyhedron::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>=

  Polyhedron polyhedron_reflection;

  int status;

  try
     {
       status = Polyhedron::reflect_in(p,
                            static_cast<void*>(&polyhedron_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Polyhedron::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Icosahedron::reflect_in():'"
                 << endl 
                 << "`Polyhedron::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `icosahedron_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete icosahedron_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Polyhedron::reflect_in| returned 1.@> 

@ Error handling:  |Polyhedron::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Icosahedron| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Icosahedron::reflect_in():'"
                << endl 
                << "`Polyhedron::reflect_in()' failed and returned 1."
                << endl << "Deleting `icosahedron_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete icosahedron_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Polyhedron::reflect_in| succeeded.@> 

@ |Polyhedron::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Icosahedron::reflect_in()':"
                  << endl << "`Polyhedron::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   icosahedron_reflection->Polyhedron::operator=(
                            polyhedron_reflection);

@q *** (3) Set other data members of |*icosahedron_reflection|.@> 

@ Set other data members of |*icosahedron_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>=

   icosahedron_reflection->triangle_radius = triangle_radius;

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Icosahedron| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Icosahedron::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Icosahedron::reflect_in| definition.  */

@q * (0) Semi-Regular Archimedean Polyhedra.@>
@** Semi-Regular Archimedean Polyhedra.

@q * (1) Truncated Octahedron.@>
@* {\bf Truncated Octahedron}.

@q ** (2) {\bf Trunc_Octahedron} Class definition.@>
@*1 {\bf Trunc\_Octahedron} class definition.
@<Declare |class Trunc_Octahedron|@>=

class Trunc_Octahedron : public Polyhedron
{
 protected:
  static const real angle_hex_square; /* In radians!  */
  static const real angle_hex_hex;    /* In radians!  */
  real hexagon_radius;
 public:
  @<Declare |Trunc_Octahedron| functions@>@;
};

@q *** (3) Define static const Trunc_Octahedron data members.@>

@*2 Define {\bf static const Trunc\_Octahedron} data members.

@<Define |static const Trunc_Octahedron| data members@>=

const real Trunc_Octahedron::angle_hex_square
    = (125 + (16.0 / 60.0)) * (PI / 180.0); 
const real Trunc_Octahedron::angle_hex_hex
    = (109 + (28.0 / 60.0)) * (PI / 180.0);   

@q ** (2) |Trunc_Octahedron| functions.@>
@*1 {\bf Trunc\_Octahedron} functions.
\initials{LDF 2004.10.21.}

@q ** (2) Constructors and setting functions.@>
@*1 Constructors and setting functions.

@q *** (3) Default constructor. (No arguments.)@>

@*2 Default constructor. (No arguments.)
@^\cfunc{Trunc\_Octahedron}{Trunc\_Octahedron}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.01.24.}
Now setting |shape_type = TRUNC_OCTAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG

@<Declare |Trunc_Octahedron| functions@>=
Trunc_Octahedron(void);

@
@<Define |Trunc_Octahedron| functions@>=
Trunc_Octahedron::Trunc_Octahedron(void)
{
  shape_type = TRUNC_OCTAHEDRON_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;

  do_output     = true;
  faces    = 14;          /* from |Solid_Faced|.  
                             \initials{LDF 2002.10.29.}
                             Truncated octahedrons consist of 6
                             squares and 8 hexagons.  */
  vertices = 24;
  edges    = 36;

  center = INVALID_POINT;  /* from |Polyhedron|.  */
  number_of_polygon_types = 2;
  face_radius = edge_radius = vertex_radius = INVALID_REAL;
  hexagon_radius = INVALID_REAL;
}

@q *** (3) Center, diameter of hexagon, and angles. @>
@*2 Center, diameter of hexagon, and angles.

@q **** (4) Constructor.@>
@*3 Constructor.
@^\cfunc{Trunc\_Octahedron}{Trunc\_Octahedron}@>

\LOG
\initials{LDF 2002.11.08.}  
Added this function.

\initials{LDF 2004.10.21.}
Started rewriting this function.

\initials{LDF 2004.10.22.}
Finished rewriting this function.

\initials{LDF 2005.01.24.}
Now setting |shape_type = TRUNC_OCTAHEDRON_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q ***** (5) Declaration.@>   

@<Declare |Trunc_Octahedron| functions@>=
Trunc_Octahedron(const Point& ccenter, 
                 const real diameter_of_hexagon,
                 real angle_x = 0, 
                 real angle_y = 0, 
                 real angle_z = 0,
                 Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>   

@
@<Define |Trunc_Octahedron| functions@>=
Trunc_Octahedron::Trunc_Octahedron(const Point& ccenter,
                                   const real hexagon_diameter,
                                   real angle_x, 
                                   real angle_y,
                                   real angle_z, 
                                   Scanner_Node scanner_node) 
{

@q ****** (6) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;
  
  stringstream cerr_strm;
    
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);
@q ****** (6).@> 

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering non-default `Trunc_Octahedron' constructor.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6).@> 

    shape_type = TRUNC_OCTAHEDRON_TYPE;
    surface_hiding_ctr = 0;
    decomposition_level = 0;

    do_output     = true;

    /*  !! TO DO.  TO DO:  Must calculate these!  */
    face_radius = 0;
    edge_radius = 0;
    vertex_radius = 0;

    faces    = 14;          /* from |Solid_Faced|.  
                               \initials{LDF 2002.10.29.}
                               Truncated octahedrons consist of 6
                               squares and 8 hexagons.  */
    vertices = 24;
    edges    = 36;
    number_of_polygon_types = 2;

    hexagon_radius = hexagon_diameter / 2.0;

    reg_polygons = get_net(hexagon_diameter, true);

    int i;
    
    Point p[34];

    for (i = 0; i < 6; i++)

      p[i] = reg_polygons[0]->get_point(i);

    for (i = 0; i < 6; i++)
       p[i + 9] = reg_polygons[3]->get_point(i);

    for (i = 0; i < 6; i++)
       p[i + 15] = reg_polygons[1]->get_point(i);

    real alpha = -(180 - (180 / PI * angle_hex_square));

    real beta = -(180 - (180 / PI * angle_hex_hex));

reg_polygons[5]->rotate(p[11], p[12], alpha);

    *reg_polygons[5] *= reg_polygons[3]->rotate(p[1], p[0], beta);
  
    reg_polygons[2]->rotate(p[2], p[3], beta);

    reg_polygons[4]->rotate(p[5], p[0], alpha);

    reg_polygons[6]->rotate(p[17], p[18], alpha);

    *reg_polygons[6] *= reg_polygons[1]->rotate(p[16], p[17], beta);

    for (i = 0; i < 7; i++)
       {
           reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[i]));
           reg_polygons.back()->rotate(180);
       }

     for (i = 0; i < 6; i++)
       p[i + 21] = reg_polygons[2]->get_point(i);

     for (i = 0; i < 4; i++)
       p[i + 27] = reg_polygons[11]->get_point(i);

    Transform t;

    t.shift(p[23] - p[27]);

    for (i = 7; i < 14; i++)
       {
           *reg_polygons[i] *= t;
       }

    t.reset();

   p[31] = reg_polygons[7]->get_center();

    t.shift(-.5 * p[31]);

    for (i = 0; i < 14; i++)
       {
           *reg_polygons[i] *= t;
       }

@q ****** (6) Rotate |*this| around the main axes, if necessary.@> 

@ Rotate |*this| around the main axes, if necessary.
\initials{LDF 2004.10.22.}

@<Define |Trunc_Octahedron| functions@>=

  if (angle_x || angle_y || angle_z)
    rotate(angle_x, angle_y, angle_z);

@q ****** (6) Shift |*this| so that |center| comes to lie at |ccenter|, @> 
@q ****** (6) if necessary.                                             @> 

@ Shift |*this| so that |center| comes to lie at |ccenter|, 
if necessary.                                             
\initials{LDF 2004.10.22.}

@<Define |Trunc_Octahedron| functions@>=

  Point origin(0, 0, 0);
  
  center = origin;

  if (ccenter != origin)
    center *= shift(ccenter);

@q ****** (6).@> 

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Exiting non-default `Trunc_Octahedron' "
                   << "constructor.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    return;

} /* End of non-default |Trunc_Octahedron| constructor definition.  */

@q ** (2) Get copy.@>
@*1 Get copy.
@^\cfunc{Trunc\_Octahedron}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Trunc_Octahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Trunc_Octahedron| functions@>=
Shape*
Trunc_Octahedron::get_copy() const
{
  Trunc_Octahedron* p = create_new<Trunc_Octahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q ** (2) Returning elements and information.@>
@*1 Returning elements and information.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@q *** (3) Get |Shape| type.@> 
@*2 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Trunc_Octahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return TRUNC_OCTAHEDRON_TYPE;
}

@q ** (2) Is |Trunc_Octahedron|.@> 
@*1 Is {\bf Trunc\_Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Trunc_Octahedron| functions@>=
virtual
inline
bool
is_trunc_octahedron(void) const 
{
   return true;
}

@q ** (2) Get net.@>  
@*1 Get net. 
@^\cfunc{Trunc\_Octahedron}{get\_net}@>

\LOG
\initials{LDF 2002.11.08.}  
Added this function.

\initials{LDF 2003.08.12.}  
Removed |center_0| argument.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.10.22.}
Finished rewriting this function.

\initials{LDF 2005.12.20.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

@<Declare |Trunc_Octahedron| functions@>=

static
vector<Reg_Polygon*>
get_net(const real hexagon_diameter,  
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@ 
@<Define |Trunc_Octahedron| functions@>=
vector<Reg_Polygon*>
Trunc_Octahedron::get_net(const real hexagon_diameter, 
                          bool do_half,
                          Scanner_Node scanner_node)
{
  bool DEBUG = false; /* |true| */@; 
  vector<Reg_Polygon*> reg_polygons;

  Point origin_pt(0, 0, 0);

  int i;

reg_polygons.push_back(create_new<Reg_Polygon>(0));
  reg_polygons[0]->set(origin_pt, 6, hexagon_diameter);

  Point p[24];
  for (i = 0; i < 6; i++)
    p[i] = reg_polygons[0]->get_point(i);

  reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[0]));
  reg_polygons[1]->shift(p[4] - p[2]);

  reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[0]));
  reg_polygons[2]->shift(p[3] - p[5]);

  reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[0]));
  reg_polygons[3]->shift(p[1] - p[3]);
  
  Point q[2];

  q[0] = p[0];
  q[0].shift(0, 1);
  
  p[6] = p[5];

  p[6].rotate(p[0], q[0], 90);

  p[7] = p[6].mediate(p[5]);

  real r = 2 * (p[7] - p[0]).magnitude();

  reg_polygons.push_back(create_new<Reg_Polygon>(0));
  reg_polygons.back()->set(p[7], 4, r);

  p[8] = reg_polygons.back()->get_point(3);

  reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons.back()));
  
  reg_polygons.back()->shift(p[1] - p[8]);

  reg_polygons.push_back(create_new<Reg_Polygon>(reg_polygons[4]));
  
  reg_polygons.back()->shift(p[4] - p[6]);

  return reg_polygons;

} /* End of |Trunc_Octahedron::get_net| definition.  */

@q * (1) Great Rhombicosidodecahedron.@>
@* {\bf Great Rhombicosidodecahedron}.
\initials{LDF 2005.12.14.}

Another name for the Great Rhombicosidodecahedron is
``Truncated Icosidodecahedron''.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this section.
\ENDLOG

@q ** (2) {\bf Great_Rhombicosidodecahedron} Class definition.@>
@*1 {\bf Great\_Rhombicosidodecahedron} class definition.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this |class| definition.
\ENDLOG

@<Declare |class Great_Rhombicosidodecahedron|@>=

class Great_Rhombicosidodecahedron : public Polyhedron
{
 protected:
    
  static const real angle_dec_square;  /* In radians!  */   
  static const real angle_dec_hex;   
  static const real angle_hex_square; 

  real decagon_radius;
 
 public:
  @<Declare |Great_Rhombicosidodecahedron| functions@>@;
};

@q ** (2) Define static const Great_Rhombicosidodecahedron data members.@>

@*1 Define {\bf static const Great\_Rhombicosidodecahedron} data members.

@<Define |static const Great_Rhombicosidodecahedron| data members@>=

const real Great_Rhombicosidodecahedron::angle_dec_square
    = (148 + (17.0 / 60.0)) * (PI / 180.0); 

const real Great_Rhombicosidodecahedron::angle_hex_square
    = (159 + (6.0 / 60.0)) * (PI / 180.0);   

const real Great_Rhombicosidodecahedron::angle_dec_hex
    = (142 + (37.0 / 60.0)) * (PI / 180.0); 

/* 
square-decagon:    148.28 degrees
hexagon-square:    159.095 degrees
hexagon-decagon:   142.62 degrees
*/

@q ** (2) |Great_Rhombicosidodecahedron| functions.@>
@*1 {\bf Great\_Rhombicosidodecahedron} functions.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this section.
\ENDLOG

@q ** (2) Constructors and setting functions.@>
@*1 Constructors and setting functions.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this section.
\ENDLOG

@q *** (3) Default constructor. (No arguments.)@>

@*2 Default constructor. (No arguments.)
@^\cfunc{Great\_Rhombicosidodecahedron}{Great\_Rhombicosidodecahedron}@>
\initials{LDF 2005.12.14.}

Great rhombicosidodecahedrons have 62 faces:  30 squares, 
20 hexagons, and 12 decagons.  They have 120 vertices 
and 180 edges.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Great_Rhombicosidodecahedron| functions@>=
Great_Rhombicosidodecahedron(void);

@
@<Define |Great_Rhombicosidodecahedron| functions@>=
Great_Rhombicosidodecahedron::Great_Rhombicosidodecahedron(void)
{
  shape_type = GREAT_RHOMBICOSIDODECAHEDRON_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;

  do_output     = true;
  faces    = 62;          /* from |Solid_Faced|.  */
  vertices = 120;
  edges    = 180;

  center = INVALID_POINT;  /* from |Polyhedron|.  */
  number_of_polygon_types = 3;
  face_radius = edge_radius = vertex_radius = INVALID_REAL;
  decagon_radius = INVALID_REAL;
}

@q *** (3) Center, diameter of hexagon, and angles. @>
@*2 Center, diameter of hexagon, and angles.
\initials{LDF 2005.12.14.}

@q **** (4) Constructor.@>
@*3 Constructor.
@^\cfunc{Great\_Rhombicosidodecahedron}{Great\_Rhombicosidodecahedron}@>
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.

\initials{LDF 2005.12.20.}
Finished writing this function.
\ENDLOG 

@q ***** (5) Declaration.@>   

@<Declare |Great_Rhombicosidodecahedron| functions@>=
Great_Rhombicosidodecahedron(const Point& ccenter, 
                 const real dodecagon_diameter,
                 real angle_x = 0, 
                 real angle_y = 0, 
                 real angle_z = 0,
                 Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>   

@
@<Define |Great_Rhombicosidodecahedron| functions@>=
Great_Rhombicosidodecahedron::Great_Rhombicosidodecahedron(
                                   const Point& ccenter,
                                   const real decagon_diameter,
                                   real angle_x, 
                                   real angle_y,
                                   real angle_z, 
                                   Scanner_Node scanner_node) 
{

@q ****** (6) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;
  
  stringstream cerr_strm;
    
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);
@q ****** (6).@> 

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering non-default `Great_Rhombicosidodecahedron' constructor.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6).@> 

    shape_type = GREAT_RHOMBICOSIDODECAHEDRON_TYPE;
    surface_hiding_ctr = 0;
    decomposition_level = 0;

    do_output     = true;

    /*  !! TO DO.  TO DO:  Must calculate these!  */
    face_radius = 0;
    edge_radius = 0;
    vertex_radius = 0;

    faces    = 62;          /* from |Solid_Faced|.  */

    vertices = 120;
    edges    = 180;
    number_of_polygon_types = 3;

    decagon_radius = decagon_diameter / 2.0;

    reg_polygons = get_net(decagon_diameter);

@q ****** (6) Rotations.@> 
@ Rotations.
\initials{LDF 2005.12.20.}

\LOG
\initials{LDF 2005.12.20.}
Added this section.
\ENDLOG

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******* (7)@> 

    Point axis_0;
    Point axis_1;

    Transform t;
    int i;

    real dec_hex_angle    = 180 - (angle_dec_hex * 180 / PI);

    real dec_square_angle = 180 - (angle_dec_square * 180 / PI);

    real hex_square_angle = 180 - (angle_hex_square * 180 / PI);

@q ******* (7) Column 1.@> 
@ Column 1.

@<Define |Great_Rhombicosidodecahedron| functions@>=

    axis_0 = reg_polygons[0]->get_point(9);
    axis_1 = reg_polygons[0]->get_point(0);

    reg_polygons[0]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[3]->get_point(4);
    axis_1 = reg_polygons[3]->get_point(5);

    reg_polygons[4]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[3]->get_point(2);
    axis_1 = reg_polygons[3]->get_point(3);

    *(reg_polygons[4]) *= reg_polygons[3]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[2]->get_point(1);
    axis_1 = reg_polygons[2]->get_point(2);

    *reg_polygons[4] *= *reg_polygons[3]
       *= reg_polygons[2]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[5]->get_point(0);
    axis_1 = reg_polygons[5]->get_point(1);

    *reg_polygons[4] *= *reg_polygons[3]
       *= *reg_polygons[2] 
       *= *reg_polygons[1] 
       *= reg_polygons[0]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[5]->get_point(3);
    axis_1 = reg_polygons[5]->get_point(2);

    *reg_polygons[5] *= *reg_polygons[4] *= *reg_polygons[3]
       *= *reg_polygons[2] 
       *= *reg_polygons[1] 
       *= reg_polygons[0]->rotate(axis_0, axis_1, hex_square_angle);

@q ******* (7) Column 2.@> 
@ Column 2.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[6]->get_point(0);
    axis_1 = reg_polygons[6]->get_point(5);

    reg_polygons[7]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[9]->get_point(1);
    axis_1 = reg_polygons[9]->get_point(2);

    reg_polygons[10]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[9]->get_point(5);
    axis_1 = reg_polygons[9]->get_point(0);

    *reg_polygons[9] *= reg_polygons[10]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[6]->get_point(3);
    axis_1 = reg_polygons[6]->get_point(2);

    *reg_polygons[8] *= *reg_polygons[9] 
       *= reg_polygons[10]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 
    axis_0 = reg_polygons[6]->get_point(5);
    axis_1 = reg_polygons[6]->get_point(4);

    *reg_polygons[0] *= *reg_polygons[1]
       *= *reg_polygons[2] *= *reg_polygons[3]  
       *= *reg_polygons[4] *= *reg_polygons[5] 
       *= *reg_polygons[6] *= *reg_polygons[7] 
       *= *reg_polygons[8] *= *reg_polygons[9] 
       *= reg_polygons[10]->rotate(axis_0, axis_1, hex_square_angle);

@q ******* (7) Column 3.@> 
@ Column 3.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[13]->get_point(2);
    axis_1 = reg_polygons[13]->get_point(3);

    reg_polygons[12]->rotate(axis_1, axis_0, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[15]->get_point(5);
    axis_1 = reg_polygons[15]->get_point(0);

    reg_polygons[17]->rotate(axis_1, axis_0, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[15]->get_point(4);
    axis_1 = reg_polygons[15]->get_point(5);

    reg_polygons[16]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 
    axis_0 = reg_polygons[15]->get_point(2);
    axis_1 = reg_polygons[15]->get_point(3);

    *reg_polygons[15] *= *reg_polygons[16] 
       *= reg_polygons[17]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 
    axis_0 = reg_polygons[13]->get_point(0);
    axis_1 = reg_polygons[13]->get_point(5);

    *reg_polygons[14] *= *reg_polygons[15] *= *reg_polygons[16] 
       *= reg_polygons[17]->rotate(axis_0, axis_1, hex_square_angle);

@q ******* (7) Fold columns 1 and 2 over column 3.@> 
@ Fold columns 1 and 2 over column 3.

@<Define |Great_Rhombicosidodecahedron| functions@>=

    axis_0 = reg_polygons[13]->get_point(1);
    axis_1 = reg_polygons[13]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 12; ++i)
       *reg_polygons[i] *= t;

@q ******* (7) Column 4.@> 
@ Column 4.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[20]->get_point(0);
    axis_1 = reg_polygons[20]->get_point(5);

    reg_polygons[19]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[22]->get_point(1);
    axis_1 = reg_polygons[22]->get_point(2);

    reg_polygons[23]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[22]->get_point(5);
    axis_1 = reg_polygons[22]->get_point(0);

    *reg_polygons[22] 
       *= reg_polygons[23]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[20]->get_point(3);
    axis_1 = reg_polygons[20]->get_point(2);

    *reg_polygons[21] *= *reg_polygons[22] 
       *= reg_polygons[23]->rotate(axis_0, axis_1, hex_square_angle);

@q ******* (7) Fold columns 1 through 3 over column 4.@> 
@ Fold columns 1 through 3 over column 4.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[18]->get_point(0);
    axis_1 = reg_polygons[18]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 18; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[20]->get_point(0);
    axis_1 = reg_polygons[20]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 19; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7) Column 5.@> 
@ Column 5.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[26]->get_point(3);
    axis_1 = reg_polygons[26]->get_point(2);

    reg_polygons[24]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[28]->get_point(4);
    axis_1 = reg_polygons[28]->get_point(5);

    reg_polygons[29]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[28]->get_point(2);
    axis_1 = reg_polygons[28]->get_point(3);

    *reg_polygons[28] 
       *= reg_polygons[29]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[26]->get_point(0);
    axis_1 = reg_polygons[26]->get_point(5);

    *reg_polygons[27] *= *reg_polygons[28] 
       *= reg_polygons[29]->rotate(axis_0, axis_1, hex_square_angle);

@q ******* (7) Fold columns 1 through 4 over column 5.@> 
@ Fold columns 1 through 4 over column 5.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[25]->get_point(0);
    axis_1 = reg_polygons[25]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 24; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[25]->get_point(3);
    axis_1 = reg_polygons[25]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 24; ++i)
       *reg_polygons[i] *= t;    

    *reg_polygons[25] *= t;

@q ******* (7) Column 6.@> 
@ Column 6.

@q ******** (8)@> 

@<Define |Great_Rhombicosidodecahedron| functions@>=

    axis_0 = reg_polygons[34]->get_point(1);
    axis_1 = reg_polygons[34]->get_point(2);

    reg_polygons[35]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[34]->get_point(5);
    axis_1 = reg_polygons[34]->get_point(0);

    *reg_polygons[34] *= reg_polygons[35]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[32]->get_point(3);
    axis_1 = reg_polygons[32]->get_point(2);

    *reg_polygons[33] *= *reg_polygons[34] 
       *= reg_polygons[35]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[32]->get_point(0);
    axis_1 = reg_polygons[32]->get_point(5);

    reg_polygons[31]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******* (7) Fold columns 1 through 5 over column 6.@> 
@ Fold columns 1 through 5 over column 6.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[30]->get_point(0);
    axis_1 = reg_polygons[30]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 30; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[30]->get_point(3);
    axis_1 = reg_polygons[30]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 31; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7) Column 7.@> 
@ Column 7.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[40]->get_point(4);
    axis_1 = reg_polygons[40]->get_point(5);

    reg_polygons[41]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[40]->get_point(2);
    axis_1 = reg_polygons[40]->get_point(3);

    *reg_polygons[40] *= reg_polygons[41]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[38]->get_point(0);
    axis_1 = reg_polygons[38]->get_point(5);

    *reg_polygons[39] *= *reg_polygons[40] 
       *= reg_polygons[41]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[38]->get_point(3);
    axis_1 = reg_polygons[38]->get_point(2);

    reg_polygons[37]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******* (7) Fold columns 1 through 6 over column 7.@> 
@ Fold columns 1 through 6 over column 7.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[36]->get_point(0);
    axis_1 = reg_polygons[36]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 36; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[36]->get_point(3);
    axis_1 = reg_polygons[36]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 37; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7) Column 8.@> 
@ Column 8.

@q ******** (8)@> 

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[46]->get_point(3);
    axis_1 = reg_polygons[46]->get_point(2);

    reg_polygons[49]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[46]->get_point(1);
    axis_1 = reg_polygons[46]->get_point(2);

    reg_polygons[47]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[46]->get_point(5);
    axis_1 = reg_polygons[46]->get_point(0);

    *reg_polygons[46] *= *reg_polygons[47] 
       *= reg_polygons[49]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[44]->get_point(3);
    axis_1 = reg_polygons[44]->get_point(2);

    *reg_polygons[45] *= *reg_polygons[46] *= *reg_polygons[47] 
       *= reg_polygons[49]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[44]->get_point(0);
    axis_1 = reg_polygons[44]->get_point(5);

    reg_polygons[43]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******* (7) Fold columns 1 through 7 over column 8.@> 
@ Fold columns 1 through 7 over column 8.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[42]->get_point(0);
    axis_1 = reg_polygons[42]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 42; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[42]->get_point(3);
    axis_1 = reg_polygons[42]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 43; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7) Column 9.@> 
@ Column 9.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[53]->get_point(4);
    axis_1 = reg_polygons[53]->get_point(5);

    reg_polygons[54]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[53]->get_point(2);
    axis_1 = reg_polygons[53]->get_point(3);

    *reg_polygons[53] *= reg_polygons[54]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[51]->get_point(0);
    axis_1 = reg_polygons[51]->get_point(5);

    *reg_polygons[52] *= *reg_polygons[53] 
       *= reg_polygons[54]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[51]->get_point(3);
    axis_1 = reg_polygons[51]->get_point(2);

    reg_polygons[50]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******* (7) Fold columns 1 through 8 over column 9.@> 
@ Fold columns 1 through 8 over column 9.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[48]->get_point(0);
    axis_1 = reg_polygons[48]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 48; ++i)
       *reg_polygons[i] *= t;    

    *reg_polygons[49] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[48]->get_point(3);
    axis_1 = reg_polygons[48]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 50; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7) Column 10.@> 
@ Column 10.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[59]->get_point(1);
    axis_1 = reg_polygons[59]->get_point(2);

    reg_polygons[60]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[59]->get_point(5);
    axis_1 = reg_polygons[59]->get_point(0);

    *reg_polygons[59] *= reg_polygons[60]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[57]->get_point(3);
    axis_1 = reg_polygons[57]->get_point(2);

    *reg_polygons[58] *= *reg_polygons[59] 
       *= reg_polygons[60]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[57]->get_point(4);
    axis_1 = reg_polygons[57]->get_point(5);

    reg_polygons[61]->rotate(axis_0, axis_1, hex_square_angle);

@q ******** (8)@> 

    axis_0 = reg_polygons[57]->get_point(0);
    axis_1 = reg_polygons[57]->get_point(5);

    reg_polygons[56]->rotate(axis_0, axis_1, dec_hex_angle);

@q ******* (7) Fold columns 1 through 9 over column 10.@> 
@ Fold columns 1 through 9 over column 10.

@<Define |Great_Rhombicosidodecahedron| functions@>=

@q ******** (8)@> 

    axis_0 = reg_polygons[55]->get_point(0);
    axis_1 = reg_polygons[55]->get_point(1);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 55; ++i)
       *reg_polygons[i] *= t;    

@q ******** (8)@> 

    axis_0 = reg_polygons[55]->get_point(3);
    axis_1 = reg_polygons[55]->get_point(2);

    t.reset();
    t.rotate(axis_0, axis_1, hex_square_angle);

    for (i = 0; i < 56; ++i)
       *reg_polygons[i] *= t;    

@q ******* (7)@> 

@q ****** (6)@> 

@q ****** (6)@> 

    axis_0 = reg_polygons[26]->get_center();

    Point mid_pt = axis_0.mediate(reg_polygons[57]->get_center());

    t.reset();
    t.align_with_axis(mid_pt, axis_0, 'y');

    operator*=(t);
 
    center = ORIGIN;
    
    return;

} /* End of non-default |Great_Rhombicosidodecahedron| constructor definition.  */

@q ** (2) Get copy.@>
@*1 Get copy.
@^\cfunc{Great\_Rhombicosidodecahedron}{get\_copy}@>
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Great_Rhombicosidodecahedron| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Great_Rhombicosidodecahedron| functions@>=
Shape*
Great_Rhombicosidodecahedron::get_copy() const
{
  Great_Rhombicosidodecahedron* p = create_new<Great_Rhombicosidodecahedron>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q ** (2) Returning elements and information.@>
@*1 Returning elements and information.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this section.
\ENDLOG

@q *** (3) Get |Shape| type.@> 
@*2 Get {\bf Shape} type.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Great_Rhombicosidodecahedron| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return GREAT_RHOMBICOSIDODECAHEDRON_TYPE;
}

@q ** (2) Is |Great_Rhombicosidodecahedron|.@> 
@*1 Is {\bf Great\_Rhombicosidodecahedron}.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Great_Rhombicosidodecahedron| functions@>=
virtual
inline
bool
is_great_rhombicosidodecahedron(void) const 
{
   return true;
}

@q ** (2) Get net.@>  
@*1 Get net. 
@^\cfunc{Great\_Rhombicosidodecahedron}{get\_net}@>
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.

\initials{LDF 2005.12.16.}
Finished writing this function.

\initials{LDF 2005.12.20.}
Added code for returning half of the net.

\initials{LDF 2005.12.20.}
Added the optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Great_Rhombicosidodecahedron| functions@>=

static
vector<Reg_Polygon*>
get_net(const real dodecagon_diameter,  
        bool do_half = false,
        Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@ 
@<Define |Great_Rhombicosidodecahedron| functions@>=
vector<Reg_Polygon*>
Great_Rhombicosidodecahedron::get_net(const real dodecagon_diameter, 
                                      bool do_half,
                                      Scanner_Node scanner_node)
{
@q **** (4)@> 

    vector<Reg_Polygon*> reg_polygons;

    Point normal;

    Reg_Polygon decagon[12];
    Reg_Polygon hexagon[20];
    Reg_Polygon square[30];

@q **** (4) Column 1.@> 

@q ***** (5) decagon 0.@> 

    decagon[0].set(ORIGIN, 10, dodecagon_diameter);

    real mag = (decagon[0].get_point(0) - decagon[0].get_point(9)).magnitude();

@q ***** (5) hexagon 0.@> 

    hexagon[0].set(ORIGIN, 6, 2 * mag);
    hexagon[0].shift(decagon[0].get_point(0) - hexagon[0].get_point(2));

@q ***** (5) square 0.@> 

    square[0].set(ORIGIN, 4, 2 * mag / sqrt(2.0));
    square[0].shift(hexagon[0].get_point(0) - square[0].get_point(1));

@q ***** (5) hexagon 1.@> 

    hexagon[1] = hexagon[0];
    hexagon[1].shift(square[0].get_point(0) - decagon[0].get_point(0));

@q ***** (5) square 1.@> 

    square[1] = square[0];
    square[1].shift(hexagon[1].get_point(5) - square[0].get_point(1));
 
    normal = hexagon[1].get_point(5);
    normal.shift(0, 1);

    square[1].rotate(hexagon[1].get_point(5), normal, -60);

@q ***** (5) square 2.@> 

    square[2] = square[0];
    square[2].shift(hexagon[0].get_point(4) - square[0].get_point(0));
 
    normal = hexagon[0].get_point(4);
    normal.shift(0, 1);

    square[2].rotate(hexagon[0].get_point(4), normal, -30);

@q **** (4) Column 2.@> 

@q ***** (5) hexagon 2.@> 

    hexagon[2] = hexagon[0];
    hexagon[2].shift(square[2].get_point(2) - hexagon[0].get_point(1));

@q ***** (5) decagon 1.@> 

    decagon[1] = decagon[0];
    decagon[1].shift(hexagon[2].get_point(0) - decagon[0].get_point(4));

@q ***** (5) square 3.@> 

    square[3] = square[0];
    square[3].shift(hexagon[2].get_point(2) - square[0].get_point(0));

@q ***** (5) hexagon 3.@> 

    hexagon[3] = hexagon[0];
    hexagon[3].shift(square[3].get_point(1) - hexagon[0].get_point(0));

@q ***** (5) square 4.@> 

    square[4] = square[0];
    square[4].shift(hexagon[3].get_point(1) - square[0].get_point(3));

    normal = hexagon[3].get_point(1);
    normal.shift(0, 1);

    square[4].rotate(hexagon[3].get_point(1), normal, 30);

@q ***** (5) square 5.@> 

    square[5] = square[4];
    square[5].shift(hexagon[2].get_point(5) - square[4].get_point(0));

@q **** (4) Column 3.@> 

    decagon[2] = decagon[0];
    hexagon[4] = hexagon[0];
    square[6]  = square[0];
    hexagon[5] = hexagon[1];
    square[7]  = square[1];

    Transform t;
    t.shift(square[5].get_point(2) - hexagon[0].get_point(2));

    decagon[2] *= hexagon[4] *= square[6] 
               *= hexagon[5] *= square[7] *= t;

    decagon[3] = decagon[2];
    
    decagon[3].shift(hexagon[5].get_point(0) - decagon[2].get_point(4));

@q **** (4) Column 4.@> 

    square[8]  = square[2];
    decagon[4] = decagon[1];
    hexagon[6] = hexagon[2];
    square[9]  = square[3];
    hexagon[7] = hexagon[3];
    square[10] = square[4];
   
    t.reset();
    t.shift(hexagon[4].get_point(4) - square[2].get_point(0));

    square[8] *= decagon[4] *=  hexagon[6] 
              *= square[9]  *= hexagon[7] *= square[10] *= t;

@q ***** (5) Column 5.@> 

    decagon[5] = decagon[2];
    square[11] = square[5];
    hexagon[8] = hexagon[4];
    square[12] = square[6];
    hexagon[9] = hexagon[5];
    square[13] = square[7];
    square[14] = square[8];
   
    t.reset();
    t.shift(hexagon[6].get_point(4) - square[5].get_point(1));

   decagon[5] *= square[11] *= hexagon[8] *= square[12] 
              *= hexagon[9] *= square[13] *= square[14] *= t;

@q **** (4) Column 6.@> 

    decagon[6] = decagon[4];
    hexagon[10] = hexagon[6];
    square[15]  = square[9];
    hexagon[11] = hexagon[7];
    square[16] = square[10];
    square[17] = square[11];
   
    t.reset();
    t.shift(square[14].get_point(2) - hexagon[6].get_point(1));

    decagon[6] *=  hexagon[10] *= square[15] 
              *= hexagon[11] *= square[16]  *= t;

    if (do_half)
       goto A; 

    square[17] = square[11];
    square[17] *= t;

@q **** (4) Column 7.@> 

    decagon[7] = decagon[5];
    hexagon[12] = hexagon[8];
    square[18]  = square[12];
    hexagon[13] = hexagon[9];
    square[19] = square[13];
    square[20] = square[14];
   
    t.reset();
    t.shift(square[17].get_point(2) - hexagon[8].get_point(2));

    decagon[7] *=  hexagon[12] *= square[18] 
              *= hexagon[13] *= square[19]  *= square[20] *= t;

@q **** (4) Column 8.@> 

    decagon[8] = decagon[6];
    hexagon[14] = hexagon[10];
    square[21]  = square[15];
    hexagon[15] = hexagon[11];
    square[22] = square[16];
    square[23] = square[17];
   
    t.reset();
    t.shift(hexagon[12].get_point(3) - square[14].get_point(1));

    decagon[8] *=  hexagon[14] *= square[21] 
              *= hexagon[15] *= square[22]  *= square[23] *= t;

    decagon[9] = decagon[7];

    decagon[9].shift(hexagon[15].get_point(2) - decagon[7].get_point(0));

@q **** (4) Column 9.@> 

    decagon[10] = decagon[7];
    hexagon[16] = hexagon[12];
    square[24]  = square[18];
    hexagon[17] = hexagon[13];
    square[25] = square[19];
    square[26] = square[20];
   
    t.reset();
    t.shift(square[23].get_point(2) - hexagon[12].get_point(2));

    decagon[10] *=  hexagon[16] *= square[24] 
              *= hexagon[17] *= square[25]  *= square[26] *= t;

@q **** (4) Column 10.@> 

    decagon[11] = decagon[8];
    hexagon[18] = hexagon[14];
    square[27]  = square[21];
    hexagon[19] = hexagon[15];
    square[28] = square[22];
    square[29] = square[23];
   
    t.reset();
    t.shift(square[26].get_point(2) - hexagon[14].get_point(1));

    decagon[11] *=  hexagon[18] *= square[27] 
              *= hexagon[19] *= square[28]  *= square[29] *= t;

@q **** (4) Push |Reg_Polygon| pointers onto |reg_polygons|.@> 

   A:

@q ***** (5) Column 1.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[0]));

    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[0]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[0]));

    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[1]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[1]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[2]));

@q ***** (5) Column 2.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[2]));

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[1]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[3]));

    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[3]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[4]));

    reg_polygons.push_back(create_new<Reg_Polygon>(square[5]));

@q ***** (5) Column 3.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[2]));
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[4]));
    reg_polygons.push_back(create_new<Reg_Polygon>(square[6]));
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[5]));
    reg_polygons.push_back(create_new<Reg_Polygon>(square[7])); 
    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[3]));

@q ***** (5) Column 4.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(square[8]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[4])); 
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[6])); 
    reg_polygons.push_back(create_new<Reg_Polygon>(square[9]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[7])); 
    reg_polygons.push_back(create_new<Reg_Polygon>(square[10])); 

@q ***** (5) Column 5.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[5]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(square[11]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[8]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(square[12]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[9]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(square[13]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(square[14]));  

@q ***** (5) Column 6.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[6]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[10]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(square[15]));   
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[11]));  
    reg_polygons.push_back(create_new<Reg_Polygon>(square[16]));   

    if (do_half)
       return reg_polygons;

    reg_polygons.push_back(create_new<Reg_Polygon>(square[17]));   

@q ***** (5) Column 7.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[7]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[12]));    
    reg_polygons.push_back(create_new<Reg_Polygon>(square[18]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[13]));    
    reg_polygons.push_back(create_new<Reg_Polygon>(square[19]));    
    reg_polygons.push_back(create_new<Reg_Polygon>(square[20]));    

@q ***** (5) Column 8.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[8]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[14]));    
    reg_polygons.push_back(create_new<Reg_Polygon>(square[21]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[15]));    
    reg_polygons.push_back(create_new<Reg_Polygon>(square[22]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(square[23]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[9]));     

@q ***** (5) Column 9.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[10]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[16]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(square[24]));      
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[17]));     
    reg_polygons.push_back(create_new<Reg_Polygon>(square[25]));      
    reg_polygons.push_back(create_new<Reg_Polygon>(square[26]));      

@q ***** (5) Column 10.@> 

    reg_polygons.push_back(create_new<Reg_Polygon>(decagon[11]));       
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[18]));       
    reg_polygons.push_back(create_new<Reg_Polygon>(square[27]));        
    reg_polygons.push_back(create_new<Reg_Polygon>(hexagon[19]));       
    reg_polygons.push_back(create_new<Reg_Polygon>(square[28]));       
    reg_polygons.push_back(create_new<Reg_Polygon>(square[29]));       

@q ***** (5)@> 

    return reg_polygons;

} /* End of |Great_Rhombicosidodecahedron::get_net| definition.  */

@q * (1) |struct Polyhedron_Options|.@>
@* {\bf struct Polyhedron\_Options}.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this struct declaration.

\initials{LDF 2007.10.24.}
Added |real rhombus_0_side_length|.
\ENDLOG

@<Declare |struct Polyhedron_Options|@>=
struct Polyhedron_Options
{

   real polygon_0_diameter;
   real polygon_1_diameter;
   real polygon_2_diameter;
   real polygon_3_diameter;

   real rhombus_0_side_length;

   bool do_half;
   bool do_stitch_lines;
   unsigned short stitch_divisions;

   @<Declare |Polyhedron_Options| functions@>@;

};

@q ** (2) |Polyhedron_Options| functions.@>
@*1 {\bf Polyhedron\_Options} functions.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this section.
\ENDLOG

@q *** (3) Default constructor.@>
@*2 Default constructor.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this function.

\initials{LDF 2007.10.24.}
@:BUG FIX@> BUG FIX:  Now setting |polygon_0_diameter| to 0.

\initials{LDF 2007.10.24.}
Now setting |rhombus_0_side_length| to 0.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Polyhedron_Options| functions@>=

Polyhedron_Options(void);

@q **** (4) Definition.@>
@
@<Define |Polyhedron_Options| functions@>=
Polyhedron_Options::Polyhedron_Options(void)
{

   polygon_0_diameter = 0;
   polygon_1_diameter = 0;
   polygon_2_diameter = 0;
   polygon_3_diameter = 0;

   rhombus_0_side_length = 0;

   do_half            = false;;
   do_stitch_lines    = true;
   stitch_divisions   = 5;
}

@q *** (3) Destructor.@>
@*2 Destructor.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this function.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Polyhedron_Options| functions@>=
virtual
~Polyhedron_Options(void);

@q **** (4) Definition.@>
@
@<Define |Polyhedron_Options| functions@>=
Polyhedron_Options::~Polyhedron_Options(void)
{

    return;
}

@q *** (3) Clear.@>
@*2 Clear.
\initials{LDF 2007.10.12.}

\LOG
\initials{LDF 2007.10.12.}
Added this function.

\initials{LDF 2007.10.24.}
@:BUG FIX@> BUG FIX:  Now setting |polygon_0_diameter| to 0.

\initials{LDF 2007.10.24.}
Now setting |rhombus_0_side_length| to 0.
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Polyhedron_Options| functions@>=
void
clear(void);

@q **** (4) Definition.@>
@
@<Define |Polyhedron_Options| functions@>=
void
Polyhedron_Options::clear(void)
{

    polygon_0_diameter = 0;
    polygon_1_diameter = 0;
    polygon_2_diameter = 0;
    polygon_3_diameter = 0;

    rhombus_0_side_length = 0;

    do_half            = false;;
    do_stitch_lines    = false;
    stitch_divisions   = 0;

    return;
}

@q * (1) Putting Polyhedra together.@>
@ Putting polyhedra together.
@ This is what's compiled.
@c
@<Include files@>@;
@<Declare |class Polyhedron|@>@;
@<Declare |class Tetrahedron|@>@;
@<Define |static const Tetrahedron| data members@>@;
@<Declare |class Octahedron|@>@;
@<Define |static const Octahedron| data members@>@;
@<Declare |class Icosahedron|@>@;
@<Define |static const Icosahedron| data members@>@;
@<Declare |class Trunc_Octahedron|@>@;
@<Define |static const Trunc_Octahedron| data members@>@;
@<Declare |class Great_Rhombicosidodecahedron|@>@;
@<Define |static const Great_Rhombicosidodecahedron| data members@>@;
@<Declare |struct Polyhedron_Options|@>@;
@<Define |Polyhedron| functions@>@;
@<Define |Tetrahedron| functions@>@;
@<Define |Octahedron| functions@>@;
@<Define |Icosahedron| functions@>@;
@<Define |Trunc_Octahedron| functions@>@;
@<Define |Great_Rhombicosidodecahedron| functions@>@;
@<Define |Polyhedron_Options| functions@>@;

@ This is what's written to \filename{polyhed.h}. 
@(polyhed.h@>=
@<Declare |class Polyhedron|@>@;
@<Declare |class Tetrahedron|@>@;
@<Declare |class Octahedron|@>@;
@<Declare |class Icosahedron|@>@;
@<Declare |class Trunc_Octahedron|@>@;
@<Declare |class Great_Rhombicosidodecahedron|@>@;
@<Declare |struct Polyhedron_Options|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
