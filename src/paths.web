@q paths.web @>
   
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Path.@>       
@** Path\quad ({\tt paths\PERIOD web}).\hfil
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  
Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@f Path Shape

@q * Include files. @>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  
Now including \filename{pens.h}.

\initials{LDF 2005.01.28.}
Now including \filename{nurbs.h}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"

#include <string.h>

#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"

@q * (1) class Path definition.@>
@* {\bf Path} class definition.

\LOG
\initials{LDF 2002.09.18.}  
Added |projective_extremes|.  
It contains the minimum and maximum values for 
x, y, and z of the |Points| in |points|.  It's used in
|Picture::output| for surface hiding.   

\initials{LDF 2002.4.8.}  
Added |static| variables for help lines and 
curves: |help_color|, |help_dash_pattern|,\break
|do_help_lines|.
The variables for help lines (or curves) are part of |Path|'s
interface and can be set anywhere by anyone.

\initials{LDF 2002.09.18}.  
Added |projective_extremes|.

\initials{LDF 2003.01.15}  
Added |arrow|.  It's needed for |drawarrow|.

\initials{LDF 2004.06.02.}  
Made |draw_color| and |fill_color| non-|const|.
Changed |pen| from a |string| to a |Pen*|.

\initials{LDF 2004.06.07.}  
Changed |string dashed| to 
|Dash_Pattern* dash_pattern|.  
Removed |static string help_dash_pattern|.

\initials{LDF 2004.06.07.}  
Removed |static const Color* help_color| and
|static bool do_help_lines|.

\initials{LDF 2004.11.07.}
Changed |bool arrow| to |unsigned short|.
Added the |static const unsigned shorts NO_ARROW|,
|SINGLE_ARROW|, and |DOUBLE_ARROW| for setting it.

\initials{LDF 2004.11.08.}
Made the |static const unsigned shorts| |NO_ARROW|,
|SINGLE_ARROW|, and |DOUBLE_ARROW| |public|.

\initials{LDF 2005.02.07.}
Added |vector<Color*> draw_color_vector|.  It's needed for 
decomposing |Paths|.

\initials{LDF 2005.03.10.}
Changed the type of |draw_color_vector| from |vector<Color*>| to 
|Pointer_Vector<Color>*|.

\initials{LDF 2005.03.16.}
Removed |Color* draw_color|. 
Removed all references to it without comment.

\initials{LDF 2005.03.16.}
Added |Pointer_Vector<Dash_Pattern>* dash_pattern_vector|
and |Pointer_Vector<Pen>* pen_vector|.

\initials{LDF 2005.03.16.}
Removed conditionally compiled code for declaring
|Pointer_Vector<Dash_Pattern>* dash_pattern_vector|
and |Pointer_Vector<Pen>* pen_vector|.  About to try 
declaring them in the |class Shape| definition in 
\filename{shapes.web}.

\initials{LDF 2005.03.18.}
Removed |Color* fill_color|.  Removed some, if not all, other
references to it without comment.

\initials{LDF 2005.03.18.}
Removed |Pen* pen|.  Removed all references to it without comment.

\initials{LDF 2005.03.18.}
Removed |Dash_Pattern* dash_pattern|.  
Removed some, if not all, other
references to it without comment.

\initials{LDF 2005.04.04.}
Added |valarray <real> world_extremes|.

\initials{LDF 2005.08.16.}
Added |friend| declaration for 
|Scan_Parse::clip_to_func(void*, void*)|.

\initials{LDF 2013.11.10.}
@:BUG FIX@> BUG FIX:  Changed the type of derivation from |Shape| 
from |protected| to |public|.  This caused a compilation error in 
|Pointer_Vector<C, D>::convert| when compiling with GCC 4.8.2.
It had still worked with GCC 4.6.2.
\ENDLOG 

@q ** (2) Definition.  @>

@<Define |class Path|@>=

class Path : public Shape
{
   friend void* Scan_Parse::clip_to_func(void*, void*);
   friend int Scanner_Type::show_database(void);
   friend int yyparse(yyscan_t);

 protected:
  
  bool line_switch;
  bool cycle_switch;
  
  bool do_output; /* LDF 2002.09.18.  Added.  */
  
@q *** (3) Variables for drawing and filling.  @>
@ Variables for drawing and filling.  

@<Define |class Path|@>=

  signed short fill_draw_value;  
    
  unsigned short arrow; 

@ 
\LOG
\initials{LDF 2005.06.30.}
Added |valarray <real> pre_projective_extremes|.
\ENDLOG 

@<Define |class Path|@>=

  valarray <real> world_extremes;   
  valarray <real> pre_projective_extremes;   
  valarray <real> projective_extremes;   

  vector <Point*> points;
  vector <string> connectors;
  vector <Connector_Type*> connector_type_vector;

 public:

  static const unsigned short NO_ARROW;
  static const unsigned short SINGLE_ARROW;
  static const unsigned short DOUBLE_ARROW;

  @<Declare |Path| functions@>@;
};

@q ** (2) Static member variable definitions.  @>
@*1 Static member variable definitions.

\LOG
\initials{LDF 2004.11.07.}
Added the |static const unsigned shorts NO_ARROW|,
|SINGLE_ARROW|, and |DOUBLE_ARROW| for setting 
|arrow|.
\ENDLOG 

@<Define |static| |class Path| data members@>=

   const unsigned short Path::NO_ARROW      = 0;
   const unsigned short Path::SINGLE_ARROW  = 1;
   const unsigned short Path::DOUBLE_ARROW  = 2;

@q * (1) Assignment. @>
@* Assignment. 
@^\cofunc{Path}{=}@>

\LOG 
\initials{LDF 2002.10.23.} 
|draw_color| and |fill_color| point to the same |Color| as
|p.draw_color| and |p.fill_color|.  No memory allocation 
is performed.

\initials{LDF 2002.10.23.}  
Now all of the data members of |class Path| 
are assigned to except for |on_free_store|.  This has become necessary
because of changes in |Solid::output|, where temporary |Paths| have
to be created in order to sort them. 

\initials{LDF 2002.12.18.}  
@^porting@>
Moved here.  With the DEC compiler under Compaq Tru64
on the DEC Alpha computer, it worked to have this following the
constructors.  With the GNU \CPLUSPLUS/ compiler (GCC) under GNU/Linux on the
Intel i686 computer, it didn't:  The copy constructor used the default
assignment operator instead of this function, presumably because this
function wasn't known at the time the copy constructor was compiled, 
{\it although it had been declared previously\/}!  @:!! URGENT@>  URGENT:
Move assignment operators for the other |classes| before the constructors!

\initials{LDF 2003.04.09.}  
@:??@> ?? 
@: BUG FIX@> BUG FIX: 
Now resizing |projective_extremes|, if after setting it to\newline
|p.projective_extremes|, |projective_extremes.size() == 0|.  This
prevents a Memory Fault error at run-time.  I don't know why it should
be necessary, though, since all of the constructors of |Path| and its
derived classes resize |projective_extremes|;  at least, I thought
they did.

\initials{LDF 2004.06.02.}  
Changed the way |pen| is handled to
reflect the fact that it's now a |Pen*| rather than a |string|.

\initials{LDF 2004.06.07.}  
Changed the way |dash_pattern| is handled to reflect
the fact that it's now a |Dash_Pattern*| rather than a |string|.  It also used
to be called |dashed| rather than |dash_pattern|.

\initials{LDF 2004.06.18.}
Now allocating memory and copying |p.draw_color| to |draw_color| 
if |p.draw_color| is non-null.  Otherwise, |draw_color| is set to 0.  The same
applies to |p.fill_color|. 

\initials{LDF 2004.06.18.}
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2005.03.10.}
Made debugging output thread-safe.

\initials{LDF 2005.03.16.}
Added code for setting |dash_pattern_vector| and |pen_vector|.
\ENDLOG 

@q ** (2) Declaration. @>

@<Declare |Path| functions@>=
virtual
Path&
operator=(const Path& p);

@q ** (2) Definition. @>

@
@<Define |Path| functions@>=

Path&
Path::operator=(const Path& p)
{

@q *** (3) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q *** (3).@>
@
\LOG
\initials{LDF 2005.10.30.}
@:BUG FIX@> BUG FIX:  Now setting |arrow = p.arrow|.
\ENDLOG 

@<Define |Path| functions@>=

  if (this == &p) /* Make sure it's not self-assignment. */
    return *this;

  @<Discard |points| and |connectors|@>@;

  line_switch = p.line_switch;
  cycle_switch = p.cycle_switch;
  do_output = p.do_output;
  fill_draw_value = p.fill_draw_value;  
  arrow = p.arrow;

@q *** (3) Handle |Colors|.  @>
@ Handle |Colors|.
\initials{LDF 2005.03.}

\LOG
\initials{LDF 2005.03.10.}
Put this code in a |try| block and now catching |bad_alloc|.
Added code for handling copying |draw_color_vector|.
\ENDLOG 

@<Define |Path| functions@>=

  try 
     {

@q **** (4) @>   

@q **** (4) @>   

         if (   draw_color_vector == static_cast<Pointer_Vector<Color>*>(0)  
             && p.draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
            ; /* Do nothing.  */@; 

         else if (   draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
                  && p.draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
            {

                draw_color_vector = new Pointer_Vector<Color>; 

                *draw_color_vector = *(p.draw_color_vector);

            }

         else if (   draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                  && p.draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
            {
                draw_color_vector->clear();
                delete draw_color_vector;
                draw_color_vector = 0;

            }

          else if (   draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                   && p.draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
             *draw_color_vector = *(p.draw_color_vector);

@q **** (4) @>   

         if (   fill_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
             && p.fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
            ; /* Do nothing.  */@; 

         else if (    fill_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
                  &&  p.fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
            {

                fill_color_vector = new Pointer_Vector<Color>; 

                *fill_color_vector = *(p.fill_color_vector);

            }

         else if (   fill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                  && p.fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
            {
                fill_color_vector->clear();
                delete fill_color_vector;
                fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);

            }

          else if (   fill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                   && p.fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
             *fill_color_vector = *(p.fill_color_vector);

@q **** (4) @>   

     }  /* |try|  */

     catch (bad_alloc)
        {
            cerr_strm << thread_name << "ERROR!  In `Path::operator=(const Path&)':"
                      << endl 
                      << "`create_new<Color>' or `new Pointer_Vector<Color>' "
                      << "failed, throwing `bad_alloc'."
                      << endl  
                      << "Rethrowing.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");
                 
            throw;

        }  /* |catch (bad_alloc)|  */

@q *** (3) Handle |dash_pattern_vector|.  @>
@ Handle |dash_pattern_vector|.
\initials{LDF 2005.03.16.}

\LOG
\initials{LDF 2005.03.16.}
Added this section.
\ENDLOG

@<Define |Path| functions@>=

         if (   dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
             && p.dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
            ; /* Do nothing.  */@; 

         else if (   dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                  && p.dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
            {

                dash_pattern_vector = new Pointer_Vector<Dash_Pattern>; 

                *dash_pattern_vector = *(p.dash_pattern_vector);

            }

         else if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                  && p.dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
            {
                dash_pattern_vector->clear();
                delete dash_pattern_vector;
                dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);

            }

          else if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                   && p.dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
             *dash_pattern_vector = *(p.dash_pattern_vector);

@q *** (3) Handle |pen_vector|.  @>
@ Handle |pen_vector|.
\initials{LDF 2005.03.16.}

\LOG
\initials{LDF 2005.03.16.}
Added this section.
\ENDLOG

@<Define |Path| functions@>=

         if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
             && p.pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
            ; /* Do nothing.  */@; 

         else if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
                  && p.pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
            {

                pen_vector = new Pointer_Vector<Pen>; 

                *pen_vector = *(p.pen_vector);

            }

         else if (   pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
                  && p.pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
            {
                pen_vector->clear();
                delete pen_vector;
                pen_vector = static_cast<Pointer_Vector<Pen>*>(0);

            }

          else if (   pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
                   && p.pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
             *pen_vector = *(p.pen_vector);

@q *** (3).@> 
@
\LOG
\initials{LDF 2002.09.18.}
Now setting |projective_extremes = p.projective_extremes|.

\initials{LDF 2003.04.09.} 
Now resizing |projective_extremes|, if necessary.

\initials{LDF 2005.04.04.}
Now setting |world_extremes = p.world_extremes| and subsequently 
resizing it, if necessary.

\initials{LDF 2005.06.30.}
Now setting |pre_projective_extremes = p.pre_projective_extremes|
and subsequently resizing it, if necessary.
\ENDLOG 

@<Define |Path| functions@>=

  world_extremes = p.world_extremes;

  if (world_extremes.size() == 0)
     world_extremes.resize(6, 0);

  pre_projective_extremes = p.pre_projective_extremes; 

  if (pre_projective_extremes.size() == 0)  
    pre_projective_extremes.resize(6, 0);

  projective_extremes = p.projective_extremes; 

  if (projective_extremes.size() == 0)  
    projective_extremes.resize(6, 0);

  for (vector <Point*>::const_iterator p_iter = p.points.begin();
     p_iter != p.points.end();
     p_iter++)
     points.push_back(create_new<Point>(*p_iter));      
    
  for (vector <string>::const_iterator c_iter = p.connectors.begin();
       c_iter != p.connectors.end();
       c_iter++)
  {
    connectors.push_back(*c_iter);
  }

  for (vector <Connector_Type*>::const_iterator c_iter = p.connector_type_vector.begin();
       c_iter != p.connector_type_vector.end();
       c_iter++)
  {
    connector_type_vector.push_back(create_new<Connector_Type>(*c_iter));
  }

  return *this;

} /* End of |Path::operator=(const Path& p)| definition.  */

@q * (1) Constructors and setting functions.@>

@* Constructors and setting functions.
Each constructor taking an argument has a corresponding function for
setting an already existing |Path|.

\LOG
\initials{LDF 2003.04.06.}  
@: BUG FIX@> BUG FIX: 
Now setting |dashed = ""|, |pen = ""|, and |arrow = false| in all
constructors and setting functions.  This fixed a problem I was having
with |Icosahedron|:  One of the |Reg_Polygons| was drawn with an
arrow.   

\initials{LDF 2004.06.02.}  Changed the way |pen| is handled, because 
it's now a |Pen*| rather than a |string|.
\ENDLOG 

@q ** (2) Discard points and connectors.@>

@*1 Discard points and connectors.
This is useful in the setting functions.

@<Discard |points| and |connectors|@>=

   if (points.size() > 0)
      {
         for(vector<Point*>::iterator iter = points.begin();
             iter != points.end();
             ++iter)
           {
              delete *iter;
           }    
         points.clear();
      }

   if (connectors.size() > 0)
        connectors.clear();
   
   if (connector_type_vector.size() > 0)
   {
       for (vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
            iter != connector_type_vector.end();
            ++iter)
       {
          delete *iter;
          *iter = 0;
       }
       connector_type_vector.clear();
   }

@q ** (2) Default constructor. No arguments.@>
@*1 Default constructor. No arguments.
@^\cfunc{Path}{Path}@>

\LOG
\initials{LDF 2002.09.18.}  
Now setting |do_output = true| and
resizing |projective_extremes|.

\initials{LDF 2003.04.06.}  
Now setting |dashed = ""|, |pen = ""|, and 
|arrow = false|.

\initials{LDF 2004.06.02.}  
Now setting |pen = 0| instead of 
|pen = ""|, since it's now a |Pen*| rather than a |string|.

\initials{LDF 2004.06.07.}  
Now setting |dash_pattern = 0| rather than
|dashed = ""|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = PATH_TYPE|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.04.}
Now resizing |world_extremes|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.

\initials{LDF 2005.06.30.}
Now resizing |pre_projective_extremes|.
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare |Path| functions@>=
Path(void);

@q *** (3) Definition.  @>

@ 
@<Define |Path| functions@>=

Path::Path(void)
{
   bool DEBUG = false; /* |true| */

   if (DEBUG)
     cerr << "Entering Path() (default version).\n";

   line_switch = false;
   cycle_switch = false;
   fill_draw_value = 0;

arrow = NO_ARROW;

   draw_color_vector = 0;
   fill_color_vector = 0;

   pen_vector = 0;
   dash_pattern_vector = 0;

   do_output = true;  

   shape_type = PATH_TYPE;
   surface_hiding_ctr = 0;   
   decomposition_level = 0;

   world_extremes.resize(6, 0); 

   pre_projective_extremes.resize(6, 0); 
   projective_extremes.resize(6, 0); 

   if (DEBUG)
     cerr << "Exiting Path() (default version)." << endl;

   return;
}

@q ** (2) Lines.@>
@*1 Lines.  
\initials{LDF 2002.10.15.}
Lines in this sense are |Paths| containing two |Points|
and the connector ``|--|'' They should not be confused with the
|struct Line|, which is for vector operations (where the word
``vector'' is used in its mathematical sense).  

@q *** (3) Constructor.@>

@*2 Constructor.
@^\cfunc{Path}{Path}@>

\LOG
\initials{LDF 2002.09.18.} 
Now resizing |projective_extremes|.

\initials{LDF 2004.06.02.}  
Now setting |pen = 0| instead of 
|pen = ""|, since it's now a |Pen*| rather than a |string|.

\initials{LDF 2004.06.07.}  
Now setting |dash_pattern = 0| rather than
|dashed = ""|.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = PATH_TYPE|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.04.}
Now resizing |world_extremes|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.

\initials{LDF 2005.06.30.}
Now resizing |pre_projective_extremes|.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Path| functions@>=
Path(const Point& p0, const Point& p1);

@q **** (4) Definition.@> 

@ 
@<Define |Path| functions@>=
Path::Path(const Point& p0, const Point& p1)
{
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path() (line version).\n";

  line_switch = true;
  cycle_switch = false;

  do_output = true;  /* LDF 2002.09.18.  Added this line.  */

  world_extremes.resize(6, 0);

  pre_projective_extremes.resize(6, 0); 
  projective_extremes.resize(6, 0); 

  fill_draw_value = 0;

  draw_color_vector = 0;
  fill_color_vector = 0;

  pen_vector = 0;
  dash_pattern_vector = 0;

  arrow = NO_ARROW;

  shape_type = PATH_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;

  points.push_back(create_new<Point>(p0));

  points.push_back(create_new<Point>(p1));

  connectors.push_back("--");

  Connector_Type *c = create_new<Connector_Type>(0);
  c->type0 = Connector_Type::PLAIN_TYPE;
  c->type1 = Connector_Type::NULL_TYPE;
  c->connector_string = "--";

  connector_type_vector.push_back(c);

  if (DEBUG)
    cerr << "Exiting Path() (line version).\n";
  return;

}  /* End of |Path::Path(const Point& p0, const Point& p1)| 
      definition.  */  

@q *** (3) Setting function.@>

@*2 Setting function.
@^\cfunc{Path}{set}@>

\LOG
\initials{LDF 2003.04.06.}  
Now setting |dashed = ""|, |pen = ""|, and 
|arrow = false|.

\initials{LDF 2004.06.02.}  
Now deleting |pen|, if it's not a null
pointer, and setting it to 0 instead of |""|, since it's now a |Pen*|
rather than a |string|.  Testing whether it's not a null pointer is
just for insurance, since only |Paths| that are on |Pictures| should
have non-null |pens|.

\initials{LDF 2004.06.07.}  
Changed the way |dash_pattern| is handled to reflect
the fact that it's now a |Dash_Pattern*| rather than a |string|.  It also used
to be called |dashed| rather than |dash_pattern|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now deleting |draw_color_vector|, |dash_pattern_vector|,
and |pen_vector|, and setting them to 0, if they aren't already 0.

\initials{LDF 2005.04.04.}
Now setting |world_extremes| to 0.

\initials{LDF 2005.06.30.}
Now setting |pre_projective_extremes| to 0.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Path| functions@>=
void
set(const Point& p0, const Point& p1);

@q **** (4) Definition.  @>

@ 
@<Define |Path| functions@>=
void
Path::set(const Point& p0, const Point& p1)
{
  line_switch = true;
  cycle_switch = false;
  do_output = true;  /* LDF 2002.09.18.  Added this line.  */
  fill_draw_value = 0;

  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete draw_color_vector;
        draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete fill_color_vector;
        fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
        delete dash_pattern_vector;
        dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);
    }

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
        delete pen_vector;
        pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
    }

  arrow = NO_ARROW;

  @<Discard |points| and |connectors|@>@;

  world_extremes = 0;

  pre_projective_extremes = 0; 

  projective_extremes = 0; /* LDF 2002.09.18.  Added this line.  */

  points.push_back(create_new<Point>(p0));
  points.push_back(create_new<Point>(p1));
  connectors.push_back("--");

  Connector_Type *c = create_new<Connector_Type>(0);
  c->type0 = Connector_Type::PLAIN_TYPE;
  c->type1 = Connector_Type::NULL_TYPE;
  c->connector_string = "--";

  connector_type_vector.push_back(c);

  line_switch = true;

} /* End of |Path::set(const Point& p0, const Point& p1)| definition  */

@q ** (2) Points and one type of connector.@>
@*1 {\bf Points} and one type of connector.

This constructor takes a variable number of |Point*| arguments,
but only allows one type of connector. The argument list must end with
0. If the order of the named arguments is reversed, the compiler
can't resolve certain calls to |Path|. It couldn't resolve between
|Path(bool cycle, string connector ...)| and 
|Path(Point* first_point_ptr ...)|. 
I don't know why it should have
had trouble, though, since pointers to |Points| are not |bools|. 

\initials{LDF 2002.4.6.}  
Probably it couldn't distinguish
between a pointer and an |int| on the one hand and a |bool| and an
|int| on the other.  I hope that |bools| are more efficiently
implemented than as |ints|, though!

\initials{LDF 2002.10.29.}  
@:??@> ?? I don't know why \cweave/ needs
instructions to put thin spaces after the ``|bool|'' in the
declaration and definition below.  Maybe it's because of the
``$\ldots$''. 

\LOG
\initials{LDF 2004.06.02.}  
Now deleting |pen|, if it's not a null
pointer, and setting it to 0 instead of |""|, since it's now a |Pen*|
rather than a |string|.  Testing whether it's not a null pointer is
just for insurance, since only |Paths| that are on |Pictures| should
have non-null |pens|.

\initials{LDF 2004.06.07.}  
Now setting |dash_pattern = 0| rather than |dashed = ""|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.
\ENDLOG 

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Path}{Path}@>

\LOG
\initials{LDF 2005.01.24.}
Now setting |shape_type = PATH_TYPE|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.04.}
Now resizing |world_extremes|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.

\initials{LDF 2005.06.30.}
Now resizing |pre_projective_extremes|.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Path| functions@>=
Path(string connector, bool@,@, cycle ...);

@q **** (4) Definition.  @>

@ 
@<Define |Path| functions@>=
Path::Path(string connector, bool@,@, cycle ... )
{
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path() (connector, cycle, ...).\n";

  shape_type = PATH_TYPE;
  surface_hiding_ctr = 0;
  decomposition_level = 0;
  line_switch = false;

  cycle_switch = cycle;

  connectors.push_back(connector);

  Connector_Type *c = create_new<Connector_Type>(0);
  c->type0 = Connector_Type::PLAIN_TYPE;
  c->type1 = Connector_Type::NULL_TYPE;
  c->connector_string = connector;

  connector_type_vector.push_back(c);

  do_output = true;  /* LDF 2002.09.18.  Added this line.  */

  world_extremes.resize(6, 0);

  pre_projective_extremes.resize(6, 0); 

  projective_extremes.resize(6, 0); /* LDF 2002.09.18.   Added this line.  */

  fill_draw_value = 0;

  draw_color_vector = 0;
  fill_color_vector = 0;

  pen_vector = 0;
  dash_pattern_vector = 0;

  arrow = NO_ARROW;

  va_list ap;  /* For the variable length argument list. */
  va_start(ap, cycle);

  Point* arg_ptr;

  while ((arg_ptr = va_arg(ap, Point*)) != static_cast<Point*>(0))
    points.push_back(create_new<Point>(arg_ptr));

  va_end(ap);
  if (DEBUG)
    cerr << "Exiting Path() (connector, cycle, ...).\n";
  return;
}

@q *** (3) Setting function.@>

@*2 Setting function.
@^\cfunc{Path}{set}@>

\LOG
\initials{LDF 2003.04.06.}  
Now setting |dashed = ""|, |pen = ""|, and |arrow = false|.

\initials{LDF 2004.06.02.}  
Now deleting |pen|, if it's not a null
pointer, and setting it to 0 instead of |""|, since it's now a |Pen*|
rather than a |string|.  Testing whether it's not a null pointer is
just for insurance, since only |Paths| that are on |Pictures| should
have non-null |pens|.

\initials{LDF 2004.06.07.}  
Changed the way |dash_pattern| is handled to reflect
the fact that it's now a |Dash_Pattern*| rather than a |string|.  It also used
to be called |dashed| rather than |dash_pattern|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now deleting |draw_color_vector|, |dash_pattern_vector|,
and |pen_vector|, and setting them to 0, if they aren't already 0.

\initials{LDF 2005.04.04.}
Now setting |world_extremes| to 0.

\initials{LDF 2005.06.30.}
Now setting |pre_projective_extremes| to 0.
\ENDLOG 

@q **** (4) Declaration.@>   

@<Declare |Path| functions@>=
void
set(string connector, bool@,@, cycle ...);

@q **** (4) Definition.@>   

@ 
@<Define |Path| functions@>=
void
Path::set(string connector, bool cycle ... )
{
@q ***** (5) @>

    volatile bool DEBUG = false; /* |true| */

#if DEBUG_COMPILE
    if (DEBUG)
    {
        cerr_mutex.lock();
        cerr << "Entering `Path::set'."
             << endl;
        cerr_mutex.unlock(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    line_switch = false;
    cycle_switch = cycle;

    do_output = true;  /* LDF 2002.09.18.  Added this line.  */

    @<Discard |points| and |connectors|@>@;
  
    fill_draw_value = 0;

  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete draw_color_vector;
        draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete fill_color_vector;
        fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
        delete dash_pattern_vector;
        dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);
    }

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
        delete pen_vector;
        pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
    }

    arrow = NO_ARROW;

    world_extremes = 0;

    pre_projective_extremes = 0; 
    projective_extremes = 0; 

    connectors.push_back(connector);

    Connector_Type *c = create_new<Connector_Type>(0);
    c->type0 = Connector_Type::PLAIN_TYPE;
    c->type1 = Connector_Type::NULL_TYPE;
    c->connector_string = connector;

    connector_type_vector.push_back(c);

    va_list ap;  /* For the variable length argument list. */
    va_start(ap, cycle);

    Point* arg_ptr;

    while ((arg_ptr = va_arg(ap, Point*)) != static_cast<Point*>(0))
    {
        points.push_back(create_new<Point>(arg_ptr)); 
    }

    va_end(ap);

@q ***** (5) @>

}  /* End of |Path::set(string connector, bool cycle ... )| definition  */

@q ** (2) Variable number of Points and connectors.@>
@*1 Variable number of {\bf Points} and connectors.
These functions takes a variable number of alternating |Point*| and connector
arguments, starting with a |Point*|.  The argument list must end with
0. We don't need an argument for whether it's a cycle or not, because
if it is, it will have a connector at the end.

\LOG
\initials{LDF 2002.10.29.}  
@:BUG FIX@> BUG FIX:  No longer pushing
|first_point_ptr| onto |points|.  Copying it instead.  

\initials{LDF 2003.04.06.}  
Now setting |dashed = ""|, |pen = ""|, and 
|arrow = false|.

\initials{LDF 2004.06.02.}  
Now setting |pen| to 0 instead of |""|, 
since it's now a |Pen*| rather than a |string|.

\initials{LDF 2002.09.18.}  
Now setting |do_output = true| and
resizing |projective_extremes|.

\initials{LDF 2005.04.04.}
Now resizing |world_extremes|.

\initials{LDF 2005.06.30.}
Now resizing |pre_projective_extremes|.
\ENDLOG 

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Path}{Path}@>

\LOG
\initials{LDF 2004.06.07.}  
Now setting |dash_pattern = 0| rather than
|dashed = ""|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.01.24.}
Now setting |shape_type = PATH_TYPE|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@<Declare |Path| functions@>=
Path(Point* first_point_ptr ...);

@ 
@<Define |Path| functions@>=
Path::Path(Point* first_point_ptr ... )
{
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path() (Point* ...).\n";

  shape_type = PATH_TYPE;
  surface_hiding_ctr = 0;

  decomposition_level = 0;

  line_switch = false;
  cycle_switch = false;

  do_output = true;  

  world_extremes.resize(6, 0);

  pre_projective_extremes.resize(6, 0);
  projective_extremes.resize(6, 0);

  fill_draw_value = 0;

  draw_color_vector = 0;

  fill_color_vector = 0;  

  pen_vector = 0;
  dash_pattern_vector = 0;

  arrow = NO_ARROW;

  points.push_back(create_new<Point>(first_point_ptr));

  va_list ap;  /* For the variable length argument list. */
  va_start(ap, first_point_ptr);

  Point* point_ptr;
  char* connector_ptr;
  string connector_string;

  Connector_Type *c = 0;

  while ((connector_ptr = va_arg(ap, char*)) != static_cast<char *>(0))
    {
      connectors.push_back((connector_string = connector_ptr));

      c = create_new<Connector_Type>(0);
      c->type0 = Connector_Type::PLAIN_TYPE;
      c->type1 = Connector_Type::NULL_TYPE;
      c->connector_string = connector_string;

      connector_type_vector.push_back(c);

      if ((point_ptr = va_arg(ap, Point*)) ==  static_cast<Point*>(0))
        {
          cycle_switch = true;
          break;
        }
      points.push_back(create_new<Point>(point_ptr));
    }

  va_end(ap);
  if (DEBUG)
    cerr << "Exiting Path() (Point* ...).\n";
}

@q *** (3) Setting function.@>
@*2 Setting function.
@^\cfunc{Path}{set}@>

\LOG
\initials{LDF 2003.04.06.}  
Now setting |dashed = ""|, |pen = ""|, and 
|arrow = false|.

\initials{LDF 2004.06.02.}  
Now deleting |pen|, if it's not a null
pointer, and setting it to 0 instead of |""|, since it's now a |Pen*|
rather than a |string|.  Testing whether it's not a null pointer is
just for insurance, since only |Paths| that are on |Pictures| should
have non-null |pens|.

\initials{LDF 2004.06.07.}  
Changed the way |dash_pattern| is handled to reflect
the fact that it's now a |Dash_Pattern*| rather than a |string|.  It also used
to be called |dashed| rather than |dash_pattern|.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2004.11.07.}
Now setting |arrow| to |NO_ARROW| rather than |false|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now deleting |draw_color_vector|, |dash_pattern_vector|,
and |pen_vector|, and setting them to 0, if they aren't already 0.

\initials{LDF 2005.04.04.}
Now setting |world_extremes| to 0.

\initials{LDF 2005.06.30.}
Now setting |pre_projective_extremes| to 0.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Path| functions@>=
void
set(Point* first_point_ptr ...);

@q **** (4) Definition.  @>

@ 
@<Define |Path| functions@>=
void
Path::set(Point* first_point_ptr ... )
{

    line_switch = false;
    cycle_switch = false;

    do_output = true;  /* LDF 2002.09.18.  Added this line.  */

    @<Discard |points| and |connectors|@>@;

    world_extremes = 0;

    pre_projective_extremes = 0; 

    projective_extremes = 0; /* LDF 2002.09.18.  Added this line.  */

    fill_draw_value = 0;

  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete draw_color_vector;
        draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete fill_color_vector;
        fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
        delete dash_pattern_vector;
        dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);
    }

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
        delete pen_vector;
        pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
    }

    arrow = NO_ARROW;

    points.push_back(create_new<Point>(first_point_ptr));

    va_list ap;  /* For the variable length argument list. */
    va_start(ap, first_point_ptr);

    Point* point_ptr;
    char* connector_ptr;
    string connector_string;

    Connector_Type *c = 0;

    while ((connector_ptr = va_arg(ap, char*)) != (char *) 0)
    {
        connectors.push_back((connector_string = connector_ptr));

        c = create_new<Connector_Type>(0);

        c->type0 = Connector_Type::PLAIN_TYPE;
        c->type1 = Connector_Type::NULL_TYPE;
        c->connector_string = connector_string;
        connector_type_vector.push_back(c);

        if ((point_ptr = va_arg(ap, Point*)) ==  static_cast<Point*>(0))
        {
            cycle_switch = true;
            break;
        }
        points.push_back(create_new<Point>(point_ptr));
    }
    va_end(ap);
}

@q ** Copy constructor. @>
@ Copy constructor.
@^\cfunc{Path}{Path}@>

\LOG
\initials{LDF 2002.10.15.}  
Rewrote this function.  The old version caused a
memory fault when I tried to use it.  I've taken code from the default
constructor and the assignment operator and put it here without
bothering to see what was causing the problem.  Probably the old
version didn't account for changes I've made in other places, perhaps
in the class definition.  

\initials{LDF 2002.11.03.}  
Rewrote this function.  
Now just using the assignment operator. 

\initials{LDF 2003.04.06.}  
Got a memory fault when I tried 
to use this function.  Haven't tested it yet.  It worked to use the
default constructor and then the assignment operator.  Maybe it's not
kosher to use ``|*this = p|'' in a copy constructor.  

\initials{LDF 2004.06.18.}  
Now setting all of the data members that are
pointers to 0.

\initials{LDF 2005.01.24.}
Now setting |shape_type = PATH_TYPE|.

\initials{LDF 2005.03.10.}
Now setting |draw_color_vector = 0|.

\initials{LDF 2005.03.16.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Path| functions@>=
Path(const Path& p);

@q **** (4) Definition.  @>

@
@<Define |Path| functions@>=
Path::Path(const Path& p) 
{
  bool DEBUG = false; /* |true| */@;
  if (DEBUG)
    cerr << "Entering Path copy constructor.\n";

  shape_type = PATH_TYPE;
  surface_hiding_ctr = 0;  
  decomposition_level = 0;

  draw_color_vector = 0;

  fill_color_vector = 0;

  pen_vector = 0;
  dash_pattern_vector = 0;

  *this = p;

  if (DEBUG)
    cerr << "Exiting Path() (copy constructor).\n";
  return;
}

@q * (1) Pseudo-constructor for dynamic allocation. @>
@* Pseudo-constructor for dynamic allocation. 

@q ** (2) Pointer argument.@>
@ Pointer argument.@>

\LOG
\initials{LDF 2002.10.29.}  
Added argument |const Path* p|.  
If |p != 0|, the new |Path| is assigned to using the values from |p|.    

\initials{LDF 2003.12.30.}  
Replaced this version of
|Path::create_new_path| with
a specialization of |template <class C> C* create_new|.  

\initials{LDF 2003.12.30.}  
Changed the argument.  It's now a 
|const Path*|. 

\initials{LDF 2003.12.30.}  
Removed default argument ``0'', because
this caused a compiler error when using the DEC \CPLUSPLUS/ compiler.
Apparently, it suffices to declare a default argument in the template
declaration. 

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare non-member template functions for |Path|@>=

Path* 
create_new(const Path* p, Scanner_Node scanner_node);

@q ** (2) Reference argument.@>
@*1 Reference argument.@>

\LOG
\initials{LDF 2002.10.29.}  
Added this function.

\initials{LDF 2003.12.30.}  
Replaced this version of
|Path::create_new_path| with
a specialization of |template <class C> C* create_new|.  

\initials{LDF 2003.12.30.}  
Changed argument from |Path| to |const Path&|.

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare non-member template functions for |Path|@>=

Path* 
create_new(const Path& p, Scanner_Node scanner_node);

@q * (1) Destructor. @>
@* Destructor.
@^\cfunc{Path}{\~{}Path}@>

Make sure to delete anything else that I allocate
dynamically! 

\LOG
\initials{LDF 2002.10.07.}
Added code for handling
|draw_color| and |fill_color|.

\initials{LDF 2002.11.03.}  
Now calling |points.clear|.  This replaces a |while| loop
in which |pop_back| was used to empty |points|. 

\initials{LDF 2002.11.03.}   
Now clearing |connectors|.

\initials{LDF 2003.08.27.}  
Made this function |virtual|, 
because GCC with the ``{\tt -Wall}'' option issued the following
warning:  
``{}`class Path' has virtual functions but non-virtual destructor''.

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.
\ENDLOG 

@q ** (2) Declaration.@> 

@<Declare |Path| functions@>=
virtual
~Path(void);

@q ** (2) Definition.@> 

@
@<Define |Path| functions@>=
Path::~Path(void)
{
   bool DEBUG = false; /* |true| */
   if (DEBUG)
     {
       cerr << "Entering ~Path().\n";
       show("Path:");
     }
   for(vector<Point*>::iterator iter = points.begin();
      iter != points.end();
      iter++)
   {
      delete *iter;
      *iter = 0;
   }

   points.clear();  

   connectors.clear();  

   for(vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
      iter != connector_type_vector.end();
      iter++)
   {
      delete *iter;
      *iter = 0;
   }
   
   connector_type_vector.clear();

@q *** (3).@> 

@
\LOG
\initials{LDF 2005.02.08.}
Added this section.

\initials{LDF 2005.03.10.}
Changed the code in this section to reflect the 
fact that I've changed the type of |draw_color_vector| 
from |vector<Color*>| to |Pointer_Vector<Color>*|.

\initials{LDF 2005.03.16.}
Now deleting |dash_pattern_vector| and |pen_vector| and setting them to
0, if they aren't already 0.
\ENDLOG

@<Define |Path| functions@>=

   if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      {
          delete draw_color_vector;
          draw_color_vector = static_cast<Pointer_Vector<Color>*>(0);
        
      }  /* |if (draw_color_vector != 0)|  */

  if (fill_color_vector != 0)
    {
        delete fill_color_vector;
        fill_color_vector = static_cast<Pointer_Vector<Color>*>(0);
    }

  if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
        delete dash_pattern_vector;
        dash_pattern_vector = static_cast<Pointer_Vector<Dash_Pattern>*>(0);
    }

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
        delete pen_vector;
        pen_vector = static_cast<Pointer_Vector<Pen>*>(0);
    }

@q *** (3) @>
@
\LOG
\initials{LDF 2021.12.24.}
Added this section.
\ENDLOG

@<Define |Path| functions@>=

  for (vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
       iter != connector_type_vector.end();
       ++iter)
  {
     delete *iter;
     *iter = 0;
  }
  connector_type_vector.clear();

@q *** (3) @>
@
@<Define |Path| functions@>=

    if (DEBUG)
      {
          cerr << "Exiting Path destructor.\n";
      }

} /* End of |Path| destructor definition  */

@q * (1) Clear.@>
@* Clear.  
@^\cfunc{Path}{clear}@>

LDF Undated.
This function is needed because it's a pure |virtual| function in
|Shape|, and for getting rid of items in |Picture::clear|. 

\initials{LDF 2002.10.07.}
|clear| is needed because
it's called on the |Shapes| that are stored in |Pictures|, and I don't
know of a way of overloading destructors.  That is, in
|Picture::clear|, the actual types of the |Shapes| are unknown, so I
can't call |~Path|, |~Circle|, or other destructors directly.  But
a named function such as |clear| can serve the same purpose.  

\LOG

\initials{LDF 2002.10.07.} 
Added code for handling |draw_color| and |fill_color|.

\initials{LDF 2002.10.07.}  
Added code for deallocating the memory allocated 
for |draw_color| and |fill_color|, if any.  

\initials{LDF 2004.06.18.} 
Fixed the way |pen| and |dash_pattern| are handled.

\initials{LDF 2005.03.16.}
Now deleting |draw_color_vector|, |dash_pattern_vector|,
and |pen_vector|, and setting them 0, if they aren't already 0.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF Undated.}
@:??@> ??  
I tried calling |~Path| inside |Path:clear|, but I got
a memory fault.  Don't know why.  Try to find out.  However, this isn't urgent.
\ENDTODO 

@q ** Declaration.  @>

@<Declare |Path| functions@>=
virtual
void 
clear();

@q ** Definition.  @>

@ 
@<Define |Path| functions@>=
void 
Path::clear()
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path::clear().\n";
#endif /* |DEBUG_COMPILE|  */@; 

  @<Discard |points| and |connectors|@>@;
  
  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete draw_color_vector;
        draw_color_vector = 0;
    }

  if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    {
        delete fill_color_vector;
        fill_color_vector = 0;
    }

  if (dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
        delete dash_pattern_vector;
        dash_pattern_vector = 0;
    }

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
        delete pen_vector;
        pen_vector = 0;
    }

#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr << "Exiting Path::clear().\n";
      }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

} /* End of |Path::clear| definition.  */

@q * (1) Clear connectors.@>
@* Clear connectors.  
@^\cfunc{Path}{clear\_connectors}@>

\LOG
\initials{LDF 2004.11.01.}
Added this function.
\ENDLOG

@q ** Declaration.  @>

@<Declare |Path| functions@>=
inline
void 
clear_connectors(void)
{
   connectors.clear();

   for(vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
      iter != connector_type_vector.end();
      iter++)
   {
      delete *iter;
      *iter = 0;
   }
   
   connector_type_vector.clear();

   return;

} /* End of |Path::clear_connectors| definition.  */

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Path}{get\_copy}@>
\LOG
\initials{LDF 2002.11.03.}  Made |virtual|.  
Changed |dynamic_cast| to
|static_cast|.  This may not work.

\initials{LDF 2003.01.29.}  It seems to work.  At least, I haven't had any
problems with it.
\ENDLOG 
@<Declare |Path| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Path| functions@>=
Shape*
Path::get_copy() const
{
  Path* p = create_new<Path>(0);
  *p = *this;
  return static_cast<Shape*>(p);
}

@q * (1) Copy coordinates.@> 
@* Copy coordinates.
\initials{LDF 2005.04.09.}

\LOG
\initials{LDF 2005.04.09.}
Added this function.

\initials{LDF 2005.04.11.}
Removed the defaults for the |const char| 
arguments |from| and |to|.  Added the |Scanner_Node scanner_node| argument with
the default 0.

\initials{LDF 2005.04.15.}
Added the optional argument |bool set_z_to_zero| 
with the default |false|.

\initials{LDF 2005.04.15.}
Added real code to this function.  
Previously, it just returned 0 immediately.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Path| functions@>=

virtual 
int 
copy_coords(const char from, 
            const char to, 
            bool set_z_to_zero = false,
            Scanner_Node scanner_node = 0);

@q ** (2) Definition.@> 

@
@<Define |Path| functions@>=
int 
Path::copy_coords(const char from, 
                  const char to, 
                  bool set_z_to_zero,
                  Scanner_Node scanner_node)
{

@q *** (3) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q *** (3).@>

   int status;

   for (vector<Point*>::iterator iter = points.begin();
        iter != points.end();
        ++iter)
      {
         status = (**iter).copy_coords(from, to, set_z_to_zero, scanner_node);

         if (status != 0)
            {
               
                cerr_strm << thread_name << "ERROR!  In `Path::copy_coords':"
                          << endl 
                          << "`Point::copy_coords' returned " 
                          << status << "."
                          << endl 
                          << "Exiting function with return value " << status << ".";

                log_message(cerr_strm);
                cerr_message(cerr_strm, error_stop_value);
                cerr_strm.str(""); 

                return status;

            }  /* |if (status != 0)|  */

      } /* |for|  */
   
   return 0;

}  /* End of |Path::copy_coords| definition.  */

@q * (1) Setting and querying drawing and filling data.@>
@* Setting and querying drawing and filling data.
\initials{LDF Undated.}

@q ** (2) Set fill_draw_value.@>
@*1 Set {\bf fill\_draw\_value}.
@^\cfunc{Path}{set\_fill\_draw\_value}@>
\initials{LDF Undated.}

@<Declare |Path| functions@>=

virtual
void
set_fill_draw_value(const signed short s);

@
@<Define |Path| functions@>=
void
Path::set_fill_draw_value(const signed short s)
{
  fill_draw_value = s;
  return;
}

@q ** (2) Get fill_draw_value.@>
@*1 Set {\bf fill\_draw\_value}.
@^\cfunc{Path}{get\_fill\_draw\_value}@>
\initials{LDF 2005.08.16.}

\LOG
\initials{LDF 2005.08.16.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual
signed short
get_fill_draw_value(void);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
signed short
Path::get_fill_draw_value(void)
{
  return fill_draw_value;
}

@q ** (2) Push draw color.@>
@*1 Push draw color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.04.04.}
@:BUG FIX@> BUG FIX:  Now only setting |c| to 0 if |copy == false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual
int
push_draw_color(Color*& c, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::push_draw_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
      {
         d = c;
         c = 0;
      }

   *draw_color_vector += d;

   return 0;

}  /* End of |Path::push_draw_color|  */

@q ** (2) Push fill color.@>
@*1 Push fill color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.04.04.}
@:BUG FIX@> BUG FIX:  Now only setting |c| to 0 if |copy == false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual
int
push_fill_color(Color*& c, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::push_fill_color(Color*& c, bool copy)
{
   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   if (copy == true)
      d = create_new<Color>(c);

   else
     {
        d = c;
        c = 0;
     }

   *fill_color_vector += d;

   return 0;

}  /* End of |Path::push_fill_color|  */

@q ** (2) Push color.@>
@*1 Push color.
\initials{LDF 2005.03.17.}

\LOG
\initials{LDF 2005.03.17.}
Added this function.

\initials{LDF 2005.04.04.}
@:BUG FIX@> BUG FIX:  Now only setting |c| to 0 if |copy == false|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual
int
push_color(Color*& c, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::push_color(Color*& c, bool copy)
{
   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      draw_color_vector = new Pointer_Vector<Color>;

   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      fill_color_vector = new Pointer_Vector<Color>;

   Color* d;

   d = create_new<Color>(c);

   *draw_color_vector += d;

   if (copy == true)
      d = create_new<Color>(c);
   else
      {
         d = c;
         c = 0;
      }

   *fill_color_vector += d;

   return 0;

}  /* End of |Path::push_color|  */

@q ** (2) Push pen.@>
@*1 Push {\bf Pen}.
@^\cfunc{Path}{push\_pen}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual 
int 
push_pen(Pen*& p, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int 
Path::push_pen(Pen*& p, bool copy)
{
   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      pen_vector = new Pointer_Vector<Pen>;

   Pen* q;

   if (copy == true)
      q = create_new<Pen>(p);

   else
     {
         q = p;
         p = 0;
     }

   *pen_vector += q;

   return 0;

}  /* End of |Path::push_pen| definition.  */

@q ** (2) Push dash_pattern.@>
@*1 Push {\bf Dash\_Pattern}.
@^\cfunc{Path}{push\_dash\_pattern}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual 
int 
push_dash_pattern(Dash_Pattern*& d, bool copy = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int 
Path::push_dash_pattern(Dash_Pattern*& d, bool copy)
{
   if (dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
      dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;

   Dash_Pattern* e;

   if (copy == true)
      e = create_new<Dash_Pattern>(d);

   else
     {
         e = d;
         d = 0;
     }

   *dash_pattern_vector += e;

   return 0;

}  /* End of |Path::push_dash_pattern| definition.  */

@q ** (2) Set connectors.@>
@*1 Set connectors.
@^\cfunc{Path}{set\_connectors}@>
\initials{LDF 2003.02.08.}  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.02.08.}
Overload with a version taking a |vector<string>| as its argument.
arguments.  
\ENDTODO 

\LOG
\initials{LDF 2003.02.08.}  
Added this function.
\ENDLOG 

@<Declare |Path| functions@>=

virtual
void
set_connectors(const string s = "..");

@
@<Define |Path| functions@>=
void
Path::set_connectors(const string s)
{
  connectors.clear();
  connectors.push_back(s);

  for (vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
       iter != connector_type_vector.end();
       ++iter)
  {
     delete *iter;
     *iter = 0;
  }

  connector_type_vector.clear();

  Connector_Type *c = create_new<Connector_Type>(0); 
  c->type0 = Connector_Type::PLAIN_TYPE;      
  c->type0 = Connector_Type::NULL_TYPE;      
  c->connector_string = s;
  connector_type_vector.push_back(c);

  return;

}

@q * (1) Functions for checking integrity of form.@> 
@* Functions for checking integrity of form.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this section.
\ENDLOG

@q ** (2) Is whatever.@>
@*1 Is whatever. 
@^\cfunc{Path}{is\_whatever}@>
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
bool
is_whatever(Scanner_Node scanner_node = 0,
            real tolerance = Shape::DEFAULT_TOLERANCE) const;

@
@<Define |Path| functions@>=

bool
Path::is_whatever(Scanner_Node scanner_node,
                  real tolerance) const
{
  return true;
}

@q * (1) Functions for checking types.@> 
@* Functions for checking types.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this section.
\ENDLOG

@q ** (2) Is |Point|.@> 
@*1 Is {\bf Point}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_point(void) const
{
   return false;
}

@q ** (2) Is |Nurb|.@> 
@*1 Is {\bf Nurb}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_nurb(void) const
{
   return false;
}

@q ** (2) Is |Path|.@> 
@*1 Is {\bf Path}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_path(void) const
{
   return true;
}

@q ** (2) Is |Polygon|.@> 
@*1 Is {\bf Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_polygon(void) const
{
   return false;
}

@q ** (2) Is |Triangle|.@> 
@*1 Is {\bf Triangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_triangle(void) const
{
   return false;
}

@q ** (2) Is |Rectangle|.@> 
@*1 Is {\bf Rectangle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_rectangle(void) const
{
   return false;
}

@q ** (2) Is |Reg_Polygon|.@> 
@*1 Is {\bf Reg\_Polygon}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_reg_polygon(void) const
{
   return false;
}

@q ** (2) Is |Ellipse|.@> 
@*1 Is {\bf Ellipse}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_ellipse(void) const
{
   return false;
}

@q ** (2) Is |Ellipse_Slice|.@> 
@*1 Is {\bf Ellipse\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_ellipse_slice(void) const
{
   return false;
}

@q ** (2) Is |Circle|.@> 
@*1 Is {\bf Circle}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_circle(void) const
{
   return false;
}

@q ** (2) Is |Circle_Slice|.@> 
@*1 Is {\bf Circle\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_circle_slice(void) const
{
   return false;
}

@q ** (2) Is |Parabola|.@> 
@*1 Is {\bf Parabola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_parabola(void) const
{
   return false;
}

@q ** (2) Is |Hyperbola|.@> 
@*1 Is {\bf Hyperbola}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_hyperbola(void) const
{
   return false;
}

@q ** (2) Is |Arc|-type.@> 
@*1 Is {\bf Arc}-type.
\initials{LDF 2007.10.13.}

\LOG
\initials{LDF 2007.10.13.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_arc_type(void) const
{
   return false;
}

@q ** (2) Is |Helix|.@> 
@*1 Is {\bf Helix}.
\initials{LDF 2005.05.18.}

\LOG
\initials{LDF 2005.05.18.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_helix(void) const
{
   return false;
}

@q ** (2) Is |Helix_Slice|.@> 
@*1 Is {\bf Helix\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_helix_slice(void) const
{
   return false;
}

@q ** (2) Is |Solid|.@> 
@*1 Is {\bf Solid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_solid(void) const
{
   return false;
}

@q ** (2) Is |Solid_Faced|.@> 
@*1 Is {\bf Solid\_Faced}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_solid_faced(void) const
{
   return false;
}

@q ** (2) Is |Polyhedron|.@> 
@*1 Is {\bf Polyhedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_polyhedron(void) const
{
   return false;
}

@q ** (2) Is |Polyhedron_Slice|.@> 
@*1 Is {\bf Polyhedron\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_polyhedron_slice(void) const
{
   return false;
}

@q ** (2) Is |Cuboid|.@> 
@*1 Is {\bf Cuboid}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cuboid(void) const
{
   return false;
}

@q ** (2) Is |Cuboid_Slice|.@> 
@*1 Is {\bf Cuboid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cuboid_slice(void) const
{
   return false;
}

@q ** (2) Is |Tetrahedron|.@> 
@*1 Is {\bf Tetrahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_tetrahedron(void) const
{
   return false;
}

@q ** (2) Is |Octahedron|.@> 
@*1 Is {\bf Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_octahedron(void) const
{
   return false;
}

@q ** (2) Is |Dodecahedron|.@> 
@*1 Is {\bf Dodecahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_dodecahedron(void) const
{
   return false;
}

@q ** (2) Is |Icosahedron|.@> 
@*1 Is {\bf Icosahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_icosahedron(void) const
{
   return false;
}

@q ** (2) Is |Trunc_Octahedron|.@> 
@*1 Is {\bf Trunc\_Octahedron}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_trunc_octahedron(void) const
{
   return false;
}

@q ** (2) Is |Great_Rhombicosidodecahedron|.@> 
@*1 Is {\bf Great\_Rhombicosidodecahedron}.
\initials{LDF 2005.12.14.}

\LOG
\initials{LDF 2005.12.14.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_great_rhombicosidodecahedron(void) const
{
   return false;
}

@q ** (2) Is |Cone|.@> 
@*1 Is {\bf Cone}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cone(void) const
{
   return false;
}

@q ** (2) Is |Cone_Slice|.@> 
@*1 Is {\bf Cone\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cone_slice(void) const
{
   return false;
}

@q ** (2) Is |Cylinder|.@> 
@*1 Is {\bf Cylinder}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cylinder(void) const
{
   return false;
}

@q ** (2) Is |Cylinder_Slice|.@> 
@*1 Is {\bf Cylinder\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_cylinder_slice(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid|.@> 
@*1 Is {\bf Ellipsoid}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_ellipsoid(void) const
{
   return false;
}

@q ** (2) Is |Ellipsoid_Slice|.@> 
@*1 Is {\bf Ellipsoid\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_ellipsoid_slice(void) const
{
   return false;
}

@q ** (2) Is |Sphere|.@> 
@*1 Is {\bf Sphere}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_sphere(void) const
{
   return false;
}

@q ** (2) Is |Sphere_Slice|.@> 
@*1 Is {\bf Sphere\_Slice}.
\initials{LDF 2005.05.24.}

\LOG
\initials{LDF 2005.05.24.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_sphere_slice(void) const
{
   return false;
}

@q ** (2) Is |Paraboloid|.@> 
@*1 Is {\bf Paraboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_paraboloid(void) const
{
   return false;
}

@q ** (2) Is |Hyperboloid|.@> 
@*1 Is {\bf Hyperboloid}.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
bool
is_hyperboloid(void) const
{
   return false;
}

@q * (1) Transformations. @>
@* Transformations.
\initials{LDF 2002.11.03.}
All of the transformations return a |Transform|, so that the same
|Transform| can be applied to multiple objects by chaining
expressions.

@q ** (2) Affine transformations.@>
@*1 Affine transformations.
\initials{LDF Undated.}

@q *** (3) Rotation.@>
@*2 Rotation. 
\initials{LDF Undated.}

@q **** (4) Rotatation around the main axes.@>
@*3 Rotation  around the main axes. 
@^\cfunc{Path}{rotate}@>
\initials{LDF Undated.}

@<Declare |Path| functions@>=
virtual
Transform 
rotate(const real x, const real y = 0, const real z = 0);

@
@<Define |Path| functions@>=
Transform 
Path::rotate(const real x, const real y, const real z)
{
  Transform t;
  t.rotate(x, y, z);
  return *this *= t;
}

@q **** (4) Rotatation around an arbitrary axis. @>
@ Rotatation around an arbitrary axis. 

@q ***** (5) Transform version.@>
@ {\bf Transform} version.
Declared in \filename{transfor.web}.  Must be defined here, because
|Path| is an incomplete type there.
@^\cfunc{Transform}{rotate}@>
\LOG
\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.

\initials{LDF 2003.07.06.}  Changed, so that |is_linear| is used, instead of
|get_line_switch|. 
\ENDLOG 

@<Define |Transform| functions@>=
Transform
Transform::rotate(const Path& p, const real angle)
{
  if (!p.is_linear())
    {
      cerr << "ERROR! In Transform::rotate(Path, real).\n"
        << "Path is not linear.  Returning INVALID_TRANSFORM.\n\n";
      return INVALID_TRANSFORM;
    }
  Transform t;
  t.rotate(p.get_point(0), p.get_last_point(), angle);
  return (*this *= t);
}

@q ***** (5) Point version.@>
@ {\bf Point} version.
@^\cfunc{Point}{rotate}@>
Declared in \filename{points.web}.  Must be defined here, because
|Path| is an incomplete type there.
\LOG
\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Define |Point| functions@>=
Transform
Point::rotate(const Path& p,  const real angle)
{
  if (!p.get_line_switch())
    {
      cerr << "ERROR! In Point::rotate(Path, real).\n"
           << "Path is not a line.  Returning INVALID_TRANSFORM.\n\n";
      return INVALID_TRANSFORM;
    }
  Point pt0 = p.get_point(0);
  Point pt1 = p.get_point(1);
  return rotate(pt0, pt1, angle);
}

@q ***** (5) Path versions.@>
@ {\bf Path} versions.

@q ****** (6) Point arguments.@>
@ {\bf Point} arguments.
@^\cfunc{Path}{rotate}@>
\LOG
\initials{LDF 2002.4.7.}  Added default value for |angle| $\equiv 180$.

\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Declare |Path| functions@>=
virtual
Transform 
rotate(const Point& p0, const Point& p1, const real angle = 180);

@ @:!! TO DO@> TO DO: Change this, so that I use
|operator*=(Transform)| here and in the other transformation functions. 
@<Define |Path| functions@>=
Transform 
Path::rotate(const Point& p0, const Point& p1, const real angle)
{
  Transform t;
  t.rotate(p0, p1, angle);
  return (*this *= t);
}

@q ****** (6) Path arguments.@>
@ {\bf Path} arguments.
@^\cfunc{Path}{rotate}@>
\LOG
\initials{LDF 2002.4.7.}  Added default value for |angle| $\equiv 180$.

\initials{LDF 2002.11.03.}  Got rid of local |Points p0| and |p1|.   

\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.

\initials{LDF 2003.07.13.}  Changed, so that |is_linear| is used instead of
checking the return value of\newline
|get_line_switch|.  Also,
|get_last_point| passed as the second argument to |rotate|,
instead of |get_point(1)|. 
\ENDLOG 

@<Declare |Path| functions@>=
Transform 
rotate(const Path& p, const real angle = 180);

@
@<Define |Path| functions@>=
Transform 
Path::rotate(const Path& p, const real angle)
{
  if (!p.is_linear())
    {
      cerr << "ERROR! In Path::rotate(Path, real).\n"
        << "Path is not a line.  Returning INVALID_TRANSFORM.\n\n";
      return INVALID_TRANSFORM;
    }
  return rotate(p.get_point(0),
                       p.get_last_point(), angle);  
}   

@q *** Scale. @>
@ Scale. 
@^\cfunc{Path}{scale}@>
\initials{LDF 2002.12.20.}  @:!! TO DO@> TO DO:  Make all of the transformations |virtual|!
@<Declare |Path| functions@>=
Transform 
scale(real x, real y = 1, real z = 1);

@
@<Define |Path| functions@>=
Transform 
Path::scale(real x, real y, real z)
{
  Transform t;
  t.scale(x, y, z);
  return (*this *= t);
}

@q *** Shear.@>
@ Shear. 
@^\cfunc{Path}{shear}@>
@<Declare |Path| functions@>=
Transform 
shear(real xy, real xz = 0, real yx = 0, real yz = 0, 
      real zx = 0, real zy = 0);

@
@<Define |Path| functions@>=
Transform 
Path::shear(real xy, real xz, real yx, real yz, 
      real zx, real zy)
{
  bool DEBUG = false; /* |true| */@; 
  if (DEBUG)
    cerr << "Entering Path::shear().\n";
                       
  Transform t;
  t.shear(xy, xz, yx, yz, zx, zy);

  if (DEBUG)
    cerr << "Exiting Path::shear().\n";
  return (*this *= t);
}

@q *** Shift. @>
@ Shift. 

@q **** (4) real arguments. @>
@ {\bf real} arguments. 
@^\cfunc{Path}{shift}@>
@<Declare |Path| functions@>=
Transform 
shift(real x, real y = 0, real z = 0);

@
@<Define |Path| functions@>=
Transform
Path::shift(real x, real y, real z)
{
  Transform t;
  t.shift(x, y, z);
  return (*this *= t);
}

@q **** (4) Point argument. @>
@ {\bf Point} argument. 
@^\cfunc{Path}{shift}@>
@<Declare |Path| functions@>=
Transform 
shift(const Point& p);

@
@<Define |Path| functions@>=
Transform 
Path::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}

@q *** Shift times. @>
@ Shift times. 

\initials{LDF 2003.01.19.}  |shift_times| returns |void|, because |Path|
doesn't have a |Transform| data member, and there's no guarantee that
all of the |Points| on |points| will have identical |transforms|.

\initials{LDF 2003.01.19.}  Note that |shift_times| will only have an effect on
the |Points| on a |Path| if it's called {\it after\/} a call to
|shift| and {\it before\/} an operation is applied that causes
|Point::apply_transform| to be called.

\LOG
\initials{LDF 2003.01.19.}  Added this section.
\ENDLOG 

@q **** (4) real arguments. @>
@ {\bf real} arguments. 
@^\cfunc{Path}{shift\_times}@>

\LOG
\initials{LDF 2003.01.19.}  Added this function.
\ENDLOG 
@<Declare |Path| functions@>=
virtual
void 
shift_times(real x, real y = 1, real z = 1);

@
@<Define |Path| functions@>=
void 
Path::shift_times(real x, real y, real z)
{

  for(vector<Point*>::iterator iter = points.begin();
      iter != points.end(); ++iter)
    (**iter).shift_times(x, y, z);
  return;
}

@q **** (4) Point argument. @>
@ {\bf Point} argument. 
@^\cfunc{Path}{shift\_times}@>

\LOG
\initials{LDF 2003.01.19.}  Added this function.
\ENDLOG 
@<Declare |Path| functions@>=
virtual
void
shift_times(const Point& p);

@
@<Define |Path| functions@>=
void
Path::shift_times(const Point& p)
{
  return shift_times(p.get_x(), p.get_y(), p.get_z());
}

@q ** Applying transformations. @>
@ Applying transformations.

@q *** Multiplying by a Transform.@>
@ Multiplying by a {\bf Transform}.
@^\cofunc{Path}{*=}@>
@<Declare |Path| functions@>=
virtual
Transform
operator*=(const Transform& t);

@
@<Define |Path| functions@>=
Transform
Path::operator*=(const Transform& t)
{
    for(vector<Point*>::iterator iter = points.begin();
        iter != points.end();
        iter++)
      (**iter) *= t;
    return t;
}

@q *** (3) Applying transform to points.@>
@*2 Applying {\bf transform} to {\bf points}.
@^\cfunc{Path}{apply\_transform}@>
@<Declare |Path| functions@>=
virtual
void 
apply_transform();

@
@<Define |Path| functions@>=
void
Path::apply_transform()
{
  for(vector <Point*>::iterator iter = points.begin();
      iter != points.end();
      iter++)
    (**iter).apply_transform();
  return;
}

@q ** (2) Projection.@>
@*1 Projection.
@^\cfunc{Path}{project}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.04.15.}
Made this function |virtual|.  Added defaults for the arguments
|const unsigned short proj| and |real factor|.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
bool 
project(const Focus& f, 
        const unsigned short proj = Projections::persp, 
        real factor = 1);

@
@<Define |Path| functions@>=
bool 
Path::project(const Focus& f, 
              const unsigned short proj, 
              real factor)
{
  for(vector <Point*>::iterator iter = points.begin();
      iter != points.end();
      iter++)
    {
      
      if (!(**iter).project(f, proj, factor))
        {
          cerr << "ERROR! In Path::project():\n"
               << "Point::project() returned false.\n"
               << "Returning false.\n\n";
          return false;
        }
    }
  return true;
}

@q * (1) Reflection in a |Plane|.@>
@* Reflection in a {\bf Plane}.
\initials{LDF 2004.10.03.}
@^\cfunc{Path}{reflect\_in}@>

Please note that this function tries to allocate memory on the free
store for the |Path| pointed to by the pointer to |Shape| which is its
return value.  Therefore, programmers who use this function must
ensure that this memory is
\initials{LDF 2004.10.03.}

If allocation fails, this function throws a |bad_alloc| exception.  If
the reflection of |*this| cannot be found in the |Plane|, this
function returns 0.
\initials{LDF 2004.10.03.}

\LOG
\initials{LDF 2004.10.03.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.  Following a system update, having |Shape*| 
as the return value no longer worked.
\ENDLOG

@<Declare |Path| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Path| functions@>=
int
Path::reflect_in(const Plane& p, 
                 void* v,
                 const Scanner_Node scanner_node) const
{

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Path* path_reflection = static_cast<Path*>(v);

@q *** (3) If |path_reflection == 0|, try to allocate memory @> 
@q *** (3) for it on the free store.@> 

@ If |path_reflection == 0|, try to allocate memory for it
@ on the free store.
\initials{LDF 2004.10.12.}

@<Define |Path| functions@>=

   if (path_reflection == static_cast<Path*>(0))
     {
        cerr_strm << thread_name 
                  << "WARNING! In `Path::reflect_in':"
                  << endl << "`path_reflection' == 0. "
                  << "Will try to allocate memory on the free store for it.";
 
        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");

        try
        {
           path_reflection = create_new<Path>(0, scanner_node);
        }

@q **** (4) Error handling:  |create_new<Path>| failed.@>   

@ Error handling:  |create_new<Path>| failed.
\initials{LDF 2004.10.12.}

@<Define |Path| functions@>=

        catch (bad_alloc)
        {
              cerr_strm << thread_name 
                        << "ERROR! In `Path::reflect_in':"
                        << endl << "`create_new<Path>' failed. "
                        << "Rethrowing `bad_alloc'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              throw;

        } /* |catch (bad_alloc)|  */

@q **** (4) |create_new<Path>| succeeded.@>           

@ |create_new<Path>| succeeded.
\initials{LDF 2004.10.12.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Path::reflect_in':"
                   << endl << "`create_new<Path>' succeeded.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

     } /* |if (path_reflection == 0)|  */

@q **** (4) Cycle through |points| and try to find @> 
@q **** (4) reflections of the |Points|.@> 

@ Cycle through |points| and try to find reflections of 
the |Points|.
\initials{LDF 2004.10.03.}

@<Define |Path| functions@>=

  int status;

  Point* point_reflection;
  
  vector<string>::const_iterator connector_iter = connectors.begin();
  vector<Connector_Type*>::const_iterator connector_type_iter = connector_type_vector.begin();

  for (vector<Point*>::const_iterator point_iter = points.begin();
       point_iter != points.end();
       point_iter++)
     {
@q ***** (5) @>

          try 
          {
             point_reflection = create_new<Point>(0, scanner_node);
          }

@q ***** (5) Error handling:  |create_new<Point>| failed.@> 
@ Error handling:  |create_new<Point>| failed.
\initials{LDF 2004.10.11.}

@<Define |Path| functions@>=

         catch (bad_alloc)
          {
            
              cerr_strm << thread_name << "ERROR! In `Path::reflect_in':" 
                        << "`create_new<Point>' failed."
                        << endl
                        << "Deleting `path_reflection' and "
                        << "rethrowing `bad_alloc'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              delete path_reflection;
            
              throw;

          }  /* |catch (bad_alloc)|  */
        
@q ***** (5).@> 

           status
             = (*point_iter)->reflect_in(p,
                                         static_cast<void*>(point_reflection), 
                                         scanner_node);

@q ***** (5) Error handling:  |Point::reflect_in| failed.@> 

@ Error handling:  |Point::reflect_in| failed.

\initials{LDF 2004.10.03.}

@<Define |Path| functions@>=

       if (status != 0)
         {
           cerr_strm << thread_name << "ERROR! In `Path::reflect_in':" 
                     << "`Point::reflect_in' failed."
                     << endl
                     << "Deleting `path_reflection' and "
                     << "exiting function with return value 1.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete path_reflection;
          
           return 1;

         } /* |if (status != 0)|  */

@q ***** (5) |Point::reflect_in| succeeded.@> 

@ |Point::reflect_in| succeeded.  Push |point_reflection| onto |vector<Points*> points| 
and the next connector onto |vector<string> connectors|.
\initials{LDF 2004.10.03.}

\LOG
\initials{LDF 2004.10.05.}
@:BUG FIX@> BUG FIX: Now only appending |*connector_iter| to
|path_reflection->connectors| if |connector_iter != connectors.end|.
Also advancing |connector_iter| in this case.
\ENDLOG 

@<Define |Path| functions@>=

#if DEBUG_COMPILE
    if (DEBUG)
      {

        cerr_strm << thread_name << "In `Path::reflect_in':" 
                  << endl
                  << "`Point::reflect_in() succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */

       *path_reflection += point_reflection;

       if (connector_iter != connectors.end())
       {
         *path_reflection += *connector_iter;
         connector_iter++;
       }

       if (connector_type_iter != connector_type_vector.end())
       {
         path_reflection->connector_type_vector.push_back(*connector_type_iter++);
       }

@q ***** (5).@> 

     } /* |for|  */

@q **** (4) Set |path_reflection->cycle| to |cycle| and    @> 
@q **** (4) exit function successfully with return value 0.@> 

@ Set |path_reflection->cycle| to |cycle| and  
exit function successfully with return value 0.

@<Define |Path| functions@>=

#if DEBUG_COMPILE
    if (DEBUG)
      {

        cerr_strm << thread_name << "In `Path::reflect_in':" 
                  << endl
                  << "`Point::reflect_in() succeeded for all `Points' "
                  << "on `*this'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */

  path_reflection->set_cycle(cycle_switch);

  return 0;

} /* End of |Path::reflect_in| definition */

@q * (1) Reflection off of a |Plane|.@>
@* Reflection off of a {\bf Plane}.
\initials{LDF 2004.12.10.}

\LOG
\initials{LDF 2004.12.10.}
Added this function.

\initials{LDF 2004.12.14.}
Added default of 0 for the 
|const Scanner_Node scanner_node| argument.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
int
reflect_off(const Plane& p,
            Point direction,
            void* v,
            const Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::reflect_off(const Plane& p,
                  Point direction,
                  void* v,
                  const Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@> 

  bool DEBUG = false; /* |true| */ @; 

  using namespace Scan_Parse;

  stringstream cerr_strm;
  
  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
						   &error_stop_value,
						   &warning_stop_value);

@q **** (4).@> 

  Pointer_Vector<Path>* path_ptr_vector 
     = static_cast<Pointer_Vector<Path>*>(v);

@q **** (4) Error handling:  |path_ptr_vector == 0|.  @> 

@ Error handling:  |path_ptr_vector == 0|.  Return 1.
\initials{LDF 2004.12.09.}

\LOG
\initials{LDF 2004.12.09.}
Added this section.
\ENDLOG

@<Define |Path| functions@>=
  
  if (path_ptr_vector == static_cast<Pointer_Vector<Path>*>(0))
     {

         cerr_strm << thread_name << "ERROR!  In `Path::reflect_off':"
                   << endl 
                   << "`Pointer_Vector<Path>* path_ptr_vector' == 0."
                   << endl << "Returning 1.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
      
         return 1;

      }  /* |if (path_ptr_vector == 0)|  */

@q **** (4) Error handling:  |path_ptr_vector->ctr < 4|.  @> 

@ Error handling:  |path_ptr_vector->ctr < 4|.  
Delete |path_ptr_vector| and return 1.
\initials{LDF 2004.12.09.}

\LOG
\initials{LDF 2004.12.09.}
Added this section.
\ENDLOG

@<Define |Path| functions@>=

  if (path_ptr_vector->ctr < 4)
     {

         cerr_strm << thread_name << "ERROR!  In `Path::reflect_off':"
                   << endl 
                   << "`Pointer_Vector<Path>* path_ptr_vector->ctr' < 4."
                   << endl << "Deleting `path_ptr_vector' and returning 1.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
       
         delete path_ptr_vector;

return 1;

      }  /* |if (path_ptr_vector->ctr < 4)|  */

@q **** (4) Error handling:  |direction == origin|.@> 

@ Error handling:  |direction == origin|.
\initials{LDF 2004.10.11.}

@<Define |Path| functions@>=

  Point origin;

  if (direction == origin)
    {

      cerr_strm << thread_name << "ERROR! In `Path::reflect_off':"
                    << endl 
                    << "`direction'  == (0, 0, 0)."
                    << endl << "Deleting `path_ptr_vector', setting it to 0,"
                    << endl 
                    << "and exiting function with return value 1.";
              
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete path_ptr_vector;
         
          path_ptr_vector = 0;

          return 1;

    }  /* |if (direction == *this)|  */

@q **** (4) @>   

@ 

@<Define |Path| functions@>=

   Pointer_Vector<Point>* point_ptr_vector;

   try 
      {
          point_ptr_vector = new Pointer_Vector<Point>;

          *point_ptr_vector += create_new<Point>(0, scanner_node);
          *point_ptr_vector += create_new<Point>(0, scanner_node);
          *point_ptr_vector += create_new<Point>(0, scanner_node);
          *point_ptr_vector += create_new<Point>(0, scanner_node);

      } /* |try|  */

@q ***** (5) .@> 
@
@<Define |Path| functions@>=

   catch (bad_alloc)    
      {

         cerr_strm << thread_name << "ERROR! In `Path::reflect_off':"
                       << endl 
                       << "`new Pointer_Vector<Point>' or "
                       << "`create_new<Point>' failed, "
                       << "throwing `bad_alloc'."
                       << endl 
                       << "Deleting `path_ptr_vector', setting it to 0,"
                       << endl 
                       << "and rethrowing `bad_alloc'.";
                 
             log_message(cerr_strm);
             cerr_message(cerr_strm, error_stop_value);
             cerr_strm.str("");

             delete path_ptr_vector;
            
             path_ptr_vector = 0;

             throw;

      }  /* |catch (bad_alloc)|  */

@q **** (4).@> 

@

@<Define |Path| functions@>=

   vector<Point*>::const_iterator iter = points.begin(); 
   vector<string>::const_iterator connector_iter = connectors.begin();
   vector<Connector_Type*>::const_iterator connector_type_iter = connector_type_vector.begin();

   int status;

   for (; iter != points.end(); ++iter)
   {
      status = (**iter).reflect_off(p,
                                    direction, 
                                    static_cast<void*>(point_ptr_vector),
                                    scanner_node);

@q ***** (5) Error handling:  |Point::reflect_off| failed.@> 

@ Error handling:  |Point::reflect_off| failed.
\initials{LDF 2004.12.10.}

@<Define |Path| functions@>=

        if (status != 0)
        {

           cerr_strm << thread_name << "ERROR! In `Path::reflect_off':"
                     << endl 
                     << "`Point::reflect_off' failed, returning "
                     << status << "." << endl
                     << "Deleting `path_ptr_vector', setting it to 0,"
                     << endl 
                     << "and exiting function with return value 1.";
                      
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete path_ptr_vector;
           
           path_ptr_vector = 0;

           return 1;

        } /* |if (status != 0)|  */

@q ***** (5) |Point::reflect_off| succeeded.@> 

@ |Point::reflect_off| succeeded.
\initials{LDF 2004.12.10.}

@<Define |Path| functions@>=

       else /* |status == 0|  */
       { 

#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr_strm << thread_name << "In `Path::reflect_off':"
                            << endl 
                            << "`Point::reflect_off' succeeded.";
                      
              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");

           }       
#endif /* |DEBUG_COMPILE|  */@; 

           for (int i = 0; i < 4; ++i)
           {  
              *(path_ptr_vector->v[i]) += *(point_ptr_vector->v[i]);

              if (connector_iter != connectors.end())
                 *(path_ptr_vector->v[i]) += *connector_iter++;


              if (connector_type_iter != connector_type_vector.end())
                 (path_ptr_vector->v[i])->connector_type_vector.push_back(*connector_type_iter++);

           }  /* |for|  */

       }   /* |else| (|status == 0|)  */

@q ***** (5).@> 

      } /* |for|  */

      for (int i = 0; i < 4; ++i)
      {  
         (path_ptr_vector->v[i])->set_cycle(cycle_switch);
      }

      delete point_ptr_vector;
      point_ptr_vector = 0;

@q **** (4) Exit function successfully with return value 0.@>

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.11.}

@<Define |Path| functions@>=

  return 0;

}  /* End of |Path::reflect_off| definition.  */

@q * (1) Functions for lines.@>
@* Functions for lines.

@q ** (2) Alignment with an axis. @>
@*1 Alignment with an axis.

@q *** (3) For linear |Paths|. @>
@*2 For linear {\bf Paths}.

@q **** (4) No assignment.  (No |Point| arguments.)@>
@*3 No assignment.  (No {\bf Point} arguments.)
@^\cfunc{Path}{align\_with\_axis}@>
\initials{LDF Undated.}

This function returns the |Transform| that would
transform |Path| such that it would come to lie on the major axis
indicated by its argument (by default, the z-axis).  It does not
actually perform the transformation on the |Path|.
\initials{LDF 2002.11.03.}  

\LOG
\initials{LDF 2002.11.03.}  
Changed |char| argument to |const char|.

\initials{LDF 2007.10.02.}
Now calling |Path::is_linear| instead of |Path::get_line_switch|.
Made error output thread-safe.  Added optional |Scanner_Node| argument 
with the default 0.
\ENDLOG 

@q ***** (5) Declaration.@>

@<Declare |Path| functions@>=
Transform
align_with_axis(const char axis = 'z', 
                Scanner_Node scanner_node = 0) const;

@q ***** (5) Definition.@>
@
@<Define |Path| functions@>=
Transform
Path::align_with_axis(const char axis, Scanner_Node scanner_node) const
{
  
@q ****** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6)@>

  Transform t;
  if (!is_linear())
    {
       cerr_strm << thread_name << "ERROR! In `Path::align_with_axis:"
                 << endl 
                 << "Path is not linear.  Returning `INVALID_TRANSFORM'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");
   
       return INVALID_TRANSFORM;

    }  /* |if|  */

  Point p0(*points[0]);
  Point p1(*points[1]);
  return t.align_with_axis(p0, p1, axis);

}  /* End of |Path::align_with_axis| definition.  */

@q **** (4) With assignment.@>
@*3 With assignment.
@^\cfunc{Path}{align\_with\_axis}@>
\initials{LDF 2002.11.03.}  This function should never be called with the |bool|
argument |assign == false|.  It won't cause any harm, though, since it
will just call the |const| version above.

\LOG
\initials{LDF 2002.11.03.}  Added this function.

\initials{LDF 2003.07.18.}
Changed, so that |is_linear| is used, rather than
|get_line_switch|.  Also, changed the way |Transform t| is set.  
The latter change was necessary, because GCC 3.3 couldn't compile this
file the way it was before.
\ENDLOG 

@<Declare |Path| functions@>=

Transform
align_with_axis(bool assign, const char axis = 'z');

@
@<Define |Path| functions@>=
Transform
Path::align_with_axis(bool assign, const char axis)
{
   if (!is_linear())
   {
     cerr << "ERROR! In Path::align_with_axis." << endl 
          << "Path is not linear.  Returning INVALID_TRANSFORM." 
          << endl;

     return INVALID_TRANSFORM;
   }

   Transform t;

   t.align_with_axis(get_point(0), get_last_point(), axis);

   if (assign == false) 
   {
     cerr << "WARNING! In Path::align_with_axis():\n"
          << "Don't call this function with the \"assign\" "
          << "argument == false.\nIt won't cause any harm, though.\n"
          << "Continuing.\n\n";
     return t;
   }

   return (*this *= t);

} /* |Path::align_with_axis| */

@q *** (3) For non-lines. ({\bf Point} and axis arguments).@>
@*2 For non-lines.  ({\bf Point} and axis arguments).
@^\cfunc{Path}{align\_with\_axis}@>
\initials{LDF 2002.11.03.}  
This function finds the transformation that would
align the line segment $\overrightarrow{p_0p_1}$ with the major axis
indicated by the |axis| argument, and applies it to |*this|.  |p0| and
|p1| are not changed.

\LOG
\initials{LDF 2002.11.03.}  
Changed |Point| arguments to |const Point&| and
|char| argument to |const char|.
\ENDLOG 

@<Declare |Path| functions@>=
Transform
align_with_axis(const Point& p0, const Point& p1, const char axis);

@
@<Define |Path| functions@>=
Transform
Path::align_with_axis(const Point& p0, const Point& p1, const char axis = 'z')
{
  Transform t;
  t.align_with_axis(p0, p1, axis);
  return (*this *= t);

}

@q * (1) Adding Points to Paths.@>
@* Adding {\bf Points} to {\bf Paths}.

@q ** (2) With assignment.@>
@*1 With assignment.  
@^\cofunc{Path}{+=}@>

@q *** (3) |const Point&| argument.@>
@*2 {\bf const Point} reference argument.  
@^\cofunc{Path}{+=}@>

\LOG
\initials{LDF 2002.4.6.}  
Added this function.
Currently, it doesn't return a |Path|.  If it turns out that it would
be useful to return |*this|, I can change it.
\ENDLOG 

@<Declare |Path| functions@>=
void
operator+=(const Point& p);

@
@<Define |Path| functions@>=
void
Path::operator+=(const Point& p)
{
  points.push_back(create_new<Point>(p));
  return;
}

@q *** (3) |Point*| argument.@>
@*2 Pointer to {\bf Point} argument.  
@^\cofunc{Path}{+=}@>

This function pushes the |Point*| argument itself onto 
|vector<Point*> points|, not a copy of it.  Therefore, the argument 
to this function should be a pointer to a |Point| that has been 
allocated on the free store.
\initials{LDF 2004.10.03.}

\LOG
\initials{LDF 2004.10.03.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
void
operator+=(Point* p);

@
@<Define |Path| functions@>=
void
Path::operator+=(Point* p)
{
  points.push_back(p);
  return;
}

@q ** (2) Without assignment.@>
@*1 Without assignment.  
@^\cofunc{Path}{+}@>

\LOG
\initials{LDF 2002.4.6.}  Added this function.
\ENDLOG 

@<Declare |Path| functions@>=
Path
operator+(const Point& pt) const;

@
@<Define |Path| functions@>=
Path
Path::operator+(const Point& pt) const
{
  Path pa(*this);
  pa.points.push_back(create_new<Point>(pt));
  return pa;
}

@q * (1) Adding connectors to Paths.@>
@* Adding connectors to {\bf Paths}.
@^\cofunc{Path}{+=}@>
\initials{LDF 2003.02.09.}  

@q ** (2) |string| version.  @>

@ |string| version.
\initials{LDF 2003.02.09.}  

\LOG
\initials{LDF 2003.02.09.}  
Added this function.

\initials{LDF 2005.03.10.}
Made this function virtual.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
void
operator+=(const string s);

@
@<Define |Path| functions@>=
void
Path::operator+=(const string s)
{
   connectors.push_back(s);

   Connector_Type *c = create_new<Connector_Type>(0);
   c->type0 = Connector_Type::PLAIN_TYPE;
   c->type1 = Connector_Type::NULL_TYPE;
   c->connector_string = s;
   connector_type_vector.push_back(c);

   return;
}


@q ** (2) |Connector_Type&| version.  @>

@ |Connector_Type&| version.
\initials{LDF 2022.01.12.}

\LOG
\initials{LDF 2022.01.12.}
Added this function.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
void
operator+=(const Connector_Type& c);

@
@<Define |Path| functions@>=
void
Path::operator+=(const Connector_Type &c)
{

   Connector_Type *cc = create_new<Connector_Type>(c);
   connector_type_vector.push_back(cc);

   return;
}

@q ** (2) |Connector_Type*| version.  @>

@ |Connector_Type*| version.
\initials{LDF 2022.01.12.}

Please note:  The |Connector_Type*| argument is pushed onto |Path::connector_type_vector| directly,
i.e., not copied!
\initials{LDF 2022.01.12.}

\LOG
\initials{LDF 2022.01.12.}
Added this function.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
void
operator+=(Connector_Type *c);

@
@<Define |Path| functions@>=
void
Path::operator+=(Connector_Type *c)
{
   connector_type_vector.push_back(c);

   return;
}

@q * (1) Adding |Colors| to Paths.@>
@* Adding {\bf Colors} to {\bf Paths}.
@^\cofunc{Path}{+=}@>
\initials{LDF 2005.03.10.}

\LOG
\initials{LDF 2005.03.10.}
Added this function.
\ENDLOG 

@q ** (2) Declaration.@> 

@<Declare |Path| functions@>=
virtual
int
operator+=(Color* c);

@q ** (2) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::operator+=(Color* c)
{

@q *** (3) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q *** (3) |c == 0|.  Issue a warning and return 1.@>
@ |c == 0|.  Issue a warning and return 1.
\initials{LDF 2005.03.10.}

@<Define |Path| functions@>=

   if (c == static_cast<Color*>(0))
      {
          cerr_strm << thread_name << "WARNING!  In `Path::operator+=(Color*)':"
                    << endl 
                    << "The `Color* c' argument is null.  "
                    << "Not appending it to `*draw_color_vector'."
                    << endl 
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");  
          
          return 1;

      }  /* |if (c == 0)|  */

@q *** (3).@> 

   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      {
 
         try 
            { 
                draw_color_vector = new Pointer_Vector<Color>;
            }         

         catch (bad_alloc)
            {
                cerr_strm << thread_name << "ERROR!  In `Path::operator+=(Color*)':"
                          << endl 
                          << "`new Pointer_Vector<Color>' failed, throwing `bad_alloc'.  "
                          << "Deleting `Color* c', setting it to 0, and rethrowing.";

                log_message(cerr_strm);
                cerr_message(cerr_strm, error_stop_value);
                cerr_strm.str("");  

                delete c;
                c = 0;

                throw;

            }  /* |catch (bad_alloc)|  */

      }  /* |if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))|  */

@q *** (3).@> 

   *draw_color_vector += c;

@q *** (3) Exit function successfully, returning 0.@> 

@ Exit function successfully, returning 0.
\initials{LDF 2005.03.10.}

@<Define |Path| functions@>=

   return 0;

} /* End of |Path::operator+=(Color* c)| definition.  */

@q * (1) Concatenating Paths.@>
@* Concatenating {\bf Paths}.

@q ** (2) Versions using ``{\AM}''.@>
@*1 Versions using ``{\AM}''.

@q *** (3) With assignment.@>
@*2 With assignment. 
@^\cofunc{Path}{\AM=}@>
This function appends the |Path| argument |pa| to |*this|.

\LOG
\initials{LDF 2002.4.6.}  
Added this function.

\initials{LDF 2002.11.03.}  
Made non-|inline|.
\ENDLOG 

@<Declare |Path| functions@>=
void
operator&=(const Path& pa);

@
@<Define |Path| functions@>=
void
Path::operator&=(const Path& pa)
{
  if (is_cycle() || pa.is_cycle())  /* Return  if either one of the
                                       |Paths| is a cycle.  */ 
    {
      cerr << "ERROR! In Path::operator&(Path&).\n"
        << "One of the Paths is a cycle. Can't concatenate.\n"
          << "Returning *this.\n\n";
      return;
    }

  string last_connector;

@ \initials{LDF 2002.4.6.}  If there isn't an explicit connector for every pair
of |Points| in |this->points|, then we have to fill up
|connectors| so that there are enough. Otherwise, the ``{\AM}'' 
will be at the wrong place.  We don't have to worry about the 
connectors for |pa|. 
@<Define |Path| functions@>=

if (connectors.size() == 0)
    last_connector = "--";
  else
    last_connector = connectors.back();
  
  while (connectors.size() < points.size() - 1)
    connectors.push_back(last_connector);

@ \initials{LDF 2002.4.6.}   
If the |Paths| don't touch, they are joined using ``..'' instead
of ``{\AM}''.  This mimics the behavior of \MF/.  

\LOG
\initials{LDF 2002.11.03.}  Now using |*(points.back())| instead of
|get_point(points.size() - 1)|. 
\ENDLOG 
@<Define |Path| functions@>=
  if (*(points.back()) != pa.get_point(0))
    {
      cerr << "ERROR! In Path::operator&(Path&)."
        << "Paths don't touch.\n"
          << "Using \"..\" to join them instead of \"&\".\n";

      connectors.push_back("..");
    }
  else
    connectors.push_back("&");

  for(vector<Point*>::const_iterator iter
      = pa.points.begin();  /* \initials{LDF 2002.4.6.} 
                               Copy the |Points| in |pa| and put the
                               copies onto |points|.  */
      iter != pa.points.end();
      iter++)
    points.push_back(create_new<Point>(*iter));

@  \initials{LDF 2002.4.6.} 
Put the connectors from |pa| onto the new |Path|.  Since they're
|strings|, and not pointers, we don't have to copy them.  I tested
this to make sure it's true.  I don't know how |strings| are
implemented, but they seem to be handled like string literals.  
@<Define |Path| functions@>=

  for(vector<string>::const_iterator iter
      = pa.connectors.begin();
      iter != pa.connectors.end();
      iter++)
    {
      connectors.push_back(*iter);
    }
  return;
}

@q *** (3) Without assignment.@>
@*2 Without assignment.  
@^\cofunc{Path}{\AM}@>
\initials{LDF 2002.4.6.}  

\LOG
\initials{LDF 2002.4.6.}  
Added this function.
It behaves the way the
operator ``{\AM}'' does in \MF/.
\ENDLOG 

@<Declare |Path| functions@>=
Path
operator&(const Path& pa) const;

@
@<Define |Path| functions@>=
Path
Path::operator&(const Path& pa) const
{
  Path r(*this);
  r &= pa;
  return r;
}

@q ** (2) Appending with a connector argument.@>
@*1 Appending with a connector argument.
@^\cfunc{Path}{append}@>
\initials{LDF 2002.4.7.} 

It would not have been possible to specify a connector if I'd defined
this function as a binary operator, e.g., |operator+=|, so I've made
it a named function.  It can be useful when, for instance, rotation
causes two |Points|, which should be identical, to differ by a small
amount, like $1/10,000$ in one coordinate.  This has actually
happened, which is why I've added this function.
\MP/ can recover gracefully by using ``\.{..}'' instead of
``{\AM}'' to connect the paths, but it issues an error message and
stops to wait for a response.  Using this function can help to avoid
such problems. 
\initials{LDF 2002.4.7.} 

\LOG
\initials{LDF 2002.4.7.} 
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
Path
append(const Path& pa, string connector = "--", bool assign = true);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
Path
Path::append(const Path& p, string connector, bool assign)
{

Path r(*this);

  string last_connector;

  r.set_cycle(false);

@q **** (4) @>   

@ If there isn't an explicit connector for every pair
of |Points| in |points|, then we have to fill up
|connectors| so that there are enough. Otherwise, the ``{\AM}'' 
will be at the wrong place.  
\initials{LDF 2002.4.6.}  

@<Define |Path| functions@>=

  if (r.connectors.size() == 0)
    last_connector = "--";
  else
    last_connector = r.connectors.back();
    
  while (r.connectors.size() < r.points.size() - 1)
    r.connectors.push_back(last_connector);

  r.connectors.push_back(connector);

@q **** (4) @>   

@ Copy the |Points| in |p| and put the copies onto |points|.
\initials{LDF 2002.4.6.} 

@<Define |Path| functions@>=

  for(vector<Point*>::const_iterator iter = p.points.begin();
      iter != p.points.end();
      iter++)
    r.points.push_back(create_new<Point>(*iter));

@q **** (4) @>   
   
@ Put the connectors from |p| onto the new |Path|.  Since they're
|strings|, and not pointers, we don't have to copy them.  
\initials{LDF 2002.4.6.}

\LOG
\initials{LDF 2004.11.01.}
Now removing excess connectors.
\ENDLOG 

@<Define |Path| functions@>= 
  for(vector<string>::const_iterator iter = p.connectors.begin();
      iter != p.connectors.end();
      iter++)
    {
      r.connectors.push_back(*iter);
    }

   while (r.connectors.size() >= r.points.size())
     r.connectors.pop_back();

  if (assign == true)
    *this = r;

  return r;

} /* End of |Path::append| definition.  */

@q * (1) |Plane| functions.@> 
@* {\bf Plane} functions.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.
\ENDLOG

@q ** (2) Get |Path|.@> 
@*1 Get {\bf Path}.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this function definition.
\ENDLOG

@q *** (3)@> 

@<Define |Plane| functions@>=
Path*
Plane::get_path(Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   if (   point == INVALID_POINT || normal == INVALID_POINT
       || distance == INVALID_REAL)
      return 0;

   Point p0(point);
   Point p1(normal);

   p1.shift(point);

   Transform t;
   t.align_with_axis(p0, p1, 'y');
   
   p0 *= p1 *= t;

   Point origin(0, 0, 0);

@q **** (4) Error handling.@> 
@ Error handling.
@<Define |Plane| functions@>=

   if (!(p0 == origin || p1 == origin))
      {
          cerr_strm << thread_name << "ERROR!  In `Plane::get_path':"
                    << endl 
                    << "Neither `p0' nor `p1' is equal to `(0, 0, 0)'."
                    << endl 
                    << "Can't make `path'.  Exiting function unsuccessfully "
                    << "with return value `(Path*) 0'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      }  /* |if (!(p0 == origin || p1 == origin))|  */

@q **** (4)@> 
@
@<Define |Plane| functions@>=

   else if (p1 != origin && p1.get_y() < 0)
      t *= p1.rotate(0, 0, 180);
   else if (p0 != origin && p0.get_y() < 0)
      t *= p0.rotate(0, 0, 180);

   Point q0(1, 0, 0);
   Point q1(1, 0, 1);

   Path* r = create_new<Path>(0);

   *r += origin;
   *r += q0;
   *r += q1;
   r->set_cycle();

   *r *= t.inverse();

   return r;

}  /* |Plane::get_path(void)| */

@q * (1) Drawing and filling. @>
@* Drawing and filling.

@q ** (2) Draw.@>
@*1 Draw.

@q *** (3) Path versions.@>
@*2 {\bf Path} versions.
@^\cfunc{Path}{draw}@>

\LOG
\initials{LDF 2002.10.07.}  
Added code for handling |draw_color| and |fill_color|.  

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2002.11.03.}  
Changed |dynamic_cast| to
|static_cast| in ``|picture += static_cast<Shape*>(p)|''.

\initials{LDF 2004.06.02.}  
Changed |const string ppen| to |const Pen* ppen| and
|const Color& ddraw_color| to |const Color* ddraw_color|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |const string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|, and changed the code in this function 
accordingly.

\initials{LDF 2004.06.07.}  
Now setting |p->fill_color = 0| instead of 
|p->fill_color = Colors::background_color|, because I've gotten rid 
of |Colors::background_color|.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2004.06.30.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory for |p->draw_color| if |ddraw_color != 0|.
Otherwise it's set to 0.  

\initials{LDF 2005.03.10.}
Added optional |Scanner_Node scanner_node| argument with the default 0.
Made debugging and error output thread-safe.  
Formatting changes.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Path| functions@>=
virtual
int
draw(Picture& picture,
     Pointer_Vector<Color>* ddraw_color_vector = 0, 
     Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
     Pointer_Vector<Pen>* ppen_vector = 0, 
     unsigned short aarrow = Path::NO_ARROW,
     Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@>

@
@<Define |Path| functions@>=

int
Path::draw(Picture& picture,
           Pointer_Vector<Color>* ddraw_color_vector,
           Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
           Pointer_Vector<Pen>* ppen_vector, 
           unsigned short aarrow,
           Scanner_Node scanner_node) const

{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (5).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "Entering `Path::draw'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5).@> 
@
\LOG
\initials{LDF 2002.09.27.} 
Added this error handling code.  If the 
|Path| is empty, don't draw it.
\ENDLOG 

@<Define |Path| functions@>=
          
  if (points.size() == 0)    
    {
        cerr_strm << thread_name << "WARNING!  In `Path::draw':"
                  << endl 
                  << "The `Path' doesn't contain any `Points'."
                  << endl 
                  << "Not adding `Path' to `Picture' and exiting function "
                  << "with return value 1.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");

        dummy_func();

        return 1;
    }

@q ***** (5).@> 

@
\LOG
\initials{LDF 2005.03.10.}
Now calling |create_new<Path>|, |create_new<Color>|,
|create_new<Dash_Pattern>|, and |create_new<Pen>|
in a |try| block and catching |bad_alloc|.

\initials{LDF 2005.03.10.}
Now trying to allocate memory for 
|Pointer_Vector<Color> p->draw_color_vector|,
if |draw_color_vector != 0|.  Otherwise, it's set to 0.
It's assigned to below.

\initials{LDF 2005.03.15.}
Now setting |p->draw_color_vector| to the |ddraw_color_vector| 
argument.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.

\initials{LDF 2005.03.18.}
Changed the following code to account for the fact that I've removed |Pen* Path::pen| and
am now using |Pointer_Vector<Pen>* Shape::pen_vector| instead.
\ENDLOG 

@<Define |Path| functions@>=

   Path* p;

   try
      {

          p = static_cast<Path*>(get_copy());

if (ppen_vector != static_cast<Pointer_Vector<Pen>*>(0))
             {
                 p->pen_vector = new Pointer_Vector<Pen>;
                 *(p->pen_vector) = *ppen_vector;
             }

          else
            p->pen_vector = 0;

          if (ddash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
             {
                 p->dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
                 *(p->dash_pattern_vector) = *ddash_pattern_vector;
             }

          else
            p->dash_pattern_vector = 0;

      }  /* |try|  */

   catch (bad_alloc)
      {
          cerr_strm << thread_name << "ERROR!  In `Path::draw':"
                    << endl 
                    << "`Path::get_copy', `new Pointer_Vector<Color>', "
                    << "`create_new<Color>', "
                    << "`new Pointer_Vector<Dash_Pattern>',"
                    << endl 
                    << "or `new Pointer_Vector<Pen>' failed, "
                    << "throwing `bad_alloc'.  "
                    << "Rethrowing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          throw;

      }  /* |catch (bad_alloc)|  */

@q ****** (6).@> 
@
\LOG
\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now allocating memory for |p->draw_color_vector| 
and copying |ddraw_color_vector| to it, if the latter is non-null.
Previously, it was simply set to |ddraw_color_vector|, which caused 
a segmentation fault error.
\ENDLOG 

@<Define |Path| functions@>=

    if (ddraw_color_vector)
       {
           p->draw_color_vector = new Pointer_Vector<Color>;
           *p->draw_color_vector = *ddraw_color_vector;
       }

    p->fill_draw_value = DRAW_VALUE;
    p->arrow = aarrow;

    p->fill_color_vector = 0;

@q ***** (5) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
       {
           cerr_strm << thread_name << "ERROR!  In `Path::draw':"
                     << "`Picture::lock' failed.  "
                     << "Exiting function with return value 1.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
        cerr_strm << thread_name << "In `Path::draw':  "
                  << "`Picture::lock' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q ***** (5) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

  picture += static_cast<Shape*>(p);  

@q ***** (5) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
       {
           cerr_strm << thread_name << "ERROR!  In `Path::draw':"
                     << "`Picture::unlock' failed. "
                     << "Exiting function with return value 1.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

           return 1;
       }
#if DEBUG_COMPILE
  else if (DEBUG)
     {
      
         cerr_strm << thread_name << "In `Path::draw':  "
                   << "`Picture::unlock' succeeded.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q ***** (5) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "Exiting `Path::draw'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;

} /* End of |Path::draw| definition.  */

@q *** (3) Point versions.@>
@*2 {\bf Point} versions.  
@^\cfunc{Point}{draw}@>

Declared in \filename{points.web}, but must be
defined here, because |Path| is an incomplete type here.
\initials{LDF Undated.}

Unlike the |Path| versions of |draw|, this function
returns a |Path|.  This can be useful, if you want to use the |Path|
that it creates again for something else. 
\initials{LDF 2002.11.03.}  

\LOG
\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| to 
|const Dash_Pattern* ddash_pattern|.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
Added "preliminaries" for making debugging and error output
thread-safe.  Now allocating memory for a |Pointer_Vector<Color>|, 
appending a pointer to a copy of the |Color| pointed to by the 
|ddraw_color| argument to it, passing a pointer to it to |Path::draw|, 
and subsequently deleting the pointer.

\initials{LDF 2005.03.18.}
Now allocating memory for a |Pointer_Vector<Pen>|, 
appending a pointer to a copy of the |Pen| pointed to by the 
|ppen| argument to it, passing a pointer to it to |Path::draw|, 
and subsequently deleting the pointer.

\initials{LDF 2005.03.18.}
Now allocating memory for a |Pointer_Vector<Dash_Pattern>|, 
appending a pointer to a copy of the |Dash_Pattern| pointed to by the 
|ddash_pattern| argument to it, passing a pointer to it to |Path::draw|, 
and subsequently deleting the pointer.
\ENDLOG 

@q **** (4) Definition.@>   

@<Define |Point| functions@>=
Path
Point::draw(Picture& picture,
            const Point& p,
            const Color* ddraw_color, 
            const Dash_Pattern* ddash_pattern,
            const Pen* ppen, 
            unsigned short aarrow,
            Scanner_Node scanner_node) const
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

   Path q(*this, p);

   Pointer_Vector<Color>* pv;

   try 
      {
         pv = new Pointer_Vector<Color>;
      }
   catch (bad_alloc)
      {
          cerr_strm << thread_name << "ERROR!  In `Point:.draw':"
                    << endl 
                    << "`new Pointer_Vector<Color>' failed, throwing `bad_alloc'.  "          
                    << "Rethrowing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
  
          throw;

      }  /* |catch (bad_alloc)|  */ 

   pv->append_copy(ddraw_color);

   Pointer_Vector<Pen>* ppen_vector = 0; 

   if (ppen != static_cast<Pen*>(0))
      {
         ppen_vector = new Pointer_Vector<Pen>;
         ppen_vector->append_copy(ppen);
      }

   Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0;

   if (ddash_pattern != static_cast<Dash_Pattern*>(0))
      {
         ddash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
         ddash_pattern_vector->append_copy(ddash_pattern);
      }

   q.draw(picture, pv, ddash_pattern_vector, ppen_vector, aarrow);

   delete pv;
   delete ppen_vector;

   return q;

}  /* End of |Point::draw| definition.  */

@q ** (2) Draw arrow.@>
@*1 Draw arrow.

@q *** (3) Path versions.@>
@*2 {\bf Path} versions.
@^\cfunc{Path}{drawarrow}@>

\LOG
\initials{LDF 2003.01.15.}  
Added this function.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.03.}  Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  Changed |string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  
Now returning the return value of |draw|, whose return value 
I've also changed to |int| today.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
int
drawarrow(Picture& picture,
          Pointer_Vector<Color>* ddraw_color_vector = 0,
          Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
          Pointer_Vector<Pen>* ppen_vector = 0) const;

@
@<Define |Path| functions@>=
int
Path::drawarrow(Picture& picture,
                Pointer_Vector<Color>* ddraw_color_vector,
                Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                Pointer_Vector<Pen>* ppen_vector) const
{
    return draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector, SINGLE_ARROW);
}

@q *** (3) Point versions.@>
@*2 {\bf Point} versions.
@^\cfunc{Point}{drawarrow}@>

\LOG
\initials{LDF 2003.01.15.}  
Added this function.

\initials{LDF 2003.06.03.}  
Made |drawarrow| |const|.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| to 
|const Dash_Pattern* ddash_pattern|.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
Now simply calling |Point::draw| with |Path::SINGLE_ARROW| as the 
|unsigned short arrow| argument and returning its return value. 
\ENDLOG 

@<Define |Point| functions@>=
Path
Point::drawarrow(Picture& picture,
                 const Point& p,
                 const Color* ddraw_color, 
                 const Dash_Pattern* ddash_pattern,
                 const Pen* ppen,
                 Scanner_Node scanner_node) const
{
   return draw(picture, p, ddraw_color, ddash_pattern, ppen, 
               Path::SINGLE_ARROW, scanner_node);
}

@q ** (2) Draw double arrow.@>
@*1 Draw double arrow.
\initials{LDF Undated.}

@q *** (3) Path versions.@>
@*2 {\bf Path} versions.
@^\cfunc{Path}{drawdblarrow}@>
\initials{LDF 2004.11.07.}

\LOG
\initials{LDF 2004.11.07.}
Added this function.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
int
drawdblarrow(Picture& picture,
             Pointer_Vector<Color>* ddraw_color_vector = 0,
             Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
             Pointer_Vector<Pen>* ppen_vector = 0) const;

@
@<Define |Path| functions@>=
int
Path::drawdblarrow(Picture& picture,
                   Pointer_Vector<Color>* ddraw_color_vector,
                   Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                   Pointer_Vector<Pen>* ppen_vector) const
{
     return draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector, DOUBLE_ARROW);
}

@q *** (3) Point versions.@>
@*2 {\bf Point} versions.
@^\cfunc{Point}{drawdblarrow}@>
\initials{LDF 2004.11.07.}

\LOG
\initials{LDF 2004.11.07.}
Added this function.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.
Now simply calling |Point::draw| with |Path::SINGLE_ARROW| or 
|Path::DOUBLE_ARROW| as the 
|unsigned short arrow| argument and returning its return value. 
\ENDLOG 

@<Define |Point| functions@>=
Path
Point::drawdblarrow(Picture& picture,
                    const Point& p,
                    const Color* ddraw_color, 
                    const Dash_Pattern* ddash_pattern,
                    const Pen* ppen,
                    Scanner_Node scanner_node) const
{

   return draw(picture, p, ddraw_color, ddash_pattern, ppen, Path::DOUBLE_ARROW, scanner_node);
}

@q ** (2) Fill.@>
@*1 Fill.
@^\cfunc{Path}{fill}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.09.27.}  
Added error handling code for the case
that the |Path| is empty, in which case it's not filled.

\initials{LDF 2002.10.07.}  
Added code for handling  and |fill_color|.  

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  
Changed |const Color& ffill_color| 
to |const Color* ffill_color|.

\initials{LDF 2004.06.03.}  
Changed default for |ffill_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Now setting |p->dash_pattern = 0| rather than 
|p->dashed = ""| and |p->draw_color = 0| rather than 
|p->draw_color = Colors::background_color|.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2004.06.30.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory for |p->fill_color| if |ffill_color != 0|.
Otherwise it's set to 0.  

\initials{LDF 2005.03.15.}
Changed the argument |const Color* ffill_color| to |Color* ffill_color|.  
Now setting |p->fill_color| to |ffill_color| directly rather 
than allocating memory and copying it.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.

\initials{LDF 2005.03.18.}
Now setting |pen_vector| and |dash_pattern_vector| to 0.  Formerly, I set
|pen| and |dash_pattern| to 0, but I've removed them.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
int
fill(Picture& picture,
     Color* ffill_color = 0) const;

@q *** (3) Definition.@>
@
@<Define |Path| functions@>=

int
Path::fill(Picture& picture, Color* ffill_color) const
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ 
  if (DEBUG) 
    cerr << "Entering Path::fill().\n";
#endif /* |DEBUG_COMPILE|  */@; 
  
  if (points.size() == 0)    
    {
      cerr << "WARNING! In Path::fill():\n"
        << "Path doesn't contain any Points.\n"
        << "Not adding `Path' to `Picture', returning 1, "
        << "and will try to continue.\n\n";
      return 1;
    }

  Path* p = static_cast<Path*>(get_copy());

  p->fill_draw_value = FILL_VALUE;

  if (ffill_color)
     p->push_fill_color(ffill_color, false);

  p->pen_vector = 0;

  p->dash_pattern_vector = 0;

@q **** (4) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::fill':"
             << "`Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

  picture += static_cast<Shape*>(p);

@q **** (4) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::fill':"
             << "`Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    cerr << "Exiting Path::fill().\n";
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;
}

@q ** (2) Filldraw.@>
@*1 Filldraw.
@^\cfunc{Path}{filldraw}@>
\initials{LDF Undated.}

At the present time, |filldraw| differs from the
{\bf filldraw} command in \MF/ and \MP/:
In the default case, the outline is drawn
in the default color (currently black) and the |Path| is filled with
the background color (currently white by default).  This makes it
possible to hide objects that are behind the 
|Path| by using the painter's algorithm when rendering.  If you want a
|Path| to be filled with another color, you will have to use explicit
arguments for |ddraw_color| and |ffill_color|.  Either or both of
these can be |""|, which causes the default color (currently black) to
be used.  Of course, plain |fill| followed by plain |draw| will
produce the same result.
\initials{LDF 2002.03.25 and 2002.11.03.}

\LOG
\initials{LDF 2002.09.27.}  
Added error handling code for the case
that the |Path| is empty, in which case it's not filldrawn.

\initials{LDF 2002.10.07.}  
Added code for handling |draw_color| and |fill_color|.

\initials{LDF 2003.07.16.}  
Made both versions |const|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const Color& ddraw_color| to |const Color* ddraw_color|,
|const Color& ffill_color| to |const Color* ffill_color|, and
|const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |string ddashed = ""| to |const Dash_Pattern* ddash_pattern = 0|, 
and changed the code in this function 
accordingly.

\initials{LDF 2004.06.03.}  
Changed default for |ffill_color| from
|Colors::background_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2004.06.30.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory for |p->draw_color| if |ddraw_color != 0|.  Otherwise
it's set to 0.  
Also, now only allocating memory for |p->fill_color| if |ffill_color != 0|.  Otherwise
it's set to 0.  

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.
Now setting |p->draw_color_vector| to |ddraw_color_vector|.

\initials{LDF 2005.03.15.}
Changed the argument |const Color* ffill_color| to |Color* ffill_color|.  
Now setting |p->fill_color| to |ffill_color| directly rather 
than allocating memory and copying it.

\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now allocating memory for |p->draw_color_vector| 
and copying |ddraw_color_vector| to it, if the latter is non-null.
Previously, it was simply set to |ddraw_color_vector|, which caused 
a segmentation fault error.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
int
filldraw(Picture& picture,
         Pointer_Vector<Color>* ddraw_color_vector = 0,
         Color* ffill_color = 0,
         Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
         Pointer_Vector<Pen>* ppen_vector = 0) const;

@q *** (3) Definition.@>
@
@<Define |Path| functions@>=
int
Path::filldraw(Picture& picture,
               Pointer_Vector<Color>* ddraw_color_vector,
               Color* ffill_color,
               Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
               Pointer_Vector<Pen>* ppen_vector) const
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path::filldraw().\n";
#endif /* |DEBUG_COMPILE|  */@; 

  if (points.size() == 0)  
    {
      cerr << "WARNING! In Path::filldraw():\n"
        << "Path doesn't contain any Points.\n"
        << "Not adding `Path' to `Picture', returning 1, "
        << "and will try to continue.\n\n";
      return 1;
    }

  Path* p = static_cast<Path*>(get_copy());
    
  p->fill_draw_value = FILLDRAW_VALUE;

  if (ddraw_color_vector)
     {
         p->draw_color_vector = new Pointer_Vector<Color>;
         *p->draw_color_vector = *ddraw_color_vector;
     }

  if (ffill_color)
     p->push_fill_color(ffill_color, false);

  if (ppen_vector != static_cast<Pointer_Vector<Pen>*>(0))
    {
      p->pen_vector = new Pointer_Vector<Pen>;
      *(p->pen_vector) = *ppen_vector;
    }
  else
    p->pen_vector = 0;

  if (ddash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
    {
      p->dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
      *(p->dash_pattern_vector) = *ddash_pattern_vector;
    }
  else
    p->dash_pattern_vector = 0;

@q **** (4) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::filldraw':"
             << "`Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

  picture += static_cast<Shape*>(p);

@q **** (4) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::filldraw':"
             << "`Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE

  if (DEBUG)
    cerr << "Exiting Path::filldraw().\n";

#endif /* |DEBUG_COMPILE|  */@; 

  return 0;
}

@q ** (2) Undraw.@>
@*1 Undraw.
\initials{LDF Undated.}

@q *** (3) Path versions.@>
@*2 {\bf Path} versions.
@^\cfunc{Path}{undraw}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.09.27.}  
Added error handling code for the case
that the |Path| is empty, in which case it's not undrawn.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  
Changed |const string ppen| to |const Pen* ppen|. 

\initials{LDF 2004.06.07.}  
Changed |string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|, and changed the code in this function 
accordingly.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Path| functions@>=
int
undraw(Picture& picture, 
       Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
       Pointer_Vector<Pen>* ppen_vector = 0);

@q **** (4) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::undraw(Picture& picture, 
             Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
             Pointer_Vector<Pen>* ppen_vector)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  if (points.size() == 0)  
    {
      cerr << "WARNING! In Path::undraw():\n"
           << "Path doesn't contain any Points.\n"
           << "Not adding `Path' to `Picture', returning 1, "
           << "and will try to continue.\n\n";
      return 1;
    }

    Path* p = static_cast<Path*>(get_copy());
    
    p->fill_draw_value = UNDRAW_VALUE;

    p->draw_color_vector = 0;
    p->fill_color_vector = 0;

    if (ppen_vector != static_cast<Pointer_Vector<Pen>*>(0))
       { 
           p->pen_vector = new Pointer_Vector<Pen>;
           *(p->pen_vector) = *ppen_vector;
       }
    else
       p->pen_vector = 0;

    if (ddash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
       { 
           p->dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
           *(p->dash_pattern_vector) = *dash_pattern_vector;
       }
    else
       p->dash_pattern_vector = 0;

@q ***** (5) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::undraw':"
             << "`Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q ***** (5) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

    picture += static_cast<Shape*>(p);

@q ***** (5) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::undraw':"
             << "`Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q ***** (5) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

  return 0;

} /* End of |Path::undraw| definition.  */

@q *** (3) Point versions.@>
@*2 {\bf Point} versions.
@^\cfunc{Point}{undraw}@>
\initials{LDF Undated.}

This function is declared in \filename{points.web}, but must be
defined here, because |Path| is an incomplete type here.
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.4.8.} 
Added this function.

\initials{LDF 2002.11.03.}  
Changed this function, so that it returns the |Path pa|, instead of |void|.  

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  
Changed |const string ppen| to |const Pen* ppen|. 

\initials{LDF 2004.06.07.}  Changed |string ddashed| to 
|const Dash_Pattern* ddash_pattern|.

\initials{LDF 2005.03.15.}
Added the optional |Scanner_Node scanner_node| argument, with default 0.

\initials{LDF 2005.03.18.}
Now allocating memory for a |Pointer_Vector<Pen>|, 
appending a pointer to a copy of the |Pen| pointed to by the 
|ppen| argument to it, passing a pointer to it to |Path::draw|, 
and subsequently deleting the pointer.

\initials{LDF 2005.03.18.}
Now allocating memory for a |Pointer_Vector<Dash_Pattern>|, 
appending a pointer to a copy of the |Dash_Pattern| pointed to by the 
|ddash_pattern| argument to it, passing a pointer to it to |Path::draw|, 
and subsequently deleting the pointer.
\ENDLOG 

@<Define |Point| functions@>=
Path
Point::undraw(Picture& picture,
              const Point& pt,
              const Dash_Pattern* ddash_pattern,
              const Pen* ppen, 
              Scanner_Node scanner_node)
{
  Path pa(*this, pt);

  Pointer_Vector<Pen>* ppen_vector = 0;

  if (ppen != static_cast<Pen*>(0))
     {
        ppen_vector = new Pointer_Vector<Pen>;
        ppen_vector->append_copy(ppen);
     }

  Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0;

  if (ddash_pattern != static_cast<Dash_Pattern*>(0))
     {
        ddash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
        ddash_pattern_vector->append_copy(ddash_pattern);
     }

pa.undraw(picture, ddash_pattern_vector, ppen_vector);

  delete ppen_vector;
  delete ddash_pattern_vector;
 
  return pa;
}

@q ** (2) Unfill.@>
@*1 Unfill.
@^\cfunc{Path}{unfill}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.05.25.}  
Removed the default for 
|Picture& picture|, which was formerly |current_picture|. 

\initials{LDF 2004.06.07.}  
Now setting |p->dash_pattern = 0| rather than 
|p->dash_pattern = 0|.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.
\ENDLOG 

@q *** Declaration.@> 

@<Declare |Path| functions@>=
int
unfill(Picture& picture);

@q *** Definition.@> 

@
@<Define |Path| functions@>=
int
Path::unfill(Picture& picture)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  if (points.size() == 0)  /* LDF 2002.09.27.  Added this error
                              handling code.  If the |Path|
                              is empty, don't unfill it.  */ 
    {
      cerr << "WARNING! In Path::unfill():\n"
        << "Path doesn't contain any Points.\n"
        << "Not adding `Path' to `Picture', returning 1, "
        << "and will try to continue.\n\n";
      return 1;
    }

    Path* p = static_cast<Path*>(get_copy());

    p->fill_draw_value = UNFILL_VALUE;

    p->draw_color_vector = 0;
    p->fill_color_vector = 0;

    p->dash_pattern_vector = 0; 
    p->pen_vector = 0;

@q **** (4) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::unfill':"
             << "`Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

    picture += static_cast<Shape*>(p);

@q **** (4) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::unfill':"
             << "`Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=
  
  return 0;

}

@q ** (2) Unfilldraw.@>
@*1 Unfilldraw.
@^\cfunc{Path}{unfilldraw}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.09.27.}  
Added error handling code for the case
that the |Path| is empty, in which case it's not unfilldrawn.

\initials{LDF 2002.10.07.}
Added code for handling
|draw_color| and |fill_color|.  Will get rid of this if I do
actually change it to make it act more like {\bf unfilldraw} in 
\MP/.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const Color& ddraw_color| to |const Color* ddraw_color| and 
|const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |const string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|, and changed the code in this function 
accordingly.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::background_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.24.}
Changed return value from |void| to |int|.  Now trying to lock and unlock
|picture.mutex|, if |HAVE_PTHREAD_H| is defined.

\initials{LDF 2004.06.30.}
@:BUG FIX@> BUG FIX: 
Now only allocating memory for |p->draw_color| if |ddraw_color != 0|.  Otherwise
it's set to 0.  

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.
Now setting |p->draw_color_vector| to |ddraw_color_vector|.

\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now allocating memory for |p->draw_color_vector| 
and copying |ddraw_color_vector| to it, if the latter is non-null.
Previously, it was simply set to |ddraw_color_vector|, which caused 
a segmentation fault error.

\initials{LDF 2005.03.18.}
Now calling |get_copy| rather than |create_new<Path>|.
This causes the copy to have the same type as |*this|, which 
was not the case before.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
int
unfilldraw(Picture& picture,
           Pointer_Vector<Color>* ddraw_color_vector = 0,
           Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
           Pointer_Vector<Pen>* ppen_vector = 0);

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
int
Path::unfilldraw(Picture& picture,
                 Pointer_Vector<Color>* ddraw_color_vector,
                 Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                 Pointer_Vector<Pen>* ppen_vector)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ 
  if (DEBUG)
    cerr << "Entering Path::unfilldraw().\n";
#endif /* |DEBUG_COMPILE|  */@; 

  if (points.size() == 0)  
    {
      cerr << "WARNING! In Path::unfilldraw():\n"
           << "Path doesn't contain any Points.\n"
           << "Not adding `Path' to `Picture', returning 1, "
           << "and will try to continue.\n\n";
      return 1;
    }

  Path* p = static_cast<Path*>(get_copy());

  p->fill_draw_value = UNFILLDRAW_VALUE;

  if (ddraw_color_vector)
     {
         p->draw_color_vector = new Pointer_Vector<Color>;
         *p->draw_color_vector = *ddraw_color_vector;
     }

  p->fill_color_vector = 0;

  if (ppen_vector != static_cast<Pointer_Vector<Pen>*>(0))
     {
         p->pen_vector = new Pointer_Vector<Pen>;
         *(p->pen_vector) = *ppen_vector;
     }
  else
    p->pen_vector = 0;

  if (ddash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
     {
         p->dash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
         *(p->dash_pattern_vector) = *ddash_pattern_vector;
     }
  else
    p->dash_pattern_vector = 0;

@q **** (4) Try to lock |picture.mutex|.@>   
@ Try to lock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    int status;
    status = picture.lock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::unfilldraw':"
             << "`Picture::lock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::lock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Add |p| to |picture|.@>   
@ Add |p| to |picture|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

  picture += static_cast<Shape*>(p);

@q **** (4) Try to unlock |picture.mutex|.@>   
@ Try to unlock |picture.mutex|.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#ifdef HAVE_PTHREAD_H 

    status = picture.unlock();

    if (status != 0)
      {
        cerr << "ERROR! In `Path::unfilldraw':"
             << "`Picture::unlock' failed. "
             << "Returning 1 and will try to continue."
             << endl;
        return 1;
      }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      
      cerr << "`Picture::unlock' succeeded."
           << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Exit function successfully.@>   
@ Exit function successfully.
\initials{LDF 2004.06.24.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
  if (DEBUG) 
    cerr << "Exiting Path::unfilldraw().\n";
#endif /* |DEBUG_COMPILE|  */@;   

  return 0;
}

@q * (1) Labelling.@>
@* Labelling.

@q ** (2) Label.@>
@*1 Label.
@^\cfunc{Path}{label}@>

\LOG
\initials{LDF 2002.03.25.}  
Added argument |dot| and changed definition of |dotlabel|
below so that it just calls |label|.  

\initials{LDF 2003.04.01.}  
@:BUG FIX@> BUG FIX: 
Got rid of the first argument
|unsigned int i|, and made the third argument |short text_short| the
first argument.  Formerly, the |Points| in |Paths| were
always numbered starting from 0, because the argument |text_short| was
passed to |Point::label|, not |i|.  Also changed the following
versions of |label| and |dotlabel|, that call this function.

\initials{LDF 2003.05.06.}  
Changed the conditional, where |text_short| is
compared with |WORLD_VALUES|,\newline
|PROJ_VALUES|, etc.  I had to
change it, 
because I've added |WORLD_VALUES_X_Y|, etc.  Now, the conditional
tests for |VIEW_VALUES_X_Y@t$\le$@>text_short@t$\le$@>WORLD_VALUES|.
Of course, this makes an assumption about the values that are used to
signal that coordinate values should be used for the label, but I
think it's worth it, to avoid testing |text_short| against each
value individually. 

\initials{LDF 2003.07.09.}  
Made |position_string| and |dot| arguments |const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.10.08.}
Started revising this function.

\initials{LDF 2004.10.09.}
Replaced |const text_short| argument with |const string prefix| and 
|unsigned short counter|.  Changed default of 
|const string position_string| from |"top"| to |""|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to |Point::label|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
void
label(Picture& picture,
      const string prefix = "",
      unsigned short counter = 0,
      const string position_string = "",
      Color* ttext_color = 0,
      Color* ddot_color = 0,
      const bool dot = false,
      Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
void
Path::label(Picture& picture,
            string prefix,
            unsigned short counter,
            const string position_string,
            Color* ttext_color,
            Color* ddot_color,
            const bool dot,
            Scanner_Node scanner_node) const
{

@q **** (4) Preliminaries.@>

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "Entering 'Path::label'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 
 
  if (Label::DO_LABELS == false)
    return;

@q **** (4) Error handling: |points.size() == 0|.@>   
@ Error handling: |points.size() == 0|.
\initials{LDF 2002.09.27.} 

\LOG
\initials{LDF 2002.09.27.} 
Added this section.  
\ENDLOG 

@<Define |Path| functions@>=

  if (points.size() == 0)  
    {
      cerr_strm << thread_name << "WARNING! In 'Path::label':\n"
        << "Path doesn't contain any Points." << endl 
        << "Not doing anything.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, warning_stop_value);
      cerr_strm.str("");
      return;

    } /* |if (points.size() == 0)|  */

@q **** (4) Iterate through |points| and label the |Points|.@>   

@ Iterate through |points| and label the |Points|.
\initials{LDF 2004.10.09.}

\LOG
\initials{LDF 2005.08.14.}
Now passing 0 as the |Transform*| argument to |Point::label|.
\ENDLOG 

@<Define |Path| functions@>=

  stringstream label_strm;

  for(vector<Point*>::const_iterator iter = points.begin();
      iter != points.end();
      iter++)
      {

        if (prefix != "")
          label_strm << "$" << prefix << "_{" << counter << "}$";

        else 
          label_strm << counter;

        (**iter).label(picture, label_strm.str(), position_string, 0, 
                       ttext_color, ddot_color, dot);

        counter++;
        label_strm.str("");

      } /* |for|  */

@q **** (4) Exit function successfully with no return value..@>   

@ Exit function successfully with no return value.
\initials{LDF 2004.10.09.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Exiting `Path::label'.";
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   return;

} /* End of |Path::label| definition.  */

@q ** (2) Dotlabel.@>
@*1 Dotlabel.
@^\cfunc{Path}{dotlabel}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.07.09.}  
Made |text_short| and |position_string| arguments
|const|. 

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.10.09.}
Made this function inline.  Replaced the |const short text_short|
argument with the arguments |const string prefix| 
and |unsigned short counter|.  Added the argument 
|Scanner_Node scanner_node|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to 
|Point::label|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
inline
void
dotlabel(Picture& picture,
         const string prefix = "",
         unsigned short counter = 0,
         const string position_string = "top",
         Color* ttext_color = 0,
         Color* ddot_color = 0,
         Scanner_Node scanner_node = 0) const
{
  label(picture, prefix, counter, position_string, 
        ttext_color, ddot_color, true, scanner_node);
}

@q * (1) Outputting.@>
@* Outputting.

@q ** (2) Extract.@>
@*1 Extract.  
@^\cfunc{Path}{extract}@>
\initials{LDF Undated.}

This function is needed for outputting a |Picture|.
\initials{LDF Undated.}

\initials{LDF 2003.01.31.} 
?? @:??@> Do I need to call |Point::project| on the
|Points| here and in |Path::project|?

\LOG
\initials{LDF 2002.09.17.}  
Added |const Focus& f| argument and error handling
code.  Now, if any of the |Points| on |vector <Point*> points| cannot
be projected onto the projection plane using the |Focus f|, the |Path|
is not put onto the |vector <Shape*>| |Picture::elements|, and
consequently never reaches |Picture::output| and |Path::output|. 

\initials{LDF 2003.05.09.}  
Rewrote this function.  It now calls
|Point::extract| instead of calling |apply_transform| and
|project| on the |Points| directly.  This makes much more sense,
since any changes to |Point::extract| would otherwise not have been
applied to |Points| on |Paths|.  
\ENDLOG 

@<Declare |Path| functions@>=
vector<Shape*>
extract(const Focus& f, const unsigned short proj,
                 real factor);

@
@<Define |Path| functions@>=
vector<Shape*>
Path::extract(const Focus& f, const unsigned short proj, real factor)
{
  bool DEBUG = false; /* |true| */

  vector<Shape*> v;

  int i = 0;
  for(vector <Point*>::iterator iter = points.begin();
      iter != points.end();
      iter++)
    {
      if (DEBUG)
        cerr << "Point " << i++ << ":" << endl;
      v = (**iter).extract(f, proj, factor);
      if (DEBUG)
        cerr << endl;

      if (v.size() == 0) /* |Point::extract| failed. 
                             LDF 2003.05.09.  */
        return v;                   
    }
  vector<Shape*> r;
  r.push_back(this);
  return r;
}

@q ** (2) Set world extremes.@> 
@*1 Set world extremes.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.04.04.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=

virtual 
bool 
set_world_extremes(Scanner_Node scanner_node = 0);

@
@<Define |Path| functions@>=

bool 
Path::set_world_extremes(Scanner_Node scanner_node)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Entering `Path::set_world_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   

@ If there are no |Points| on the |Path|, set all the elements of
|world_extremes| to |INVALID_REAL| and return |false|. 
\initials{LDF 2005.04.04.}

@<Define |Path| functions@>=

  if (points.size() <= 0)
    {
      cerr_strm << thread_name << "ERROR!  In `Path::set_world_extremes':"
                << endl 
                << "points.size() <= 0. "
                << "Setting extremes to INVALID_REAL and exiting function with return "
                << "value `false'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
    
      world_extremes = INVALID_REAL;

      return false;

    }

@q **** (4) @>   
@ 
@<Define |Path| functions@>=

   world_extremes[0] = MAX_REAL; /* Minima.  */
   world_extremes[2] = MAX_REAL; 
   world_extremes[4] = MAX_REAL; 

   world_extremes[1] = -MAX_REAL; /* Maxima.  */
   world_extremes[3] = -MAX_REAL; 
   world_extremes[5] = -MAX_REAL; 

   for (vector <Point*>::iterator iter = points.begin();
        iter != points.end(); ++iter)
     {

       world_extremes[0] = min(world_extremes[0],
                                     (**iter).get_x('w', false, false)); /* Min x */
       world_extremes[2] = min(world_extremes[2],                       
                                     (**iter).get_y('w', false, false)); /* Min y */
       world_extremes[4] = min(world_extremes[4],                       
                                     (**iter).get_z('w', false, false)); /* Min z */

       world_extremes[1] = max(world_extremes[1],
                                     (**iter).get_x('w', false, false)); /* Max x */

       world_extremes[3] = max(world_extremes[3],
                                     (**iter).get_y('w', false, false)); /* Max y */

       world_extremes[5] = max(world_extremes[5],                       
                                     (**iter).get_z('w', false, false)); /* Max z */
     }

@q **** (4) @>   
@ 
@<Define |Path| functions@>=

   for (int i = 0; i < 6; i += 2)
     {
       if (world_extremes[i] == MAX_REAL /* Minima */
           || world_extremes[i + 1] == -MAX_REAL) /* Maxima */
         {

           cerr_strm << thread_name << "ERROR!  In `Path::set_world_extremes':\n"
                     << "maxima and minima could not be set properly. "
                     << "Setting them all to INVALID_REAL and returning false."; 

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           world_extremes = INVALID_REAL;
           return false;
           break;
         }
     }

#if DEBUG_COMPILE
   if (DEBUG)
     {

         cerr << "In `Path::set_world_extremes':" << endl;

         for (int i = 0; i < 6; ++i)
            { 
               cerr << "world_extremes[" << i << "] == " 
                    << world_extremes[i] << endl;

            }

         cerr_strm << thread_name << "Exiting `Path::set_world_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
  return true;

}  /* End of |Path::set_world_extremes| definition.  */

@q ** (2) Set pre-projective extremes.@>
@*1 Set pre-projective extremes.
@^\cfunc{Path}{set\_pre\_projective\_extremes}@>
\initials{LDF 2005.06.30.}

\LOG
\initials{LDF 2005.06.30.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
bool
set_pre_projective_extremes(Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::set_pre_projective_extremes(Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Entering `Path::set_pre_projective_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@ If there are no |Points| on the |Path|, set all the elements of
|pre_projective_extremes| to |INVALID_REAL| and return |false|. 
\initials{LDF 2005.06.30.}

@<Define |Path| functions@>=

  if (points.size() <= 0)
    {
      cerr_strm << thread_name << "ERROR!  In `Path::set_pre_projective_extremes':"
                << endl 
                << "points.size() <= 0. "
                << "Setting extremes to INVALID_REAL and returning.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
    
      pre_projective_extremes = INVALID_REAL;

      return false;

    }

@ 
@<Define |Path| functions@>=

   pre_projective_extremes[0] = MAX_REAL; /* Minima.  */
   pre_projective_extremes[2] = MAX_REAL; 
   pre_projective_extremes[4] = MAX_REAL; 

   pre_projective_extremes[1] = -MAX_REAL; /* Maxima.  */
   pre_projective_extremes[3] = -MAX_REAL; 
   pre_projective_extremes[5] = -MAX_REAL; 

   for (vector <Point*>::iterator iter = points.begin();
        iter != points.end(); ++iter)
     {

       pre_projective_extremes[0] = min(pre_projective_extremes[0],
                                     (**iter).get_x('p', false, false)); /* Min x */
       pre_projective_extremes[2] = min(pre_projective_extremes[2],                       
                                     (**iter).get_y('p', false, false)); /* Min y */
       pre_projective_extremes[4] = min(pre_projective_extremes[4],                       
                                     (**iter).get_z('p', false, false)); /* Min z */

       pre_projective_extremes[1] = max(pre_projective_extremes[1],
                                     (**iter).get_x('p', false, false)); /* Max x */

       pre_projective_extremes[3] = max(pre_projective_extremes[3],
                                     (**iter).get_y('p', false, false)); /* Max y */

       pre_projective_extremes[5] = max(pre_projective_extremes[5],                       
                                     (**iter).get_z('p', false, false)); /* Max z */
     }

@ 
@<Define |Path| functions@>=

   for (int i = 0; i < 6; i += 2)
     {
       if (pre_projective_extremes[i] == MAX_REAL /* Minima */
           || pre_projective_extremes[i + 1] == -MAX_REAL) /* Maxima */
         {

           cerr_strm << thread_name 
                     << "ERROR!  In `Path::set_pre_projective_extremes':"
                     << endl 
                     << "maxima and minima could not be set properly. "
                     << "Setting them all to INVALID_REAL and returning false."; 

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           pre_projective_extremes = INVALID_REAL;
           return false;
           break;
         }
     }

#if DEBUG_COMPILE
   if (DEBUG)
     {

         cerr << "In `Path::set_pre_projective_extremes':" << endl;

         for (int i = 0; i < 6; ++i)
            { 
               cerr << "pre_projective_extremes[" << i << "] == " 
                    << pre_projective_extremes[i] << endl;

            }

         cerr_strm << thread_name << "Exiting `Path::set_pre_projective_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
  return true;

}  /* End of |Path::set_pre_projective_extremes| definition.  */

@q ** (2) Set projective extremes.@>
@*1 Set projective extremes.
@^\cfunc{Path}{set\_projective\_extremes}@>
\initials{LDF 2002.09.17.}  

\initials{LDF 2002.09.18.}  
|set_projective_extremes| doesn't check that the 
|projective_coordinates|
in all of the |Points| on the |Path| are valid.  This is
done already in |project| and |extract|, 
so I don't think it's
necessary to repeat it here, since |extract| 
(which invokes 
|project|), is called before |set_projective_extremes| 
in |Picture::output|. 
The latter is the only place where |set_projective_extremes| is invoked. 
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2005.03.23.}
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.03.23.}
Made debugging and error output thread-safe.

\initials{LDF 2005.04.04.}
Changed the name of this function from |set_extremes| to 
|set_projective_extremes|.  Changed all references to it without comment.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
bool
set_projective_extremes(Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::set_projective_extremes(Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Entering `Path::set_projective_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@ If there are no |Points| on the |Path|, set all the elements of
|projective_extremes| to |INVALID_REAL| and return |false|. 
\initials{LDF 2005.03.23.}

@<Define |Path| functions@>=

  if (points.size() <= 0)
    {
      cerr_strm << thread_name << "ERROR!  In `Path::set_projective_extremes':"
                << endl 
                << "points.size() <= 0. "
                << "Setting extremes to INVALID_REAL and returning.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
    
      projective_extremes = INVALID_REAL;

      return false;

    }

@ \initials{LDF 2002.09.18.}  Added this routine.
Set the {\it minimum\/} values to |MAX_REAL| and the {\it maximum\/}
values to |-MAX_REAL|.  This way, any valid perspective coordinates will
replace them on the first iteration of the |for| loop.

\initials{LDF 2002.09.18.}
I had some difficulty debugging this because 
instead of using |-MAX_REAL|, I defined 
and used |MIN_REAL = numeric_limits <real>::min|.  
However, this isn't the 
negative |real| with the largest magnitude, but the 
smallest positive |real|.

@<Define |Path| functions@>=

   projective_extremes[0] = MAX_REAL; /* Minima.  */
   projective_extremes[2] = MAX_REAL; 
   projective_extremes[4] = MAX_REAL; 

   projective_extremes[1] = -MAX_REAL; /* Maxima.  */
   projective_extremes[3] = -MAX_REAL; 
   projective_extremes[5] = -MAX_REAL; 

   for (vector <Point*>::iterator iter = points.begin();
        iter != points.end(); ++iter)
     {

       projective_extremes[0] = min(projective_extremes[0],
                                     (**iter).get_x('p', false, false)); /* Min x */
       projective_extremes[2] = min(projective_extremes[2],                       
                                     (**iter).get_y('p', false, false)); /* Min y */
       projective_extremes[4] = min(projective_extremes[4],                       
                                     (**iter).get_z('p', false, false)); /* Min z */

       projective_extremes[1] = max(projective_extremes[1],
                                     (**iter).get_x('p', false, false)); /* Max x */

       projective_extremes[3] = max(projective_extremes[3],
                                     (**iter).get_y('p', false, false)); /* Max y */

       projective_extremes[5] = max(projective_extremes[5],                       
                                     (**iter).get_z('p', false, false)); /* Max z */
     }

@ 
\LOG
\initials{LDF 2002.09.18.}  
Added this error handling code.  There is a remote chance that a 
valid |Point| could have a coordinate $\equiv$ |MAX_REAL| or 
|@t$\pm$@>MIN_REAL|, however, 
it is virtually impossible that it would be projectable.  If it's 
the x or y-coordinate,
it would probably lie outside the limits defined for the invocation of 
|Picture::output|, and if it was the |z|, it would either be behind 
the |Focus| or
so far away as to be practically invisible.  I believe that this 
is the case, even though 
the z-coordinates are made smaller by applying the equation 
$z_p = z/(z + p)$.
\ENDLOG 

@<Define |Path| functions@>=

   for (int i = 0; i < 6; i += 2)
     {
       if (projective_extremes[i] == MAX_REAL /* Minima */
           || projective_extremes[i + 1] == -MAX_REAL) /* Maxima */
         {

           cerr_strm << thread_name << "ERROR!  In `Path::set_projective_extremes':\n"
                     << "maxima and minima could not be set properly. "
                     << "Setting them all to INVALID_REAL and returning false."; 

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           projective_extremes = INVALID_REAL;
           return false;
           break;
         }
     }

#if DEBUG_COMPILE
   if (DEBUG)
     {

         cerr << "In `Path::set_projective_extremes':" << endl;

         for (int i = 0; i < 6; ++i)
            { 
               cerr << "projective_extremes[" << i << "] == " 
                    << projective_extremes[i] << endl;

            }

         cerr_strm << thread_name << "Exiting `Path::set_projective_extremes'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
  return true;

}  /* End of |Path::set_projective_extremes| definition.  */

@q ** (2) Enclosing Cuboids Intersect.@>
@*1 Enclosing Cuboids Intersect.
@^\cfunc{Path}{enclosing\_cuboids\_intersect}@>
\initials{LDF 2005.03.23.}

This function returns 0 if the |Path| and the |Shape| 
don't intersect at all, 1 if the objects truly intersect, 
and 2 if they merely touch.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.

\initials{LDF 2005.03.31.}
Changed the name of this function from |enclosing_prisms_intersect|
to |enclosing_cuboids_intersect|.

\initials{LDF 2005.04.01.}
Changed the return type of this function from |unsigned short|
to |Unsigned_Byte|.

\initials{LDF 2005.04.04.}
Now calling |Path::set_world_extremes| and |Path::get_world_extremes| instead of 
|Path::set_projective_extremes| and |Path::get_projective_extremes|.
Added error handling code.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual 
Unsigned_Byte
enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=

Unsigned_Byte
Path::enclosing_cuboids_intersect(Shape* s, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   bool b = set_world_extremes();
  
   if (b == false) 
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Path::enclosing_cuboids_intersect(Shape* s)' "
                    << "(non-const version):"
                    << endl << "`Path::set_world_extremes' failed for `*this', "
                    << "returning `false'."
                    << endl 
                    << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;
                  
      }  /* |if (b == false)|  */

   valarray<real> v(6);   

   v = s->get_world_extremes();

   if (b == false) 
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Path::enclosing_cuboids_intersect(Shape* s)' "
                    << "(non-const version):"
                    << endl << "`Path::set_world_extremes' failed for `*s', "
                    << "returning `false'."
                    << endl 
                    << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;
                  
      }  /* |if (b == false)|  */

   real& min_x   = world_extremes[0];
   real& max_x   = world_extremes[1];
   real& min_y   = world_extremes[2];
   real& max_y   = world_extremes[3];
   real& min_z   = world_extremes[4];
   real& max_z   = world_extremes[5];

   real& s_min_x = v[0];
   real& s_max_x = v[1];
   real& s_min_y = v[2];
   real& s_max_y = v[3];
   real& s_min_z = v[4];
   real& s_max_z = v[5];

   if (   (max_x < s_min_x || min_x > s_max_x)
       && (max_y < s_min_y || min_y > s_max_y)
       && (max_z < s_min_z || min_z > s_max_z))

       return 0;

   real eps = Point::epsilon();

   if (   fabs(max_x - s_min_x) < eps || fabs(min_x - s_max_x) < 0
       || fabs(max_y - s_min_y) < eps || fabs(min_y - s_max_y) < 0
       || fabs(max_z - s_min_z) < eps || fabs(min_z - s_max_z) < 0)

      return 1;       

   else
       return 2;       

}  /* End of |Path::enclosing_cuboids_intersect| definition.  */

@q ** (2) Intersection with |Shape|.@>
@*1 Intersection with |Shape|.
@^\cfunc{Path}{intersection}@>
\initials{LDF 2005.03.23.}

\LOG
\initials{LDF 2005.03.23.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

virtual 
Int_Void_Ptr
intersection(Shape* s, Scanner_Node scanner_node = 0);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=

Int_Void_Ptr
Path::intersection(Shape* s, Scanner_Node scanner_node)
{

   Int_Void_Ptr ivp;

   return ivp;
}

@q * (1) Projections intersect.@>  
@* Projections intersect.
@^\cfunc{Path}{projections\_intersect}@>
\initials{LDF 2005.04.11.}

\LOG
\initials{LDF 2005.04.11.}
Added this function.  Currently, it just returns 0 immediately.
\ENDLOG

@q ** (2) Declaration.@>  

@<Declare |Path| functions@>=
virtual 
Unsigned_Byte
projections_intersect(Shape* s,
                      Scanner_Node scanner_node = 0);

@q ** (2) Definition.@>  

@ 
@<Define |Path| functions@>=
Unsigned_Byte
Path::projections_intersect(Shape* s,
                            Scanner_Node scanner_node)
{
   return 0;
}

@q ** (2) Get world extremes.@> 
@*1 Get world extremes.
\initials{LDF 2005.04.04.}

\LOG
\initials{LDF 2005.04.04.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=

virtual 
inline
const valarray<real>& 
get_world_extremes(void) const
{
   return world_extremes;
}

@q ** (2) Get pre-projective extremes.@>
@*1 Get pre-projective extremes.
@^\cfunc{Path}{get\_pre\_projective\_extremes}@>
\initials{LDF 2005.06.30.}

Any code that calls 
|get_projective_extremes| must ensure that |project| has been 
invoked first.
\initials{LDF 2005.06.30.}

\LOG
\initials{LDF 2005.06.30.}
Added this function.  
\ENDLOG 

@q *** (3) Definition.@> 

@<Declare |Path| functions@>=

virtual
const valarray <real>&
get_pre_projective_extremes() const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=

const valarray <real>&
Path::get_pre_projective_extremes() const
{
#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
        cerr_mutex.lock(); 
        cerr << "In 'Path::get_pre_projective_extremes':" << endl;
        for (int i = 0; i < 6; ++i)
           cerr << "'pre_projective_extremes[" << i << "]' == " 
                << pre_projective_extremes[i] << endl;
        cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return pre_projective_extremes;

}  /* End of |Path::get_pre_projective_extremes| definition.  */

@q ** (2) Get projective extremes.@>
@*1 Get projective extremes.
@^\cfunc{Path}{get\_projective\_extremes}@>
\initials{LDF 2002.09.18.}  

Any code that calls 
|get_projective_extremes| must ensure that |project| has been 
invoked first.
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.18.}  
Added this function.  

\initials{LDF 2005.03.23.}
Made this function non-inline.

\initials{LDF 2005.03.23.}
Changed the return value from |const valarray <real>| to 
|const valarray <real>&|, i.e., I've made it a reference.

\initials{LDF 2005.04.04.}
Changed the name of this function from |get_extremes| to 
|get_projective_extremes|.  Changed all references to it without comment.

\initials{LDF 2005.04.04.}
Added debugging code.
\ENDLOG 

@q *** (3) Definition.@> 

@<Declare |Path| functions@>=

virtual
const valarray <real>&
get_projective_extremes() const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=

const valarray <real>&
Path::get_projective_extremes() const
{
#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
        cerr_mutex.lock(); 
        cerr << "In `Path::get_projective_extremes':" << endl;
        for (int i = 0; i < 6; ++i)
           cerr << "`projective_extremes[" << i << "]' == " 
                << projective_extremes[i] << endl;
        cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return projective_extremes;
}

@q ** (2) Get minimum x.@>
@*1 Get minimum x.
@^\cfunc{Path}{get\_minimum\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
real
get_minimum_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
real
Path::get_minimum_x(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Path::get_minimum_x()" << endl;

  if (DEBUG)
    cerr << "minimum_x == " << projective_extremes[0] << endl;

  if (DEBUG)
    cerr << "Exiting Path::get_minimum_x()" << endl;

  return projective_extremes[0];
}

@q ** (2) Get maximum x.@>
@*1 Get maximum x.
@^\cfunc{Path}{get\_maximum\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=

virtual
real
get_maximum_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
real
Path::get_maximum_x(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Path::get_maximum_x()" << endl;

  if (DEBUG)
    cerr << "maximum_x == " << projective_extremes[1] << endl;

  if (DEBUG)
    cerr << "Exiting Path::get_maximum_x()" << endl;

  return projective_extremes[1];
}

@q ** (2) Get mean x.@>
@*1 Get mean x.
@^\cfunc{Path}{get\_mean\_x}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
virtual
real
get_mean_x(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
real
Path::get_mean_x(const unsigned short s) const
{
  return ((projective_extremes[0] + projective_extremes[1]) / 2);
}

@q ** (2) Get minimum y.@>
@*1 Get minimum y.
@^\cfunc{Path}{get\_minimum\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
real
get_minimum_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
real
Path::get_minimum_y(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Path::get_minimum_y()" << endl;

  if (DEBUG)
    cerr << "minimum_y == " << projective_extremes[2] << endl;

  if (DEBUG)
    cerr << "Exiting Path::get_minimum_y()" << endl;

  return projective_extremes[2];
}

@q ** (2) Get maximum y.@>
@*1 Get maximum y.
@^\cfunc{Path}{get\_maximum\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=

virtual
real
get_maximum_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
real
Path::get_maximum_y(const unsigned short s) const
{
  bool DEBUG = false; /* |true| */
  if (DEBUG)
    cerr << "Entering Path::get_maximum_y()" << endl;

  if (DEBUG)
    cerr << "maximum_y == " << projective_extremes[3] << endl;

  if (DEBUG)
    cerr << "Exiting Path::get_maximum_y()" << endl;

  return projective_extremes[3];
}

@q ** (2) Get mean y.@>
@*1 Get mean y.
@^\cfunc{Path}{get\_mean\_y}@>
\initials{LDF 2005.04.19.}

\LOG
\initials{LDF 2005.04.19.}
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
virtual
real
get_mean_y(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
real
Path::get_mean_y(const unsigned short s) const
{
  return ((projective_extremes[2] + projective_extremes[3]) / 2);
}

@q ** (2) Get minimum z.@>
@*1 Get minimum z.
@^\cfunc{Path}{get\_minimum\_z}@>
\initials{LDF 2003.05.16.}  

\LOG
\initials{LDF 2003.05.16.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 

@<Declare |Path| functions@>=

virtual
real
get_minimum_z(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@
@<Define |Path| functions@>=
real
Path::get_minimum_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Path::get_minimum_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@;

if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return projective_extremes[4];

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return pre_projective_extremes[4];
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Path::get_minimum_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */

}  /* End of |Path::get_minimum_z| definition.  */

@q ** (2) Get maximum z.@>
@*1 Get maximum z.
@^\cfunc{Path}{get\_maximum\_z}@>
\initials{LDF 2002.09.17.}  

\LOG
\initials{LDF 2002.09.17.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 

@<Declare |Path| functions@>=

virtual
real
get_maximum_z(const unsigned short s 
              = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@
@<Define |Path| functions@>=
real
Path::get_maximum_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Path::get_maximum_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@;

if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return projective_extremes[5];

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return pre_projective_extremes[5];
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Path::get_maximum_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */

}  /* End of |Path::get_maximum_z| definition.  */

@q ** (2) Get mean z.@>
@*1 Get mean z.
@^\cfunc{Path}{get\_mean\_z}@>

\LOG
\initials{LDF 2003.05.16.}  
Added this function.

\initials{LDF 2005.06.30.}
Added a |const unsigned short| argument.
The default is is the |static const unsigned short|
|Shape::PROJECTIVE_COORDINATES_VALUE|.

\initials{LDF 2005.07.07.}
Rewrote this function.  It now tests the value of 
the |const unsigned short s| argument.  Made the debugging and
error output thread-safe.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
real
get_mean_z(const unsigned short s = Shape::PROJECTIVE_COORDINATES_VALUE) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
real
Path::get_mean_z(const unsigned short s) const
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

/* This code is for functions that don't take a |Scanner_Node scanner_node|
   argument.  */

   Scanner_Node scanner_node = 0;

#ifdef HAVE_PTHREAD_H

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

   if (thread_info != static_cast<Thread_Info_Type*>(0))
      scanner_node = thread_info->scanner_node;

#endif /* |HAVE_PTHREAD_H|  */@; 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering 'Path::get_mean_z'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@;

if (s == Shape::PROJECTIVE_COORDINATES_VALUE)
       return ((projective_extremes[4] + projective_extremes[5]) / 2);

    else if (s == PRE_PROJECTIVE_COORDINATES_VALUE)
       return ((pre_projective_extremes[4] + pre_projective_extremes[5]) / 2);
       
    else
      {
          cerr_strm << thread_name 
                    << "ERROR!  In 'Path::get_mean_z':"
                    << endl 
                    << "Invalid value for the unsigned short 's' argument:  "
                    << s 
                    << endl 
                    << "Haven't programmed this case yet."
                    << endl 
                    << "Exiting function unsuccessfully with return value "
                    << "'INVALID_REAL'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_REAL;

      }  /* |else|  */

}  /* End of |Path::get_mean_z| definition.  */

@q ** (2) Suppress output.@>
@*1 Suppress output.
@^\cfunc{Path}{suppress\_output}@>
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.18.}  
Added this function.  It's needed because trying to erase 
a |Shape*| from |elements| in |Picture::output| causes a memory fault.
\ENDLOG 

@<Declare |Path| functions@>=

virtual
void
suppress_output();

@
@<Define |Path| functions@>=
void
Path::suppress_output()
{
  do_output = false;
}

@q ** (2) Unsuppress output.@>
@*1 Unsuppress output.
@^\cfunc{Path}{unsuppress\_output}@>
\initials{LDF 2002.09.18.}  

\LOG
\initials{LDF 2002.09.18.}  
Added this function.  It's needed because trying to erase 
a |Shape*| from |elements| in |Picture::output| causes a memory fault.
\ENDLOG 

@<Declare |Path| functions@>=

virtual
void
unsuppress_output();

@
@<Define |Path| functions@>=
void
Path::unsuppress_output()
{
  do_output = true;
}

@q ** (2) Output.@>

@*1 Output.
@^\cfunc{Path}{output}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.09.17.}  
Removed error checking code to |extract|. 
Now |output| assumes that all of the |Points| in |points| can be 
projected using |focus|.  If they can't be, |extract| will
already have ensured that the |Path| is not on |vector <Shape*>
elements| in the |Picture|. 

\initials{LDF 2003.01.15.}  
Added code for writing ``drawarrow'' to |out_stream|,
if |arrow == true|.  This is for the |drawarrow| functions for
|Path| and |Point| that I've added today.

\initials{LDF 2004.05.25.}  
Added |Scanner_Node| argument.  Changed 
|out_stream| from a global |ofstream| to an |ofstream*|.  It's now set
using the |Scanner_Node| argument.

\initials{LDF 2004.06.02.}  
Changed the way |draw_color|, |fill_color|, and
|pen| are handled to reflect in the fact that they are now pointers.

\initials{LDF 2004.06.03.}  
No longer using 
|Colors::default_color|, since I've gotten rid of it.

\initials{LDF 2004.06.07.}  
Now using |@<Handle |dash_pattern|@>|.

\initials{LDF 2005.02.08.}
Made debugging and error output thread-safe.
Formatting changes.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
virtual
void   
output(Scanner_Node scanner_node);

@q *** (3) Definition.@>

@
@<Define |Path| functions@>=
void
Path::output(Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG) 
      {
          cerr_strm << thread_name << "Entering `Path::output'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

   Output_Struct* os = scanner_node->out[Run_State::METAPOST];
   ofstream* out_stream  = static_cast<ofstream*>(os->stream_ptr);

   if (do_output == false)
   {

#if DEBUG_COMPILE
      if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "In `Path::output': "
                    << "`do_output' == `false'. Returning.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 
  
      return;

   } /* |if (do_output == false)|  */

@q **** (4) @>   
@  
\LOG
\initials{LDF 2002.09.27.}  
Added this error handling code.  If the |Path|
is empty, don't output it.  
This code should never be reached, because the case of a |Path|
containing no |Points| should be caught in |Path::draw| and the
other drawing and filling commands. 
If it should reach |set_projective_extremes| and |Picture::output|, which
also shouldn't be possible, they would  catch it, too.  
\ENDLOG 

@<Define |Path| functions@>=

  if (points.size() == 0)
    {
        cerr_strm << thread_name << "WARNING!  In `Path::output':"
                  << endl 
                  << "`*this' doesn't contain any Points."
                  << endl 
                  << "This code should never be reached, " 
                  << "but it may be possible to recover.";
         
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return;
    }  /* |if (points.size() == 0)|  */

@q **** (4) @>   
@
@<Define |Path| functions@>=

    vector <Point*>::iterator point_iter = points.begin();
    vector <string>::iterator connector_iter = connectors.begin();
    string connector_string;

  if (connectors.size() > 0)
      connector_string = *connector_iter++;
    else
      connector_string = "--";

@q **** (4) Draw.@>
@ Draw.

\LOG
\initials{LDF 2004.11.07.}
Revised the code that checks the value of |arrow|.
\ENDLOG 

@<Define |Path| functions@>=

    if (fill_draw_value == DRAW_VALUE) 
      {
#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  "
                         << "Drawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 

         status = sub_output_draw(scanner_node, out_stream);

         if (status != 0)
            {
                  cerr_strm << thread_name 
                            << "ERROR!  In `Path::output':  "
                            << "`sub_output_draw' failed, returning "
                            << status << "."
                            << "Exiting function.";
  
                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");
               
                  return;

            }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
          else if (DEBUG)
              {
                  cerr_strm << thread_name 
                            << "In `Path::output':  "
                            << "`sub_output_draw' succeeded.";
  
                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
              }        
#endif /* |DEBUG_COMPILE|  */@; 

      } /* |if (fill_draw_value == DRAW_VALUE)|  */

@q **** (4) Fill.@>

@*3 Fill.

@<Define |Path| functions@>=

    else if (fill_draw_value == FILL_VALUE) 
      {
#if DEBUG_COMPILE
        if (DEBUG)
          {
              cerr_strm << thread_name 
                        << "In `Path::output':  "
                        << "Filling.";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 
 
          *out_stream << "fill " << **point_iter++;

          @<Output |Path|@>@;

          if (   fill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
              && fill_color_vector->ctr > 0)
            *out_stream << " withcolor " << *(fill_color_vector->v[0]);

        *out_stream << ";" << endl << flush;

    }  /* |else if (fill_draw_value == FILL_VALUE) |  */

@q **** (4) Filldraw.@>

@ Filldraw.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.03.14.}
Modified this code to handle the case that 
|draw_color_vector != 0 && draw_color_vector.size() > 0|.
\ENDLOG 

@<Define |Path| functions@>=

    else if (fill_draw_value == FILLDRAW_VALUE) 
      {
        
#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  "
                         << "Filldrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 
      
@q ***** (5).@> 
  
@
\LOG
Now setting defaults for |*fill_color|, if |fill_color == 0|.
\ENDLOG 

@<Define |Path| functions@>=

              *out_stream << "fill " << **point_iter++;

              @<Output |Path|@>@;

              Id_Map_Entry_Node entry;
              void* v = 0;

              Color* temp_color;

              if (   fill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                  && fill_color_vector->ctr > 0)
              {
                temp_color = fill_color_vector->v[0];
              }
              else 
                 temp_color = 0;
            
              if (temp_color == static_cast<Color*>(0))
                  {
                      entry = scanner_node->lookup("background_color");
              
                      if (entry != static_cast<Id_Map_Entry_Node>(0))
                         v = entry->get_object();         

                      if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                          && v != static_cast<void*>(0))
                      {
                         temp_color = static_cast<Color*>(v);
                      }
                      else 
                         temp_color = const_cast<Color*>(&Colors::white);

                  }  /* |if (temp_color == 0)|  */

              *out_stream << " withcolor " << *temp_color;

              *out_stream << ";" << endl << flush;
                
              status = sub_output_draw(scanner_node, out_stream);

              if (status != 0)
                 {
                       cerr_strm << thread_name 
                                 << "ERROR!  In `Path::output':  "
                                 << "`sub_output_draw' failed, returning "
                                 << status << "."
                                 << "Exiting function.";
  
                       log_message(cerr_strm);
                       cerr_message(cerr_strm, error_stop_value);
                       cerr_strm.str("");
                    
                       return;

                 }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
              else if (DEBUG)
                  {
                      cerr_strm << thread_name 
                                << "In `Path::output':  "
                                << "`sub_output_draw' succeeded.";
  
                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");
                  }        
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5).@> 

 } /* |else if (fill_draw_value == FILLDRAW_VALUE)|  */

@q **** (4) Undraw.@>
@*3 Undraw.
@<Define |Path| functions@>=

    else if (fill_draw_value == UNDRAW_VALUE) 
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  "
                         << "Undrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           } 
#endif /* |DEBUG_COMPILE| */@;

          *out_stream << "undraw " << **point_iter++;

          @<Output |Path|@>@;

          @<Handle |pen|@>@;

          @<Handle |dash_pattern|@>@;
 
          *out_stream << ";\n" << flush;

  } /* |else if (fill_draw_value == UNDRAW_VALUE)|  */

@q **** (4) Unfill.@>
@ Unfill.
@<Define |Path| functions@>=

    else if (fill_draw_value == UNFILL_VALUE) 
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Path::output':  " 
                         << "Unfilling.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 
        
          *out_stream << "unfill " << **point_iter++;

          @<Output |Path|@>@;

          *out_stream << ";\n" << flush;

      }  /* |else if (fill_draw_value == UNFILL_VALUE)|  */

@q **** (4) Unfilldraw.@>
@ Unfilldraw.

\LOG
\initials{LDF 2003.03.25.}  
Changed this section, so that the outline of the
|Path| is drawn, if |draw_color != Colors::background_color|.  

\initials{LDF 2004.06.07.}
Changed |if (draw_color == Colors::background_color)| to 
|if (draw_color == 0)| below, because I've gotten rid of
|Colors::background_color|.
\ENDLOG 

@<Define |Path| functions@>=

    else if (fill_draw_value == UNFILLDRAW_VALUE)
      {

#if DEBUG_COMPILE
        if (DEBUG)
           {
               cerr_strm << thread_name << "In `Path::output':  "
                         << "Unfilldrawing.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5).@> 

          if (   draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
              || draw_color_vector->v.size() == 0)
            {
                *out_stream << "unfilldraw " << **point_iter++;

                @<Output |Path|@>@;

                @<Handle |pen|@>@;

                @<Handle |dash_pattern|@>@;

                *out_stream << ";\n" << flush;
            }

@q ***** (5).@> 
@
\LOG
\initials{LDF 2005.03.14.}
Now calling |Path::sub_output_draw|.
\ENDLOG 

@<Define |Path| functions@>=

          else  /* |   draw_color_vector != 0 
                    && draw_color_vector->v.size() != 0|  */
            {
                *out_stream << "unfill " << **point_iter++;

                @<Output |Path|@>@;

                *out_stream << ";" << endl << flush;
                
                status = sub_output_draw(scanner_node, out_stream);

                if (status != 0)
                   {
                         cerr_strm << thread_name 
                                   << "ERROR!  In `Path::output':  "
                                   << "`sub_output_draw' failed, returning "
                                   << status << "."
                                   << "Exiting function.";
  
                         log_message(cerr_strm);
                         cerr_message(cerr_strm, error_stop_value);
                         cerr_strm.str("");
                      
                         return;

                   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
              else if (DEBUG)
                  {
                      cerr_strm << thread_name 
                                << "In `Path::output':  "
                                << "`sub_output_draw' succeeded.";
  
                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");
                  }        
#endif /* |DEBUG_COMPILE|  */@; 

            }    /* |else| (|   draw_color_vector != 0 
                             && draw_color_vector->v.size() != 0|)  */

      } /* End of |UNFILLDRAW_VALUE| case.  */

@q **** (4) Invalid |fill_draw_value|:  Signal an error and return.@>
@ Invalid |fill_draw_value|:  Signal an error and return.
\initials{LDF 2005.03.13.}

\LOG
\initials{LDF 2004.11.07.}
Revised the code that checks the value of |arrow|.

\initials{LDF 2005.03.13.}
Now signalling an error and returning.  Previously, |*this| was drawn.  
\ENDLOG 

@<Define |Path| functions@>=

    else 
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Path::output':"
                    << endl 
                    << "Invalid `fill_draw_value':  "
                    << fill_draw_value << "."
                    << endl << "Not drawing or filling `Path'.  "
                    << "Exiting function.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return;

      }  /* |else| (Invalid |fill_draw_value|)  */

@q **** (4) Return.@>
@ Return.
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG) 
      {
          cerr_strm << thread_name 
                    << "Exiting `Path::output'.";
 
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

    return;

} /* End of |Path::output(Scanner_Node scanner_node)| definition.  */

@q *** (3) Sub-Output:  Draw.@>
@*2 Sub-Output:  Draw.
\initials{LDF 2005.03.13.}

\LOG
\initials{LDF 2005.03.13.}
Added this function.  Removed from |Path::output| and put here.  
|Path::output| now calls this function.
\ENDLOG

@q **** (4) Declaration.@>   

@<Declare |Path| functions@>=
int
sub_output_draw(Scanner_Node scanner_node, ofstream* out_stream);

@q **** (4) Definition.@>   

@
@<Define |Path| functions@>=

int
Path::sub_output_draw(Scanner_Node scanner_node, ofstream* out_stream)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;

@q ***** (5).@> 
@
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Entering `Path::sub_output_draw'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
    vector<string>::const_iterator connector_iter;

    string connector_string;

@q ***** (5).@>

@
\LOG
\initials{LDF 2005.03.18.}
Now testing that |*this| is of a type consisting of straight lines,
i.e., |POLYGON|, |TRIANGLE|, |RECTANGLE|, or |REG_POLYGON|.
This code won't work for curved |Paths| yet.

\initials{LDF 2005.03.18.}
Added code for handling |pen_vector| and |dash_pattern_vector|.

\initials{LDF 2005.03.19.}
Changed this conditional, so that |draw_color_vector->ctr|, 
|pen_vector->ctr|, or |dash_pattern_vector->ctr| must 
be greater than 1.  Previously, they had to be greater than 0.

\initials{LDF 2005.04.05.}
Added code for suppressing output if the type of the current 
|Pen| is |Pen::NULL_PEN|.
\ENDLOG 

@<Define |Path| functions@>=

        if (    (   shape_type == POLYGON_TYPE 
                 || shape_type == TRIANGLE_TYPE 
                 || shape_type == RECTANGLE_TYPE 
                 || shape_type == REG_POLYGON_TYPE)
             && (  (    draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                    && draw_color_vector->ctr > 1)
                 || (   pen_vector != static_cast<Pointer_Vector<Pen>*>(0) 
                     && pen_vector->ctr > 1)
                 || (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                     && dash_pattern_vector->ctr > 1))
           )

           {
#if DEBUG_COMPILE
               if (DEBUG)
                 {
                     cerr_strm << thread_name 
                               << "In `Path::sub_output_draw':"
                               << endl 
                               << "`At least one vector is non-empty.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str("");   
                 }         
#endif /* |DEBUG_COMPILE|  */@; 
  
               vector<Color*>::const_iterator color_iter;
               vector<Pen*>::const_iterator pen_iter;
               vector<Dash_Pattern*>::const_iterator dash_pattern_iter;

               bool do_colors;
               bool do_pens;
               bool do_dash_patterns;

@q ****** (6).@> 

               status = adjust_draw_color_vector();

               if (status == 0)
                  {
                      color_iter = draw_color_vector->v.begin();
                      do_colors = true;
                  }
               else
                  do_colors = false;

@q ****** (6).@> 

               status = adjust_pen_vector();

               if (status == 0)
                  {
                     pen_iter = pen_vector->v.begin();
                     do_pens = true;
                  }
               else
                  do_pens = false;

               status = adjust_dash_pattern_vector();

if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                   && dash_pattern_vector->ctr > 0)
                  {
                      dash_pattern_iter = dash_pattern_vector->v.begin();
                      do_dash_patterns = true;
                  }
               else
                  do_dash_patterns = false;

               adjust_connectors();
             
               connector_iter = connectors.begin();

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr << "`do_pens' == " << do_pens
                           << endl;

                      if (do_pens && pen_vector != static_cast<Pointer_Vector<Pen>*>(0))
                         cerr << "`pen_vector->v.size' == " 
                              << pen_vector->v.size()
                              << endl;

                      cerr << "`do_dash_patterns' == " << do_dash_patterns
                           << endl;

                      if (do_dash_patterns && dash_pattern_vector 
                             != static_cast<Pointer_Vector<Dash_Pattern>*>(0))
                         cerr << "`dash_pattern_vector->v.size' == " 
                              << dash_pattern_vector->v.size()
                              << endl;
                  }            
#endif /* |DEBUG_COMPILE|  */@;

@q ****** (6) Draw the first segment.@> 

@ Draw the first segment.  
If |points.size() == 1| no connector is used in the {\bf draw} command, 
and this functions returns after writing it to |*out_stream|.
In addition, the first segment also requires special handling if 
|arrow == DOUBLE_ARROW|. 
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

@q ******* (7) @> 

               if (   (arrow == DOUBLE_ARROW && points.size() == 1)
                   && (   !do_pens 
                       || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))  
                   {

                      *out_stream << "drawarrow " << *points[0];

                      if (do_colors)
                         *out_stream << "withcolor " << **color_iter;

                      if (do_pens)
                         *out_stream << " withpen " << **pen_iter;

                      if (do_dash_patterns)
                         *out_stream << **dash_pattern_iter;                          

                       *out_stream << ";" << endl << flush;

                       return 0; 

                      }

@q ******* (7).@> 

               else if (   (arrow == DOUBLE_ARROW && points.size() > 1)
                        && (   !do_pens 
                            || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))

                  {
                      *out_stream << "drawarrow " << *points[1] 
                                  << *connector_iter << *points[0]; 

                      if (do_colors)
                         *out_stream << endl << "withcolor " << **color_iter;

                      if (do_pens)
                         *out_stream << endl << "withpen " << **pen_iter;

                      if (do_dash_patterns)
                         *out_stream << endl << **dash_pattern_iter;

                       *out_stream << ";" << endl << flush;

                  }  

@q ******* (7).@>              

               else if (   (arrow != DOUBLE_ARROW && points.size() == 1)
                        && (   !do_pens 
                            || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN)))  
                  {
                      *out_stream << "draw " 
                                  << *points[0];

                      if (do_colors)
                         *out_stream << " withcolor " << **color_iter;

                      if (do_pens)
                         *out_stream << " withpen " << **pen_iter;

                      if (do_dash_patterns)
                         *out_stream << **dash_pattern_iter;                          

                       *out_stream << ";" << endl << flush;

                       return 0;

                  }  

@q ******* (7) @> 

               else if (   !do_pens 
                        || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

                  {
                       *out_stream << "draw " << *points[0] 
                                   << *connector_iter << *points[1];

                      if (do_colors)
                         *out_stream << endl << "withcolor " << **color_iter;

                      if (do_pens)
                         *out_stream << endl << "withpen " << **pen_iter;

                      if (do_dash_patterns)
                         *out_stream << endl << **dash_pattern_iter;

                       *out_stream << ";" << endl << flush;

                  }  

@q ****** (6) Draw the middle segments.@> 

@ Draw the middle segments.
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

               int i = 1;
               int j = points.size() - 2;
               int k;

               if (cycle_switch)
                  {
                     ++j;
                     k = 0;
                  }
               else
                  k = j + 1;

@q ******* (7) @> 

               for (; i < j; ++i)
                  {
                     
                      ++connector_iter;

                      if (do_colors)
                         ++color_iter;

                      if (do_pens)
                         ++pen_iter;
   
                      if (do_dash_patterns) 
                        ++dash_pattern_iter;
                     
                      if (   !do_pens 
                          || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

                         {
                             *out_stream << "draw " << *points[i] 
                                         << *connector_iter << *points[i + 1];

                             if (do_colors)
                                *out_stream << endl << "withcolor " << **color_iter;

                             if (do_pens)
                                *out_stream << endl << " withpen " << **pen_iter;

                             if (do_dash_patterns)
                                *out_stream << endl << **dash_pattern_iter;

                              *out_stream << ";" << endl << flush;

                         }

@q ******** (8) @> 

                  }  /* |for|  */

@q ******* (7) @> 

@q ****** (6) Draw the last segment.@> 

@ Draw the last segment.  
This requires special handling because |arrow| could be equal to 
|SINGLE_ARROW| or |DOUBLE_ARROW|. 
\initials{LDF 2005.03.13.}

@<Define |Path| functions@>=

               ++connector_iter;

               if (do_colors)
                  ++color_iter;

               if (do_pens)
                  ++pen_iter;
   
               if (do_dash_patterns) 
                 ++dash_pattern_iter;

               if (   !do_pens 
                   || (do_pens && (**pen_iter).get_type() != Pen::NULL_PEN))

                  {
       
                      if (arrow == NO_ARROW)
                         *out_stream << "draw ";
                      else
                         *out_stream << "drawarrow ";

                         *out_stream << *points[j] 
                                     << *connector_iter << *points[k];

                       if (do_colors)
                          *out_stream << endl << "withcolor " << **color_iter;

                       if (do_pens)
                          *out_stream << endl << "withpen " << **pen_iter;

                       if (do_dash_patterns)
                          *out_stream << endl << **dash_pattern_iter;

                       *out_stream << ";" << endl << flush;
                  }

@q ****** (6).@> 
               
           }  /*  |if|  */

@q ***** (5).@>   
@
\LOG
\initials{LDF 2005.03.18.}
@:BUG FIX@> BUG FIX:  Now setting 
|connector_iter = connector_iter = connectors.begin|.

\initials{LDF 2005.04.05.}
Added code for suppressing output if the type of the current 
|Pen| is |Pen::NULL_PEN|.
\ENDLOG 

@<Define |Path| functions@>=

        else if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
                 || pen_vector->ctr == 0 
                 || pen_vector->v[0]->get_type() != Pen::NULL_PEN)  
                
                 /*  Not dividing |Path|.  */
           {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
                         cerr << "`pen_vector' == 0." << endl;

                      else 
                         cerr << "`pen_vector->ctr' == " << pen_vector->ctr
                              << endl 
                              << "`pen_vector->v[0]->get_type' == "
                              << pen_vector->v[0]->get_type() << endl;

                  }
#endif /* |DEBUG_COMPILE|  */@; 
 
               vector<Point*>::const_iterator point_iter = points.begin();

               connector_iter = connectors.begin();

               if (connectors.size() > 0)
                  connector_string = *connector_iter;
               else
                  connector_string = "--";

#if DEBUG_COMPILE
               if (DEBUG)
                 {
                     cerr_strm << thread_name << "In `Path::sub_output_draw':"
                               << endl 
                               << "Not drawing segments individually.";

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str("");   
                 }         
#endif /* |DEBUG_COMPILE|  */@; 

               if (arrow == SINGLE_ARROW)
                 *out_stream << "drawarrow " << **point_iter++;
               else if (arrow == DOUBLE_ARROW)
                 *out_stream << "drawdblarrow " << **point_iter++;
               else
                 *out_stream << "draw " << **point_iter++;

               @<Output |Path|@>@;

               if (   draw_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                   && draw_color_vector->ctr > 0)
                  *out_stream << endl << "withcolor " << *(draw_color_vector->v[0]) << " ";

               if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
                  *out_stream << endl << "withpen " << *(pen_vector->v[0]) << " ";

               if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
                   && dash_pattern_vector->ctr > 0)
                  *out_stream << endl << *(dash_pattern_vector->v[0]);

               *out_stream << ";\n" << flush;

           }  /*  |else if (   pen_vector == static_cast<Pointer_Vector<Pen>*>(0) 
                            || pen_vector->ctr == 0 
                            || pen_vector->v[0]->get_type() != Pen::NULL_PEN)| 
                  (Not dividing |Path|.)  */

@q ***** (5).@>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "Exiting `Path::sub_output_draw' successfully "
                   << "with return value 0.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

}  /* End of |sub_output_draw| definition.  */

@q **** (4) Output |Path|.@>
@*3 Output {\bf Path}.
When |fill_color| and |draw_color| are different, this will have to
be performed twice, so I've made it a named section.
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.11.03.}  
|counter| is now initially set to 2 instead of 1.  This
makes each line have at most two |Points|.  Previously, the first line
had 3 |Points| (if the |Path| had at least three |Points| on it).

\initials{LDF 2002.12.20.}  
Using the manipulator ``|fixed|'' below.  It solves
the problem of |Points| being output in scientific format, which
Metapost doesn't understand.  
 
\initials{LDF 2002.12.20.}  
@^Porting@>
I had to add preprocessor code for conditional compilation, because 
``|fixed|'' is unknown to the GNU \CPLUSPLUS/ Compiler.  However, it doesn't
need it in this case, since the problem only occurred when using the DEC
\CPLUSPLUS/ compiler on a DEC Alpha computer under Compaq Tru64.

\initials{LDF 2004.06.18.}
Now inserting a line break before ``\.{cycle}''.

\initials{LDF 2005.02.08.}
Made debugging output thread-safe.
\ENDLOG 

@q ***** (5) Code.@> 

@<Output |Path|@>=

#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr_strm << thread_name << "Entering `@@<Output |Path|@@>'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 
 
   for (unsigned short counter = 2; point_iter != points.end();)
     {

        *out_stream << " " << connector_string << " " << **point_iter++;

          /* This breaks the line and indents after two points */
        
          if  (counter == 2 && point_iter != points.end())
            {
              *out_stream << "\n  ";
              counter = 1;
            }
          else
            {
              ++counter;
            }
          if (connector_iter != connectors.end())
            connector_string = *connector_iter++;
      }

    if (is_cycle())
      *out_stream << endl << "   " << connector_string 
                  << " cycle";
    
#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name << "Exiting `@@<Output |Path|@@>'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) Handle |pen|.@>
@ Handle |pen|.  
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.06.02.}  
Added this section.

\initials{LDF 2004.11.12.}
Replaced the code in this section with a call to 
|operator<<(ostream& o, Pen& p)|.
\ENDLOG 

@<Handle |pen|@>=

  if (pen_vector != static_cast<Pointer_Vector<Pen>*>(0) && pen_vector->ctr > 0)
    {

        *out_stream << endl << "withpen " << *(pen_vector->v[0]);

    } /* |if (pen_vector != 0 && pen_vector->ctr > 0)|  */

@q **** (4) Handle |dash_pattern|.@>
@ Handle |dash_pattern|.  
\initials{LDF 2004.06.07.}

\LOG
\initials{LDF 2004.06.07.}  
Added this section.

\initials{LDF 2004.11.12.}
Removed the code in this section to 
the output operator for |Dash_Pattern|.
\ENDLOG 

@<Handle |dash_pattern|@>=

  if (   dash_pattern_vector != static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
      && dash_pattern_vector->ctr > 0)
    {

        *out_stream << endl << *(dash_pattern_vector->v[0]);

    } /* |if (dash_pattern_vector != 0 && dash_pattern_vector->ctr > 0)|  */

@q * (1) Showing.@>
@* Showing.

@q ** Show.@>
@ Show.
@^\cfunc{Path}{show}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.07.13.}  
Commented-out the line that prints |fill_draw_value|
to |stdout|.

\initials{LDF 2003.08.20.}  
Now printing |points.size| and |connectors.size|
to |stdout|.  If the latter is 0, a message is printed, that |"--"| will
be used as the connector. 

\initials{LDF 2004.05.13.}  
Now returning from this function instead
of ``falling off the end''.

\initials{LDF 2004.06.07.}  
Now showing |fill_draw_value|, |draw_color|, 
|fill_color|, |pen|, |dash_pattern|, and |arrow|.

\initials{LDF 2004.06.08.}  
Made this function |virtual|.

\initials{LDF 2005.03.10.}
Now showing |*draw_color_vector|, if |draw_color_vector| is non-null.

\initials{LDF 2005.03.16.}
Now showing |*dash_pattern_vector|, if |dash_pattern_vector| is non-null,
and |*pen_vector|, if |pen_vector| is non-null.

\initials{LDF 2005.04.02.}
Now outputting the |Shape|-type.

\initials{LDF 2005.04.02.}
Now outputting |surface_hiding_ctr|.

\initials{LDF 2005.04.18.}
Now outputting |decomposition_level|.
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare |Path| functions@>=
virtual
void 
show(string text = "", char coords = 'w',
     const bool do_persp = true, const bool do_apply = true,
     Focus* f = 0, const unsigned short proj = Projections::persp,
     const real factor = 1) const;

@q *** (3) Definition.  @>

@
@<Define |Path| functions@>=
void 
Path::show(string text, char coords,
           const bool do_persp, const bool do_apply,
           Focus* f, const unsigned short proj,
           const real factor) const
{
   if (text == "")
     text = "Path:";

   cerr << text << endl;
   
   coords = tolower(coords);
   
   if (coords == 'w')
     ; /* Do nothing.  */

   else if (coords == 'p')
      cerr << "Projective coordinates.\n";

   else if (coords == 'u')
     cerr << "User coordinates.\n";

   else if (coords == 'v')
     cerr << "View coordinates.\n";

   else
     {
       cerr << "WARNING!  In `Path::show':  "
            << "Invalid character for coords argument.\n" 
            << "Showing world coordinates.\n";
       coords = 'w';
     }

   valarray <real> v;
   v.resize(4, 0);  /* LDF 2002.12.13.  Added this line.  Needed 
                       for porting to Intel Linux (i686).  */
   
   string connector_string;
   vector <string> ::const_iterator connectors_iter = connectors.begin();

   cerr << "type:  " << Shape::type_name_map[get_shape_type()] << endl;
   cerr << "surface_hiding_ctr:  " << surface_hiding_ctr << endl;

   cerr << "decomposition_level:  " << decomposition_level << endl;

   cerr << "points.size() == " 
        << points.size() << endl;  

   cerr << "connectors.size() == " 
        << connectors.size() << endl;  

   if (connectors.size() == 0)
     {
       cerr << "Using \"--\" as connector.\n";
       connector_string  = "--";
     }

     int loop_ctr = 0;

     for(vector <Point*>::const_iterator points_iter = points.begin();
         points_iter != points.end();
         ++points_iter)
       {

         if (points_iter != points.begin())
           {
             cerr << " " << connector_string << " ";
           }

         if (connectors_iter != connectors.end())
           connector_string = *connectors_iter++;

         if (loop_ctr == 2) /* Break each line after 2 |Points|.  */
           {
             cerr << endl;
             loop_ctr = 0;
           }
         ++loop_ctr;     
         
         v = (**points_iter).get_all_coords(coords, do_persp, do_apply,
                                            f, proj, factor);
         
         cerr << "(" << v[0] << ", " << v[1] << ", " << v[2] << ")";

       }  /* |for|  */

   if (cycle_switch)
     {
       if (connectors_iter != connectors.end())
         connector_string = *connectors_iter++;
       cerr << " " << connector_string << " cycle;" << endl;
     }
   else
     cerr << ";\n";

   cerr << "fill_draw_value == ";

   if (fill_draw_value == DRAW_VALUE)
     cerr << "DRAW_VALUE";

   else if (fill_draw_value == FILL_VALUE)
     cerr << "FILL_VALUE";

   else if (fill_draw_value == FILLDRAW_VALUE)
     cerr << "FILLDRAW_VALUE";

   else if (fill_draw_value == UNDRAW_VALUE)
     cerr << "DRAW_VALUE";

   else if (fill_draw_value == UNFILL_VALUE)
     cerr << "FILL_VALUE";

   else if (fill_draw_value == UNFILLDRAW_VALUE)
     cerr << "FILLDRAW_VALUE";
   
   else
     cerr << fill_draw_value;

   cerr << endl;

   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
     cerr << "`fill_color_vector' == 0" << endl;
   else
     fill_color_vector->show("fill_color_vector:");

   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      cerr << "`draw_color_vector' == 0" << endl;
   else
      draw_color_vector->show("draw_color_vector:");

   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      cerr << "`pen_vector' == 0" << endl;
   else
      pen_vector->show("pen_vector:");

   if (dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
      cerr << "`dash_pattern_vector' == 0" << endl;
   else
      dash_pattern_vector->show("dash_pattern_vector:");

   if (arrow == SINGLE_ARROW)
     cerr << "`arrow' == `Path::SINGLE_ARROW'.";

   else if (arrow == DOUBLE_ARROW)
     cerr << "`arrow' == `Path::DOUBLE_ARROW'." << endl;

   else
     cerr << "`arrow' == `Path::NO_ARROW'." << endl;

   cerr << "connector_type_vector.size() == " << connector_type_vector.size() << endl;

   if (connector_type_vector.size() > 0)
      cerr << "connector_type_vector:" << endl;

   for (vector<Connector_Type*>::const_iterator iter = connector_type_vector.begin();
        iter != connector_type_vector.end();
        ++iter)
   {
       (*iter)->show();
   }

   cerr << endl << endl;

  return;

} /* End of |Path::show| definition.  */

@q ** (2) Show Colors.@>
@*1 Show {\bf Colors}.
@^\cfunc{Path}{show\_colors}@>
\initials{LDF Undated.}

@<Declare |Path| functions@>=
void
show_colors(bool stop = false);

@
@<Define |Path| functions@>=
void
Path::show_colors(bool stop)
{
  if (draw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    draw_color_vector->show("draw_color_vector:");
  else
    cerr << "draw_color_vector == static_cast<Pointer_Vector<Color>*>(0).\n";

  if (fill_color_vector != static_cast<Pointer_Vector<Color>*>(0))
    fill_color_vector->show("fill_color_vector:");
  else
    cerr << "fill_color_vector == static_cast<Pointer_Vector<Color>*>(0).\n";

  if (stop)
    getchar(); /* Don't delete this!  */ 
}

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF Undated.}

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return PATH_TYPE;
}

@q ** (2) Is planar.@>
@*1 Is planar.
@^\cfunc{Path}{is\_planar}@>
\initials{LDF 2002.11.05.}

|is_planar| uses the return value of |get_normal| to determine whether |*this| lies in a plane or not.  
If it does, |is_planar| returns |true|, otherwise, it returns |false|.  If |*this| is linear, 
|is_planar| issues a warning and returns |true|.

\LOG
\initials{LDF 2002.11.03.}  
Rewrote this function.  It should now work for all
|Paths|.

\initials{LDF 2002.11.05.}  
Rewrote this function again.  It now uses the new version of |get_normal|.

\initials{LDF 2002.11.06.}  
Added optional |const bool verbose| and |string text|
arguments for writing a message to the standard output.

\initials{LDF 2003.08.14.}  
Made |verbose| non-|const|.  Setting it to |true| if
|VERBOSE_GLOBAL| is |true|.\newline
Added |VERBOSE_GLOBAL| to \filename{pspglb.web} today.   

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.02.11.}
@:BUG FIX@> BUG FIX:  Now returning |false| immediately 
if |points.size() < 3|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
bool
is_planar(bool verbose = false, string text = "") const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_planar(bool verbose, string text) const
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */@; 
#endif /* |DEBUG_COMPILE|  */@;

if (VERBOSE_GLOBAL)
    verbose = true;

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr << "Entering Path::is_planar().\n";
    }
#endif /* |DEBUG_COMPILE|  */@; 
 
   if (points.size() < 3)
      return false;

  Point p(get_normal());

  Point origin_pt(0, 0, 0);

  if (p == INVALID_POINT)
    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr << "Exiting Path::is_planar(). Returning false."
               << endl;
        }
#endif /* |DEBUG_COMPILE|  */@;

if (verbose)
        {
          if (text == "")
            text = "Path";
          cerr << text << " is non-planar.\n\n";
        }
    return false;
    }

@

\LOG
\initials{LDF 2004.12.07.}
Commented-out the warning.
\ENDLOG 

@<Define |Path| functions@>=

  else if( p == origin_pt)
    {
#if 0 
      cerr << "WARNING! In Path::is_planar():\n"
           << "Path is linear.  Returning true.\n\n";
#endif 
      if (verbose)
        {
          if (text == "")
            text = "Path";
          cerr << text << " is planar.\n\n";
        }
      return true;
    }
  else
    {
      if (verbose)
        {
          if (text == "")
            text = "Path";
          cerr << text << " is planar.\n\n";
        }

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr << "Exiting Path::is_planar(). Returning true."
               << endl; 
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      return true;
    }
}

@q ** (2) Is linear.@>
@*1 Is linear.
@^\cfunc{Path}{is\_linear}@>

|is_linear| first checks whether |line_switch| is |true|.  If it is,
it returns |true| right away.  Otherwise, it uses the return value of
|get_normal| to determine whether |*this| is linear or not.  If it
 is, |is_linear| returns |true|, otherwise, it returns |false|.
\initials{LDF 2003.04.09.} 

\LOG
\initials{LDF 2002.11.05.}  
Added this function.

\initials{LDF 2002.11.06.}  
Added optional |const bool verbose| and |string text|
arguments for writing a message to the standard output.

\initials{LDF 2003.04.09.}  
Now checking whether |line_switch| is |true| before
calling |get_normal|.  
@:!!@> !!  If a |Path| whose |line_switch == true| is 
modified such that it's no longer linear, the programmer must ensure 
that |line_switch| is set to |false|!

\initials{LDF 2003.08.14.}  
Made |verbose| non-|const|.  
Setting it to |true| if |VERBOSE_GLOBAL| is
|true|.\newline
Added |VERBOSE_GLOBAL| to \filename{pspglb.web} today.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.09.06.}
Now returning |false| if |points.size() < 2| and |true| if 
|points.size() == 2|.  The latter condition will have to be changed if
I add connectors that can cause |Paths| with two |Points| to be
non-linear.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_linear(bool verbose = false, string text = "") const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_linear(bool verbose, string text) const
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */@; 
  if (DEBUG)
    {
      cerr << "Entering Path::is_linear." << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 
 
  if (line_switch)  /* LDF 2003.04.09.  Added this conditional.  */
    return true;

 if (points.size() < 2)
    return false;

/* !! TO DO. LDF 2004.09.06.  This will have to be changed if I add 
    connectors that can cause |Paths| with two |Points| to be
    non-linear.  */@; 

if (points.size() == 2)
    return true;

  Point p(get_normal());

  Point origin_pt(0, 0, 0);

  if (p == origin_pt)
    {

      if (verbose)
        {
          if (text == "")
            text = "Path";
          cerr << text << " is linear.\n\n";
        }
      
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr << "Exiting Path::is_linear(). "
               << "Returning true." << endl;
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
    return true;
    }
  else
    {
      if (verbose)
        {
          if (text == "")
            text = "Path";
          cerr << text << " is non-linear.\n\n";
        }
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr << "Exiting Path::is_linear(). "
               << "Returning false." << endl;
        }
#endif /* |DEBUG_COMPILE|  */@;

return false;
    }
}  

@q ** (2) Get line switch.@>
@*1 Get line switch.
@^\cfunc{Path}{get\_line\_switch}@>
\initials{LDF 2002.11.03.}  This function returns |true| for |Paths| that are
created or set using two |Points| only, and no connectors, as
arguments. 

\LOG
\initials{LDF 2002.11.03.}  
Renamed this function |get_line_switch| from
|is_line|.  About to add |is_linear|, which will test whether all
the |Points| are colinear or not.
\ENDLOG 

@q *** (3) Definition.@> 

@<Declare |Path| functions@>=
inline
bool
get_line_switch() const
{
    return line_switch;
}

@q ** (2) Test for cycles.@>
@*1 Test for cycles. 
@^\cfunc{Path}{is\_cycle}@>

@<Declare |Path| functions@>=
inline
bool
is_cycle() const
{
  return cycle_switch;
}

@q ** (2) Size (number of points).@>
@*1 Size (number of points).
@^\cfunc{Path}{size}@>
\initials{LDF Undated.}

\LOG
\initials{LDF Undated.}
Added this function.

\initials{LDF 2007.07.09.}
Made this function |virtual| because a special version is needed for |class Hyperbola|.
Also made it |const| and non-|inline|, and changed the return value from |int| 
to |size_t|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
size_t
size(void) const;

@q *** (3) Definition.@> 
@
@<Define |Path| functions@>=
size_t
Path::size(void) const
{
  return points.size();
}

@q ** (2) Is triangular.@>
@*1 Is triangular.
@^\cfunc{Path}{is\_triangular}@>
\initials{LDF 2005.01.23.}

@q *** (3) Log.@> 

\LOG
\initials{LDF 2005.01.23.}
Added this function. 

\initials{LDF 2005.01.24.}
Got this function to work.

\initials{LDF 2005.01.24.}
@:BUG FIX@> BUG FIX:  Changed, so that a |Path| needn't be 
a cycle in order to be considered triangular.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_triangular(void) const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_triangular(void) const
{

#if 0 
   cerr << "points.size() == " << points.size() << endl
        << "points.size() == " << points.size() << endl
        << "is_linear() == " << is_linear() << endl
        << "connectors.size() == " << connectors.size() << endl;
#endif 

  if (points.size() != 3)
      return false;

   if(connectors.size() > 0)
      {
          for (vector<string>::const_iterator iter = connectors.begin();
               iter != connectors.end();
               iter++)

             {
                if (*iter != "--")
                return false;
             }
      } /* |if|  */

   return !is_linear();

} /* End of |Path::is_triangular| definition.  */

@q ** (2) Is polygonal.@>
@*1 \.{is\_polygonal}.
@^\cfunc{Path}{is\_polygonal}@>
\initials{LDF 2005.02.11.}

\LOG
\initials{LDF 2005.02.11.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_polygonal(Scanner_Node scanner_node = 0) const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_polygonal(Scanner_Node scanner_node) const
{
   
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4) Test planarity and cyclicity.@>

@ Test planarity and cyclicity.
\initials{LDF 2005.02.11.}

@<Define |Path| functions@>=

  if (!(is_planar() && is_cycle()))
    return false;

@q **** (4) Test connectors.@>   
@ Test connectors.
\initials{LDF 2005.02.11.}

@<Define |Path| functions@>=

  for (vector<string>::const_iterator iter = connectors.begin();
       iter != connectors.end();
       iter++)

    {
       if (*iter != "--")
          return false;

    } /* |for|  */

@q **** (4) @>   

   return true;

} /* End of |Path::is_polygonal| definition.  */

@q ** (2) Is convex and_polygonal.@>
@*1 \.{is\_convex\_polygonal}.
@^\cfunc{Path}{is\_convex\_polygonal}@>
\initials{LDF 2005.02.07.}

\LOG
\initials{LDF 2005.02.07.}
Added this function. 

\initials{LDF 2005.02.08.}
Debugged this function.

\initials{LDF 2005.02.11.}
Finished writing this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_convex_polygonal(Scanner_Node scanner_node = 0) const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_convex_polygonal(Scanner_Node scanner_node) const
{
   
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4) Test planarity and cyclicity.@>

@ Test planarity and cyclicity.
\initials{LDF 2005.02.10.}

@<Define |Path| functions@>=

  if (!(is_planar() && is_cycle()))
    return false;

@q **** (4) Test connectors.@>   
@ Test connectors.
\initials{LDF 2005.02.11.}

@<Define |Path| functions@>=

  for (vector<string>::const_iterator iter = connectors.begin();
       iter != connectors.end();
       iter++)

    {
       if (*iter != "--")
          return false;

    } /* |for|  */

@q **** (4) Cull |Points| that lie on line segments.@>

@ Cull |Points| that lie on line segments.  
They aren't removed from |*this|, but they aren't used in the rest of
this function.
\initials{LDF 2005.02.11.}

\LOG
\initials{LDF 2005.02.11.}
Added this section. 
\ENDLOG

@<Define |Path| functions@>=

   unsigned int i;
   unsigned int j;
   unsigned int k;
   unsigned int m;

   vector<Point*> temp_points;

   vector<Point*>::size_type size = points.size();

@q ***** (5).@> 

   for (j = 0; j < size; ++j)
      {
         i = (j - 1 + size) % size;
         k = (j + 1) % size;

         if (!points[j]->is_on_segment(*points[i], *points[k]).first)
            temp_points.push_back(points[j]);

@q ****** (6).@> 

      }  /* |for|  */

@q ***** (5).@> 

   size = temp_points.size();

@q **** (4) Test that none of the sides intersect.@>

@ Test that none of the sides intersect.@>
\initials{LDF 2005.02.10.}

\LOG
\initials{LDF 2005.02.10.}
Started working on this section. 

\initials{LDF 2005.02.11.}
Got the code in this section to work.
\ENDLOG

@<Define |Path| functions@>=

   Bool_Point bp; 

@q ***** (5).@> 

   for (i = 0; i < size; ++i)
      {
         j = (i + 1) % size;

@q ****** (6).@> 

         for (k = i + 2; k < size; ++k)
            {
                m = (k + 1) % size;

                if (m == i)
                   continue;

                bp = Point::intersection_point(*points[i], *points[j],
                                               *points[k], *points[m]); 

                if (bp.b)
                   {
#if DEBUG_COMPILE
                       if (DEBUG)
                          {
                              cerr_strm << thread_name 
                                        << "In `Path::is_convex_polygonal':"
                                        << endl 
                                        << i << ", " << j << " and "
                                        << k << ", " << m << " intersect."
                                        << endl << "Returning `false'.";

                              log_message(cerr_strm);
                              cerr_message(cerr_strm);
                              cerr_strm.str("");   
                          }
#endif /* |DEBUG_COMPILE|  */@; 
 
                       return false;

                   }  /* |if (Point::intersection_point(*points[i], *points[j],
                                                   *points[k], *points[m]).b)|  */
 @q ******* (7) @> 

            }  /* Inner |for|.  */

@q ****** (6).@> 

      }  /* Outer |for|.  */

@q ***** (5).@> 

@q **** (4) Test that all angles are < 180 degrees.@>

@ Test that all angles are $< 180^\circ$.
\initials{LDF 2005.02.10.}

@<Define |Path| functions@>=

   real angle;
  
   Point next_vector;
   Point prev_vector;

   for (i = 0; i < size; ++i)
      {
         next_vector = *temp_points[(i + 1) % size] - *temp_points[i];
         prev_vector = *temp_points[i] - *temp_points[(i - 1 + size) % size];

         angle = next_vector.angle(prev_vector);

         if (fabs(angle) >= 180) 
            return false;

      }  /* |for|  */

   return true;

} /* End of |Path::is_convex_polygonal| definition.  */

@q ** (2) Is rectangular.@>
@*1 Is rectangular.
@^\cfunc{Path}{is\_rectangular}@>

|is_rectangular| tests whether a |Path| is rectangular.  
It first tests if it'splanar.  Then it
creates vectors from the points on the |Path|, and checks their
angles to one another.  If they are within |Point::epsilon|
(exclusive) of $180^\circ$ in one case, and  
$90^\circ$ in the other two, |is_rectangular| returns 1, 
otherwise 0. \initials{LDF 2003.12.02.} 

Please note that this function will return |false| for some |Paths|
that may actually be rectangular, for example, if they contain more
than four |Points|.
\initials{LDF 2004.10.14.}

@q *** (3) Log.@> 

\LOG
\initials{LDF 2003.11.28.}  
Added this function. 

\initials{LDF 2003.12.02.}  
Added test of planarity at beginning of function. 

\initials{LDF 2003.12.09.}  
Now using |cross_product| to test for
parallelity of the sides.  @:!! TO DO@> TO DO:  Add
|Path::is_parallel| and a version for |Points|. 

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.10.14.}
Moved this function from \filename{rectangs.web} to this file
(\filename{paths.web}) and made it a member of |Path| rather than
|Rectangle|.  Now testing whether |points.size() == 4|, whether the
|Path| is a cycle, and whether any
connector is not |"--"|.  If there are no connectors, |"--"| is used, 
so a |Path| with no explicit connectors can be rectangular.  
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_rectangular() const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_rectangular() const
{

  if (!(is_planar() && is_cycle() && points.size() == 4))
    return false;

  for (vector<string>::const_iterator iter = connectors.begin();
       iter != connectors.end();
       iter++)

    {
       if (*iter != "--")
         return false;
    }

  Point origin_pt(0, 0, 0);

  Point a = (get_point(1) - get_point(0));
  Point b = (get_point(2) - get_point(3));
  Point c = (get_point(3) - get_point(0));
  Point d = (get_point(2) - get_point(1));

  return (   a.cross_product(b) == origin_pt 
          && c.cross_product(d) == origin_pt 
          && fabs(fabs(a.angle(d)) - 90) < Point::epsilon());

} /* End of |Path::is_rectangular| definition.  */

@q ** (2) Is quadrilateral.@>
@*1 Is quadrilateral.
@^\cfunc{Path}{is\_quadrilateral}@>
\initials{LDF 2005.01.25.}

\LOG
\initials{LDF 2005.01.25.}
Added this function. 
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_quadrilateral(Scanner_Node scanner_node = 0) const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_quadrilateral(Scanner_Node scanner_node) const
{
   
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

  if (!(is_planar() && is_cycle() && points.size() == 4))
    return false;

  for (vector<string>::const_iterator iter = connectors.begin();
       iter != connectors.end();
       iter++)

    {
       if (*iter != "--")
         return false;
    }

real angle[4];

   angle[0] = (*points[1] - *points[0]).angle(*points[3] - *points[0]);
   angle[1] = (*points[2] - *points[1]).angle(*points[0] - *points[1]);
   angle[2] = (*points[3] - *points[2]).angle(*points[1] - *points[2]);
   angle[3] = (*points[2] - *points[3]).angle(*points[0] - *points[3]);

real sum = 0;

   for (int i = 0; i < 4; ++i)
      sum += angle[i];

#if DEBUG_COMPILE
   if (DEBUG)
     {
        for (int i = 0; i < 4; ++i)
           cerr << "`angle[" << i << "]' == " << angle[i] << endl;

        cerr << "`sum'  == "  << sum << endl;
            
     }
#endif /* |DEBUG_COMPILE|  */@;

return (fabs(sum - 360) <= Point::epsilon());

} /* End of |Path::is_quadrilateral| definition.  */

@q ** (2) Is square.@>
@*1 Is square.
@^\cfunc{Path}{is\_square}@>

\LOG
\initials{LDF 2004.10.14.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
bool
is_square() const;
   
@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_square() const
{
   if (!is_rectangular())
     return false;

  Point a = (get_point(1) - get_point(0));
  Point b = (get_point(2) - get_point(1));
  Point c = (get_point(3) - get_point(2));
  Point d = (get_point(0) - get_point(3));

  return (   a.magnitude() == b.magnitude() 
          == c.magnitude() == d.magnitude());

} /* End of |Path::is_square| definition.  */

@q ** (2) Is elliptical.@>
@*1 Is elliptical.
@^\cfunc{Path}{is\_elliptical}@>

\LOG
\initials{LDF 2004.10.16.}
Added this function declaration.  
This function must be defined in \filename{ellipses.web}, 
because it uses an |Ellipse|, which is an incompletely defined 
type in this file (\filename{paths.web}).
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
bool
is_elliptical(Scanner_Node scanner_node = 0) const;

@q ** (2) Is circular.@>
@*1 Is circular.

\LOG
\initials{LDF 2004.10.16.}
Added this function declaration.  
This function must be defined in \filename{circles.web}, 
because it uses a |Circle|, which is an incompletely defined type in 
this file (\filename{paths.web}).
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
bool
is_circular(Scanner_Node scanner_node = 0) const;

@q ** (2) Is parabolic.@>
@*1 Is parabolic.

\LOG
\initials{LDF 2005.11.07.}
Added this function declaration.  
This function must be defined in \filename{parabola.web}, 
because it uses a |Parabola|, which is an incompletely defined type in 
this file (\filename{paths.web}).
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
bool
is_parabolic(Scanner_Node scanner_node = 0) const;

@q ** (2) Is hyperbolic.@>
@*1 Is hyperbolic.

\LOG
\initials{LDF 2005.11.07.}
Added this function declaration.  
This function must be defined in \filename{hyprbola.web}, 
because it uses a |Hyperbola|, which is an incompletely defined type in 
this file (\filename{paths.web}).
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
bool
is_hyperbolic(Scanner_Node scanner_node = 0) const;

@q ** (2) Is helical.@>
@*1 Is helical.

\LOG
\initials{LDF 2005.05.18.}
Added this function declaration.  This function is defined 
in \.{helices.web}.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Path| functions@>=
bool
is_helical(Scanner_Node scanner_node = 0) const;

@q ** (2) Is coplanar.@> 
@*1 Is coplanar.
\initials{LDF 2004.10.25.}

\LOG
\initials{LDF 2004.10.25.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=

bool
is_coplanar(const Path& p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
bool
Path::is_coplanar(const Path& p, Scanner_Node scanner_node) const
{
 
@q **** (4) Preliminaries.@>

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4) @>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "Entering `Path::is_coplanar'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) One or both |Paths| is non-planar.  Return |false|.@>    

@ One or both |Paths| is non-planar.  Return |false|.
\initials{LDF 2004.10.25.}

@<Define |Path| functions@>=

  if (!(is_planar() && p.is_planar()))
    {
#if DEBUG_COMPILE
       if (DEBUG)
         {
            cerr_strm << thread_name << "In `Path::is_coplanar':"
                      << endl << "One or both `Paths' is non-planar. "
                      << "Returning `false'.";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");
         }  
#endif /* |DEBUG_COMPILE|  */@; 
 
       return false;

    } /* |if (!(is_planar() && p.is_planar()))|  */

@q **** (4) Boths |Paths| are planar.@>  
@ Boths |Paths| are planar.  Compare |normals| and distance to origin.
\initials{LDF 2004.10.25.}

@<Define |Path| functions@>=

   Plane t_plane = get_plane();
   Plane p_plane = p.get_plane();

@q ***** (5) |t_plane == p_plane|.  Return |true|.@> 

@ |t_plane == p_plane|.  Return |true|.
\initials{LDF 2004.10.25.}

@<Define |Path| functions@>=

   if (t_plane == p_plane)
      { 

#if DEBUG_COMPILE
          if (DEBUG)
            {
               cerr_strm << thread_name << "In `Path::is_coplanar':"
                         << endl << "The planes of the `Paths' are congruent. "
                         << "Returning `true'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
            }  
#endif /* |DEBUG_COMPILE|  */@; 

         return true;

      } /* |if (t_plane == p_plane)|  */

@q ***** (5) |t_plane.normal == -p_plane.normal|, but the planes @> 
@q ***** (5) are otherwise congruent.  Return |true|.            @>

@ |t_plane.normal == -p_plane.normal|, but the planes 
are otherwise congruent.  Return |true|.           
\initials{LDF 2004.10.25.}

\LOG
\initials{LDF 2005.11.02.}
@:BUG FIX@> BUG FIX:  Changed 
|t_plane.distance == p_plane.distance && t_plane.point.is_on_plane(p_plane)|
to 
|t_plane.distance == p_plane.distance || t_plane.point.is_on_plane(p_plane)|
in the following conditional.  This may still need some work.
\ENDLOG 

@<Define |Path| functions@>=

   else if (   (   t_plane.normal == p_plane.normal
                || t_plane.normal == -p_plane.normal)
            && (   t_plane.distance == p_plane.distance 
                || t_plane.point.is_on_plane(p_plane)))
     {
#if DEBUG_COMPILE
       if (DEBUG)
         {
            cerr_strm << thread_name << "In `Path::is_coplanar':"
                      << "The `paths' are coplanar.  "
                      << "Returning `true'.";           

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");
         }  
#endif /* |DEBUG_COMPILE|  */@; 

      return true;
        
     }  /* |else|  */

@q ***** (5) The |Paths| aren't coplanar.  Returning |false|.@> 

@ The |Paths| aren't coplanar.  Returning |false|.
\initials{LDF 2004.10.25.}

@<Define |Path| functions@>=

   else
      {
#if DEBUG_COMPILE
         if (DEBUG)
           {

               t_plane.normal.show("t_plane.normal:");
               p_plane.normal.show("p_plane.normal:");

               cerr_mutex.lock(); 
               cerr << "(t_plane.normal == p_plane.normal): "
                    << (t_plane.normal == p_plane.normal)
                    << endl 
                    << "(t_plane.normal == -p_plane.normal): "
                    << (t_plane.normal == -p_plane.normal)
                    << endl 
                    << "t_plane.distance == " << t_plane.distance
                    << endl 
                    << "p_plane.distance == " << p_plane.distance
                    << endl 
                    << "(t_plane.distance == p_plane.distance): "
                    << (t_plane.distance == p_plane.distance)
                    << endl 
                    << "t_plane.point.is_on_plane(p_plane): "
                    << t_plane.point.is_on_plane(p_plane)
                    << endl; 
               cerr_mutex.unlock();  

              cerr_strm << thread_name << "In `Path::is_coplanar':"
                        << endl << "The `Paths' aren't coplanar. "
                        << "Returning `false'.";           

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");

           }  
#endif /* |DEBUG_COMPILE|  */@; 

     return false;

      } /* |else|  */

} /* End of |Path::is_coplanar| definition.  */

@q ** (2) Is on segment.  |Point| function.@> 
@*1 Is on segment.  |Point| function.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this function definition.
\ENDLOG

@<Define |Point| functions@>=

Bool_Real
Point::is_on_segment(const Path& p) const
{
  
    if (!p.is_linear())
       {
           return Bool_Real(false, INVALID_REAL);
       }
  
    return is_on_segment(p.get_point(0), p.get_point(1));
}

@q ** (2) Slope.@>
@*1 Slope.
@^\cfunc{Path}{slope}@>

|slope| can only be used for linear |Paths|. 
It returns a |real| value representing the slope of the {\it trace\/}
of a line on the major plane represented by the |char| arguments, or
|INVALID_REAL|, if the |Path| is non-linear.  For
example, if $\overrightarrow{p_0p_1}$ is a |Path p| and
$\overrightarrow{q_0q_1}$ is the trace of |p| on the x-y plane, then
|p.slope('x', 'y')| returns a |real| $m$ such that $m =  (b - y)/x$
where $b$ is the y-intercept of $\overrightarrow{q_0q_1}$ and $x$ and $y$
are the x and y-coordinates of points on $\overrightarrow{q_0q_1}$.
\initials{LDF 2002.11.05.}

\LOG
\initials{LDF 2002.11.05.}  
Changed this function so that |is_linear| is used
instead of |get_line_switch| (formerly ``|is_line|'').  Now, it
can be used for all linear |Paths|, not just ones created using the
constructor for lines.  Also, it was commented-out.  
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
real
slope(char a = 'x', char b = 'y');

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
real
Path::slope(char a, char b)
{
  if (!is_linear())
    {
      cerr << "ERROR! In Path::slope(). Path is not linear!\n"
           << "Returning INVALID_REAL\n";
      return INVALID_REAL;
    }
  return points[1]->slope(*points[0], a, b);
}

@q ** Subpath.@>
@*1 Subpath.
@^\cfunc{Path}{subpath}@>
\initials{LDF 2002.11.05.}
|subpath| returns a new |Path| using |points[start]|
through\newline
|points[end - 1]| from |*this|.  If the optional |bool|
argument |cycle| is used, then the new |Path| will be a cycle, whether
|*this| is or not.  One optional connector
argument can be used.  If it is, it will be the only connector.
Otherwise, the connectors from |*this| are used.  

\initials{LDF 2002.11.05.}  |start| must be $<$ |end|.  It is not possible to
have |start| $>$ |end|, even if |*this| is a cycle.

\LOG
\initials{LDF 2002.11.05.}  Rewrote this function.  
Made |subpath| itself and its arguments |const|. 
Added error handling code.  

\initials{LDF 2003.07.16.}  Please note that |start| and |end| cannot be made
|const|.

\initials{LDF 2003.08.27.}  Changed |int i| to |size_t i| in the |for| loops that
compare |i| to |start| and |end|.  The way it was before caused GCC
with the ``{\tt -Wall}'' option to issue a warning.
\ENDLOG 
@<Declare |Path| functions@>=
Path
subpath(size_t start, size_t end, const bool cycle = false,
        const string connector = "") const;

@q *** Definition.@>
@   
@<Define |Path| functions@>=
Path
Path::subpath(size_t start, size_t end,
              const bool cycle, const string connector) const
{
  
  bool DEBUG = false; /* |true| */@; 
  Path p;
  
@  \initials{LDF 2002.11.05.}  
There is no ``|INVALID_PATH|'', so I return an empty one, if 
|start >= end|.  Since |operator==| currently doesn't exist, there's
not much point in defining |INVALID_PATH|, since there's no way to
compare another |Path| to it.

@<Define |Path| functions@>=

  if (start >= end)
    {
      cerr << "ERROR! In Path::subpath():\n"
           << "The \"start\" argument is < the \"end\" argument.\n"
           << "Returning empty Path.\n\n";
      return p;  
    }

@ \initials{LDF 2002.11.05.}  More error handling.  In these cases, it's possible
to recover.
@<Define |Path| functions@>=
  if (start > points.size() - 1)
    {
      cerr << "ERROR! In Path::subpath():\n"
           << "\"start\" argument is > points.size() - 1.\n"
           << "Will try to recover by setting start = 0.\n\n";

      start = 0;
    }

  if (end > points.size())
    {
      cerr << "ERROR! In Path::subpath():\n"
           << "\"end\" argument is > points.size().\n"
           << "Will try to recover by setting end = points.size().\n\n";

      end = points.size();
    }

@ \initials{LDF 2002.11.05.}  If a |connector| argument is specified, all we have
to do is put the appropriate |Points| from |points| onto |p.points|,
put |connector| onto |p.connectors|, and return |p|.
@<Define |Path| functions@>=
        @;
  if (connector != "")
    {
      for(size_t i = start; i < end; i++)
        {
          if (i >= points.size())
            {
              cerr << "ERROR! In Path::subpath():\n"
                   << "end argument > points.size().\n"
               << "Breaking out of loop.\n\n";
              break;
            }
          p.points.push_back(create_new<Point>(points[i]));
        }
      p.connectors.push_back(connector);
      p.set_cycle(cycle);
      return p;
    }
  
@ \initials{LDF 2002.11.05.}  If no |connector| argument is specified, then we
have to get the appropriate connectors from |*this|.  This is slightly
tricky, because |connectors| doesn't have to contain a |connector| for
each pair of |Points| that is joined in a |Path|. So, first we must
fill up |p.connectors| so that we can tell which ones to use.

\initials{LDF 2002.11.05.}  Actually, with the constructors that exist, there
will either be only one connector or a connector for each pair of |Points|
that need to be joined.  However, it would be easy to write functions
that add or remove connectors, so it's best to have this routine.
@<Define |Path| functions@>=

  @;  
  p = *this;

  unsigned short a = points.size();
  if (!cycle)
    a -= 1;

  int i;
  string s = connectors.back();

  for (i = connectors.size(); i < a; i++)
    {
      p.connectors.push_back(s);
    }
  if (DEBUG)   
    cerr << "p.connectors.size() == " << p.connectors.size() << endl;
  
  Path q;
  
  for (size_t i = start; i < end; i++)
    {
      q.points.push_back(create_new<Point>(p.points[i]));
      if (i < p.connectors.size())
          q.connectors.push_back(p.connectors[i]);
    }
  q.set_cycle(cycle);
  return q;
}

@q ** (2) Getting points.@>
@*1 Getting points. 
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this section.
\ENDLOG

@q *** (3) Get point---non-const version.@>
@*2 Get point---non-{\bf const} version. 
@^\cfunc{Path}{get\_point}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.11.05.}  
Made non-|inline|.  Changed return value to 
|const Point&|. 

\initials{LDF 2003.11.28.}  
@:BUG FIX@> BUG FIX:  Changed, so that |apply_transform| is 
called on the |Point|.  This entailed making this function
non-|const|.  Added |const| version below.  
This may actually be a bug, rather than a bug
fix, depending on how this function is used elsewhere.  However, I
really think |apply_transform| should be called.

\initials{LDF 2007.07.09.}
Made this function |virtual| because a separate version is needed 
for |class Hyperbola|.
\ENDLOG 
 
@q **** (4) Declaration.@>

@<Declare |Path| functions@>=
virtual
const Point&
get_point(const unsigned short a);

@q **** (4) Definition.@> 
@
@<Define |Path| functions@>=
const Point&
Path::get_point(const unsigned short a)
{
    if (a < points.size())
      {
          (points[a])->apply_transform();
          return *points[a];
      }
    else
      {
        cerr << "ERROR! In Path::get_point():\n"
             << "Argument is >= size of Path.\n"
             << "Returning INVALID_POINT.\n\n" ;
        return INVALID_POINT;
      }
}

@q *** (3) Get point---const version.@>
@*2 Get point---{\bf const} version. 
@^\cfunc{Path}{get\_point}@>
\LOG
\initials{LDF 2003.11.28.}  
Added this version.

\initials{LDF 2007.07.09.}
Made this function |virtual| because a separate version is needed 
for |class Hyperbola|.
\ENDLOG 
 
@q **** (4) Declaration.@>

@<Declare |Path| functions@>=
virtual
Point
get_point(const unsigned short a) const;

@q **** (4) Definition.@> 
@
@<Define |Path| functions@>=
Point
Path::get_point(const unsigned short a) const
{
    if (a < points.size())
      {
          Point p = *(points[a]);
          p.apply_transform();
          return p;
      }
    else
      {
        cerr << "ERROR! In Path::get_point():\n"
             << "Argument is >= size of Path.\n"
             << "Returning INVALID_POINT.\n\n" ;
        return INVALID_POINT;
      }
}

@q *** (3) Get last point.@>
@*2 Get last point. 
@^\cfunc{Path}{get\_last\_point}@>

\LOG
\initials{LDF 2002.05.10.}  
Added this function.

\initials{LDF 2002.11.05.}  
Made non-|inline|.  Changed return value to 
|const Point&|. 

\initials{LDF 2007.07.09.}
Made this function |virtual| because a separate version is needed 
for |class Hyperbola|.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Path| functions@>=
virtual
const Point&
get_last_point() const;

@q **** (4) Definition.@> 
@
@<Define |Path| functions@>=
const Point&
Path::get_last_point() const
{
    if (points.size() != 0)
      return *points[points.size() - 1];
    else
      {
        cerr << "ERROR! In Path::get_last_point():\n"
             << "Path is empty.\n"
             << "Returning INVALID_POINT.\n\n" ;
        return INVALID_POINT;
      }
}

@q ** (2) Get connector.@>
@*1 Get connector. 
@^\cfunc{Path}{get\_connector}@>

\LOG
\initials{LDF 2004.11.26.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
virtual
string
get_connector(const unsigned int i) const;

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
string
Path::get_connector(const unsigned int i) const
{

   vector<string>::size_type s = connectors.size();

   if (s == 0)
     return "--";

   else if (i < s)
      return connectors[i];

   else 
      return connectors[s - 1];

}  /* End of |Path::get_connector| definition.  */

@q ** (2) Get normal.@>
@*1 Get normal.
\initials{LDF Undated.}

\LOG
\initials{LDF Undated.}
Added this section.
\ENDLOG

@q *** (3) |Path| version.@>
@*2 {\bf Path} version.
@^\cfunc{Path}{get\_normal}@>
\initials{LDF 2002.11.05.}  
|get_normal| returns a unit vector representing the normal to the
plane of the |Path *this|, if |*this| is planar.  If the |Points| on
|*this| are colinear and there are no connectors that could make the
|Path| non-linear, then |origin| ($(0, 0, 0)$) is returned.
If the |Path| is neither planar nor linear, |get_normal| returns
|INVALID_POINT|.

\initials{LDF 2002.11.05.}  
\item{$\bullet$} |get_normal| first checks whether a |Path| contains
no |Points| or only one |Point|.  If so, |get_normal| returns
|INVALID_POINT|.   
\smallskip
%
\item{$\bullet$} Then it checks whether the |Path| has connnectors
that might make the |Path| non-planar, even if the |Points| lie in a
plane.  If it does, it returns |INVALID_POINT|.  Note that there is no
guarantee that the connectors actually {\it will\/} make the |Path|
non-planar. 
\smallskip
%
\item{$\bullet$} Then it checks whether the |Path| has only two
|Points|.  If it does, |get_normal| returns the |Point| $(0, 0, 0)$,  
because the |Path| will be linear.
\smallskip
%
\item{$\bullet$} Then it gets the cross product $b_0$ of
$\overrightarrow{p_0p_1}$ and $\overrightarrow{p_0p_2}$, where $p_0$ and 
$p_1$ are the first and second |Points| on the |Path|, and $p_2$ is
the next |Point| on the |Path| such that $b_0 \neq (0, 0, 0)$.
If no |Points| on the |Path| 
fulfill this condition, then all of the |Points| are colinear, so
|get_normal| returns |origin|.
\smallskip
%
\item{$\bullet$} 
If, however, $b_0 \neq (0, 0, 0)$ exists, then cross
products $b_x$ are calculated using $\overrightarrow{p_0p_1}$ and the
direction vectors $\overrightarrow{p_0p_x}$ for the rest of the
|Points| $p_x$ on the |Path|.  If and only if $b_x = b_0$, or $b_x =
-b_0$, or $b_x = (0, 0, 0)$ for all $b_x$, then the |Path| is planar,
and |get_normal| returns $-b_0$ (see explanation of sign below).  
Otherwise, the |Path| is
non-planar, and |get_normal| returns |INVALID_POINT|.
\smallskip  

\initials{LDF 2003.06.04.}
Reversing the sign of $b_0$ ensures that the normal will
point in the direction of the positive y-axis, when a 
plane figure is created in the x-z plane, using one of the
constructors taking a |Point| argument for the center, |real|
arguments for the dimensions, and three |real| arguments for the
rotation about the major axes.  If non-zero arguments are used for
rotation, the normal will be 
rotated accordingly.  This direction considered to be ``outside''.  In
3DLDF, the constructors generally generate |Points| moving about the
figure in the counter-clockwise direction (as seen from a |Point| with
a positive y-coordinate).  However, according to Huw
Jones, {\it Computer Graphics Through Key Mathematics}, p.~197,
``outside'' is considered to be the side of a plane, where the
|Points| are meant to be traversed in the clockwise direction.  
@:!!@> !! Watch out for problems that may arise from this discrepancy!
\LOG
\initials{LDF 2002.11.05.}  Rewrote this function.

\initials{LDF 2003.06.04.}  Changed sign of the normal, when it's returned, in
the cases where a proper normal is found 
(not |INVALID_POINT| or |origin|).  See explanation above.

\initials{LDF 2004.06.08.}  Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Path| functions@>=
virtual
Point
get_normal(void) const;

@q **** (4) Definition.@>
@ 
@<Define |Path| functions@>=
Point
Path::get_normal(void) const
{
  volatile bool DEBUG = false; /* |true| */@; 

  if (DEBUG)
  {
     cerr_mutex.lock(); 
     cerr << "Entering Path::get_normal().\n";
     cerr_mutex.unlock(); 
  }

  Point origin_pt(0, 0, 0);

  if (points.size() <= 0)
    {
      cerr_mutex.lock(); 
      cerr << "WARNING! In Path::get_normal():\n"
        << "Path is empty or contains only one Point. "
        << "Returning INVALID_POINT.\n\n";
      cerr_mutex.unlock();  

      return INVALID_POINT;

    }

@ \initials{LDF 2002.11.05.}  Connectors other than the ones in the conditional
below could cause the |Path| to be non-linear or non-planar, even if
the |Points| lie on a line or in a plane.
@<Define |Path| functions@>=

  for (vector<string>::const_iterator iter = connectors.begin();
       iter != connectors.end(); ++iter)
  {
    if (!(*iter == ".." || *iter == "--"
        || *iter == "..." || *iter == "---"))
      {
        cerr_mutex.lock(); 
        cerr << "WARNING! In Path::get_normal():\n"
             << "Connector may make Path non-linear or non-planar: " 
             << *iter << endl << "Returning INVALID_POINT.\n\n";
        cerr_mutex.unlock();  

        return INVALID_POINT;
      }
  }

@ \initials{LDF 2002.11.05.}  Two points determine a line.  

\LOG
\initials{LDF 2004.12.07.}
Commented-out warning.
\ENDLOG 

@<Define |Path| functions@>=
  if (points.size() == 2)  
  {
#if 0 
      cerr << "WARNING! In Path::get_normal():\n"
           << "Path has 2 Points.  Returning origin_pt.\n\n";
#endif 
      return origin_pt;
  }

@
@<Define |Path| functions@>=

  vector<Point*>::const_iterator iter = points.begin();

  Point p0(**iter++);
  Point p1(**iter++);
  Point p2;
  
  Point a0(p1 - p0);

  Point a1;
  Point b0;

  while(b0 == origin_pt && iter != points.end())
  {
    p2 = **iter++;
    a1 = p2 - p0;
    b0 = a0.cross_product(a1);
  }
  
  if (iter == points.end() && b0 == origin_pt)
  {
    if (DEBUG) 
    {
        cerr_mutex.lock(); 
        cerr << "Exiting Path::get_normal(). "
             << "Points are all colinear.\n"
             << "Returning origin_pt.\n\n";
        cerr_mutex.unlock();  
    }

    return origin_pt;
  }

#if DEBUG_COMPILE
  else if (DEBUG)
  {
    cerr_mutex.lock(); 
    cerr << "Exiting Path::get_normal(). "
         << "Points are not all colinear.\n";
    cerr_mutex.unlock();  
          
  }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

  if (DEBUG) 
  {
      b0.show("b0");
  }

  b0.unit_vector(true);

  if (iter == points.end() && b0 != origin_pt)
    {
      if (DEBUG)
        {
          cerr << "Exiting Path::get_normal(). " 
               << "Points are all colinear except for one.\n"
               << "Returning normal.\n\n";

        }
      return -b0;
    }

  Point b1;

  if (DEBUG)
  {
    cerr_mutex.lock(); 
    cerr << "Entering second while." << endl;
    cerr_mutex.unlock();  
  }

  while(iter != points.end())
    {
      p2 = **iter++;
      a1 = p2 - p0;
      b1 = a0.cross_product(a1);

      if (b1 != origin_pt)  /* \initials{LDF 2002.11.03.}  This |if| merely prevents
                            a warning from being issued 
                            by |unit_vector|.  */
        b1.unit_vector(true);

      if (DEBUG) 
      {
         b1.show("b1");
      }

      if (!(b1 == origin_pt || b1 == b0 || b1 == -b0))
        {
          if (DEBUG)
          {
            cerr_mutex.lock(); 
            cerr << "Exiting Path::get_normal(). " 
                 << "Returning INVALID_POINT.\n\n";
            cerr_mutex.unlock();  
          }

          return INVALID_POINT;
        }
    }

  if (DEBUG)
  {
    cerr_mutex.lock(); 
    cerr << "Exiting Path::get_normal(). " 
         << "Returning normal." << endl;
    cerr_mutex.unlock();  
  }

  return -b0;

}  /* End of |Path::get_normal(void) const|  */

@q *** (3) |Point| version.@>
@*2 {\bf Point} version.
@^\cfunc{Point}{get\_normal}@>
|Point::get_normal| is declared \filename{points.web}, but it must
be defined here, because it calls |Path::get_normal|.  
\initials{LDF 2003.07.11.}  

\LOG
\initials{LDF 2003.07.11.}  Added this function.
\ENDLOG 
@<Define |Point| functions@>=
Point
Point::get_normal(const Point& p, const Point& q) const
{
  Path r;
  r.set_connectors("--");
  r += *this;
  r += p;
  r += q;

  if (!r.is_planar())
    {
      cerr_mutex.lock(); 
      cerr << "ERROR! In Point::get_normal():\n"
           << "The Points do not determine a plane.\n"
           << "Returning INVALID_POINT.\n\n";
      cerr_mutex.unlock();  
      return INVALID_POINT;
    }
  
  else
    return r.get_normal();
}

@q ** (2) Get plane.@>
@*1 Get plane.
@^\cfunc{Path}{get\_plane}@>

\LOG
\initials{LDF 2002.11.05.}  
Rewrote this function to correspond to the new
definition of |get_normal|.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
Plane
get_plane(void) const;

@ 
@<Define |Path| functions@>=
Plane
Path::get_plane(void) const
{
  Point normal(get_normal());

  Point origin_pt(0, 0, 0);

  if (normal == INVALID_POINT || normal == origin_pt)
    {
      cerr_mutex.lock(); 
      cerr << "WARNING! In Path::get_plane().\n"
           << "Path is not a Plane. Returning `INVALID_PLANE'."
           << endl;
      cerr_mutex.unlock();  
      return INVALID_PLANE;
    }

  Point point(get_point(0));
  return Plane(point, normal);
}

@q ** |Point| lies within triangle.@>
@ {\bf Point} lies within triangle.
\initials{LDF 2003.06.11.}  Declared in \filename{points.web}.  Must be defined
here, because |Path| is an incompletely defined type there.  

\LOG
\initials{LDF 2003.06.11.}  
Added this function.

\initials{LDF 2003.06.24.}  
Removed the argument |test_points|.  Now, planarity
is always tested.

\initials{LDF 2003.06.24.}  
@:BUG FIX@> BUG FIX:  When the |Points| all lay in
the x-z plane, or a plane parallel to it,\newline
|lambda_denominator| was 0.
This caused |is_in_triangle| to return |false|, even when |*this|
did lie in the triangle.  Now, if |lambda_denominator| or 
|mu_denominator| is equal to 0, the y and z-coordinates 
are exchanged, and |lambda_denominator| and
|mu_denominator| are recalculated.  If either of the new values is 0, 
the x and z-coordinates are exchanged (based on the original
coordinate values), and |lambda_denominator| and
|mu_denominator| are again recalculated.  Only one exchange has been
needed in the cases I've tested so far.  

\initials{LDF 2003.08.14.}  Setting |verbose| to |true| if |VERBOSE_GLOBAL| is
|true|.  Added |VERBOSE_GLOBAL| to\newline
\filename{pspglb.web} today.
\ENDLOG

@<Define |Point| functions@>=
bool
Point::is_in_triangle(const Point& p0,
               const Point& p1,
               const Point& p2,
               bool verbose) const
{
  bool DEBUG = false; /* |true| */@; 

  if (VERBOSE_GLOBAL)
    verbose = true;

  Path q;
  q += p0;
  q += p1;
  q += p2;
   
  Plane q_pl = q.get_plane();

  if (q_pl == INVALID_PLANE)
    {
      if (verbose)
        {
          cerr << "WARNING! In Point::is_in_triangle():\n"
            << "The Point arguments do not determine a plane.\n"
              << "Returning false.\n\n";
        }
      return false;
    }
  else if (!is_on_plane(q_pl))
    {
      if (verbose)
        {
          cerr << "WARNING! In Point::is_in_triangle():\n"
            << "*this doesn't lie in the plane determined "
              << "by the arguments.\n"
                << "Returning false.\n\n";
            }
      return false;
    }

  Point t(*this);
  Point c(p0);
  Point d(p1);
  Point e(p2);

  t.apply_transform();
  c.apply_transform();
  d.apply_transform();
  e.apply_transform();

  if (DEBUG)
    {
      show("t:");
      c.show("c:");
      d.show("d:");
      e.show("e:");
    }

  real t_x = t.world_coordinates[0];
  real t_y = t.world_coordinates[1];
  real t_z = t.world_coordinates[2];

  real c_x = c.world_coordinates[0];
  real c_y = c.world_coordinates[1];
  real c_z = c.world_coordinates[2];

  real d_x = d.world_coordinates[0];
  real d_y = d.world_coordinates[1];
  real d_z = d.world_coordinates[2];

  real e_x = e.world_coordinates[0];
  real e_y = e.world_coordinates[1];
  real e_z = e.world_coordinates[2];

  real lambda_denominator = (((e_x - c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x)));
  real mu_denominator = ((e_x -  c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x));

  bool exchange_y_z = false;
  bool exchange_x_z = false;
  if (lambda_denominator == ZERO_REAL || mu_denominator == ZERO_REAL)
    {
      if (DEBUG)
        cerr << "lambda_denominator or mu_denominator == 0. "
             << "Exchanging y and z-coordinates.\n";
      real temp;

      temp = t_y;
      t_y = t_z;
      t_z = temp;
          
      temp = c_y;
      c_y = c_z;
      c_z = temp;

      temp = d_y;
      d_y = d_z;
      d_z = temp;

      temp = e_y;
      e_y = e_z;
      e_z = temp;
    
      lambda_denominator = (((e_x - c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x)));
      mu_denominator = ((e_x -  c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x));

      if (!(lambda_denominator == ZERO_REAL || mu_denominator == ZERO_REAL))
        {
          if (DEBUG)
            cerr << "Exchanging y and z-coordinates worked.\n" 
                 << "lambda_denominator and mu_denominator are no longer 0.\n";

          exchange_y_z = true;
        }
      else
        {
          if (DEBUG)
            cerr << "Exchanging y and z-coordinates didn't work.\n" 
                 << "Exchanging x and z-coordinates.\n";

@ First, put things back the way they were.
It's wasteful, but less confusing.  \initials{LDF 2003.06.24.}  
@<Define |Point| functions@>=          
          temp = t_y; 
          t_y = t_z;
          t_z = temp;

          temp = c_y; 
          c_y = c_z;
          c_z = temp;

          temp = d_y; 
          d_y = d_z;
          d_z = temp;
          
          temp = e_y; 
          e_y = e_z;
          e_z = temp;

@ Now, exchange the x and z-coordinates.  \initials{LDF 2003.06.24.}
@<Define |Point| functions@>=          
          temp = t_x;
          t_x = t_z;
          t_z = temp;

          temp = c_x;
          c_x = c_z;
          c_z = temp;
          
          temp = d_x;
          d_x = d_z;
          d_z = temp;

          temp = e_x;
          e_x = e_z;
          e_z = temp;

          lambda_denominator = (((e_x - c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x)));
          mu_denominator = ((e_x -  c_x) * (d_y - c_y)) - ((e_y - c_y) * (d_x - c_x));

          if (!(lambda_denominator == ZERO_REAL || mu_denominator == ZERO_REAL))
            {
              if (DEBUG)
                cerr << "Exchanging x and z-coordinates worked.\n" 
                  << "lambda_denominator and mu_denominator are no longer 0.\n";

              exchange_x_z = true;
            }
          else
            {
              if (verbose || DEBUG)
                {
                  cerr << "WARNING! In Point::is_in_triangle():\n"
                    << "lambda_denominator or mu_denominator is 0.\n"
                      << "Returning false.\n\n";
                }
              return false;
            }
        }
    }
  
  real lambda =   (((t_x - c_x) * (d_y - c_y)) - ((t_y - c_y) * (d_x - c_x)))
    / lambda_denominator;

  real mu =   -((((t_x - c_x) * (e_y - c_y)) - ((t_y - c_y) * (e_x - c_x)))
           / mu_denominator);

  if (DEBUG)
    {
      cerr << "lambda == " << lambda << endl;
      cerr << "mu == " << mu << endl;
      cerr << "lambda + mu == " << lambda + mu << endl;

      cerr << "(lambda >= 0 && mu >= 0 && ((lambda + mu) <= 1)) == "
           << (lambda >= 0 && mu >= 0 && ((lambda + mu) <= 1)) << endl;
    }
 
  bool b = (lambda >= 0 && mu >= 0 && ((lambda + mu) <= 1));
  
  if (verbose)
    {
      cerr << "In Point::is_in_triangle:\n";
      if (b)
        cerr << "The Point lies within the triangle. "
             << "Returning true.";
      else
        cerr << "The Point doesn't lie within the triangle. "
             << "Returning false."; 
      cerr << endl << endl;
    }
  return b;  
}

@q * (1) Manipulating {\bf Paths}.@>
@* Manipulating {\bf Paths}.

@q ** (2) Set cycle. @>
@*1 Set cycle.
@^\cfunc{Path}{set\_cycle}@>

\LOG
\initials{LDF 2002.4.7.}  
Changed, so that the argument |bool c| is |true| by
default. 

\initials{LDF 2002.11.05.}  
Made |bool c| argument |const|.

\initials{LDF 2004.11.01.}
Now removing excess connectors, if 
|c == false && connectors.size() >= points.size|. 

\initials{LDF 2004.11.01.}
@:BUG FIX@> BUG FIX:  Now making sure that |connectors.size() > 0| 
before calling |connectors.pop_back|.

\initials{LDF 2005.11.18.}
Made this function virtual.  Added optional |Scanner_Node scanner_node| 
argument with default 0.  Changed return type from |void| to |int|.
\ENDLOG 

@<Declare |Path| functions@>=
virtual
int
set_cycle(const bool c = true, Scanner_Node scanner_node = 0);

@
@<Define |Path| functions@>=
int
Path::set_cycle(const bool c, Scanner_Node scanner_node)
{
 
#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */
   if (DEBUG)
     {
         cerr << "Entering `Path::set_cycle':  `c' == " << c << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

  cycle_switch = c;

  if (c == false)
   {
    
    vector<string>::size_type i = connectors.size();
    vector<Point*>::size_type j = points.size();

    while (i > 0 && i >= j)
       {
          connectors.pop_back();
          --i;
       }

   } /* |if (c == false)|  */

    return 0;

}  /* End of |Path::set_cycle| definition.  */

@q ** (2) Adjust connectors. @>
@*1 Adjust connectors.
@^\cfunc{Path}{adjust\_connectors}@>
\initials{LDF 2004.11.01.}

\LOG
\initials{LDF 2004.11.01.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
void 
adjust_connectors(void);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
void 
Path::adjust_connectors(void)
{
  
  vector<string>::size_type i = points.size();

  if (!cycle_switch)
   --i;

@q **** (4) If |connectors.size() > i|, pop excess connectors.@>   

@ If |connectors.size() > i|, pop excess connectors.
\initials{LDF 2004.11.01.}

@<Define |Path| functions@>=

  while (connectors.size() > i)
     connectors.pop_back();

@q **** (4) If |connectors.size() < i|, fill it up with copies of   @>   
@q **** (4) the last connector, or |--|, if there are no connectors.@>   

@ If |connectors.size() < i|, fill it up with copies of      
the last connector, or |--|, if there are no connectors.   
\initials{LDF 2004.11.01.}

@<Define |Path| functions@>=

  if (connectors.size() < i)
    {
       string last_connector;

       if (connectors.size() == 0)
          last_connector = "--";
       else
          last_connector = connectors.back();

       while (connectors.size() < i)
         connectors.push_back(last_connector);
  
    } /* |if (connectors.size() < i)|  */

} /* End of |Path::adjust_connectors| definition.  */

@q ** (2) Adjust |draw_color_vector|.@>
@*1 Adjust {\bf draw\_color\_vector}.
@^\cfunc{Path}{adjust\_draw\_color\_vector}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
int
adjust_draw_color_vector(void);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::adjust_draw_color_vector(void)
{
   if (   draw_color_vector == static_cast<Pointer_Vector<Color>*>(0) 
       || draw_color_vector->ctr <= 0)
      return 1;

   int i = 0;
   int j = draw_color_vector->ctr;
   int k = points.size();

   if (!cycle_switch)
      --k;

   Color* c;

   while (j < k)
      {
         c = create_new<Color>(draw_color_vector->v[i++]);
         *draw_color_vector += c;
         ++j;
      }

   return 0;

} /* End of |Path::adjust_draw_color_vector| definition.  */

@q ** (2) Adjust |pen_vector|.@>
@*1 Adjust {\bf pen\_vector}.
@^\cfunc{Path}{adjust\_pen\_vector}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
int
adjust_pen_vector(void);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::adjust_pen_vector(void)
{
   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0) || pen_vector->ctr <= 0)
      return 1;

   int i = 0;
   int j = pen_vector->ctr;
   int k = points.size();

   if (!cycle_switch)
      --k;

   Pen* c;

   while (j < k)
      {
         c = create_new<Pen>(pen_vector->v[i++]);
         *pen_vector += c;
         ++j;
      }

   return 0;

} /* End of |Path::adjust_pen_vector| definition.  */

@q ** (2) Adjust |dash_pattern_vector|.@>
@*1 Adjust {\bf dash\_pattern\_vector}.
@^\cfunc{Path}{adjust\_dash\_pattern\_vector}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Path| functions@>=
int
adjust_dash_pattern_vector(void);

@q *** (3) Definition.@> 

@
@<Define |Path| functions@>=
int
Path::adjust_dash_pattern_vector(void)
{
   if (   dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0) 
       || dash_pattern_vector->ctr <= 0)
      return 1;

   int i = 0;
   int j = dash_pattern_vector->ctr;
   int k = points.size();

   if (!cycle_switch)
      --k;

   Dash_Pattern* c;

   while (j < k)
      {
         c = create_new<Dash_Pattern>(dash_pattern_vector->v[i++]);
         *dash_pattern_vector += c;
         ++j;
      }

   return 0;

} /* End of |Path::adjust_dash_pattern_vector| definition.  */

@q ** (2) Reverse.@>
@*1 Reverse.

@q *** (3) With assignment.@>
@*2 With assignment.
@^\cfunc{Path}{reverse}@>

\LOG
\initials{LDF 2002.4.6.}  
Added this function.

\initials{LDF 2003.07.16.}  
Added error handling code for the case that this
function is called with |assign == false|.  I've now added a |const|
version, so there's no need to call this version with 
|assign == false|.  If |assign| is |false|, the |const| version is
called, so I could simplify the code in this version.

\initials{LDF 2004.11.25.}
Added optional |Scanner_Node scanner_node| argument 
with default 0 and made the debugging output thread-safe.

\initials{LDF 2004.11.25.}
Rewrote this function.  Now, it can reverse cyclical |Paths|.

\initials{LDF 2004.11.26.}
Changed the |assign| argument from |bool| to |int|.  
The way it was before caused the following 
compilation error:\hfil\break
``paths.web:6990: error: ISO C++ says that `Path Path::reverse(Scanner\_Type*) 
const' and `Path Path::reverse(bool, Scanner\_Type*)' are ambiguous even 
though the worst conversion for the former is better than the worst 
conversion for the latter''
\ENDLOG 

@<Declare |Path| functions@>=
Path
reverse(int assign, Scanner_Node scanner_node = 0);

@ 
@<Define |Path| functions@>=
Path
Path::reverse(int assign, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  using namespace Scan_Parse;

@q **** (4) No assignment.  Call |const| version.@>
@ No assignment.  Call |const| version.
The latter simply creates a local copy of |*this|,
calls this function on it with |assign == 1|, 
and returns the return value of this function.
\initials{LDF 2004.11.25.}

@<Define |Path| functions@>=

   if (!assign)
      return reverse(scanner_node);

@q **** (4) Adjust connectors.@> 
@ Adjust connectors.
If there isn't an explicit connector for every pair of |Points| in
|points|, |connectors| must be filled up so that there is.
Otherwise, the connectors and the |Points| may not match up properly 
when they are reversed.  In addition, if |*this| 
is a |cycle|, the last |connector| must be saved and popped off the 
back of |connectors|.  Otherwise, it will be the first |connector| 
in the reversed |Path|, which isn't what we want.
\initials{LDF 2004.11.25.}

@<Define |Path| functions@>=

   if (connectors.size() == 0)
      connectors.push_back("--");   

   string last_connector = connectors.back();

   while (connectors.size() < points.size() - 1)
      connectors.push_back(last_connector);

   while (connectors.size() > points.size() - 1)
        connectors.pop_back();

@q **** (4).@> 

@ If I don't explicitly refer to the |std| namespace here, this function is called, and since the 
arguments are different from the one used for this function, this causes an error at compile time.  
\initials{LDF 2002.4.7.}

@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr_strm << thread_name 
                   << "In `Path::reverse':  "
                   << "Reversing connectors and points.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str();

      } /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;

  std::reverse(connectors.begin(), connectors.end());
  std::reverse(points.begin(), points.end());

  if (is_cycle())
    connectors.push_back(last_connector);

#if DEBUG_COMPILE
   if (DEBUG)
      {

          cerr_mutex.lock(); 
          cerr_strm << thread_name 
                    << "In `Path::reverse':  "
                    << "Showing connectors:" << endl; 

          for(vector<string>::iterator iter = connectors.begin();
              iter != connectors.end();
              iter++)
            cerr_strm << *iter << endl;

          cerr_strm << "Showing points:" << endl;

          log_message(cerr_strm); 
          cerr << cerr_strm.str();
          cerr_strm.str();
          cerr_mutex.unlock(); 

          for(vector<Point*>::iterator iter = points.begin();
              iter != points.end();
              iter++)
            (**iter).show();

      } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  return *this;

}  /* End of non-const |Path::reverse| definition.  */

@q *** (3) No assignment.@>
@*2 No assignment.
@^\cfunc{Path}{reverse}@>

This version merely copies |*this| and calls |reverse(true)| on the
copy, returning the return value of that function call.
\initials{LDF 2003.07.16.}  

\LOG
\initials{LDF 2003.07.16.}  
Added this function.

\initials{LDF 2004.11.25.}
Added optional |Scanner_Node scanner_node| argument with default 0.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Path| functions@>=
Path
reverse(Scanner_Node scanner_node = 0) const;

@q **** (4) Definition.@> 

@ 
@<Define |Path| functions@>=
Path
Path::reverse(Scanner_Node scanner_node) const
{
  Path p = *this;
  return p.reverse(1, scanner_node);
}

@q * (1) Equality.@>
@* Equality.
@^\cofunc{Path}{==}@>
@:!! TO DO@> TO DO: 
I'll need to make all connectors explicit in order to make
this work.  See |operator&| for an example of how to make this work.
@<Declare |Path| functions@>=
#if 0 
virtual
bool
operator==(Path& p);
#endif 

@ 
@<Define |Path| functions@>=
#if 0 
virtual
bool
Path::operator==(Path& p)
{

}
#endif 

@q * (1) Intersection.@>
@* Intersection. 

@q ** (2) Intersection of two linear |Paths|.@>
@*1 Intersection of two linear {\bf Paths}.
@^\cfunc{Path}{intersection\_point}@> 
If |*this| is a line and the argument |pa| is a line,\newline 
|intersection_point| calls the version for
|Points| in \filename{points.web}.

Other kinds of |Paths| and other classes will need their own versions
of this function. 

I may have a problem with the constancy of |*this| and |pa|.  If I do,
just remove it.

\LOG
\initials{LDF 2002.04.15.}  Changed return value from |Bool_Real_Point| to
|Bool_Point|, since I've had to comment-out the version of
|Point::intersection_point| that uses the |Line| version.

\initials{LDF 2002.04.10.}  Changed return type to |Bool_Real_Point| to
correspond with the same change to |Point::intersection_point|. 

\initials{LDF 2003.07.04.}  Added |trace| argument.  Added conditional using
|trace| to choose which version of |Point::intersection_point|
should be called.  Changed so that
|is_linear| is used instead of\newline
|get_line_switch|.  Now using
|get_last_point| instead of |*points[1]|.
\ENDLOG 

@q *** (3) Declaration.@>   

@<Declare |Path| functions@>=
Bool_Point
intersection_point(const Path& pa, const bool trace = false) const;
                   
@q *** (3) Definition.@>   

@
@<Define |Path| functions@>=
Bool_Point
Path::intersection_point(const Path& pa, const bool trace) const
{

    if (is_linear() && pa.is_linear())
      {
        if (trace)
          return Point::intersection_point(*points[0],
                                           get_last_point(),
                                           *pa.points[0],
                                           pa.get_last_point(),
                                           trace);
        else
          return Point::intersection_point(*points[0],
                                           get_last_point(),
                                           *pa.points[0],
                                           pa.get_last_point(),
                                           trace);
      }

    else
      {
          cerr << "Haven't coded this case yet. "
               << "Returning INVALID_BOOL_POINT.\n";
          return INVALID_BOOL_POINT;
      }

}  /* End of |Path::intersection_point| definition.  */

@q ** (2) Intersection points.@> 
@*1 Intersection points.
\initials{LDF 2005.10.27.}
Dummy function.  It simply calls |intersection_point|.  It's needed in 
|Scan_Parse::intersection_points_func|.

\LOG
\initials{LDF 2005.10.27.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@>   

@<Declare |Path| functions@>=
Bool_Point
intersection_points(const Path& p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@>   

@
@<Define |Path| functions@>=
Bool_Point
Path::intersection_points(const Path& p, Scanner_Node scanner_node) const
{
   return intersection_point(p);
}

@q ** (2) Intersection of a linear |Path| with a |Plane|.@>
@*1 Intersection of a linear {\bf Path} with a {\bf Plane}.
@^\cfunc{Plane}{intersection\_point}@> 
\initials{LDF 2003.06.03.}  

This function must be defined here, because |Path| is  
an incomplete type in \filename{planes.web}.
\initials{LDF 2003.06.03.}  

\LOG
\initials{LDF 2003.06.03.}  
Added this function.
\ENDLOG 

@<Define |Plane| functions@>=
Bool_Point
Plane::intersection_point(const Path& p) const
{
  if (p.is_linear())
    return intersection_point(p.get_point(0), p.get_last_point());
  else
    {
      cerr << "ERROR! In Plane::intersection_point(const Path&):"
           << endl << "Path is not linear!  Returning INVALID_BOOL_POINT."
           << endl << endl;
      return INVALID_BOOL_POINT;
    }
}

@q * (1) Drawing axes.@>
@* Drawing axes.
This function draws and labels arrows for the main axes at the
origin.  It can be helpful for determining whether the ``|up|''
direction is correct for a |Focus|.

\initials{LDF 2003.04.01.}  Sometimes placeholders are needed for the |dist|
and position arguments.
If |dist| is a number $x\leq 0$, then it's 
set to the default, currently 2.5.  If a position argument (|pos_x|,
|pos_y|, or |pos_z|) is |"d"|, it's set to the default.

\LOG
\initials{LDF 2003.02.05.}  Moved this function from \filename{main.web} to here,
so I can use it in my examples for the Texinfo documentation.  Also,
added additional arguments specifying the positions of labels and 
suppressing drawing the axes (and their labels).

\initials{LDF 2003.04.01.}  Added arguments for dash pattern (|ddashed|) and pen
(|ppen|).  Rearranged order of arguments.  Also, got rid of the
arguments |suppress_x|, |suppress_y|, and |suppress_z|.  Now using the
empty string (|""|) in the arguments |pos_x|, |pos_y|, and |pos_z| to
indicate that the corresponding axes should be suppressed.  Added
error handling code that prints a warning to |stderr| if all axes are
suppressed.  (\initials{LDF 2003.05.06.}  Note that |""| will never be needed for
labelling an axis, because putting the label on top of the |Point|
would interfere with the arrow.)  

\initials{LDF 2003.04.01.}  Added arguments |shift_x|, |shift_y|, and |shift_z|
for adjusting the position of the labels.  Note that the adjustment
affects the position of the three-dimensional |Point| within the
|Label|, {\it not\/} the two-dimensional projected point.  Therefore,
it's not possible to adjust the position of the |Label| precisely
without changing the Metapost code.  @:!! TO DO@> TO DO:  Change
|label|, so that it's possible to adjust the position of the points
in the projection!  This may open a can of worms, though, especially
if the same code is used to generate drawings using different
projections and/or different |Focuses|.    

\initials{LDF 2003.07.13.}  Made |ddashed| and |ppen const| in both versions.
\ENDLOG 

@q ** Length argument first.@>
@ Length argument first.

\LOG
\initials{LDF 2004.05.02.}  Changed calls to the |Point| constructor
taking three |real| arguments.  It now requires three explicit |real|
arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.

\initials{LDF 2004.05.25.}  Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}
Changed |const Color& ddraw_color| to |const Color* ddraw_color|,
and |const string ppen| to |const Pen* ppen|.

\initials{LDF 2004.06.03.}  Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  Changed |const string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2004.06.08.}  Changed the |const Point&| arguments |shift_x|, 
|shift_y|, and |shift_z| to |const Point*|, and changed their defaults from
|origin| to 0.  Now declaring and setting the |Points| |origin_pt|, 
|x_pt|, |y_pt|, and |z_pt| locally.  If |shift_x != 0|, then I set |x_pt| to 
|*shift_x|, otherwise I set it to |origin_pt == (0, 0, 0)|.  |y_pt| and |z_pt|
are set analogously.

\initials{LDF 2004.06.08.}  
These changes were necessary, because
I've removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@q *** Declaration.@>

@<Declare |draw_axes|@>=
void
draw_axes(Picture& picture,
          real dist = 2.5,
          string pos_x = "bot",
          string pos_y = "lft",
          string pos_z = "bot",
          const Color* ddraw_color = 0,
          const Dash_Pattern* ddash_pattern = 0,
          const Pen* ppen = 0,
          const Point* shift_x = 0,
          const Point* shift_y = 0,
          const Point* shift_z = 0); 

@q *** Definition.@>
@
@<Define |draw_axes|@>=
void
draw_axes(Picture& picture,
          real dist, 
          string pos_x,
          string pos_y,
          string pos_z,
          const Color* ddraw_color, 
          const Dash_Pattern* ddash_pattern,
          const Pen* ppen,
          const Point* shift_x,
          const Point* shift_y,
          const Point* shift_z) 
{

@
@:!!@> Remember to change this if you change any of the defaults!  

\LOG
\initials{LDF 2003.04.01.}  Added this section.
\ENDLOG 
@<Define |draw_axes|@>=

  if (dist <= 0) 
    dist = 2.5;

  if (pos_x == "d")
    pos_x = "bot";
  if (pos_y == "d")
    pos_y = "lft";
  if (pos_z == "d")
    pos_z = "bot";

Point origin_pt(0, 0, 0);
  Point x_pt;
  Point y_pt;
  Point z_pt;

x_pt = (shift_x != static_cast<const Point*>(0)) ? *shift_x : origin_pt;
  y_pt = (shift_y != static_cast<const Point*>(0)) ? *shift_y : origin_pt;
  z_pt = (shift_z != static_cast<const Point*>(0)) ? *shift_z : origin_pt;

@  
\LOG
\initials{LDF 2003.04.01.}  Added this error handling code.  
\ENDLOG 
@<Define |draw_axes|@>=
  if (pos_x == "" && pos_y == "" && pos_z == "") 
    {
      cerr << "WARNING! In draw_axes():" << endl 
           << "All axes are suppressed. Returning." 
           << endl << endl;
      return;
    }

@  
@<Define |draw_axes|@>=
if (pos_x != "")
{
  Point x0(-dist, 0, 0);
  Point x1(dist, 0, 0);
  x0.drawarrow(picture, x1, ddraw_color, ddash_pattern, ppen);
  x1 += x_pt;
  x1.label(picture, "x", pos_x, 0);
}

if (pos_y != "")
{
  Point y0(0, -dist, 0);
  Point y1(0, dist, 0);
  y0.drawarrow(picture, y1, ddraw_color, ddash_pattern, ppen);
  y1 += y_pt;
  y1.label(picture, "y", pos_y, 0);
}
if (pos_z != "")
{
  Point z0(0, 0, -dist);
  Point z1(0, 0, dist);
  z0.drawarrow(picture, z1, ddraw_color, ddash_pattern, ppen);
  z1 += z_pt;
  z1.label(picture, "z", pos_z, 0);
}
return;
}

@q ** Color argument second.@>
@ {\bf Color} argument second.
\LOG
\initials{LDF 2003.05.02.}  Added this function.

\initials{LDF 2004.05.25.}  Changed the arguments, so that 
|Picture& picture| is first.  Formerly, |current_picture| was the 
default for |picture|, but I'm changing the way |current_picture| is
used. 

\initials{LDF 2004.06.07.}  Changed |const string ddashed = ""| to 
|const Dash_Pattern* ddash_pattern = 0|.

\initials{LDF 2004.06.08.}  Changed the |const Point&| arguments |shift_x|, 
|shift_y|, and |shift_z| to |const Point*|, and changed their defaults from
|origin| to 0.  

\initials{LDF 2004.06.08.}  
These changes were necessary, because
I've removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.06.08.}
See the log entry of this date for the preceding version of this function for a 
complete explanation.
\ENDLOG 

@<Declare |draw_axes|@>=
void
draw_axes(Picture& picture,
          const Color* ddraw_color,
          real dist = 2.5,
          string pos_x = "bot",
          string pos_y = "lft",
          string pos_z = "bot",
          const Dash_Pattern* ddash_pattern = 0,
          const Pen* ppen = 0,
          const Point* shift_x = 0,
          const Point* shift_y = 0,
          const Point* shift_z = 0); 

@
@<Define |draw_axes|@>=
void
draw_axes(Picture& picture,
          const Color* ddraw_color,
          real dist, 
          string pos_x,
          string pos_y,
          string pos_z,
          const Dash_Pattern* ddash_pattern,
          const Pen* ppen,
          const Point* shift_x,
          const Point* shift_y,
          const Point* shift_z) 
{
  draw_axes(picture, dist, pos_x, pos_y, pos_z, ddraw_color, ddash_pattern,
            ppen, shift_x, shift_y, shift_z);
}

@q * |Paths| and |Lines|.@>
@ {\bf Paths} and {\bf Lines}.
\LOG
\initials{LDF 2003.06.06.}  Added this heading.
\ENDLOG 

@q ** Get |Line|.@>
@ Get {\bf Line}.
@^\cfunc{Path}{get\_line}@>
Returns a |Line| corresponding to |*this|, if |*this| is linear.
Otherwise, |get_line| returns |INVALID_LINE|.
\LOG
\initials{LDF 2003.06.06.}  Added this function.
\ENDLOG 
@<Declare |Path| functions@>=
Line
get_line(void) const;

@
@<Define |Path| functions@>=
Line
Path::get_line(void) const
{
  if (is_linear())
    return points.front()->get_line(*(points.back()));
  else
    {
      cerr << "ERROR! In Path::get_line():\n"
           << "Path is not linear. Returning INVALID_LINE.\n\n";
      return INVALID_LINE;
    }
}

@q ** Get |Path|.@>
@ Get {\bf Path}.
@^\cfunc{Line}{get\_path}@>
Declared in \filename{lines.web}.  Must be defined here,
because |Path| is an incomplete type there.
\LOG
\initials{LDF 2003.06.06.}  Added this function.
\ENDLOG 
@<Define |Line| functions@>=
Path
Line::get_path(void) const
{
  Point p(position + direction);
  return Path(position, p);
}

@q * (1) Surface Hiding.@>
@* Surface Hiding.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this section.
\ENDLOG

@q ** (2) Set |surface_hiding_ctr|.@> 
@*1 Set {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
void
set_surface_hiding_ctr(unsigned long u)
{
   surface_hiding_ctr = u;
}

@q ** (2) Reset |surface_hiding_ctr|.@> 
@*1 Reset {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
unsigned long
reset_surface_hiding_ctr(unsigned long u = 0)
{
   unsigned long old_value = surface_hiding_ctr;
   surface_hiding_ctr = u;
   return old_value;
}

@q ** (2) Get |surface_hiding_ctr|.@> 
@*1 Get {\it surface\_hiding\_ctr}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
unsigned long
get_surface_hiding_ctr(void)
{
   return surface_hiding_ctr;
}

@q ** (2) Set |decomposition_level|.@> 
@*1 Set {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
void
set_decomposition_level(unsigned long u)
{
   decomposition_level = u;
}

@q ** (2) Reset |decomposition_level|.@> 
@*1 Reset {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
unsigned long
reset_decomposition_level(unsigned long u = 0)
{
   unsigned long old_value = decomposition_level;
   decomposition_level = u;
   return old_value;
}

@q ** (2) Get |decomposition_level|.@> 
@*1 Get {\it decomposition\_level}.
\initials{LDF 2005.04.18.}

\LOG
\initials{LDF 2005.04.18.}
Added this function.
\ENDLOG

@<Declare |Path| functions@>=
virtual
inline
unsigned long
get_decomposition_level(void)
{
   return decomposition_level;
}

@q ** (2) Decompose.@> 

@*1 Decompose.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this section.
\ENDLOG

@q *** (3) |Point*| argument.@> 
@*2 {\bf Point*} argument.
\initials{LDF 2007.06.19.}

\LOG
\initials{LDF 2007.06.19.}
Added this function.  
\ENDLOG

@q **** (4) Declaration.@> 

@<Declare |Path| functions@>=

virtual 
int
decompose(Point* p, 
          Pointer_Vector<Path>* pv, 
          Scanner_Node scanner_node = 0);

@q **** (4) Definition.@> 
@
@<Define |Path| functions@>=
int
Path::decompose(Point* p, 
                Pointer_Vector<Path>* pv, 
                Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << "Entering `Path::decompose(Point*, ...)'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling:  |Point* p| and/or @>
@q ***** (5) |Pointer_Vector<Path>* pv| is null.@> 
@ Error handling:  |Point* p| and/or |Pointer_Vector<Path>* pv| 
is null.
\initials{LDF 2007.06.19.}

@<Define |Path| functions@>=

   if (p == static_cast<Point*>(0) || pv == static_cast<Pointer_Vector<Path>*>(0))
   {
       cerr_strm << "ERROR! In `Path::decompose':"
                 << endl
                 << "`Point* p' and/or `Pointer_Vector<Path>* pv' is null.  "
                 << "Deleting `p' and `pv', setting them to 0, "
                 << "and exiting with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete p;
       p = 0;

       delete pv;
       pv = 0;
  
       return 1;

   }  /* |if (p == 0)|  */

@q ***** (5) |Path| is linear.@>
@ |Path| is linear.
\initials{LDF 2007.06.19.}

@<Define |Path| functions@>=

   if (is_linear())
   {

#if DEBUG_COMPILE
       if (DEBUG)
       {
           cerr_strm << "`Path' is linear.";
           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

       }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6)@> 

       Bool_Real br = p->is_on_segment(*this);

       if (br.first)
       {
#if DEBUG_COMPILE
          if (DEBUG)
          {
             cerr_strm << "`Point' is on segment.";
             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

          }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) |Point| is one of the endpoints of the |Path|.@> 
@ |Point| is one of the endpoints of the |Path|.  Put the
whole |Path| on |pv|.
\initials{LDF 2007.06.19.}

@<Define |Path| functions@>=

         if (br.second == ZERO_REAL || br.second == 1)
         {
#if DEBUG_COMPILE
             if (DEBUG)
             {
                cerr_strm << "`Point' is one of the endpoints of the `Path'.";
                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");

             }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

         }  /* |if (br.second == 0 || br.second == 1)|  */
        
@q ******* (7) Break up the |Path|.@> 
@ Break up the |Path|.
\initials{LDF 2007.06.19.}

@<Define |Path| functions@>=

        else  /* |!(br.second == 0 || br.second == 1)|  */
        {
#if DEBUG_COMPILE
             if (DEBUG)
             {
                cerr_strm << "`Point' is not one of the endpoints of the `Path'."
                          << endl 
                          << "Breaking up the `Path'.";
                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");

             }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

        }   /* |else| (|!(br.second == 0 || br.second == 1)|)  */

@q ******* (7)@> 

      }  /* |if (br.first)| */

@q ****** (6)@> 

       else /* |!br.first|  */
       {

#if DEBUG_COMPILE
          if (DEBUG)
          {
             cerr_strm << "`Point' is not on segment.";
             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

          }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

          delete p;
          p = 0;
 
          return 0; 

       }  /* |else| (|!br.first|)  */

@q ****** (6)@> 

   }  /* |if (is_linear())|  */

@q ***** (5) |Path| is none of the above.@>
@ |Path| is none of the above.
\initials{LDF 2007.06.19.}

@<Define |Path| functions@>=

   else 
   {

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << "This type of `Path' hasn't been accounted for yet.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

      delete p;
      p = 0;
 
      delete pv;
      pv = 0;

      return 1;

   }  /* |else| (Type of |Path| not accounted for)  */

@q ***** (5)@>
@
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << "Exiting `Path::decompose(Point*, ...)'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    delete p;
    p = 0;   

    return 0;

}  /* |Path::decompose| with |Point*| argument.  */

@q *** (3) |Path*| argument.@> 
@*2 {\bf Path*} argument.
\initials{LDF 2005.01.24.}

\LOG
\initials{LDF 2005.01.24.}
Added this function.  Currently, it returns 0 immediately.

\initials{LDF 2005.01.24.}
Added |unsigned short level| argument with default 0.

\initials{LDF 2005.02.01.}
Changed the return value of this function from |Pointer_Vector<Shape>*|
to |Pointer_Vector<Path>*|.  Removed the |unsigned short level|
argument and the default for the |const Path* p| argument.

\initials{LDF 2005.02.01.}
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.02.01.}
Made |Path*| argument non-|const|.

\initials{LDF 2005.04.04.}
Made the |Path*| argument, and this function itself, |const|.

\initials{LDF 2005.04.05.}
Made the |Path*| argument, and this function itself, non-|const| again.
\ENDLOG

@<Declare |Path| functions@>=

virtual 
Pointer_Vector<Path>* 
decompose(Path* p, Scanner_Node scanner_node = 0);

@
@<Define |Path| functions@>=
Pointer_Vector<Path>*
Path::decompose(Path* p, Scanner_Node scanner_node)
{
   return 0;
}

@q *** (3) |Shape*| argument.@> 
@*2 {\bf Shape*} argument.
\initials{LDF 2005.04.01.}

\LOG
\initials{LDF 2005.04.01.}
Added this function.  Currently, it returns 0 immediately.

\initials{LDF 2005.04.04.}
Made the |Shape*| argument, and this function itself, |const|.

\initials{LDF 2005.04.05.}
Made the |Shape*| argument, and this function itself, non-|const| again.
\ENDLOG

@<Declare |Path| functions@>=

virtual 
Pointer_Vector<Shape>* 
decompose(Shape* s, Scanner_Node scanner_node = 0);

@
@<Define |Path| functions@>=
Pointer_Vector<Shape>*
Path::decompose(Shape* s, Scanner_Node scanner_node)
{
   return 0;
}

@q *** (3) Self-decomposition.@> 
@*2 Self-decomposition.
\initials{LDF 2005.04.13.}

\LOG
\initials{LDF 2005.04.14.}
Added this section.
\ENDLOG

@q **** (4) Decompose.@> 
@*3 Decompose.

\LOG
\initials{LDF 2005.04.14.}
Added this function.  It currently returns 0 immediately.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Path| functions@>=

virtual
Pointer_Vector<Shape>*
decompose(const unsigned short limit, 
          const bool use_rectangles = false,
          Scanner_Node scanner_node = 0);

@q ***** (5) Definition.@>   

@
@<Define |Path| functions@>=
Pointer_Vector<Shape>*
Path::decompose(const unsigned short limit, 
                const bool use_rectangles,
                Scanner_Node scanner_node)
{
   return 0;

}  /* End of |Pointer_Vector<Shape>*
              Path::decompose(const unsigned short limit, 
                              const bool use_rectangles,
                              Scanner_Node scanner_node)|
      definition.  */


@q ** (2) Get direction.  @>
@ Get direction.  
\initials{LDF 2021.11.24.}

\LOG
\initials{LDF 2021.11.24.}
Added this function.
\ENDLOG 

@q *** (3) Declaration @>


@<Declare |Path| functions@>=
virtual
Point
get_direction(real ttime, 
              Point *x_axis_point = 0, 
              int x_axis_direction = 1, 
              real *aangle = 0, 
              Scanner_Node scanner_node = 0) const;


@q *** (3) Definition  @>
@
@<Define |Path| functions@>=
Point
Path::get_direction(real ttime, Point *x_axis_point, int x_axis_direction, real *aangle, Scanner_Node scanner_node) const
{
@q **** (4) @>

   int status = 0;

   Point p0 = get_point(0);
   Point p1;
   Point normal;

   Path q0;
   Path q1;

   Point z_axis_pt_positive(0, 0, 1);
   Point z_axis_pt_negative(0, 0, -1);

   Transform t0;
   Transform t1;

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE

   bool DEBUG = true; /* |false| */ 

   if (DEBUG)
   { 
      cerr_strm << thread_name << "Entering `Path::get_direction'." << endl;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

      show("In `Path::get_direction':  *this:");

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   normal = get_normal();   

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "normal == z_axis_pt_positive == " << (normal == z_axis_pt_positive) 
           << endl
           << "normal == z_axis_pt_negative == " << (normal == z_axis_pt_negative) 
           << endl;

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 


   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Path| functions@>=

@q ***** (5) @>

   if (normal == ORIGIN)
   {
       cerr_strm << thread_name << "WARNING!  In `Path::get_direction':" << endl
                 << "`*this' is not planar:  The points on the path are coplanar." << endl
                 << "Exiting function unsuccessfully with "
                 << "return value `ORIGIN'."
                 << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

       return ORIGIN;

   }

@q ***** (5) @>

   else if (normal == INVALID_POINT)
   {
       cerr_strm << thread_name << "WARNING!  In `Path::get_direction':" << endl
                 << "`*this' is not planar.  The points on the path do not lie in a plane." 
                 << endl 
                 << "Exiting function unsuccessfully with "
                 << "return value `INVALID_POINT'."
                 << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

       return INVALID_POINT;

   }

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr_strm << thread_name << "In `Path::get_direction':" << endl
                 << "`*this' is planar." << endl;
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

       normal.show("normal:");  

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr_strm << thread_name << "In `Path::get_direction':" << endl
                 << "`*this' is planar." << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>
@
@<Define |Path| functions@>=

  normal.shift(p0);

  if (x_axis_point)
  {
     x_axis_point->show("*x_axis_point before transformation:");
  }

  t0.align_with_axis(p0, normal, 'z', x_axis_point, 'x');

  if (x_axis_point)
  {
     x_axis_point->show("*x_axis_point after transformation:"); 

cerr << "YYY Enter <RETURN> to continue: ";
getchar(); 

  }




  q1 = *this;

  q1 *= t0;

  cerr << "In `Path::get_direction':  After call to `Transform::align_with_axis'." << endl;



#if 1 
  q1.show("q1 after transformation (should lie in x-y plane):");
#endif 

@q **** (4) @>
@
@<Define |Path| functions@>=





@q **** (4) @>
@
@<Define |Path| functions@>=

  stringstream s;

  int fd; 
  char temp_filename[] = "XXXXXX";

  fd = mkstemp(temp_filename);

#if 0 
  cerr << "fd == " << fd << endl;
#endif 

  close(fd);

#if 1 
  cerr << "temp_filename == " << temp_filename << endl;
#endif 

/* !!START HERE:  LDF 2021.11.24.  Add error handling.  Make sure unlink works.  
   Also, add a way of setting a point to put on the x-axis.  */ 

  s << "echo \"\\path p; p = ";

  string connector;
  connector = "";

  /* !!START HERE:  Account for different connectors and non-cycles.  */ 

  int i = 0;
  for (vector<Point*>::iterator iter = q1.points.begin(); iter != q1.points.end(); ++iter)
  {
      s << connector << "(" << (*iter)->get_x() << ", " << (*iter)->get_y() << ")";

      if (i == 0)
      {
        i = 1;
        connector = " .. ";
      }
  }  

  s << " .. cycle; pair d; d = direction " << ttime << " of p; write decimal xpart d to \\\"" 
    << temp_filename << "\\\"; write decimal ypart d to \\\"" << temp_filename << "\\\"; ";

  if (aangle != 0)
     s << "a = angle direction " << ttime << " of p; write decimal a to \\\"" << temp_filename << "\\\"; "; 
  else 
     s << "write \\\"0\\\" to \\\"" << temp_filename << "\\\"; ";

  s << "end;\" "
    << "| mpost -numbersystem \"double\" -interaction=\"batchmode\" >/dev/null; cat " << temp_filename;

#if 1 /* 0 */
  cerr << "s.str() == " << s.str() << endl;
#endif 

  FILE *fp = popen(s.str().c_str(), "r");

#if 0
  char mp_output[128];
  memset(mp_output, 0, 128);
  status = fread(mp_output, 1, 128, fp);
  cerr << "mp_output == " << mp_output << endl;
#endif 

  pclose(fp);
  fp = 0;

  real x_val;
  real y_val;
  real angle_val;

  ifstream in_strm;

  in_strm.open(temp_filename);

  in_strm >> x_val >> y_val >> angle_val;

  in_strm.close();

  cerr << "Unlinking " << temp_filename << endl;
  errno = 0;
  status = unlink(temp_filename);

  cerr << "status == " << status << endl;
  cerr << "strerror(errno) == " << strerror(errno) << endl;

  cerr << "XXX Enter <RETURN> to continue: ";
  getchar(); 


#if 1 /* 0 */
  cerr << "x_val == " << x_val << endl;
  cerr << "y_val == " << y_val << endl;
  cerr << "angle_val == " << angle_val << endl;
#endif 

  p1.set(x_val, y_val, 0);

  if (aangle)
     *aangle = angle_val;

#if 0
  p1.show("p1 before transformation:");
#endif 

  p1 *= t0.inverse();

#if 0
  p1.show("p1 after transformation:");
#endif 
 
@q **** (4) @>
@
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr_strm << thread_name << "Exiting `Path::get_direction' successfully with `Point' return value." 
           << endl;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }
#endif /* |DEBUG_COMPILE|  */@; 

   return p1;

}  /* End of |Path::get_direction| definition  */


@q * (1) class |Connector_Type| declaration. @>
@* class |Connector_Type| declaration.
\initials{LDF 2021.12.24.}

\LOG
\initials{LDF 2021.12.24.}
Added this section.
\ENDLOG

@<class |Connector_Type| declaration@>=
class Connector_Type 
{
   friend class Path;
   friend int yyparse(yyscan_t);

   int type0;
   int type1;

   string connector_string;
   Point *pt0;
   Point *pt1;
   real  r0;
   real  r1;
   
   public:
      const static unsigned int NULL_TYPE;
      const static unsigned int PLAIN_TYPE;     
      const static unsigned int DIR_TYPE;     
      const static unsigned int CURL_TYPE;       
      const static unsigned int TENSION_TYPE;
      const static unsigned int CONTROLS_TYPE;

      @<|Connector_Type| function declarations@>   

};

@q ** (2) @>
@
@<|Connector_Type| static constant initializations@>=

const unsigned int Connector_Type::NULL_TYPE     = 0U;
const unsigned int Connector_Type::PLAIN_TYPE    = 1U;     
const unsigned int Connector_Type::DIR_TYPE      = 2U;     
const unsigned int Connector_Type::CURL_TYPE     = 3U;       
const unsigned int Connector_Type::TENSION_TYPE  = 4U;
const unsigned int Connector_Type::CONTROLS_TYPE = 5U;


@q ** (2) |Connector_Type| functions.@>
@*2 |Connector_Type| functions.
\initials{LDF 2021.12.24.}

\LOG
\initials{LDF 2021.12.24.}
Added this section.
\ENDLOG

@q *** (3) Constructors.  @>
@ Constructor.
\initials{LDF 2021.12.24.}

@q **** (4) Default constructor.@>
@ Default constructor.
\initials{LDF 2021.12.24.}

@q ***** (5) Declaration @>

\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG

@<|Connector_Type| function declarations@>=
Connector_Type(void);

@q ***** (5) Definition @>
@
@<|Connector_Type| function definitions@>=
Connector_Type::Connector_Type(void)
{
   type0 = PLAIN_TYPE;     
   type1 = NULL_TYPE;     

   connector_string = "";

   pt0 = 0;
   pt1 = 0;
   r0  = 0;
   r1  = 0;

   return;
           
}  /* End of |Connector_Type| default constructor definition  */

@q **** (4) Copy constructor.@>
@ Copy constructor.
\initials{LDF 2021.12.24.}

@<|Connector_Type| function declarations@>=
Connector_Type(const Connector_Type &c);

@q ***** (5) Definition @>
@
@<|Connector_Type| function definitions@>=
Connector_Type::Connector_Type(const Connector_Type &c)
{
   *this = c;

   return;
           
}  /* End of |Connector_Type| default constructor definition  */


@q **** (4) @>

@q *** (3) Assignment operator.@>
@ Assignment operator.
\initials{LDF 2021.12.24.}

\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG 

@q **** (4) Declaration @>
@
\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG

@<|Connector_Type| function declarations@>=
void
operator=(const Connector_Type &c);

@q **** (4) Definition @>
@
@<|Connector_Type| function definitions@>=
void
Connector_Type::operator=(const Connector_Type &c)
{
   type0 = c.type0;     
   type1 = c.type1;     

   connector_string = c.connector_string;

   r0  = c.r0;
   r1  = c.r1;      

   if (c.pt0 != 0)
   {
      pt0 = create_new<Point>(c.pt0);        
   }

   if (c.pt1 != 0)
   {
      pt1 = create_new<Point>(c.pt1);        
   }

   return;
           
}  /* End of |Connector_Type| default constructor definition  */

@q * (1) Pseudo-constructor for dynamic allocation. @>
@* Pseudo-constructor for dynamic allocation. 

@q ** (2) Pointer argument.@>
@ Pointer argument.@>

\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.  @>

@<Declare non-member template functions for |Connector_Type|@>=

Connector_Type* 
create_new(const Connector_Type* c, Scanner_Node scanner_node);

@q ** (2) Reference argument.@>
@*1 Reference argument.@>

\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare non-member template functions for |Connector_Type|@>=

Connector_Type* 
create_new(const Connector_Type& c, Scanner_Node scanner_node);

@q *** (3) Show. @>
@*2 Show.
\initials{LDF 2021.12.24.}

\LOG
\initials{LDF 2021.12.24.}
Added this function.
\ENDLOG

@<|Connector_Type| function declarations@>=
void
show(string s = "Connector_Type:") const;

@q **** (4) Definition @>
@
@<|Connector_Type| function definitions@>=
void
Connector_Type::show(string s) const
{
@q **** (4) @>

  cerr << s << endl << "connector_string:  " << connector_string << endl;

  if (type0 == NULL_TYPE)
  {
      cerr << "type0:  NULL_TYPE." << endl;
  }
  else if (type0 == PLAIN_TYPE)
  {
      cerr << "type0:  PLAIN_TYPE." << endl;
  }
  else if (type0 == DIR_TYPE)
  {
      cerr << "type0:  DIR_TYPE." << endl;
  }
  else if (type0 == CURL_TYPE)       
  {
      cerr << "type0:  CURL_TYPE." << endl;
  }
  else if (type0 == TENSION_TYPE)
  {
      cerr << "type0:  TENSION_TYPE." << endl;
  }
  else if (type0 == CONTROLS_TYPE)
  {
      cerr << "type0:  CONTROLS_TYPE." << endl;
  }

@q **** (4) @>

  if (type1 == NULL_TYPE)
  {
      cerr << "type1:  NULL_TYPE." << endl;
  }
  else if (type1 == PLAIN_TYPE)
  {
      cerr << "type1:  PLAIN_TYPE." << endl;
  }
  else if (type1 == DIR_TYPE)
  {
      cerr << "type1:  DIR_TYPE." << endl;
  }
  else if (type1 == CURL_TYPE)       
  {
      cerr << "type1:  CURL_TYPE." << endl;
  }
  else if (type1 == TENSION_TYPE)
  {
      cerr << "type1:  TENSION_TYPE." << endl;
  }
  else if (type1 == CONTROLS_TYPE)
  {
      cerr << "type1:  CONTROLS_TYPE." << endl;
  }

@q **** (4) @>

  return;

} /* End of |Connector_Type::show| definition */


@q *** (3) @>

@q ** (2) @>

@q * (1) |Nurb| functions.@> 
@* {\bf Nurb} functions.
\initials{LDF 2005.01.28.}

\LOG
\initials{LDF 2005.01.28.}
Added this section.
\ENDLOG

@q ** (2) Generate.@> 
@*1 Generate.
\initials{LDF 2005.01.28.}

\LOG
\initials{LDF 2005.01.27.}
Added this function.

\initials{LDF 2005.01.28.}
Changed |real oorder| argument to |real power|.

\initials{LDF 2005.01.28.}
Removed |void* nurb| argument.  It's not needed because it simply duplicated |this|.

\initials{LDF 2005.01.28.}
Moved this definition from \filename{nurbs.web} to this file (\filename{paths.web}).  
This was necessary in order to be able to access |Path| functions, since |class Path| 
is an incomplete type in \filename{nurbs.web}. 

\initials{LDF 2005.01.28.}
@:BUG FIX@> BUG FIX:  Now using the values of the power |p| and the
number of control points |n| correctly.
Currently, this function generates an ordinary B-spline.  
About to start using the weights so that it will 
generate a NURB.

\initials{LDF 2005.01.28.}
Now calling |Nurb::blending_func| in a loop to set the value of 
|blend_value_denominator|, which causes this function to 
generate a NURB.  I'm not sure it works right, though.  
I don't understand why changing the weights has the 
effect it does. 
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Nurb| functions@>=
int
Nurb::generate(Scanner_Node scanner_node,
               real power,
               real time,
               Path* q)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Entering `Nurb::generate'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

   unsigned short p = static_cast<unsigned int>(floor(fabs(power) + .5));

   unsigned short n = control_points.size();

@q ***** (5).@> 

#if DEBUG_COMPILE
          if (DEBUG)
             {
                 cerr << "`p' == " << p << ", `n' == " 
                      << n << endl;
             }       
#endif /* |DEBUG_COMPILE|  */@; 
            
@q **** (4) |weights.size() < n + 1|.@>   
@ |weights.size() < n + 1|.  Fill up weights with pointers to |real r| 
such that |*r == 1|.
\initials{LDF 2005.01.28.} 

@<Define |Nurb| functions@>=

   if (weights.size() < n + 1)
      {
          real* r;       
          
@q ***** (5).@> 

          for (int i = weights.size(); i < n + 1; ++i)
             {
                 try 
                    {
                        r = new real; 
                    }

@q ****** (6).@> 

                 catch (bad_alloc)
                    {

                        cerr_strm << thread_name 
                                  << "ERROR!  In `Nurb::generate':"
                                  << endl << "`new real' failed, throwing "
                                  << "`bad_alloc'."
                                  << endl << "Deleting `Path* q' and "
                                  << "setting it to 0, and rethrowing.";

                        log_message(cerr_strm);
                        cerr_message(cerr_strm, error_stop_value);
                        cerr_strm.str("");

                        delete reinterpret_cast<Shape*>(q);
                        q = 0;

                        throw;

                    }  /* |catch (bad_alloc)|  */

@q ****** (6).@> 
               
                 *r = 1;
                 weights.push_back(r);

@q ****** (6).@> 

             }  /* |for|  */

@q ***** (5).@> 

      }  /* |if (weights.size() < n + 1)|  */

@q **** (4) @>   

   Point* C_of_u;
   real blend_value_numerator;
   real blend_value_denominator;

   for (real u = 0; u <= 1; u += time)
      {

#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr << "`u' == " << u << endl;
            }      
#endif /* |DEBUG_COMPILE|  */@;

try
             {
                C_of_u = create_new<Point>(0);
             }

@q ***** (5).@> 

          catch (bad_alloc)
             {
                 cerr_strm << thread_name 
                           << "ERROR!  In `Nurb::generate':"
                           << endl << "`create_new<Point>' failed, "
                           << "throwing `bad_alloc'.  Rethrowing.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm);
                 cerr_strm.str("");

                 throw;

             }  /* |catch (bad_alloc)|  */

@q ***** (5).@> 

          C_of_u->set(0, 0, 0);

          for (int i = 0; i < n; ++i)
             {

                 blend_value_numerator 
                    = blending_func(i, p, u, scanner_node);                 

                 blend_value_denominator = 0;

                 for (int j = 0; j < n;  ++j)
                    {
                        blend_value_denominator 
                           += blending_func(j, p, u, scanner_node);

                        blend_value_denominator *= *(weights[j]);
                    }  

#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                       cerr_mutex.lock(); 
                       cerr << "`blend_value_numerator' == " 
                            << blend_value_numerator << endl
                            << "`blend_value_denominator' == " 
                            << blend_value_denominator << endl;
                       cerr_mutex.unlock(); 

                       C_of_u->show("*C_of_u before multiplication:");

                       cerr_mutex.lock(); 
                       cerr << "`i'  = " << i << endl;
                       cerr_mutex.unlock(); 
                       (control_points[i])->show("`*(control_points[i])':");

                   }           
#endif /* |DEBUG_COMPILE|  */@; 

                *C_of_u +=   blend_value_numerator * *(weights[i])
                           * *(control_points[i]); 

                if (blend_value_denominator != ZERO_REAL)
                   *C_of_u /= blend_value_denominator;

                else  /* |blend_value_denominator == 0|  */
                   {
                      cerr_strm << thread_name 
                                << "ERROR!  In `Nurb::generate':"
                                << endl 
                                << "`blend_value_denominator' == 0.  "
                                << "Setting `*C_of_u = (0, 0, 0)' and "
                                << "will try to continue.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm, error_stop_value);
                      cerr_strm.str("");    

                      C_of_u->set(0, 0, 0);

                   }  /* |else| (|blend_value_denominator == 0|)  */

#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                       C_of_u->show("*C_of_u after multiplication:");
                   }           
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6).@> 

             }  /* |for (int i = 0; i < n; ++i)|  */

@q ***** (5).@> 

          *q += C_of_u;

      }  /* |for (; u <= 1; u += time)|  */

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
         q->show("In `Nurb::generate', `q':");
     }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "Exiting `Nurb::generate'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   return 0;

}  /* End of |Nurb::generate| definition.  */

@q * (1) |Focus| functions.@>
@* {\bf Focus} functions.
\initials{LDF 2007.09.17.}

\LOG
\initials{LDF 2007.09.17.}
Added this section.
\ENDLOG

@q ** (2) Setting functions.@> 
@*1 Setting functions.
\initials{LDF 2007.09.17.}

\LOG
\initials{LDF 2007.09.17.}
Added this section.
\ENDLOG

@q *** (3) Setting function with |real*| arguments.@>
@*2 Setting function with {\bf real*} arguments.
\initials{LDF 2007.09.19.}

This is how |Point Focus::up| is set:
\par
\item{1.}  Take the point $P$ such that $P = (0, 1, 0)$.  That is, $P$ is 
the point that represents a unit vector in the direction 
of the y-axis.
\smallskip
%
\item{2.}  Shift $P$ to the |position| of the |Focus|.
\smallskip
\item{3.}  Find the |Plane| $q$ of the |Path| |position|---|direction|---$P$.
\smallskip
\item{4.}  Find the point $N$ such that $N$ is a normal to $q$.
\smallskip
\item{5.}  Set the point $R$ equal to $P$ and rotate $R$ about the axis 
$N$---|position| to make it perpendicular to the line 
|position|---|direction|.
\par
I believe this should result in |position|---|up| being 
the vector perpendicular to the line |position|---|direction| 
with the maximum y-component, since R is both perpendicular to 
|position|---|direction| and lies in the plane $q$.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.  It contains code formerly in the version of |Focus::set|
that takes |real| arguments.
\ENDLOG

@q **** (4) Definition.@>

@<Define |Focus| functions@>=
void
Focus::set(real* pos_x, real* pos_y, real* pos_z, 
           real* dir_x, real* dir_y, real* dir_z,
           real* dist, real* ang, char ax,
           real tolerance,
           Scanner_Node scanner_node)
{

@q ***** (5) Preliminaries.@>   

   volatile bool DEBUG = false; /* |true| */ @; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Entering `Focus::set' with `real*' arguments.";
               
      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  if (dist)
     distance = *dist;

  if (ang)
     angle = *ang;

  real temp_x;
  real temp_y;
  real temp_z; 

@q ***** (5)@>

  if (pos_x || pos_y || pos_z)
  {
      temp_x = (pos_x) ? *pos_x : position.get_x();
      temp_y = (pos_y) ? *pos_y : position.get_y();
      temp_z = (pos_z) ? *pos_z : position.get_z();

      position.set(temp_x, temp_y, temp_z);
  }  

@q ***** (5)@>

  if (dir_x || dir_y || dir_z)
  {
      temp_x = (dir_x) ? *dir_x : direction.get_x();
      temp_y = (dir_y) ? *dir_y : direction.get_y();
      temp_z = (dir_z) ? *dir_z : direction.get_z();

      direction.set(temp_x, temp_y, temp_z);
  }  

#if DEBUG_COMPILE
   if (DEBUG)
   {
       position.show("position:");
       direction.show("direction:");

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5)@>

  transform.reset();
  persp.reset();

  up = position;
  up.shift(0, 1);

  axis = tolower(ax);

  if (!(axis == 'x' || axis == 'y' || axis == 'z'))
  {
       cerr_strm << thread_name << "WARNING! In `Focus::set' with `real*' arguments:"
                 << endl 
                 << "axis argument has invalid value: " << axis
                 << ". Using 'z'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, warning_stop_value);
       cerr_strm.str("");
   
       axis = 'z';

  }  /* |if|  */

@q ***** (5)@>
@
\LOG
\initials{LDF 2013.11.06.}
@:BUG FIX@> BUG FIX:  Now casting the final argument to |Path::set| to
|Point *|.  Previously, passing an uncast 0 caused a ``Segmentation fault'' 
error in |Path::set| when |va_arg| tried to read it.
\ENDLOG 

@<Define |Focus| functions@>=

  Path q;
  q.set("--", false, &position, &direction, &up, static_cast<Point*>(0));

@q ***** (5)@>
@
@<Define |Focus| functions@>=

  Plane r = q.get_plane();

  normal = r.normal;
  normal.shift(position);

  Point temp_pt[2];

  temp_pt[0] = (up - position);
  temp_pt[1] = (direction - position);

  real temp_angle = (up - position).angle(direction - position);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       temp_pt[0].show("temp_pt[0]:");
       temp_pt[1].show("temp_pt[1]:");

       cerr_mutex.lock(); 
       cerr << "temp_angle == " << temp_angle << endl;
       cerr_mutex.unlock(); 

       up.show("up before rotation:");

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   up.rotate(normal, position, 90 - temp_angle);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       up.show("up after rotation:");

       cerr_mutex.lock(); 
       cerr << "up.get_y == " << up.get_y() << endl
            << "(up.get_y() < 0.0F) " << (up.get_y() < 0.0F) << endl;
       cerr_mutex.unlock(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

  if (up.get_y() < 0)
     up.rotate(normal, position, 180);

  if (up.get_y() < 0)
  {
      cerr_strm << thread_name 
                << "ERROR!  In `Focus::set' with `real*' arguments:"
                << endl 
                << "Failed to set `up' correctly.  "
                << "Using default constructor to set values of data members "
                << "and exiting function.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      Focus f;

      *this = f;

      return;

  }  /* |if|  */

  temp_angle = (up - position).angle(direction - position);

  transform.align_with_axis(position, direction, axis);

@q ***** (5)@>

@ Use the positive y-axis for the ``up'' direction, 
if |axis == 'x'| or |'z'|, and the positive x-axis if
|axis == 'y'|. 
\initials{LDF Undated.}

@<Define |Focus| functions@>=

    Point temp_up = up;

    Point y_axis_pt(0, 1, 0);
    Point x_axis_pt(1, 0, 0);

    temp_up *= transform;

@q ****** (6)@>

    if (axis == 'z' || axis == 'x')
    {
        if (fabs(temp_up.get_y() + 1) < tolerance)
           temp_up *= transform.rotate(0, 0, 180);

#if 0 
        temp_up.show("temp_up after transform:");
#endif 

        temp_angle = temp_up.angle(y_axis_pt);

#if 0 
        cerr << "temp_angle (to y-axis): " << temp_angle << endl;
#endif 

        if (fabs(temp_angle) > tolerance)
        {
           if (fabs(temp_up.get_z()) > tolerance)
              temp_up *= transform.rotate(Point(-1, 0, 0), Point(1, 0, 0), -temp_angle);
           else if (fabs(temp_up.get_x()) > tolerance)
              temp_up *= transform.rotate(Point(0, 0, -1), Point(0, 0, 1), -temp_angle);

           temp_angle = temp_up.angle(Point(0, 1, 0));

#if 0 
           cerr << "temp_angle (to y-axis): " << temp_angle << endl;
#endif 
        }

        if (fabs(temp_angle) > tolerance)
        {
           if (fabs(temp_up.get_z()) > tolerance)
              temp_up *= transform.rotate(Point(-1, 0, 0), Point(1, 0, 0), 180);
           else if (fabs(temp_up.get_x()) > tolerance)
              temp_up *= transform.rotate(Point(0, 0, -1), Point(0, 0, 1), 180);

           temp_angle = temp_up.angle(Point(0, 1, 0));
#if 0 
           cerr << "temp_angle (to y-axis): " << temp_angle << endl;
#endif 
        }

        if (fabs(temp_angle) > tolerance)
        {
            cerr_strm << thread_name 
                      << "ERROR!  In `Focus::set' with `real*' arguments:"
                      << endl 
                      << "Failed to set `up' correctly.  "
                      << "Using default constructor to set values of data members "
                      << "and exiting function.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            Focus f;

            *this = f;

            return;
        }

#if 0 
        else 
           cerr << "Rotated `temp_up' correctly." << endl;
#endif 
       
    }  /* |if (axis == 'z' || axis == 'x')|  */

@q ****** (6)@>

    else if (axis == 'y')
    {
         cerr_strm << "ERROR!  In `Focus::set' with `real*' arguments:"
                   << endl 
                   << "`axis' == `y'.  Can't handle this case yet."
                   << endl 
                   << "Using default constructor to set values of data members "
                   << "and exiting function.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          Focus f;

          *this = f;

          return;
      
    }  /* |if (axis == 'z' || axis == 'x')|  */

@q ***** (5)@>
@
\LOG
\initials{LDF 2007.09.19.}
Now rotating |normal| along with |up|.
\ENDLOG 

@<Define |Focus| functions@>=

  if (fabs(angle) > tolerance)
    {

      normal *= up.rotate(position, direction, angle);

      if (axis == 'z')
      {
        transform.rotate(0, 0, -angle);
      }
      else if (axis == 'x')
      {
        transform.rotate(-angle);
      }
#if 0 
      /* Can't handle this case yet.  \initials{LDF 2007.09.17.}  */
      else if (axis == 'y')
      {
        transform.rotate(0, -angle);
      }
#endif 
      else
      {
          cerr_strm << thread_name << "WARNING! In `Focus::set' "
                    << "with `real*' arguments:"
                    << endl 
                    << "This can't happen!  `axis' has invalid value: " << axis
                    << endl 
                    << "Rotating around z-axis and continuing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          transform.rotate(0, 0, -angle);

      }  /* |else|  */

@q ****** (6)@>

    } /* |if (fabs(angle) > tolerance)|  */

@q ***** (5)@>

  transform.shift(0, 0, -distance);
  persp.set_element(2, 2, 0);
  persp.set_element(2, 3, 1/distance);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name 
                 << "Exiting `Focus::set' with `real*' arguments.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

  return;

@q ***** (5)@>

}  /* End of |Focus::set| definition (version with |real*| arguments)  */

@q **** (4)@>

@q *** (3)@>

@q ** (2)@>

@q * (1) Putting Path together.@>
@ Putting {\bf Path} together.
\initials{LDF Undated.}

@q ** (2).@> 

@ This is what's compiled.
\initials{LDF Undated.}

\LOG
\initials{LDF 2005.01.28.}
Now including |@<Define |Nurb| functions@>|.

\initials{LDF 2007.09.17.}
Now including |@<Define |Focus| functions@>|.
\ENDLOG 

@c
@<Include files@>@;
@<class |Connector_Type| declaration@>@;
@<|Connector_Type| static constant initializations@>@;
@<Define |class Path|@>@;
@<Define |static| |class Path| data members@>@;
@<Define |Transform| functions@>@;
@<Define |Point| functions@>@;
@<Define |Focus| functions@>@;
@<Define |Plane| functions@>@;
@<Define |Path| functions@>@;
@<Define |Line| functions@>@;
@<Define |draw_axes|@>@;
@<Declare non-member template functions for |Path|@>@;
@<Declare non-member template functions for |Connector_Type|@>@;
@<Define |Nurb| functions@>@;
@<|Connector_Type| function definitions@>@;

@q ** (2).@> 

@ This is what's written to \filename{paths.h}. 
\initials{LDF Undated.}

@(paths.h@>=
@<class |Connector_Type| declaration@>@;
@<Define |class Path|@>@;
@<Declare |draw_axes|@>@;
@<Declare non-member template functions for |Path|@>@;
@<Declare non-member template functions for |Connector_Type|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q run-cweave-on-file:"3DLDF.web" @>
@q End: @>
