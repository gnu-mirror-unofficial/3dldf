@q imetfncs.web @>
      
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation  @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>



@q * (0) |Id_Map_Type| and |Id_Map_Entry_Type| functions.@>
@** {\bf Id\_Map\_Type} and {\bf Id\_Map\_Entry\_Type} functions.


\LOG
\initials{LDF 2004.07.16.}
Created this file.

\initials{LDF 2004.09.15.}
Now using this file to define |Id_Map_Type| functions.
The first is |Id_Map_Type::operator=(const Id_Map_Type&)|.
\ENDLOG 

@q * (1) Include files.@>
@* Include files.

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"

@q * (1) |Id_Map_Type| functions.  @>
@* {\bf Id\_Map\_Type} functions. 

@q ** (2) Assignment Operator.  @>
@*1 Assignment Operator.

\LOG
\initials{LDF 2004.09.14.}
Started working on this function.

\initials{LDF 2004.09.15.}
Moved this definition from \filename{io.web} to this file
(\filename{imetfncs.web}).  It's still declared in the former. 

\initials{LDF 2004.09.17.}
Finished writing this function.

\initials{LDF 2004.09.17.}
@:BUG FIX@> BUG FIX:  Now longer declaring |Scanner_Node scanner_node|.
It shadowed a data member of |Id_Map_Type|.  Changed the way I set 
|bool stop_value|.

\initials{LDF 2004.09.17.}
Removed several unused or unnecessary variables.

\initials{LDF 2005.01.26.}
Simplified the ``preliminaries''.
\ENDLOG 

@q ***** (5) Definition.  @>
@
@<Define |Id_Map_Type| functions@>=

const Id_Map_Type&
Id_Map_Type::operator=(const Id_Map_Type& i)
{


@q ***** (6) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ****** (6) @>   


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Id_Map_Type::operator=()'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);  
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 

  Id_Map_Entry_Node curr_entry;
  string curr_name;
  
  Id_Map_Entry_Node new_entry;

  Id_Map_Entry_Node new_superordinate_vector_entry;

  Bad_Assignment_Type bad_assignment;

@q ****** (6) Cycle through |i.id_map|.@>   
@ Cycle through |i.id_map| and copy the |Id_Map_Entry_Nodes|.
\initials{LDF 2004.09.15.}

@<Define |Id_Map_Type| functions@>=

  for (Id_Map_Const_Iterator iter = i.id_map.begin();
       iter != i.id_map.end();
       iter++)

    {
      curr_name = iter->first;
      curr_entry = iter->second;


@q ******* (7) Error handling:  |curr_entry == static_cast<Id_Map_Entry_Node>(0)|.@> 

@ Error handling:  |curr_entry == static_cast<Id_Map_Entry_Node>(0)|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Type| functions@>=
  
  if (curr_entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name 
                << "ERROR! In `Id_Map_Type::operator=(const Id_Map_Type&)':"
                << endl << "`curr_entry' == 0."
                << "Throwing `Bad_Assignment_Type'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");


              throw bad_assignment;

    } /* |if (curr_entry == static_cast<Id_Map_Entry_Node>(0))|  */


@q ******* (7) Superordinate vectors.  Doing nothing.@>

@ Superordinate vectors.  Doing nothing.  
Superordinate vectors are handled in the ``subordinate array'' 
case.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Type| functions@>=
 
     else if (curr_entry->subordinate_array != static_cast<Id_Map_Entry_Node>(0))
        ;  /* Do nothing.  */@; 



@q ******* (7) Everything else.@> 

@ Everything else.
\initials{LDF 2004.09.17.}

\LOG
\initials{LDF 2004.09.18.}
Now calling |new_entry->set_id_map_node(this, true)|.
\ENDLOG 

@<Define |Id_Map_Type| functions@>=
 
     else 
       {

         new_entry = new Id_Map_Entry_Type;
         
         try
           {
             *new_entry = *curr_entry;
           }

         catch (Bad_Assignment_Type)
           {
             
             cerr_strm << thread_name 
                       << "ERROR! In `Id_Map_Type::operator=(const Id_Map_Type&)':"
                       << endl 
                       << "`Id_Map_Entry_Type::operator=(const Id_Map_Entry_Type&)' "
                       << "failed." << endl << "Throwing `Bad_Assignment_Type'.";

             log_message(cerr_strm);
             cerr_message(cerr_strm, error_stop_value);
             cerr_strm.str("");
             

             throw;

           } /* |catch (Bad_Assignment_Type)|  */
            

         new_entry->set_id_map_node(this, true);
	 
         id_map[curr_name] = new_entry;

@q ******** (8) Subordinate arrays.@> 

@ Subordinate arrays.
\initials{LDF 2004.09.17.}

\LOG
\initials{LDF 2004.09.17.}
@:BUG FIX@> BUG FIX:  
Now setting |new_superordinate_vector_entry->id_map_node| to |this| 
after the assignment.

\initials{LDF 2004.09.20.}
@:BUG FIX@> BUG FIX: 
Now putting |new_superordinate_vector_entry| onto |id_map|.
\ENDLOG 

@<Define |Id_Map_Type| functions@>=

  if (curr_entry->superordinate_vector != static_cast<Id_Map_Entry_Node>(0))
    {

      new_superordinate_vector_entry = new Id_Map_Entry_Type;

      try
        {
          *new_superordinate_vector_entry = *(curr_entry->superordinate_vector);
        }

      catch (Bad_Assignment_Type)
        {

          cerr_strm << thread_name 
                    << "ERROR! In `Id_Map_Type::operator=(const Id_Map_Type&)':"
                    << endl 
                    << "`Id_Map_Entry_Type::operator=(const Id_Map_Entry_Type&)' "
                    << "failed." << endl << "Throwing `Bad_Assignment_Type'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          throw;

          
        } /* |catch (Bad_Assignment_Type)|  */
        

 
      new_superordinate_vector_entry->id_map_node = this; 


      new_entry->set_superordinate_vector(new_superordinate_vector_entry,
                                          true, /* |set_vector|  */
                                          true, /* |traverse|  */
                                          new_entry->type);

      id_map[new_superordinate_vector_entry->name] = new_superordinate_vector_entry;


@q ********* (9).@> 

    } /* |else if (curr_entry->superordinate_vector != static_cast<Id_Map_Entry_Node>(0))|  */


@q ******** (8) @> 

       }  /* |else| (Everything else.)  */

@q ******* (7) @> 

    } /* |for|  (Cycle through |id_map|.)  */
  
@q ****** (6) Exit function, returning |i|.@>   

@ Exit function, returning |i|.
\initials{LDF 2004.09.15.}

@<Define |Id_Map_Type| functions@>=


#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name 
                << "Exiting `Id_Map_Type::operator=()' normally.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 
 
  return i;

} /* End of |Id_Map_Type::operator=()| definition.  */




@q * (1) |Id_Map_Entry_Type| functions.  @>
@* {\bf Id\_Map\_Entry\_Type} functions. 
The functions in this section are declared in \filename{io.web}.  
They must be defined here, because they use types and objects
that are undeclared in that file.  Typically, they will use |name_map|
and constants such as |POINT|, |TRANSFORM|, etc., which are declared 
in \filename{parser.w}. 

@q ** (2) Default constructor.  @>
@*1 Default constructor.

\LOG
\initials{LDF 2004.09.14.}
Added this definition.  This function is declared in \filename{io.web}.  
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=
Id_Map_Entry_Type::Id_Map_Entry_Type(void)
{
  name = "";
  const_flag = false;

  array_flag = false;

  known_state = INDEPENDENT;
  category = REGULAR;

  type = UNDECLARED;

  object = 0;

  up = 0;
  left = 0;
  right = 0;
  superordinate_vector = 0;
  subordinate_array = 0;

  id_map_node = 0;

  return;
}



@q ** (2) Destructor.  @>
@*1 Destructor.

\LOG
\initials{LDF 2004.07.01.}
Moved this definition from \.{io.web} to \.{scan.web}.

\initials{LDF 2004.07.16.}
Moved this definition from \filename{scan.web} to 
\filename{imetfncs.web} (this file).

\initials{LDF 2004.08.21.}
Made debugging and error output thread-safe.
Removed code for looping downwards through |left| and |right|.  
It was faulty anyway, and I'm now about to write 
|Id_Map_Entry_Type::destroy_array_subentries()|, which will loop through the
tree of |Id_Map_Entry_Nodes|.  I don't want to use recursion in 
|~Id_Map_Entry_Type()| (this function), because it might use up too much space
on the stack. The stacks used for threads may not be large enough, and this
would put an artificial limit on the number of items in an 
|Id_Map_Entry_Node| tree.

\initials{LDF 2004.08.21.}
Removed the section |@<Common code for deleting |object|@>|.

\initials{LDF 2004.08.22.}
Now conditionally compiling the code using |Thread_Info_Type|.

\initials{LDF 2004.08.24.}
Added code for handling |COLOR_VECTOR|.  When other vector types are
defined, it will be possible to use this code for them, too.

\initials{LDF 2004.08.27.}  

In the |COLOR_VECTOR| case: Added code for destroying |object|, if it
exists.  Also now calling
|subordinate_array->destroy_array_subentries| and setting
|subordinate_array| to 0, if it's not 0 already.  Both |object| and
|subordinate_array| should be non-null here.  It is currently not
possible to remove the |Id_Map_Entry_Node| for |subordinate_array|
from the |id_map|, because the latter is currently not accessible in
this function.  I don't know whether it's possible to pass an argument
to a destructor
@:!!@> (!! Check this), but it's certainly not possible to pass an
additional argument to |delete|, which is what usually calls this
destructor.  It would be possible to make |id_map| available by
putting a |Scanner_Node| in |Id_Map_Entry_Type| and setting it for all
entries.  (Added ``TODO'' note to myself, below.)


\initials{LDF 2004.08.27.}
Added code for handling |superordinate_vector|.  It currently 
works for |color_vectors| and |point_vectors|.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.08.21.}
Make it possible to set |stop_value| to |false| when running 3DLDF 
silently.  It's currently not possible to access the |Scanner_Node| that the
|Id_Map_Entry_Type| (|*this|) is on, so it's not possible to check its
|run_state.error_stop_mode|.  


\initials{LDF 2004.08.27.}
Perhaps make |id_map| available in this function by putting
a |Scanner_Node| in |Id_Map_Entry_Type| and setting it for all
entries.  (See log entry of this date, above.)

\initials{LDF 2004.08.27.}
Make it possible to handle |superordinate_vector| 
for more types.  Maybe put the code for it in a named section. 

\initials{LDF 2005.06.09.}
Removed code for handling objects where |type == DEFUN|.

\initials{LDF 2006.10.08.}
@:BUG FIX@> BUG FIX: 
Now setting pointers to 0 after deleting them everywhere.
\ENDTODO 

@q *** Definition.@> 

@<Define |Id_Map_Entry_Type| functions@>=
Id_Map_Entry_Type::~Id_Map_Entry_Type(void)
{

  stringstream cerr_strm;

  bool error_stop_value = true; /* |false|  */

  using namespace Scan_Parse;

  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  
  thread_info = Thread_Info_Type::get_thread_info(true);
  thread_name = Thread_Info_Type::get_thread_name(thread_info);

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG) 
     {
       cerr_strm << thread_name 
                 << "Entering `Id_Map_Entry_Type::~Id_Map_Entry_Type()'.";

       cerr_strm << endl << "`name' == " << name;

       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
       }
#endif /* |DEBUG_COMPILE|  */@; 


   Id_Map_Entry_Node node;

@q ****** (6) Handle |Shapes|.@>  
@ Handle |Shapes|.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=

   if (is_shape())
      {
        Shape* s = static_cast<Shape*>(object);
        if (s != static_cast<Shape*>(0))
          {
            s->clear();

            delete s;
            s = static_cast<Shape*>(0);
          }
        

      } /* |if (is_shape())|  */


@q ****** (6) Handle |Nurbs|.@>  
@ Handle |Nurbs|.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this section.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.01.26.}
Remove this once I've gotten |is_shape()| to return |true| for |Nurbs|
and defined |Nurb::clear()|.
\ENDTODO 

@<Define |Id_Map_Entry_Type| functions@>=

   else if (type == NURB)
       {
        Nurb* n = static_cast<Nurb*>(object);
        if (n != static_cast<Nurb*>(0))
          {
            delete n;
            n = static_cast<Nurb*>(0);
          }

       }  /* |else if (type == NURB)|  */


@q ****** (6) Handle |Conic_Section_Lattices|.@>  
@ Handle |Conic_Section_Lattices|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

   else if (type == CONIC_SECTION_LATTICE)
   {
       Conic_Section_Lattice* c = static_cast<Conic_Section_Lattice*>(object);

       delete c;
       c = 0;

   }  /* |else if (type == CONIC_SECTION_LATTICE)|  */


@q ****** (6) Handle |Sphere_Development|.@>  
@ Handle |Sphere_Development|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2009.11.09.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

   else if (type == SPHERE_DEVELOPMENT)
   {
       Sphere_Development* s = static_cast<Sphere_Development*>(object);

       delete s;
       s = 0;

   }  /* |else if (type == SPHERE_DEVELOPMENT)|  */

@q ****** (6) Handle |UNDECLARED objects|.@>  
@ Handle |UNDECLARED objects|.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=


   else if (type == UNDECLARED)
     {
       if (object != static_cast<Shape*>(0))
         {

           cerr_strm << thread_name 
                     << "ERROR! In `Id_Map_Entry_Type' destructor:" 
                     << endl
                     << "`type' is `UNDECLARED', but `object' "
                     << "is non-null."
                     << endl << "Returning.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value); 
           cerr_strm.str(""); 

           return;

         } /* |if (object != static_cast<Shape*>(0))|  */

       else if (   left != static_cast<Id_Map_Entry_Node>(0) 
                || right != static_cast<Id_Map_Entry_Node>(0))
         {

           cerr_strm << thread_name
                     << "ERROR! In `Id_Map_Entry_Type' destructor:" 
                     << endl
                     << "`type' is undeclared, but `left' and/or `right' "
                     << "is non-null."
                     << endl << "Returning.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm, error_stop_value); 
           cerr_strm.str("");

           return;

         } /* |else if (   left != static_cast<Id_Map_Entry_Node>(0) 
                        || right != static_cast<Id_Map_Entry_Node>(0))|  */

       else
         ; /* Do nothing.  */@; 

     } /* |else if (type == UNDECLARED)|  */@;



@q ****** (6) Handle vector types.@>  
@ Handle vector types.
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.24.}
Added this section.

\initials{LDF 2004.08.31.}
Modified, so that |POINT_VECTOR| are handled, too. 

\initials{LDF 2004.09.01.}
Modified, so that |BOOL_POINT_VECTOR| are handled, too. 

\initials{LDF 2004.12.10.}
Modified, so that |PATH_VECTOR| are handled, too. 

\initials{LDF 2004.12.14.}
Now calling |is_vector_type()| in the conditional and 
handling |ELLIPSE_VECTOR|.

\initials{LDF 2004.12.14.}
Now handling |CIRCLE_VECTOR|.

\initials{LDF 2004.12.14.}
Now handling |RECTANGLE_VECTOR|.

\initials{LDF 2004.12.14.}
Now handling |REG_POLYGON_VECTOR|.

\initials{LDF 2004.12.14.}
Now handling |CUBOID_VECTOR|.

\initials{LDF 2005.02.11.}
Now handling |POLYGON_VECTOR|.

\initials{LDF 2005.12.01.}
Now handling |PARABOLA_VECTOR|, |HYPERBOLA_VECTOR|, 
|ELLIPSOID_VECTOR|, and |SPHERE_VECTOR|.

\initials{LDF 2007.07.29.}
Now handling |CONIC_SECTION_LATTICE_VECTOR|.

\initials{LDF 2007.10.13.}
Now handling |ARC_VECTOR|.

\initials{LDF 2007.11.28.}
Now handling |MATRIX_VECTOR|.

\initials{LDF 2007.12.04.}
Now handling |COMPLEX_VECTOR|.

\initials{LDF 2009.11.09.}
Now handling |SPHERE_DEVELOPMENT_VECTOR|.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.08.29.}
Add code for handling other vector-types.
\ENDTODO 

@<Define |Id_Map_Entry_Type| functions@>=

   else if (is_vector_type())

     {

@q ******* (7) Destroy |object|, if it exists.@> 
@ Destroy |object|, if it exists.
\initials{LDF 2004.08.27.}


@q ******** (8) |object| exists.  Will destroy it.@> 
@ |object| exists.  Will destroy it.
\initials{LDF 2004.08.27.}

\LOG
\initials{LDF 2004.08.27.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

       if (object != static_cast<Id_Map_Entry_Node>(0))
         {


#if DEBUG_COMPILE
           if (DEBUG)
             {
 
               cerr_strm << thread_name
                         << "In `Id_Map_Entry_Type' destructor:" 
                         << endl << "`object' != 0. Destroying it.";

               log_message(cerr_strm); 
               cerr_message(cerr_strm); 
               cerr_strm.str("");

             }
#endif /* |DEBUG_COMPILE|  */@; 

@q ********* (9) |COMPLEX_VECTOR|.@> 
@ |COMPLEX_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

@q ********* (9) |COMPLEX_VECTOR|.@> 
@ |COMPLEX_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == COMPLEX_VECTOR)
           {

             typedef Pointer_Vector<Complex> PV;
       
             PV* pv = static_cast<PV*>(object);
           
             pv->v.clear();
           
             delete pv;
             pv = 0;

           }

@q ********* (9) |MATRIX_VECTOR|.@> 
@ |MATRIX_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

@q ********* (9) |MATRIX_VECTOR|.@> 
@ |MATRIX_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == MATRIX_VECTOR)
           {

             typedef Pointer_Vector<Matrix> PV;
       
             PV* pv = static_cast<PV*>(object);
           
             pv->v.clear();
           
             delete pv;
             pv = 0;

           }


@q ********* (9) |COLOR_VECTOR|.@> 
@ |COLOR_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == COLOR_VECTOR)
             {

               typedef Pointer_Vector<Color> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |POINT_VECTOR|.@> 
@ |POINT_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == POINT_VECTOR)
             {

               typedef Pointer_Vector<Point> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
               delete pv;
               pv = 0;

             }


@q ********* (9) |BOOL_POINT_VECTOR|.@> 
@ |BOOL_POINT_VECTOR|.

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == BOOL_POINT_VECTOR)
             {

               typedef Pointer_Vector<Bool_Point> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |PATH_VECTOR|.@> 
@ |PATH_VECTOR|.

\LOG
\initials{LDF 2004.12.12.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == PATH_VECTOR)
             {

               typedef Pointer_Vector<Path> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |ELLIPSE_VECTOR|.@> 
@ |ELLIPSE_VECTOR|.

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == ELLIPSE_VECTOR)
             {

               typedef Pointer_Vector<Ellipse> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |CIRCLE_VECTOR|.@> 
@ |CIRCLE_VECTOR|.

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == CIRCLE_VECTOR)
             {

               typedef Pointer_Vector<Circle> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |PARABOLA_VECTOR|.@> 
@ |PARABOLA_VECTOR|.

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == PARABOLA_VECTOR)
             {

               typedef Pointer_Vector<Parabola> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |HYPERBOLA_VECTOR|.@> 
@ |HYPERBOLA_VECTOR|.

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == HYPERBOLA_VECTOR)
             {

               typedef Pointer_Vector<Hyperbola> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }
@q ********* (9) |ARC_VECTOR|.@> 
@ |ARC_VECTOR|.
\initials{LDF 2007.10.13.}

\LOG
\initials{LDF 2007.10.13.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == ARC_VECTOR)
             {

               typedef Pointer_Vector<Arc> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |CONIC_SECTION_LATTICE_VECTOR|.@> 
@ |CONIC_SECTION_LATTICE_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == CONIC_SECTION_LATTICE_VECTOR)
             {

               typedef Pointer_Vector<Conic_Section_Lattice> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }



@q ********* (9) |RECTANGLE_VECTOR|.@> 
@ |RECTANGLE_VECTOR|.

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == RECTANGLE_VECTOR)
             {

               typedef Pointer_Vector<Rectangle> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |POLYGON_VECTOR|.@> 
@ |POLYGON_VECTOR|.
\initials{LDF 2005.02.11.}

\LOG
\initials{LDF 2005.02.11.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == POLYGON_VECTOR)
             {

               typedef Pointer_Vector<Polygon> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |REG_POLYGON_VECTOR|.@> 
@ |REG_POLYGON_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == REG_POLYGON_VECTOR)
             {

               typedef Pointer_Vector<Reg_Polygon> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |ELLIPSOID_VECTOR|.@> 
@ |ELLIPSOID_VECTOR|.

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == ELLIPSOID_VECTOR)
             {

               typedef Pointer_Vector<Ellipsoid> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }


@q ********* (9) |SPHERE_VECTOR|.@> 
@ |SPHERE_VECTOR|.

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == SPHERE_VECTOR)
             {

               typedef Pointer_Vector<Sphere> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |SPHERE_DEVELOPMENT_VECTOR|.@> 
@ |SPHERE_DEVELOPMENT_VECTOR|.

\LOG
\initials{LDF 2009.11.09.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == SPHERE_DEVELOPMENT_VECTOR)
             {

               typedef Pointer_Vector<Sphere_Development> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }

@q ********* (9) |PARABOLOID_VECTOR|.@> 
@ |PARABOLOID_VECTOR|.

\LOG
\initials{LDF 2006.01.23.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == PARABOLOID_VECTOR)
             {

               typedef Pointer_Vector<Paraboloid> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }




@q ********* (9) |CUBOID_VECTOR|.@> 
@ |CUBOID_VECTOR|.

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

           if (type == CUBOID_VECTOR)
             {

               typedef Pointer_Vector<Cuboid> PV;
       
               PV* pv = static_cast<PV*>(object);
           
               pv->v.clear();
           
               delete pv;
               pv = 0;

             }



@q ********* (9)@> 

           object = 0;

         } /* |if (object != static_cast<Id_Map_Entry_Node>(0))|  */
 

@q ******** (8) |object| doesn't exist.  Won't destroy it.@> 
@ |object| doesn't exist.  Won't destroy it.
\initials{LDF 2004.08.27.}

\LOG
\initials{LDF 2004.08.27.}
Added this section.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.08.27.}
Perhaps put some of this code in a ``Common code'' section so it can
be used for other vector-types.
\ENDTODO 

@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE

   else if (DEBUG) /* |object == static_cast<Id_Map_Entry_Node>(0)|  */
     {

       cerr_strm << thread_name
                 << "In `Id_Map_Entry_Type' destructor:" 
                 << endl << "`object' == 0. Not destroying it.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str("");

     }     /* |else if (DEBUG)| (|object == static_cast<Id_Map_Entry_Node>(0)|)  */

#endif /* |DEBUG_COMPILE|  */@; 
 
@q ******* (7) End of vector-type case.@>       

@ End of vector-type case.
\initials{LDF 2004.08.27.}

@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE

  if (DEBUG)
    {
      cerr_strm << thread_name
                 << "In `Id_Map_Entry_Type' destructor:" 
                 << endl << "End of vector-type case.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str("");
    }
 
#endif /* |DEBUG_COMPILE|  */@; 

   } /* |else if (is_vector_type())|  */

@q ****** (6) Handle other types.@>  
@ Handle other types.
\initials{LDF 2004.07.01.}

\LOG
\initials{LDF 2004.09.01.}
Added code for handling |BOOL_POINTS|.

\initials{LDF 2004.09.14.}
@:BUG FIX@> BUG FIX: 
Now casting |object| to |int*|, if |type == BOOLEAN|.  
Formerly, I cast it to |bool*|. 

\initials{LDF 2004.12.28.}
Added code for handling entries of type |MACRO|.

\initials{LDF 2005.02.04.}
Added code for handling entries of type |ORIGAMI_FIGURE|.

\initials{LDF 2005.06.09.}
Added code for handling entries of type |GLYPH|.

\initials{LDF 2005.10.30.}
Added code for handling entries of type |PLANE|.

\initials{LDF 2005.12.05.}
Added code for handling entries of type 
|ULONG_LONG|.

\initials{LDF 2007.11.28.}
Added code for handling entries of type |PREDICATE|.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

@q ******* (7) |PREDICATE|.@>  

   else if (type == PREDICATE)
     {

       Predicate* c = static_cast<Predicate*>(object);
       
       if (c != static_cast<Predicate*>(0))
         {
           delete c;
           c = static_cast<Predicate*>(0);
         }

     } /* |else if (type == PREDICATE)|  */

@q ******* (7) |BOOLEAN|.@>  

   else if (type == BOOLEAN)
     {

       int* c = static_cast<int*>(object);
       
       if (c != static_cast<int*>(0))
         {
           delete c;
           c = static_cast<int*>(0);
         }
     } /* |else if (type == BOOLEAN)|  */



   else if (type == COMPLEX)
       {
        Complex* c = static_cast<Complex*>(object);
        if (c != static_cast<Complex*>(0))
          {
            delete c;
            c = static_cast<Complex*>(0);
          }

       }  /* |else if (type == COMPLEX)|  */


   else if (type == MATRIX)
       {
        Matrix* m = static_cast<Matrix*>(object);
        if (m != static_cast<Matrix*>(0))
          {
            delete m;
            m = static_cast<Matrix*>(0);
          }

       }  /* |else if (type == MATRIX)|  */



@q ******* (7) |BOOL_POINT|.@>  

   else if (type == BOOL_POINT)
     {

       Bool_Point* bp = static_cast<Bool_Point*>(object);
       
       if (bp != static_cast<Bool_Point*>(0))
         {
           delete bp;
           bp = static_cast<Bool_Point*>(0);
         }
     } /* |else if (type == BOOL_POINT)|  */
 
@q ******* (7) |STRING|.@>  


   else if (type == STRING)
     {
       
       string* c = static_cast<string*>(object);
   
       if (c != static_cast<string*>(0))
         {
           delete c;
           c = static_cast<string*>(0);
         }
     }
  

   else if (type == NUMERIC)
     {

       real* c = static_cast<real*>(object);
   
       if (c != static_cast<real*>(0))
         {
           delete c;
           c = static_cast<real*>(0);
         }
     }

   else if (type == ULONG_LONG)
     {

       unsigned long long* c = static_cast<unsigned long long*>(object);
   
       if (c != static_cast<unsigned long long*>(0))
         {
           delete c;
           c = static_cast<unsigned long long*>(0);
         }
     }

   else if (type == PEN)
     {
       
       Pen* c = static_cast<Pen*>(object);
       
       if (c != static_cast<Pen*>(0))
         {
           delete c;
           c = static_cast<Pen*>(0);
         }
     }

   else if (type == DASH_PATTERN)
     {
       
       Dash_Pattern* c = static_cast<Dash_Pattern*>(object);
       
       if (c != static_cast<Dash_Pattern*>(0))
         {
           delete c;
           c = static_cast<Dash_Pattern*>(0);
         }
     }

   else if (type == COLOR)
     {
       
       Color* c = static_cast<Color*>(object);

       if (c != static_cast<Color*>(0))
         {
           delete c;
           c = static_cast<Color*>(0);
         }

     } /* | else if (type == COLOR)|  */


   else if (type == PICTURE)
     {
       
       Picture* c = static_cast<Picture*>(object);
       
       if (c != static_cast<Picture*>(0))
         {
           delete c;
           c = static_cast<Picture*>(0);
         }  
     }

   else if (type == TRANSFORM)
     {

       Transform* c = static_cast<Transform*>(object);
       
       if (c != static_cast<Transform*>(0))
         {
           delete c;
           c = static_cast<Transform*>(0);
         }
     }

   else if (type == PLANE)
     {
       
       Plane* c = static_cast<Plane*>(object);
       
       if (c != static_cast<Plane*>(0))
         {
           delete c;
           c = static_cast<Plane*>(0);
         }
     }



   else if (type == FOCUS)
     {
       
       Focus* c = static_cast<Focus*>(object);
       
       if (c != static_cast<Focus*>(0))
         {
           delete c;
           c = static_cast<Focus*>(0);
         }
     }


   else if (type == MACRO)
     {

       Definition_Info_Node c = static_cast<Definition_Info_Node>(object);
       
       if (c != static_cast<Definition_Info_Node>(0))
         {
           delete c;
           c = static_cast<Definition_Info_Node>(0);
         }
     }

   else if (type == ORIGAMI_FIGURE)
     {
       
       Origami_Figure* c = static_cast<Origami_Figure*>(object);
       
       if (c != static_cast<Origami_Figure*>(0))
         {
           delete c;
           c = static_cast<Origami_Figure*>(0);
         }
     }

   else if (type == GLYPH)
     {
       
       Glyph* c = static_cast<Glyph*>(object);
       
       if (c != static_cast<Glyph*>(0))
         {
           delete c;
           c = static_cast<Glyph*>(0);
         }
     }

@q ****** (6) Handle internal quantities.@>  
@ Handle internal quantities.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=



   else if (category == INTERNAL)
     {
       
       real* c = static_cast<real*>(object);
   
       if (c != static_cast<real*>(0))
         {
           delete c;
           c = static_cast<real*>(0);
         }
     }


@q ****** (6) Handle true internal quantities.@>  
@ Handle true internal quantities.
\initials{LDF 2004.11.11.}

@<Define |Id_Map_Entry_Type| functions@>=



   else if (category == TRUE_INTERNAL)
     {
       
       real* c = static_cast<real*>(object);
   
       if (c != static_cast<real*>(0))
         {
           delete c;
           c = static_cast<real*>(0);
         }
     }  




@q ****** (6) Handle synonyms.@>  
@ Handle synonyms.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=


   else if (type == SYNONYM && object != 0)
     {
       
       string*  c = static_cast<string*>(object);
       
       if (c != static_cast<string*>(0))
         {
           delete c;
           c = static_cast<string*>(0);
         }
     }

@q ****** (6) Handle sparks.@>  
@ Handle sparks.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=


   else if (category == SPARK && object == 0)
     {
       /* Do nothing.  */@; 
     }


@q ****** (6) Error handling:  @>
@q ****** (6) |object != 0| for a |type| where this isn't allowed.@>  
@ Error handling:  |object != 0| for a |type| 
where this isn't allowed.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=

   else if (object != static_cast<void*>(0))
     {
       cerr_strm << thread_name 
                 << "ERROR! In `Id_Map_Entry_Type' destructor:" 
                 << endl
                 << "`type' == " << name_map[type] << " (" << type << ") " 
                 << "and `object' is non-null." << endl
                 << "This isn't allowed. "
                 << "Returning.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value); 
       cerr_strm.str(""); 
       
       return;
     }


@q ****** (6) Error handling:  Case not accounted for.@>
@ Error handling:  Case not accounted for.
\initials{LDF 2004.07.01.}

@<Define |Id_Map_Entry_Type| functions@>=

   else
     {
       cerr_strm << thread_name 
                 << "ERROR! In `Id_Map_Entry_Type' destructor:" 
                 << endl
                 << "`type' == " << name_map[type] << " (" << type << "), " 
                 << "`category' == " << name_map[category] 
                 << " (" << category << "), " 
                 << "and `object' is null." << endl
                 << "Haven't accounted for this case, "
                 << "but it probably won't do any harm."
                 << endl
                 << "Returning.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value); 
       cerr_strm.str(""); 

       return;
     }

#if DEBUG_COMPILE
  if (DEBUG) 
    {
      cerr_strm << thread_name 
                << "Exiting `Id_Map_Entry_Type::~Id_Map_Entry_Type()' "
                << "successfully.";
      log_message(cerr_strm);
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return;

}  /* End of |~Id_Map_Entry_Type| definition.  */


@q ** (2) Destroy array subentries.  @>
@*1 Destroy array subentries.

\LOG
\initials{LDF 2004.08.21.}
Started working on this function.
It's called in |Id_Map_Type::~Id_Map_Type()| and 
|Scanner_Type::add_entry()|.

\initials{LDF 2004.08.23.}
Finished writing this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Id_Map_Entry_Type| functions@>=

int
Id_Map_Entry_Type::destroy_array_subentries(Scanner_Node scanner_node)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  using namespace Scan_Parse;

   stringstream cerr_strm;


  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  
  thread_info = Thread_Info_Type::get_thread_info(true);
  thread_name = Thread_Info_Type::get_thread_name(thread_info);

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 
 
   bool error_stop_value;

   if (scanner_node)
    error_stop_value 
      = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
        ? true : false;
   
   else
      error_stop_value = true; /* |false|  */

#if DEBUG_COMPILE
   if (DEBUG) 
      {
          cerr_strm << thread_name 
                    << "Entering `Id_Map_Entry_Type::destroy_array_subentries()'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
       }
#endif /* |DEBUG_COMPILE|  */@; 
  
   Id_Map_Entry_Node curr_entry = this;
   Id_Map_Entry_Node temp_entry = 0;


@q **** (4) Cycle down through |left| and |right|.@> 

@ Cycle down through |left| and |right|.
\initials{LDF 2004.08.21.}

@<Define |Id_Map_Entry_Type| functions@>=

   for (;;)
      {
#if DEBUG_COMPILE
          if (DEBUG)
             {
                 cerr_strm << thread_name 
                           << "In `Id_Map_Entry_Type::destroy_array_subentries()':"
                           << endl << "`curr_entry' == " << curr_entry->name
                           << ".";
 
                 log_message(cerr_strm); 
                 cerr_message(cerr_strm); 
                 cerr_strm.str(""); 
             }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5) |left| is non-null.@> 

@ |left| is non-null.
\initials{LDF 2004.08.21.}

@<Define |Id_Map_Entry_Type| functions@>=



         if (curr_entry->left)
	  {

#if DEBUG_COMPILE
             if (DEBUG)
                {
                   cerr_strm << thread_name 
                             << "In `Id_Map_Entry_Type::destroy_array_subentries()':"
                             << endl
                             << "curr_entry->left exists.";

                   log_message(cerr_strm); 
                   cerr_message(cerr_strm); 
                   cerr_strm.str(""); 
                }
#endif /* |DEBUG_COMPILE|  */@; 


	    curr_entry = curr_entry->left;
	    continue;

	  } /* |if (curr_entry->left)|  */


@q ***** (5) |right| is non-null.@> 

@ |right| is non-null.
\initials{LDF 2004.08.21.}

@<Define |Id_Map_Entry_Type| functions@>=


         if (curr_entry->right)
	  {

#if DEBUG_COMPILE
             if (DEBUG)
                {
                   cerr_strm << thread_name 
                             << "In `Id_Map_Entry_Type::destroy_array_subentries()':"
                             << endl
                             << "curr_entry->right exists.";

                   log_message(cerr_strm); 
                   cerr_message(cerr_strm); 
                   cerr_strm.str(""); 
                }
#endif /* |DEBUG_COMPILE|  */@; 


	    curr_entry = curr_entry->right;
	    continue;

	  } /* |if (curr_entry->right)|  */

@q ***** (5) |left| and |right| are both null.@> 

@ |left| and |right| are both null.
\initials{LDF 2004.08.21.}

@<Define |Id_Map_Entry_Type| functions@>=


	else /* (|!(curr_entry->left || curr_entry->right)|)  */
	  {

@q ****** (6) Reached top node.  Returning 0.@> 

@ Reached top node.  Returning 0.
\initials{LDF 2004.08.21.}

@<Define |Id_Map_Entry_Type| functions@>=


	    if (curr_entry->up == static_cast<Id_Map_Entry_Node>(0))
	      {

#if DEBUG_COMPILE
                 if (DEBUG)
                    {
                       cerr_strm << thread_name 
                                 << "In `Id_Map_Entry_Type::destroy_array_subentries()':"
                                 << endl
                                 << "Reached top: " << curr_entry->name 
                                 << ". Returning 0.";
                        
                       log_message(cerr_strm); 
                       cerr_message(cerr_strm); 
                       cerr_strm.str(""); 
                    }
#endif /* |DEBUG_COMPILE|  */@; 

		    return 0;
		  
	      } /* |if (curr_entry->up == static_cast<Id_Map_Entry_Node>(0))|  */

	    temp_entry = curr_entry;
	    curr_entry = curr_entry->up;

#if DEBUG_COMPILE
            if (DEBUG)
               {
                   cerr_strm << thread_name 
                             << "In `Id_Map_Entry_Type::destroy_array_subentries()':"
                             << endl
                             << "Deleting " << temp_entry->name << ".";
   
                   log_message(cerr_strm);
                   cerr_message(cerr_strm); 
                   cerr_strm.str(""); 
               }

#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) @> 

@ 
\LOG
\initials{LDF 2006.10.08.}
@:BUG FIX@> BUG FIX:  Now deleting |temp_entry| and setting it to 0 
after comparing it to |curr_entry->left| and (possibly) 
|curr_entry->right|.
\ENDLOG


@<Define |Id_Map_Entry_Type| functions@>=

	    if (temp_entry == curr_entry->left)
            {
   	       delete temp_entry;
               temp_entry = 0;
               curr_entry->left = 0;
            }
	      
	    else if (temp_entry == curr_entry->right)
            {
   	       delete temp_entry;
               temp_entry = 0;
 	       curr_entry->right = 0;
            }

	    continue;

	  } /* |else| (|!(curr_entry->left || curr_entry->right)|)  */  

      } /* |for|  */


  return 0;

}  /* End of |Id_Map_Entry_Type::destroy_array_subentries()| definition.  */


@q ** (2) Setting.  @>
@*1 Setting.

\LOG
\initials{LDF 2004.04.22.}  
Moved this definition from
\filename{io.web} to \filename{scan.web}.

\initials{LDF 2004.04.29.}  
Changed the name of this function from |set()| to
|set_entry()|.  It was too difficult to find the places where it's invoked
before, since the classes derived from |Shape| also have |set()| functions.

\initials{LDF 2004.05.09.}  
Added |cconst_flag| argument.  Changed
|iis_array| argument to |aarray_flag| and |is_array| to |array_flag|.

\initials{LDF 2004.06.22.}
Now calling |pthread_cond_init()| for |cond_var|
and |pthread_cond_mutex()| for |mutex|.

\initials{LDF 2004.06.29.}
No longer calling |pthread_cond_init()|, because I've removed |cond_var|.

\initials{LDF 2004.08.24.}
Added |Id_Map_Entry_Node ssuperordinate_vector| argument.
It will only be non-null when creating array entries by means 
of vector-type declarations.

\initials{LDF 2004.08.25.}
Added |Id_Map_Entry_Node ssubordinate_array| argument.
It will only be non-null when creating array entries by means 
of vector-type declarations.

\initials{LDF 2004.08.28.}
Added |Scanner_Node sscanner_node| argument.

\initials{LDF 2004.08.29.}
Replaced |Scanner_Node sscanner_node| argument with 
|Id_Map_Node iid_map_node|.
\ENDLOG 

@q *** (3) Definition.  @>

@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::set_entry(string nname,
                             unsigned int ttype,
                             Id_Map_Node iid_map_node,
                             unsigned short ccategory,
                             bool cconst_flag,
                             bool aarray_flag,
                             unsigned short kknown_state,
                             void* oobject,
                             Id_Map_Entry_Node uup,
                             Id_Map_Entry_Node lleft,
                             Id_Map_Entry_Node rright,
                             Id_Map_Entry_Node ssuperordinate_vector,
                             Id_Map_Entry_Node ssubordinate_array)

{   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @;
  if (DEBUG)
    {
      cerr << "Entering Id_Map_Entry_Type::set_entry().\n";
    }
#endif

  name                 = nname; 
  type                 = ttype;
  id_map_node          = iid_map_node;
  category             = ccategory;
  const_flag           = cconst_flag;
  array_flag           = aarray_flag;
  known_state          = kknown_state;
  object               = oobject;
  up                   = uup;
  left                 = lleft;
  right                = rright;
  superordinate_vector = ssuperordinate_vector;
  subordinate_array    = ssubordinate_array;

#ifdef HAVE_PTHREAD_H 
  int status;

  status = pthread_mutex_init(&inner_mutex, 0);

  if (status != 0)
   {
      cerr << "ERROR! In `Id_Map_Entry_Type::set_entry()':"
           << endl << "`pthread_mutex_init()' failed.";
      cerr << "Type <RETURN> to continue.\n"; 
      getchar();  /* Don't delete this!  */ 

   }
 else
   {
#if DEBUG_COMPILE
      if (DEBUG)
          {
             cerr << "In `Id_Map_Entry_Type::set_entry()':"
                  << endl << "`pthread_mutex_init()' succeeded!"
                  << endl;
          }
#endif /* |DEBUG_COMPILE|  */@; 
   }


#endif /* |HAVE_PTHREAD_H|  */@;




#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr << "name == " << name << endl; 

      cerr << "In set_entry():  type == " << type << " == " 
           << name_map[type] << endl;

      if (category == SPARK)
        cerr << "category == SPARK" << endl;

      else if (category == REGULAR)
        cerr << "category == REGULAR" << endl;

      else if (category == INTERNAL)
        cerr << "category == INTERNAL " << endl;

      else if (category == TRUE_INTERNAL)
        cerr << "category == TRUE_INTERNAL " << endl;

      else
        cerr << "ERROR! In Id_Map_Entry_Type::set():\n"
             << "category has invalid value: " 
             << category << endl << "Will try to continue.\n";

      cerr << "const_flag == " << const_flag << endl
           << "array_flag == " << array_flag << endl
           << "type == " << name_map[type] << endl;




      if (object == static_cast<void*>(0))
        cerr << "object == 0" << "\n";
      else 
        cerr << "object != 0" << "\n";

      if (up == static_cast<Id_Map_Entry_Node>(0))
        cerr << "up == 0" << "\n";
      else 
        cerr << "up != 0" << "\n";

      if (left == static_cast<Id_Map_Entry_Node>(0))
        cerr << "left == 0" << "\n";
      else 
        cerr << "left != 0" << "\n";

      if (right == static_cast<Id_Map_Entry_Node>(0))
        cerr << "right == 0" << "\n";
      else 
        cerr << "right != 0" << "\n";

      cerr << "Exiting Id_Map_Entry_Type::set()." << "\n";
    }

#endif

  return true;
}

@q ** (2) Assignment operator.  @>
@*1 Assignment operator.


\LOG
\initials{LDF 2004.09.14.}
Added this function definition.  The declaration is in
\filename{io.web}.  

\initials{LDF 2004.09.14.}
Changed the way I set |scanner_node| and |stop_value|.
Working on this function.

\initials{LDF 2004.09.17.}
Added code for handling synonyms.

\initials{LDF 2004.09.17.}
Changed the way I set |Scanner_Node scanner_node| 
and |bool stop_value|.

\initials{LDF 2005.01.26.}
Simplified the ``preliminaries''.
\ENDLOG

@q *** (3) Definition.  @>

@
@<Define |Id_Map_Entry_Type| functions@>=
const Id_Map_Entry_Type&
Id_Map_Entry_Type::operator=(const Id_Map_Entry_Type& i)
{

   Scanner_Node scanner_node;

   if (   id_map_node != static_cast<Id_Map_Node>(0) 
       && id_map_node->scanner_node != static_cast<Scanner_Node>(0))
     {
       scanner_node = id_map_node->scanner_node;

     } /* |if (id_map_node->scanner_node != static_cast<Scanner_Node>(0))|  */


   else if (i.id_map_node->scanner_node != static_cast<Scanner_Node>(0))
     {
       scanner_node = i.id_map_node->scanner_node;

     } /* |if (i.id_map_node->scanner_node != static_cast<Scanner_Node>(0))|  */



   else /* |   id_map_node->scanner_node  == static_cast<Scanner_Node>(0)
 	   && i.id_map_node->scanner_node == static_cast<Scanner_Node>(0)|  */
     {
       
       scanner_node = static_cast<Scanner_Node>(0);
     
     }    /* |else| (|i.id_map_node->scanner_node == static_cast<Scanner_Node>(0)|)  */



@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << "Entering `Id_Map_Entry_Type::operator=()'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q **** (4) @>   

  name = i.name;

  const_flag = i.const_flag;
  array_flag = i.array_flag;

  known_state = i.known_state;
  category= i.category;
  type = i.type;

  up = 0;
  left = 0;
  right = 0;

  superordinate_vector = 0;
  subordinate_array = 0;

  id_map_node = 0;

  object = 0;


@q ***** (5) Assign to |object|, if |i.object| is non-null.@>
@ Assign to |object|, if |i.object| is non-null.
\initials{LDF 2004.09.14.}


\LOG
\initials{LDF 2004.12.28.}
Added code for handling the case that |type == MACRO|.

\initials{LDF 2005.12.07.}
Added code for handling the case that |type == ULONG_LONG|.

\initials{LDF 2007.11.28.}
Added code for handling the case that |type == PREDICATE|.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

@q ****** (6) Non-|Shape| types.@>
@ Non-|Shape| types.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (type == SYNONYM && i.object != static_cast<void*>(0))
    {
      string* o = new string;
      *o = *static_cast<string*>(i.object);
      object = static_cast<void*>(o); 
      
    }

            
  else if (type == PREDICATE && i.object != static_cast<void*>(0))
    {
      Predicate* o = new Predicate;
      *o = *static_cast<Predicate*>(i.object);
      object = static_cast<void*>(o); 
      
    }

  else if (type == BOOLEAN && i.object != static_cast<void*>(0))
    {
      int* o = new int;
      *o = *static_cast<int*>(i.object);
      object = static_cast<void*>(o); 
      
    }

  else if (type == NUMERIC && i.object != static_cast<void*>(0))
    {
      real* o = new real;
      *o = *static_cast<real*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == ULONG_LONG && i.object != static_cast<void*>(0))
    {
      ulong_long* o = new ulong_long;
      *o = *static_cast<ulong_long*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == STRING && i.object != static_cast<void*>(0))
    {
      string* o = new string;
      *o = *static_cast<string*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == PEN && i.object != static_cast<void*>(0))
    {
      Pen* o = new Pen;
      *o = *static_cast<Pen*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == DASH_PATTERN && i.object != static_cast<void*>(0))
    {
      Dash_Pattern* o = new Dash_Pattern;
      *o = *static_cast<Dash_Pattern*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == COLOR && i.object != static_cast<void*>(0))
    {
      Color* o = new Color;
      *o = *static_cast<Color*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == PICTURE && i.object != static_cast<void*>(0))
    {
      Picture* o = new Picture;
      o->clear();
      *o = *static_cast<Picture*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == TRANSFORM && i.object != static_cast<void*>(0))
    {
      Transform* o = new Transform;
      *o = *static_cast<Transform*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == FOCUS && i.object != static_cast<void*>(0))
    {
      Focus* o = new Focus;
      *o = *static_cast<Focus*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == MACRO && i.object != static_cast<void*>(0))
    {
      Definition_Info_Node o = new Definition_Info_Type;
      *o = *static_cast<Definition_Info_Node>(i.object);
      object = static_cast<void*>(o); 
    }



@q ****** (6) |Shape|-types.@>

@ |Shape|-types.
\initials{LDF 2004.09.14.}


\LOG
\initials{LDF 2005.02.11.}
Added code for handling the case that 
|type == POLYGON && i.object != 0|.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=


  else if (type == BOOL_POINT && i.object != static_cast<void*>(0))
    {
      int* o = new int;
      *o = *static_cast<int*>(i.object);
      object = static_cast<void*>(o); 
      
    }

  else if (type == POINT && i.object != static_cast<void*>(0))
    {
      Point* o = new Point;
      *o = *static_cast<Point*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == PATH && i.object != static_cast<void*>(0))
    {
      Path* o = new Path;
      *o = *static_cast<Path*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == TRIANGLE && i.object != static_cast<void*>(0))
    {
      Triangle* o = new Triangle;
      *o = *static_cast<Triangle*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == POLYGON && i.object != static_cast<void*>(0))
    {
      Polygon* o = new Polygon;
      *o = *static_cast<Polygon*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == REG_POLYGON && i.object != static_cast<void*>(0))
    {
      Reg_Polygon* o = new Reg_Polygon;
      *o = *static_cast<Reg_Polygon*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == RECTANGLE && i.object != static_cast<void*>(0))
    {
      Rectangle* o = new Rectangle;
      *o = *static_cast<Rectangle*>(i.object);
      object = static_cast<void*>(o); 
    }

#if 0 /* |Square| not defined yet.  \initials{LDF 2004.09.14.}  */@;

  else if (type == SQUARE && i.object != static_cast<void*>(0))
    {
      Square* o = new Square;
      *o = *static_cast<Square*>(i.object);
      object = static_cast<void*>(o); 
    }
#endif 

  else if (type == ELLIPSE && i.object != static_cast<void*>(0))
    {
      Ellipse* o = new Ellipse;
      *o = *static_cast<Ellipse*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == CIRCLE && i.object != static_cast<void*>(0))
    {
      Circle* o = new Circle;
      *o = *static_cast<Circle*>(i.object);
      object = static_cast<void*>(o); 
    }


  else if (type == CUBOID && i.object != static_cast<void*>(0))
    {
      Cuboid* o = new Cuboid;
      *o = *static_cast<Cuboid*>(i.object);
      object = static_cast<void*>(o); 
    }

  else if (type == POLYHEDRON && i.object != static_cast<void*>(0))
    {
      Polyhedron* o = new Polyhedron;
      *o = *static_cast<Polyhedron*>(i.object);
      object = static_cast<void*>(o); 
    }

@q ***** (5) Vector-types.@>
@ Vector-types.
|object| is only created, not assigned to.  This is done in 
|Id_Map_Entry_Type::set_subordinate_array()|.
\initials{LDF 2004.09.17.}

\LOG
\initials{LDF 2004.09.17.}
Added this section.

\initials{LDF 2005.12.07.}
Added code for the case |type == ULONG_LONG_VECTOR|.
\ENDLOG 

@q ****** (6) Non-|Shape| types.@> 

@ Non-|Shape| types.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Put this code into its own section.

\initials{LDF 2005.01.26.}
Added code for the cases 
|type == BOOLEAN_VECTOR|,
|type == STRING_VECTOR|,
|type == NUMERIC_VECTOR|,
|type == PEN_VECTOR|,
|type == DASH_PATTERN_VECTOR|,
|type == PICTURE_VECTOR|,
|type == TRANSFORM_VECTOR|,
and
|type == FOCUS_VECTOR|.


\initials{LDF 2005.06.09.}
Added code for the cases 
|type == ORIGAMI_FIGURE_VECTOR| and
|type == GLYPH_VECTOR|.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

  else if (type == BOOLEAN_VECTOR)
    {
      Pointer_Vector<bool>* o = new Pointer_Vector<bool>;
      object = static_cast<void*>(o);       
    }

  else if (type == STRING_VECTOR)
    {
      Pointer_Vector<string>* o = new Pointer_Vector<string>;
      object = static_cast<void*>(o);       
    }

  else if (type == NUMERIC_VECTOR)
    {
      Pointer_Vector<real>* o = new Pointer_Vector<real>;
      object = static_cast<void*>(o);       
    }

  else if (type == ULONG_LONG_VECTOR)
    {
      Pointer_Vector<ulong_long>* o = new Pointer_Vector<ulong_long>;
      object = static_cast<void*>(o);       
    }

  else if (type == COLOR_VECTOR)
    {
      Pointer_Vector<Color>* o = new Pointer_Vector<Color>;
      object = static_cast<void*>(o);       
    }

  else if (type == PEN_VECTOR)
    {
      Pointer_Vector<Pen>* o = new Pointer_Vector<Pen>;
      object = static_cast<void*>(o);       
    }

  else if (type == DASH_PATTERN_VECTOR)
    {
      Pointer_Vector<Dash_Pattern>* o = new Pointer_Vector<Dash_Pattern>;
      object = static_cast<void*>(o);       
    }

  else if (type == PICTURE_VECTOR)
    {
      Pointer_Vector<Picture>* o = new Pointer_Vector<Picture>;
      object = static_cast<void*>(o);       
    }

  else if (type == TRANSFORM_VECTOR)
    {
      Pointer_Vector<Transform>* o = new Pointer_Vector<Transform>;
      object = static_cast<void*>(o);       
    }

  else if (type == FOCUS_VECTOR)
    {
      Pointer_Vector<Focus>* o = new Pointer_Vector<Focus>;
      object = static_cast<void*>(o);       
    }

  else if (type == BOOL_POINT_VECTOR)
    {
      Pointer_Vector<Bool_Point>* o = new Pointer_Vector<Bool_Point>;
      object = static_cast<void*>(o);       
    }

  else if (type == ORIGAMI_FIGURE_VECTOR)
    {
      Pointer_Vector<Origami_Figure>* o = new Pointer_Vector<Origami_Figure>;
      object = static_cast<void*>(o);       
    }

  else if (type == GLYPH_VECTOR)
    {
      Pointer_Vector<Glyph>* o = new Pointer_Vector<Glyph>;
      object = static_cast<void*>(o);       
    }




@q ****** (6) |Shape|-types.@> 
@ |Shape|-types.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2004.12.12.}
Added code for the case |type == PATH_VECTOR|.

\initials{LDF 2004.12.14.}
Added code for the case |type == ELLIPSE_VECTOR|.

\initials{LDF 2004.12.14.}
Added code for the case |type == CIRCLE_VECTOR|.

\initials{LDF 2004.12.14.}
Added code for the case |type == RECTANGLE_VECTOR|.

\initials{LDF 2004.12.14.}
Added code for the case |type == REG_POLYGON_VECTOR|.

\initials{LDF 2004.12.14.}
Added code for the case |type == CUBOID_VECTOR|.

\initials{LDF 2005.01.26.}
Put this code into its own section.

\initials{LDF 2005.01.26.}
Added code for the cases |type == TETRAHEDRON_VECTOR|,
|type == OCTAHEDRON_VECTOR|,
|type == DODECAHEDRON_VECTOR|,
|type == ICOSAHEDRON_VECTOR|,
and
|type == TRUNC_OCTAHEDRON_VECTOR|.

\initials{LDF 2005.02.11.}
Added code for the case |type == POLYGON_VECTOR|.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

  else if  (type == POINT_VECTOR)
    {
      Pointer_Vector<Point>* o = new Pointer_Vector<Point>;
      object = static_cast<void*>(o);       
    }


  else if (type == PATH_VECTOR)
    {
      Pointer_Vector<Path>* o = new Pointer_Vector<Path>;
      object = static_cast<void*>(o);       
    }


  else if (type == ELLIPSE_VECTOR)
    {
      Pointer_Vector<Ellipse>* o = new Pointer_Vector<Ellipse>;
      object = static_cast<void*>(o);       
    }

  else if (type == CIRCLE_VECTOR)
    {
      Pointer_Vector<Circle>* o = new Pointer_Vector<Circle>;
      object = static_cast<void*>(o);       
    }

  else if (type == RECTANGLE_VECTOR)
    {
      Pointer_Vector<Rectangle>* o = new Pointer_Vector<Rectangle>;
      object = static_cast<void*>(o);       
    }

  else if (type == TRIANGLE_VECTOR)
    {
      Pointer_Vector<Triangle>* o = new Pointer_Vector<Triangle>;
      object = static_cast<void*>(o);       
    }


  else if (type == POLYGON_VECTOR)
    {
      Pointer_Vector<Polygon>* o = new Pointer_Vector<Polygon>;
      object = static_cast<void*>(o);       
    }

  else if (type == REG_POLYGON_VECTOR)
    {
      Pointer_Vector<Reg_Polygon>* o = new Pointer_Vector<Reg_Polygon>;
      object = static_cast<void*>(o);       
    }


  else if (type == CUBOID_VECTOR)
    {
      Pointer_Vector<Cuboid>* o = new Pointer_Vector<Cuboid>;
      object = static_cast<void*>(o);       
    }


  else if (type == POLYHEDRON_VECTOR)
    {
      Pointer_Vector<Polyhedron>* o = new Pointer_Vector<Polyhedron>;
      object = static_cast<void*>(o);       
    }
  
@q ***** (5) |UNDECLARED|.@>
@ |UNDECLARED|.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=

  else if (type == UNDECLARED)
    {

@q ****** (6) Error handling:  |object != static_cast<void*>(0)|.@>
@ Error handling:  |object != static_cast<void*>(0)|.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (i.object != static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "WARNING! In `Id_Map_Entry_Type::operator=():'"
                << endl << "`i.type' == `UNDECLARED' but `i.object' != 0."
                << endl << "Setting `object' to 0 and continuing.";
          
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

    } /* |if (i.object != static_cast<void*>(0))|  */

@q ****** (6) |object == static_cast<void*>(0)|.@>
@ |object == static_cast<void*>(0)|.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG) /* |i.object == static_cast<void*>(0)| */
     {

       cerr_strm << thread_name << "In `Id_Map_Entry_Type::operator=():'"
                << endl << "`i.type' == `UNDECLARED' and `i.object' == 0."
                << endl << "This is okay.";
          
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }  /* |else if (DEBUG)| (|i.object == static_cast<void*>(0)|)  */

#endif /* |DEBUG_COMPILE|  */@; 
 
@q ****** (6).@>
  
  } /* |if (type == UNDECLARED)| */


@q ***** (5) Arrays.@>
@ Arrays.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (array_flag)
    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Id_Map_Entry_Type::operator=()':"
                    << endl << "`array_flag' == `true'."
                    << "Will traverse tree and call this "
                    << "function recursively.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
 

@q ****** (6) |i.left != static_cast<Id_Map_Entry_Node>(0)|.@>
@ |i.left != static_cast<Id_Map_Entry_Node>(0)|.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=


      if (i.left != static_cast<Id_Map_Entry_Node>(0))
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name 
                        << "In `Id_Map_Entry_Type::operator=()':"
                        << endl << "`array_flag' == `true' && `i.left' != 0."
                        << endl 
                        << "Traversing tree leftwards and calling this "
                        << "function recursively.";
          
              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

          

          left = new Id_Map_Entry_Type;

          *left = *(i.left);

          left->up = this;

        } /* |if (i.left != static_cast<Id_Map_Entry_Node>(0))|  */


@q ****** (6) |i.right != static_cast<Id_Map_Entry_Node>(0)|.@>
@ |i.right != static_cast<Id_Map_Entry_Node>(0)|.
\initials{LDF 2004.09.14.}

@<Define |Id_Map_Entry_Type| functions@>=


      if (i.right != static_cast<Id_Map_Entry_Node>(0))
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name 
                        << "In `Id_Map_Entry_Type::operator=()':"
                        << endl << "`array_flag' == `true' && `i.right' != 0."
                        << endl 
                        << "Traversing tree rightwards and calling "
                        << "this function recursively.";
          
              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

          right = new Id_Map_Entry_Type;

          *right = *(i.right);

          right->up = this;

        } /* |if (i.right != static_cast<Id_Map_Entry_Node>(0))|  */


@q ****** (6) @> 


    } /* |if (array_flag)|  */



  return i;

}   /* End of |Id_Map_Entry_Type::operator=(const Id_Map_Entry_Type&)|
     definition.  */


@q ** (2)  Set |superordinate_vector|.@>
@*1 Set {\bf superordinate\_vector}.

\LOG
\initials{LDF 2004.08.24.}
Added this function.  

\initials{LDF 2004.09.17.}
Added |bool traverse| argument with default |false|.
Made non-inline and moved this definition from \filename{io.web}
to this file (\filename{imetfncs.web}). 

\initials{LDF 2004.09.17.}
Added the arguments |bool set_vector| and |int type|.  
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Id_Map_Entry_Type| functions@>=
int
Id_Map_Entry_Type::set_superordinate_vector(Id_Map_Entry_Node s,
                                            bool set_vector,
                                            bool traverse,
                                            int type)
{

@q **** (4) |traverse == false|.@>   
@ |traverse == false|.
Don't bother declaring and setting variables for thread-safe debugging 
and error output.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (!traverse)
    {
        superordinate_vector = s;

        if (set_vector)
          s->subordinate_array = this;

        return 0;

    } /* |if (!traverse)|  */

@q **** (4) Set up for thread-safe error and debugging output.@>   
@ Set up for thread-safe error and debugging output.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

  using namespace Scan_Parse;

  bool DEBUG = false; /* |true|  */

  int status;

  Scanner_Node scanner_node = 0;

  if (   id_map_node != static_cast<Id_Map_Node>(0) 
      && id_map_node->scanner_node != static_cast<Scanner_Node>(0))
    scanner_node = id_map_node->scanner_node;
  
  string thread_name;

  bool error_stop_value;

  if (scanner_node != static_cast<Scanner_Node>(0))
    error_stop_value = (scanner_node->get_run_state()->error_stop_mode == Run_State::STOPPING)
      ? true : false;
  else 
    error_stop_value = true;  /* |false|  */


#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

@q ***** (5) Using multithreading.@>   

@ Using multithreading.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

/* !! START HERE. LDF 2004.09.17.  
   Do this in the assignment operators, too.  */ 

      if (    scanner_node != static_cast<Scanner_Node>(0) 
           &&
              (   scanner_node->get_run_state()->multithread_input 
               || scanner_node->get_run_state()->multithread_output
               || scanner_node->get_run_state()->multithread_include))

        /* Using multithreading.  */

        {
          thread_info = Thread_Info_Type::get_thread_info();
          thread_name = Thread_Info_Type::get_thread_name(thread_info);

        } /* |if| (Using multithreading.)  */


@q ***** (5) |scanner_node == static_cast<Scanner_Node>(0)| or not using multithreading.@> 

@ |scanner_node == static_cast<Id_Map_Entry_Node>(0)| or not using multithreading.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

      else 
        {
          thread_info = static_cast<Thread_Info_Type*>(0);
          thread_name = "";

        } /* |else| (|scanner_node == static_cast<Scanner_Node>(0)| 
                     or not using multithreading.)  */


#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

  stringstream cerr_strm;
 
@q **** (4) @>   
@
@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Id_Map_Entry_Type::set_superordinate_vector()'.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str("");

    }
#endif

  
@q **** (4) Error handling:  |array_flag == false && traverse == true|.@>   
@ Error handling:  |array_flag == false && traverse == true|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=


  if (!array_flag)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Id_Map_Entry_Type::set_superordinate_vector()':"
                << endl << "`traverse' == `true' and `array_flag' == `false'."
                << endl << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (!array_flag)|  */

    
@q **** (4) |array_flag == true|.  Traverse tree.@>   
@ |array_flag == true|.  Traverse tree.
\initials{LDF 2004.09.17.}

@q ***** (5) Call this function recursively on |left|.@>   
@ Call this function recursively on |left|.
\initials{LDF 2004.09.17.}


@<Define |Id_Map_Entry_Type| functions@>=


/* !! START HERE.  LDF 2004.09.17.  Add error handling like this 
      in assignment operator.  */ 


  if (left)  
    {
      status = left->set_superordinate_vector(s, set_vector, traverse, type);
      

@q ****** (6) Error handling:  Recursive call to             @>   
@q ****** (6) |set_superordinate_vector()| on |left| failed. @>   
@ Call this function recursively on |left|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=


      if (status != 0)

        {

          
          cerr_strm << thread_name 
                    << "ERROR! In `Id_Map_Entry_Type::set_superordinate_vector()':"
                    << endl << "Recursive call to `set_superordinate_vector()' "
                    << "for `left' failed."
                    << endl << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
          
          return 1;


        } /* |if (status != 0)|  */

@q ****** (6) Recursive call to |set_superordinate_vector()| @>
@q ****** (6) on |left| succeeded. @>   
@ Recursive call to |set_superordinate_vector()| on |left| succeeded.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=
      
    } /* |if (left)|  */



@q ***** (5) Set |superordinate_vector|.@>   
@ 
\initials{LDF 2004.09.17.}


@<Define |Id_Map_Entry_Type| functions@>=

  superordinate_vector = s;

  if (set_vector)
    {

        if (s->subordinate_array == static_cast<Id_Map_Entry_Node>(0))
          s->subordinate_array = this;


        if (type == COLOR && object != static_cast<void*>(0))
          {

              typedef Pointer_Vector<Color> Pv;


              if (s->object == static_cast<void*>(0))
                s->object = static_cast<void*>(new Pv); 

              Pv* pv = static_cast<Pv*>(s->object); 

              pv->v.push_back(static_cast<Color*>(object));
              pv->ctr++;


          } /* |if (type == COLOR)|  */


        else if (type == POINT && object != static_cast<void*>(0))
          {

              typedef Pointer_Vector<Point> Pv;

              if (s->object == static_cast<void*>(0))
                s->object = static_cast<void*>(new Pv); 


              Pv* pv = static_cast<Pv*>(s->object); 

              pv->v.push_back(static_cast<Point*>(object));
              pv->ctr++;

          } /* |if (type == POINT)|  */


        else if (type == BOOL_POINT && object != static_cast<void*>(0))
          {

              typedef Pointer_Vector<Bool_Point> Pv;

              if (s->object == static_cast<void*>(0))
                s->object = static_cast<void*>(new Pv); 

              Pv* pv = static_cast<Pv*>(s->object); 

              pv->v.push_back(static_cast<Bool_Point*>(object));
              pv->ctr++;

          } /* |if (type == BOOL_POINT)|  */



        else if (object != static_cast<void*>(0))  /* Invalid |type|.  */
          {


              cerr_strm << thread_name 
                        << "ERROR! In `Id_Map_Entry_Type::set_superordinate_vector()':"
                        << endl << "Invalid `type': `" << name_map[type] 
                        << "'. Exiting function with return value 1.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              return 1;

          }  /* |else if (object != static_cast<void*>(0))| (Invalid |type|.)  */




    } /* |if (set_vector)|  */


@q ***** (5) Call this function recursively on |right|.@>   
@ Call this function recursively on |right|.
\initials{LDF 2004.09.17.}


@<Define |Id_Map_Entry_Type| functions@>=



  if (right)
    {
        status = right->set_superordinate_vector(s, set_vector, traverse, type);
      

@q ****** (6) Error handling:  Recursive call to             @>   
@q ****** (6) |set_superordinate_vector()| on |right| failed. @>   
@ Call this function recursively on |right|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=


      if (status != 0)

        {

          
          cerr_strm << thread_name 
                    << "ERROR! In `Id_Map_Entry_Type::set_superordinate_vector()':"
                    << endl << "Recursive call to `set_superordinate_vector()' "
                    << "for `right' failed."
                    << endl << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
          
          return 1;


        } /* |if (status != 0)|  */

@q ****** (6) Recursive call to |set_superordinate_vector()| @>
@q ****** (6) on |right| succeeded. @>   
@ Recursive call to |set_superordinate_vector()| on |right| succeeded.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=
      
    } /* |if (right)|  */


@q **** (4) Exit function successfully with return value 0.@>   
@ Exit function successfully with return value 0.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

  return 0;

} /* End of |Id_Map_Entry_Type::set_superordinate_vector()| definition.  */


@q ** (2)  Set |id_map_node|.@>
@*1 Set {\bf id\_map\_node}.

\LOG
\initials{LDF 2004.09.17.}
Added this function.  It's declared in \filename{io.web}.
\ENDLOG 

@q *** (3) Definition.@>

@
@<Define |Id_Map_Entry_Type| functions@>=
int
Id_Map_Entry_Type::set_id_map_node(const Id_Map_Node i, bool traverse)
{


@q **** (4) |!traverse == false|.  Just set |id_map_node| and return 0.@>
@ |!traverse == false|.  Just set |id_map_node| and return 0.

@<Define |Id_Map_Entry_Type| functions@>=

   if (!traverse)
    {
       id_map_node = i;
       return 0;
    }

@q **** (4).@>
@
@<Define |Id_Map_Entry_Type| functions@>=

  using namespace Scan_Parse;

  bool DEBUG = false; /* |true|  */

  int status;

  string thread_name;

  bool error_stop_value = true; /* |false|  */


#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

  thread_info = Thread_Info_Type::get_thread_info();
  thread_name = Thread_Info_Type::get_thread_name(thread_info);

#else /* |HAVE_PTHREAD_H| is undefined.  */@; 

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

  stringstream cerr_strm;
 
@q **** (4) @>   
@
@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Id_Map_Entry_Type::set_id_map_node()'.";


      log_message(cerr_strm); 
      cerr_strm.str("");

    }
#endif


@q **** (4) If |left != static_cast<Id_Map_Entry_Node>(0)|, @>   
@q **** (4) call this function recursively on |left|.       @>

@ If |left != static_cast<Id_Map_Entry_Node>(0)|, 
call this function recursively on |left|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

   if (left != static_cast<Id_Map_Entry_Node>(0))
      {
         status = left->set_id_map_node(i);
   

@q ***** (5) Error handling:  It failed.@>   

@ Error handling:  It failed.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

         if (status != 0)
            {
               cerr_strm << thread_name
                 	 << "ERROR! In `Id_Map_Entry_Type::set_id_map_node()':"
                 	 << endl << "`left->set_id_map_node(i)' failed."
                 	 << endl << "Exiting function with return value 1.";
        
       	       cerr_message(cerr_strm); 
       	       log_message(cerr_strm, error_stop_value);
       	       cerr_strm.str(""); 

               return 1;

            } /* |if (status != 0)|  */

      } /* |if (left != static_cast<Id_Map_Entry_Node>(0))|  */
 

@q **** (4) Set |id_map_node|.@>   

@ Set |id_map_node|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

   id_map_node = i;

@q **** (4) If |right != static_cast<Id_Map_Entry_Node>(0)|, @>   
@q **** (4) call this function recursively on |right|.       @>

@ If |right != static_cast<Id_Map_Entry_Node>(0)|, 
call this function recursively on |right|.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

   if (right != static_cast<Id_Map_Entry_Node>(0))
      {
         status = right->set_id_map_node(i);
   

@q ***** (5) Error handling:  It failed.@>   

@ Error handling:  It failed.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

         if (status != 0)
            {
               cerr_strm << thread_name
                 	 << "ERROR! In `Id_Map_Entry_Type::set_id_map_node()':"
                 	 << endl << "`right->set_id_map_node(i)' failed."
                 	 << endl << "Exiting function with return value 1.";
        
       	       cerr_message(cerr_strm); 
       	       log_message(cerr_strm, error_stop_value);
       	       cerr_strm.str(""); 

               return 1;

            } /* |if (status != 0)|  */

      } /* |if (right != static_cast<Id_Map_Entry_Node>(0))|  */
 


@q **** (4) Exit function successfully with return value 0.@>   

@ Exit function successfully with return value 0.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

   return 0;

} /* End of |Id_Map_Entry_Type::set_id_map_node()| definition.  */

@q ** (2)  Set |subordinate_array|.@>
@*1 Set {\bf subordinate\_array}.

I originally wanted this to be a template function, but it failed to compile when 
I called it recursively, apparently because the definition wasn't
available.  Nor it did work to define an additional template function
that called this function and call it here.
\initials{LDF 2004.09.17.}

I am currently not using this function.  I intended it for use in 
|Id_Map_Type::operator=(const Id_Map_Type& i)|, but I've now made it
possible for |Id_Map_Entry_Type::set_superordinate_vector()| to 
push pointers onto the |Pointer_Vector| of the |superordinate_vector|
while it's setting its own |superordinate_vector| member.  This way,
the tree of |Id_Map_Entry_Nodes| is only traversed once.
\initials{LDF 2004.09.17.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.09.17.}
If it ever seems worthwhile, I could change this function, so that it
sets the |superordinate_vector| member of |s| to |this|.
\ENDTODO 

\LOG
\initials{LDF 2004.08.25.}
Added this function.  

\initials{LDF 2004.09.17.}
Added |bool traverse| argument with default |false|.
Made non-inline and moved definition from \filename{io.web} 
to this file (\filename{imetfncs.web}). 

\initials{LDF 2004.09.17.}
Added |int type| argument.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Id_Map_Entry_Type| functions@>=
int
Id_Map_Entry_Type::set_subordinate_array(Id_Map_Entry_Node s,
                                         bool traverse,
                                         int type)
{

@q **** (4) If |traverse == false|, set |superordinate_vector| and return 0.@>   
@ If |traverse == false|, set |subordinate_array| and return 0.
Don't bother declaring and setting variables for thread-safe debugging 
and error output.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=


  subordinate_array = s;

  if (!traverse)
    return 0;
  
@q **** (4) Set up for thread-safe error and debugging output.@>   
@ Set up for thread-safe error and debugging output.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

  using namespace Scan_Parse;

  bool DEBUG = false; /* |true|  */

  int status;

  Scanner_Node scanner_node = 0;

  if (   id_map_node != static_cast<Id_Map_Node>(0) 
      && id_map_node->scanner_node != static_cast<Scanner_Node>(0))
    scanner_node = id_map_node->scanner_node;
  
  string thread_name;

  bool error_stop_value;

  if (scanner_node != static_cast<Scanner_Node>(0))
    error_stop_value = (scanner_node->get_run_state()->error_stop_mode == Run_State::STOPPING)
      ? true : false;
  else 
    error_stop_value = true;  /* |false|  */


#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

@q ***** (5) Using multithreading.@>   

@ Using multithreading.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

      if (scanner_node != static_cast<Scanner_Node>(0) &&
          (   scanner_node->get_run_state()->multithread_input 
           || scanner_node->get_run_state()->multithread_output
           || scanner_node->get_run_state()->multithread_include))

        /* Using multithreading.  */

        {
          thread_info = Thread_Info_Type::get_thread_info();
          thread_name = Thread_Info_Type::get_thread_name(thread_info);

        } /* |if| (Using multithreading.)  */


@q ***** (5) |scanner_node == static_cast<Scanner_Node>(0)| or not using multithreading.@>   

@ |scanner_node == static_cast<Scanner_Node>(0)| or not using multithreading.
\initials{LDF 2004.09.17.}

@<Define |Id_Map_Entry_Type| functions@>=

      else /* |scanner_node == static_cast<Scanner_Node>(0)| or not using multithreading.  */
        {
          thread_info = static_cast<Thread_Info_Type*>(0);
          thread_name = "";

        } /* |else| (|scanner_node == static_cast<Scanner_Node>(0)| 
                     or not using multithreading.)  */


#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

  stringstream cerr_strm;
 
@q **** (4) @>   
@
@<Define |Id_Map_Entry_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name 
                  << "Entering `Id_Map_Entry_Type::set_subordinate_array()'.";


        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

    }
#endif



    if (s->left != static_cast<Id_Map_Entry_Node>(0))
      set_subordinate_array(s->left, true, type);



   if (s->object != static_cast<void*>(0))
     {
#if DEBUG_COMPILE
         if (DEBUG)
           {
               cerr_strm << thread_name 
                         << "In `Id_Map_Entry_Type::set_subordinate_array()':"
                         << endl << "Pushing back `" << s->name << "'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
           }
#endif

         if (type == COLOR)
           {
               typedef Pointer_Vector<Color> Pv;

               Pv* pv = static_cast<Pv*>(object); 

               pv->v.push_back(static_cast<Color*>(s->object));
               pv->ctr++;
           }


         else if (type == POINT)
           {
               typedef Pointer_Vector<Point> Pv;

               Pv* pv = static_cast<Pv*>(object); 

               pv->v.push_back(static_cast<Point*>(s->object));
               pv->ctr++;
           }


         else if (type == BOOL_POINT)
           {
               typedef Pointer_Vector<Bool_Point> Pv;

               Pv* pv = static_cast<Pv*>(object); 

               pv->v.push_back(static_cast<Bool_Point*>(s->object));
               pv->ctr++;
           }

         else /* Invalid |type|.  */
           {


               cerr_strm << thread_name 
                        << "ERROR! In `Id_Map_Entry_Type::set_subordinate_array()':"
                        << endl << "Invalid `type': `" << name_map[type] 
                        << "'. Exiting function with return value 1.";

               log_message(cerr_strm);
               cerr_message(cerr_strm, error_stop_value);
               cerr_strm.str("");

               return 1;

           }  /* |else| (Invalid |type|.)  */



     } /* |if (s->object != static_cast<void*>(0))|  */

   
   if (s->right != static_cast<Id_Map_Entry_Node>(0))
     set_subordinate_array(s->right, true, type);


@q **** (4) @>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Exiting `Id_Map_Entry_Type::set_subordinate_array()' "
                 << "successfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 



   return 0;

} /* End of |Id_Map_Entry_Type::set_subordinate_array()| definition.  */



@q ** (2) Transformations.  @>
@*1 Transformations.

\LOG
\initials{LDF 2004.09.29.}
Added this section.
\ENDLOG

@q *** (3) Multiplying by a |Transform| with assignment.@>
@*2 Multiplying by a {\bf Transform} with assignment.

\LOG
\initials{LDF 2004.09.29.}
Added this function.  It's used in the parser rule
\transformation command> $\longrightarrow$ \.{ROTATE} \any variable> 
\.{AROUND} \.{LEFT\_PARENTHESIS} \point expression> \.{COMMA} 
\point expression> \.{RIGHT\_PARENTHESIS} \optional by numeric expression> in 
\filename{ptrfcmnd.w}.
\ENDLOG

@q **** (4) Definition.@> 

@
@<Define |Id_Map_Entry_Type| functions@>=
Transform
Id_Map_Entry_Type::operator*=(const Transform& t)
{


@q ***** (5) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  using namespace Scan_Parse;

  stringstream cerr_strm;

  string thread_name = "";

  Scanner_Node scanner_node = 0;

  bool error_stop_value = true;

  if (id_map_node && id_map_node->scanner_node)
    {
      scanner_node = id_map_node->scanner_node;
  
      error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
        ? true : false;
    }

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

@q ***** (5).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Id_Map_Entry_Type::operator*=(const Transform&)'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling:  |object == static_cast<void*>(0)|.@>

@ Error handling:  |object == static_cast<void*>(0)|.
\initials{LDF 2004.09.29.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (object == static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Id_Map_Entry_Type::operator(const Transform&)':"
                << endl << "`object' is null. Can't transform."
                << endl 
                << "Exiting function with return value `INVALID_TRANSFORM'.";

      return INVALID_TRANSFORM;

    } /* |if (object == static_cast<void*>(0))|  */

@q ***** (5).@> 
@
@<Define |Id_Map_Entry_Type| functions@>=

  else if (is_shape())
    *static_cast<Shape*>(object) *= t;

  else if (type == PEN)
    *static_cast<Pen*>(object) *= t;

  else if (type == DASH_PATTERN)
    *static_cast<Dash_Pattern*>(object) *= t;

  else if (type == TRANSFORM)
    *static_cast<Transform*>(object) *= t;

  else if (type == BOOL_POINT)
    {
      Bool_Point* bp = static_cast<Bool_Point*>(object);
      bp->pt *= t;
    }


@q ***** (5) Error handling:  Invalid type.@>

@ Error handling:  Invalid type.
\initials{LDF 2004.09.29.}

@<Define |Id_Map_Entry_Type| functions@>=

  else  /* Invalid |type|.  */ 
    {
      cerr_strm << thread_name 
                << "ERROR! In `Id_Map_Entry_Type::operator(const Transform&)':"
                << endl << "`Id_Map_Entry_Type' has invalid type: `"
                << name_map[type] << "'." 
                << "Exiting function with return value `INVALID_TRANSFORM'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return INVALID_TRANSFORM;

    }  /* |else| (Invalid |type|.)  */ 

@q ***** (5) Exit function successfully with return value |t|.@> 

@ Exit function successfully with return value |t|.
\initials{LDF 2004.09.29.}

@<Define |Id_Map_Entry_Type| functions@>=    

  return t;

}  /* End of |Id_Map_Entry_Type::operator*=(const Transform&)|
      definition.  */


@q ** (2) Returning elements and information.  @>
@*1 Returning elements and information.

@q *** (3) Is 3DLDF object type.  @>
@*2 Is 3DLDF object type.

\LOG
\initials{LDF 2004.04.23.}  Added this function. 
\ENDLOG


@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::is_ldf_type(void) const
{
  return (type >= NUMERIC && type <= Scan_Parse::MAX_SHAPE);
}


@q *** (3) Is |Shape|.@>
@*2 Is {\bf Shape}.

\LOG
\initials{LDF 2005.07.01.}  
Added this function. 

\initials{LDF 2005.01.06.}
@:BUG FIX@> BUG FIX:  Removed |type == BOOL_POINT| from the
conditional, so that this function returns |false| if
|object| is a |Bool_Point|.

\initials{LDF 2005.02.11.}
Now returning |true| if |type == POLYGON|.

\initials{LDF 2005.03.29.}
Now returning |true| if |type| is |ELLIPSE_SLICE|,
|CIRCLE_SLICE|, or |POLYHEDRON_SLICE|.

\initials{LDF 2005.05.19.}
Now returning |true| if |type| is |HELIX|.

\initials{LDF 2005.05.25.}
Now returning |true| if |type| is |CONE| or |CYLINDER|.

\initials{LDF 2005.05.26.}
Now returning |true| if |type| is |ELLIPSOID|.

\initials{LDF 2005.06.06.}
Now returning |true| if |type| is |SPHERE|.

\initials{LDF 2005.11.07.}
Now returning |true| if |type| is |PARABOLA|, |HYPERBOLA|,
|PARABOLOID|, or |HYPERBOLOID|.

\initials{LDF 2007.10.13.}
Now returning |true| if |type| is |ARC|.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::is_shape(void) const
{
  if (   type == POINT 
      || type == PATH   
      || type == TRIANGLE
      || type == POLYGON
      || type == REG_POLYGON
      || type == RECTANGLE
      || type == SQUARE
      || type == ELLIPSE
      || type == CIRCLE
      || type == PARABOLA
      || type == HYPERBOLA
      || type == ARC
      || type == HELIX
      || type == CONE
      || type == CYLINDER
      || type == CUBOID
      || type == POLYHEDRON
      || type == ELLIPSOID
      || type == SPHERE
      || type == PARABOLOID
      || type == HYPERBOLOID
      || type == ELLIPSE_SLICE
      || type == CIRCLE_SLICE
      || type == POLYHEDRON_SLICE)

    return true;
  else
    return false;

}  /* End of |Id_Map_Entry_Type::is_shape()| definition.  */


@q *** (3) Is |Shape|-vector-type.@>
@*2 Is {\bf Shape}-vector-type.
\initials{LDF 2004.12.12.}

\LOG
\initials{LDF 2004.12.12.}
Added this function. 

\initials{LDF 2005.02.11.}
Now returning |true| if |type == POLYGON_VECTOR|.

\initials{LDF 2005.03.29.}
Now returning |true| if |type| is |ELLIPSE_SLICE_VECTOR|,
|CIRCLE_SLICE_VECTOR|, or |POLYHEDRON_SLICE_VECTOR|.

\initials{LDF 2005.05.19.}
Now returning |true| if |type| is |HELIX_VECTOR|.

\initials{LDF 2005.05.25.}
Now returning |true| if |type| is |CONE_VECTOR| 
or |CYLINDER_VECTOR|.

\initials{LDF 2005.05.26.}
Now returning |true| if |type| is |ELLIPSOID_VECTOR|. 

\initials{LDF 2005.06.06.}
Now returning |true| if |type| is |SPHERE_VECTOR|. 

\initials{LDF 2005.12.01.}
Now returning |true| if |type| is |PARABOLA_VECTOR| or |HYPERBOLA_VECTOR|.

\initials{LDF 2006.01.23.}
Now returning |true| if |type| is |PARABOLOID_VECTOR| or |HYPERBOLOID_VECTOR|.

\initials{LDF 2007.10.13.}
Now returning |true| if |type| is |ARC_VECTOR|.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::is_shape_vector_type(void) const
{
  if (   type == POINT_VECTOR 
      || type == PATH_VECTOR 
      || type == BOOL_POINT_VECTOR 
      || type == TRIANGLE_VECTOR
      || type == POLYGON_VECTOR
      || type == REG_POLYGON_VECTOR
      || type == RECTANGLE_VECTOR
      || type == SQUARE_VECTOR
      || type == ELLIPSE_VECTOR
      || type == PARABOLA_VECTOR
      || type == HYPERBOLA_VECTOR
      || type == ARC_VECTOR
      || type == CIRCLE_VECTOR
      || type == HELIX_VECTOR
      || type == CONE_VECTOR
      || type == CYLINDER_VECTOR
      || type == CUBOID_VECTOR
      || type == POLYHEDRON_VECTOR
      || type == ELLIPSOID_VECTOR
      || type == SPHERE_VECTOR
      || type == PARABOLOID_VECTOR
      || type == HYPERBOLOID_VECTOR
      || type == ELLIPSE_SLICE_VECTOR
      || type == CIRCLE_SLICE_VECTOR
      || type == POLYHEDRON_SLICE_VECTOR)

    return true;

  else
    return false;

}  /* End of |Id_Map_Entry_Type::is_shape_vector_type()| definition.  */

@q *** (3) Is Non-|Shape|-vector-type.@>
@*2 Is Non-{\bf Shape}-vector-type.
\initials{LDF 2004.12.12.}

\LOG
\initials{LDF 2004.12.12.}
Added this function. 

\initials{LDF 2004.12.28.}
Added |type == MACRO_VECTOR| to the conditional.

\initials{LDF 2005.06.09.}
Added |type == ORIGAMI_FIGURE_VECTOR| and
|type == GLYPH_VECTOR| to the conditional.

\initials{LDF 2005.12.05.}
Added |type == ULONG_LONG_VECTOR|
to the conditional.

\initials{LDF 2007.07.29.}
Added |type == CONIC_SECTION_LATTICE_VECTOR| to the conditional.

\initials{LDF 2007.12.04.}
Added |COMPLEX_VECTOR| and |MATRIX_VECTOR| to the conditional.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::is_non_shape_vector_type(void) const
{
  if (   type == BOOLEAN_VECTOR      
      || type == STRING_VECTOR       
      || type == NUMERIC_VECTOR      
      || type == COMPLEX_VECTOR      
      || type == MATRIX_VECTOR      
      || type == ULONG_LONG_VECTOR      
      || type == PEN_VECTOR          
      || type == DASH_PATTERN_VECTOR 
      || type == COLOR_VECTOR        
      || type == PICTURE_VECTOR      
      || type == TRANSFORM_VECTOR    
      || type == FOCUS_VECTOR
      || type == MACRO_VECTOR
      || type == ORIGAMI_FIGURE_VECTOR
      || type == GLYPH_VECTOR
      || type == CONIC_SECTION_LATTICE_VECTOR)

    return true;
  else
    return false;

}  /* End of |Id_Map_Entry_Type::is_non_shape_vector_type()| definition.  */


@q *** (3) Is Vector-type.@>
@*2 Is Vector-type.
\initials{LDF 2004.12.12.}

\LOG
\initials{LDF 2004.12.12.}
Added this function. 
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=
bool
Id_Map_Entry_Type::is_vector_type(void) const
{
  return (is_shape_vector_type() || is_non_shape_vector_type());

}  /* End of |Id_Map_Entry_Type::is_vector_type()| definition.  */


@q ** (2) Showing.@>
@*1 Showing.

DO NOT try to lock |cerr_mutex| or call |cerr_message()|
in this function!  Code that calls this function should lock 
|cerr_mutex| before and unlock it after the call.
\initials{LDF 2004.08.23.}

\LOG
\initials{LDF 2004.05.03.}  
@:BUG FIX@> BUG FIX:  
Now casting |object| to |Transform*| or |Point*| before calling 
|show()| on it, if it's of one of these types.  
Casting |object| to |Shape*| and calling |show()| on it caused 
3DLDF to exit abruptly. 

\initials{LDF 2004.05.09.}  
Now showing |const_flag|.  Changed |is_array| to |array_flag|.

\initials{LDF 2004.05.17.}  
Added code for showing |booleans|.

\initials{LDF 2004.05.21.}  
Added code for showing |PEN|, |COLOR|, and |PICTURE|. 

\initials{LDF 2004.06.07.}  
Added code for showing |dash_patterns|.

\initials{LDF 2004.06.08.}  
Added code for showing |FOCUS|.

\initials{LDF 2004.06.18.}  
Added code for showing |circles|.

\initials{LDF 2004.06.29.}  
Added code for showing |ellipses|.

\initials{LDF 2004.06.30.}  
Added code for showing |rectangles|.

\initials{LDF 2004.07.01.}  
Added code for showing synonyms.

\initials{LDF 2004.07.06.}  
Added code for showing |reg_polygons|.

\initials{LDF 2004.07.26.}
Added code for showing internal quantities.

\initials{LDF 2004.08.18.}
Added code for showing |cuboids|.

\initials{LDF 2004.08.23.}
Added optional |Scanner_Node scanner_node| argument.  It defaults to 0.

\initials{LDF 2004.08.23.}
Now using |stringstream cerr_strm| for terminal output.

\initials{LDF 2004.08.23.}
Now using thread information for debugging and error output.

\initials{LDF 2004.08.24.}
Added code for the |COLOR_VECTOR| case.

\initials{LDF 2004.08.24.}
Added code for showing whether |superordinate_vector| 
is null or not.

\initials{LDF 2004.08.25.}
Added code for showing whether |subordinate_array| 
is null or not.

\initials{LDF 2004.08.31.}
Added code for showing |tetrahedra|, |dodecahedra|, 
|icosahedra|, and |trunc_octahedra|.  Also added code for showing 
|octahedra|, but it's currently commented-out, because I haven't 
defined |class Octahedron| yet.

\initials{LDF 2004.08.31.}
Added code for the |POINT_VECTOR| case.

\initials{LDF 2004.09.01.}
Added code for showing |bool_points|.

\initials{LDF 2004.09.01.}
Added code for showing |bool_point_vectors|.

\initials{LDF 2004.09.14.}
Added |bool traverse| argument with default |false|.
Added code for traversing the tree structure for array entries 
if |traverse == true|.

\initials{LDF 2004.09.19.}
Removed |Scanner_Node scanner_node| argument.  Now declaring
|scanner_node| locally and setting it to |id_map_node->scanner_node|,
or 0, if |id_map_node| is 0.

\initials{LDF 2004.09.19.}
@:BUG FIX@> BUG FIX:  Replaced calls to |cerr_message()| with 
commands for writing to |cerr| directly.  
Code that calls this function usually locks |cerr_mutex|, 
and |cerr_message()| also tries to lock it, so this function shouldn't
call it.

\initials{LDF 2004.10.26.}
Added optional |bool verbose| argument with default |false|.
Reduced the amount of information output when |verbose == false|.

\initials{LDF 2004.12.28.}
Added code for showing |macros|.

\initials{LDF 2005.02.11.}
Added code for showing |polygons|.

\initials{LDF 2005.05.19.}
Added code for showing |helices|.

\initials{LDF 2005.05.25.}
Added code for showing |cones|, |cylinders|,
|cone_vectors|, and |cylinder_vectors|.

\initials{LDF 2005.05.26.}
Added code for showing |ellipsoids| and |ellipsoid_vectors|.

\initials{LDF 2005.06.06.}
Added code for showing |spheres| and |sphere_vectors|.

\initials{LDF 2005.06.09.}
Removed code for handling objects where |type == DEFUN|.

\initials{LDF 2006.01.23.}
Added code for showing |paraboloids|, |paraboloid_vectors|,
|hyperboloids|, and |hyperboloid_vectors|.  The code for showing 
|hyperboloids| is commented out.

\initials{LDF 2007.07.29.}
Added code for showing |Parabolae|, |Hyperbolae|, |Conic_Section_Lattices|,
|Parabola_Vectors|, |Hyperbola_Vectors|, and |Conic_Section_Lattice_Vectors|.

\initials{LDF 2007.10.13.}
Added code for showing |Arcs|. 
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.05.03.}
Write code for showing other types of objects.  
\ENDTODO 

@q *** Definition.  @>


@
@<Define |Id_Map_Entry_Type| functions@>=
void 
Id_Map_Entry_Type::show(string s,
                        bool traverse,
                        bool verbose) const

{

@q DO NOT try to lock |cerr_mutex| or call |cerr_message()|      @>
@q in this function!  Code that calls this function should lock  @>
@q |cerr_mutex| before and unlock it after the call.             @>
@q \initials{LDF 2004.08.23.}                                    @>
  
  using namespace Scan_Parse;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif
 
   Scanner_Node scanner_node;

   if (id_map_node != static_cast<Id_Map_Node>(0))
     scanner_node = id_map_node->scanner_node;
   else 
     scanner_node = static_cast<Scanner_Node>(0);


@q **** (4) Get thread information, or not, depending on circumstances.@>   

@ Get thread information, or not, depending on circumstances.
\initials{LDF 2004.08.23.}

@<Define |Id_Map_Entry_Type| functions@>=


  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  

@q ***** (5) |scanner_node != static_cast<Scanner_Node>(0)|.@>   

@ |scanner_node != static_cast<Scanner_Node>(0)|.
\initials{LDF 2004.08.23.}

@<Define |Id_Map_Entry_Type| functions@>=

  if (scanner_node != static_cast<Scanner_Node>(0)) 
    {
   
@q ****** (6) Using multithreading.@>   

@ Using multithreading.
\initials{LDF 2004.08.23.}

@<Define |Id_Map_Entry_Type| functions@>=

      if (scanner_node->get_run_state()->multithread_input 
        || scanner_node->get_run_state()->multithread_output
        || scanner_node->get_run_state()->multithread_include)

        /* Using multithreading.  */

        {
          thread_info = Thread_Info_Type::get_thread_info(true);
          thread_name = Thread_Info_Type::get_thread_name(thread_info);

        } /* Using multithreading.  */


@q ****** (6) |scanner_node != static_cast<Scanner_Node>(0)|, but not using multithreading.@> 

@ |scanner_node != static_cast<Scanner_Node>(0)|, but not using multithreading.
\initials{LDF 2004.08.23.}

@<Define |Id_Map_Entry_Type| functions@>=

      else /* |scanner_node != static_cast<Scanner_Node>(0)|, but not using multithreading.  */
        {
          thread_info = static_cast<Thread_Info_Type*>(0);
          thread_name = "";

        } /* |else| (|scanner_node != static_cast<Scanner_Node>(0)|, 
                     but not using multithreading.)  */

    } /* |if (scanner_node)|  */


@q ***** (5) |scanner_node == static_cast<Scanner_Node>(0)|.  Assume we're using multithreading.@>
@ |scanner_node == static_cast<Scanner_Node>(0)|.  Assume we're using multithreading.

@<Define |Id_Map_Entry_Type| functions@>=

  else /* (|scanner_node == static_cast<Scanner_Node>(0)|)  */
    {

      thread_info = Thread_Info_Type::get_thread_info(true);
      thread_name = Thread_Info_Type::get_thread_name(thread_info);


    } /* |else| (|scanner_node == static_cast<Scanner_Node>(0)|)  */

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 
 

@q **** (4) Set |error_stop_value|.@>   

@ Set |error_stop_value|.
\initials{LDF 2004.08.23.}

@<Define |Id_Map_Entry_Type| functions@>=

  bool error_stop_value;

  if (scanner_node != static_cast<Scanner_Node>(0))
    error_stop_value 
       = (   scanner_node->get_run_state()->error_stop_mode 
          == Run_State::STOPPING)
      ? true : false;

  else 
    error_stop_value = true;  /* |false|  */

@q **** (4) @>   
@
@<Define |Id_Map_Entry_Type| functions@>=

  stringstream cerr_strm;

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Id_Map_Entry_Type::show()'.";


      log_message(cerr_strm); 
      cerr << cerr_strm.str() << endl;
      cerr_strm.str("");

    }
#endif


  if (verbose)
     {

         if (s == "")
           s = "Id_Map_Entry_Type:";

 
         cerr_strm << s << endl
                   << "name == " << name << endl
                   << "type == " << name_map[type];

         log_message(cerr_strm); 
         cerr << cerr_strm.str() << endl;
         cerr_strm.str("");

   } /* |if (verbose)|  */

  else /* |!verbose| */
     {

        cerr_strm << name << ": " << endl;

        log_message(cerr_strm); 
        cerr << cerr_strm.str();
        cerr_strm.str("");

     }     /* |else| (|!verbose|)  */


@q **** (4) Print |category|.@>

@ Print |category|.
\initials{LDF 2004.08.23.}   

@<Define |Id_Map_Entry_Type| functions@>=

  if (verbose)
     {
       if (category == SPARK)
         {
           cerr_strm << "category == SPARK";

         }
  
       else if (category == REGULAR)
         {
           cerr_strm << "category == REGULAR";

         }

       else if (category == INTERNAL)
         {
           cerr_strm << "category == INTERNAL";

         }



       else if (category == TRUE_INTERNAL)
         {
           cerr_strm << "category == TRUE_INTERNAL";

         }

       else
         {
           cerr_strm << thread_name << "ERROR! In `Id_Map_Entry_Type::show()':"
                     << endl
                     << "`category' has invalid value: " 
                     << category << endl << "Will try to continue.";
         }  

       log_message(cerr_strm); 
       cerr << cerr_strm.str() << endl;
       cerr_strm.str("");


   } /* |if (verbose)|  */

@q **** (4)@>
@ 
@<Define |Id_Map_Entry_Type| functions@>=


     if (verbose)
       {

        cerr_strm << "const_flag == " << const_flag << endl
                  << "array_flag == " << array_flag;


        log_message(cerr_strm); 
        cerr << cerr_strm.str() << endl;
        cerr_strm.str("");

    } /* |if (verbose)|  */

@q **** (4) Print out |known_state|.@>

@ Print out |known_state|.
\initials{LDF 2004.08.23.}

\LOG
\initials{LDF 2004.08.27.}
Added code for the case that |known_state == EXPIRED|.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

   if (verbose)
     {
  
         bool temp_bool = false;

         if (known_state == INDEPENDENT)
           {
             cerr_strm << "known_state == INDEPENDENT";
           }

         else if (known_state == DEPENDENT)
           {
             cerr_strm << "known_state == DEPENDENT";
           }
    
         else if (known_state == KNOWN)
           {
             cerr_strm << "known_state == KNOWN";
           }
    
         else
           {
             cerr_strm << thread_name << "ERROR! In `Id_Map_Entry_Type::show()':"
                       << endl 
                       << "`known_state' has invalid value: " << known_state
                       << endl << "Will try to continue.";

             temp_bool = true;

           }


         log_message(cerr_strm); 
         cerr << cerr_strm.str() << endl;
         cerr_strm.str("");

  } /* |if (verbose)|  */


@q **** (4)@>
@ 
@<Define |Id_Map_Entry_Type| functions@>=



  if (object != static_cast<void*>(0))
    {

@q ***** (5) |PREDICATE|  @>
@ |PREDICATE|.
\initials{LDF 2007.11.28.}

\LOG
\initials{LDF 2007.11.28.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

      if (type == PREDICATE)
        {
          if (verbose)
             cerr_strm << "Predicate == ";
   
          log_message(cerr_strm); 
          cerr << cerr_strm.str();
          cerr_strm.str("");
          
        }

@q ***** (5)@>


      else if (type == BOOLEAN)
        {
          if (verbose)
             cerr_strm << "boolean value == ";
   
         
          cerr_strm << ((*static_cast<bool*>(get_object())) 
                       ? "true" : "false");

          log_message(cerr_strm); 
          cerr << cerr_strm.str();
          cerr_strm.str("");
          
        }


@q ***** (5)@>

      else if (type == BOOL_POINT)
        {

          Bool_Point* bp = static_cast<Bool_Point*>(get_object());

          if (verbose)
             cerr_strm << "bool_point value: bool == ";

          if (bp->b)
            cerr_strm << "true.";
          else
            cerr_strm << "false.";

          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
            
          bp->pt.show();
          
        } /* |else if (type == BOOL_POINT)|  */

@q ***** (5)@>

      else if (type == STRING)
        {
          if (verbose)
             cerr_strm << "string value == ";

          cerr_strm << *static_cast<string*>(get_object());
          
          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
        }

@q ***** (5)@>

      else if (type == NUMERIC)
        {

          if (verbose)
             cerr_strm << "numeric value == ";
      
          cerr_strm << *static_cast<real*>(object);

          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
        }

@q ***** (5)@>

      else if (type == ULONG_LONG)
        {

          if (verbose)
             cerr_strm << "ulong_long value == ";
      
          cerr_strm << *static_cast<ulong_long*>(object);

          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
        }



@q ***** (5)@>

      else if (type == PEN)
        {
          static_cast<Pen*>(object)->show("pen:");
        }

@q ***** (5)@>

      else if (type == DASH_PATTERN)
        {
          static_cast<Dash_Pattern*>(object)->show("dash_pattern:");
        }

@q ***** (5)@>

      else if (type == COLOR)
        {
          static_cast<Color*>(object)->show("color:");
        }


@q ***** (5)@>

      else if (type == TRANSFORM)
        {
          static_cast<Transform*>(object)->show("transform:");
        }


@q ***** (5)@>

      else if (type == PICTURE)
        {
          static_cast<Picture*>(object)->show("picture:");
        }


@q ***** (5)@>

      else if (type == POINT)
        {
          static_cast<Point*>(object)->show();
        }

@q ***** (5)@>

      else if (type == FOCUS)
        {
          static_cast<Focus*>(object)->show("focus:");
        }


@q ***** (5)@>

      else if (type == MACRO)
        {
          static_cast<Definition_Info_Node>(object)->show("macro:");
        }


@q ***** (5)@>

      else if (type == PATH)
        {
          static_cast<Path*>(object)->show("path:");
        }

@q ***** (5)@>

      else if (type == CIRCLE)
        {
          static_cast<Circle*>(object)->show("circle:");
        }


@q ***** (5)@>

      else if (type == ELLIPSE)
        {
          static_cast<Ellipse*>(object)->show("ellipse:");
        }


@q ***** (5)@>

      else if (type == PARABOLA)
        {
          static_cast<Parabola*>(object)->show("parabola:");
        }

@q ***** (5)@>

      else if (type == HYPERBOLA)
        {
          static_cast<Hyperbola*>(object)->show("hyperbola:");
        }

@q ***** (5)@>

      else if (type == ARC)
        {
          static_cast<Arc*>(object)->show("arc:");
        }

@q ***** (5)@>

      else if (type == CONIC_SECTION_LATTICE)
        {
          static_cast<Conic_Section_Lattice*>(object)->show("conic_section_lattice:");
        }


@q ***** (5)@>

      else if (type == HELIX)
        {
          static_cast<Helix*>(object)->show("helix:");
        }

@q ***** (5)@>

      else if (type == POLYGON)
        {
          static_cast<Polygon*>(object)->show("polygon:");
        }

@q ***** (5)@>

      else if (type == RECTANGLE)
        {
          static_cast<Rectangle*>(object)->show("rectangle:");
        }

@q ***** (5)@>

      else if (type == REG_POLYGON)
        {
          static_cast<Reg_Polygon*>(object)->show("reg_polygon:");
        }

@q ***** (5)@>  

      else if (type == CONE)
        {
          static_cast<Cone*>(object)->show("cone:");
        }


@q ***** (5)@>  

      else if (type == CYLINDER)
        {
          static_cast<Cylinder*>(object)->show("cylinder:");
        }


@q ***** (5)@>

      else if (type == ELLIPSOID)
        {
          static_cast<Ellipsoid*>(object)->show("ellipsoid:");
        }


@q ***** (5)@>

      else if (type == SPHERE)
        {
          static_cast<Sphere*>(object)->show("sphere:");
        }

@q ***** (5)@>
@
\LOG
\initials{LDF 2009.11.04.}
Added this section.
\ENDLOG

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == SPHERE_DEVELOPMENT)
        {
          static_cast<Sphere_Development*>(object)->show("sphere_development:");
        }

@q ***** (5)@>

      else if (type == PARABOLOID)
        {
          static_cast<Paraboloid*>(object)->show("paraboloid:");
        }


@q ***** (5)@>

#if 0 
      else if (type == HYPERBOLOID)
        {
          static_cast<Hyperboloid*>(object)->show("hyperboloid:");
        }
#endif 

@q ***** (5)@>

      else if (type == CUBOID)
        {
          static_cast<Cuboid*>(object)->show("cuboid:");
        }


@q ***** (5)@>

      else if (type == POLYHEDRON)
        {
          static_cast<Polyhedron*>(object)->show("polyhedron:");
        }

@q ***** (5)@>
@

\LOG
\initials{LDF 2004.10.08.}
Commented this section in.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

@q ***** (5)@>

      else if (type == SYNONYM)
        {
           if (verbose)
              cerr_strm << "object (string): ";
          
          cerr_strm << *static_cast<string*>(object);

          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
        }
      

@q ***** (5) Vector types.@>

@ Vector types.
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.24.}
Added this section.
\ENDLOG 

@q ****** (6) |COLOR_VECTOR|.@>

@ |COLOR_VECTOR|.
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == COLOR_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
              if (verbose)
                 {
                    cerr_strm << "object != static_cast<void*>(0).";
              
                    log_message(cerr_strm); 
                    cerr << cerr_strm.str() << endl;
                    cerr_strm.str("");
                 } /* |if (verbose)|  */

              typedef Pointer_Vector<Color> PV;
              
              PV*  pv = static_cast<PV*>(object);
              
              pv->show("color_vector:");
              

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == COLOR_VECTOR)|  */
      

@q ****** (6) |POINT_VECTOR|.@>

@ |POINT_VECTOR|.
\initials{LDF 2004.08.31.}

\LOG
\initials{LDF 2004.08.31.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == POINT_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {

              if (verbose)
                  {
                      cerr_strm << "object != static_cast<void*>(0).";
              
                      log_message(cerr_strm); 
                      cerr << cerr_strm.str() << endl;
                      cerr_strm.str("");

                  } /* |if (verbose)|  */

              typedef Pointer_Vector<Point> PV;

              PV*  pv = static_cast<PV*>(object);
              
              pv->show("point_vector:");
              

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == POINT_VECTOR)|  */


@q ****** (6) |BOOL_POINT_VECTOR|.@>

@ |BOOL_POINT_VECTOR|.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == BOOL_POINT_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Bool_Point> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("bool_point_vector:");
              

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == BOOL_POINT_VECTOR)|  */



@q ****** (6) |PATH_VECTOR|.@>

@ |PATH_VECTOR|.
\initials{LDF 2004.12.12.}

\LOG
\initials{LDF 2004.12.12.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == PATH_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Path> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("path_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == PATH_VECTOR)|  */

@q ****** (6) |ELLIPSE_VECTOR|.@>

@ |ELLIPSE_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == ELLIPSE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Ellipse> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("ellipse_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == ELLIPSE_VECTOR)|  */


@q ****** (6) |CIRCLE_VECTOR|.@>

@ |CIRCLE_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == CIRCLE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Circle> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("circle_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == CIRCLE_VECTOR)|  */


@q ****** (6) |PARABOLA_VECTOR|.@>
@ |PARABOLA_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == PARABOLA_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Parabola> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("parabola_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == PARABOLA_VECTOR)|  */


@q ****** (6) |HYPERBOLA_VECTOR|.@>
@ |HYPERBOLA_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == HYPERBOLA_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Hyperbola> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("hyperbola_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == HYPERBOLA_VECTOR)|  */


@q ****** (6) |ARC_VECTOR|.@>
@ |ARC_VECTOR|.
\initials{LDF 2007.10.13.}

\LOG
\initials{LDF 2007.10.13.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == ARC_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Arc> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("arc_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == ARC_VECTOR)|  */




@q ****** (6) |CONIC_SECTION_LATTICE_VECTOR|.@>
@ |CONIC_SECTION_LATTICE_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == CONIC_SECTION_LATTICE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Conic_Section_Lattice> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("conic_section_lattice_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == CONIC_SECTION_LATTICE_VECTOR)|  */


@q ****** (6) |HELIX_VECTOR|.@>

@ |HELIX_VECTOR|.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == HELIX_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Helix> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("helix_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == HELIX_VECTOR)|  */

@q ****** (6) |POLYGON_VECTOR|.@>

@ |POLYGON_VECTOR|.
\initials{LDF 2005.02.11.}

\LOG
\initials{LDF 2005.02.11.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == POLYGON_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Polygon> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("polygon_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == POLYGON_VECTOR)|  */

@q ****** (6) |RECTANGLE_VECTOR|.@>

@ |RECTANGLE_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == RECTANGLE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Rectangle> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("rectangle_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == RECTANGLE_VECTOR)|  */

@q ****** (6) |REG_POLYGON_VECTOR|.@>

@ |REG_POLYGON_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == REG_POLYGON_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Reg_Polygon> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("reg_polygon_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == REG_POLYGON_VECTOR)|  */


@q ****** (6) |CONE_VECTOR|.@>

@ |CONE_VECTOR|.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == CONE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Cone> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("cone_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == CONE_VECTOR)|  */


@q ****** (6) |CYLINDER_VECTOR|.@>

@ |CYLINDER_VECTOR|.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == CYLINDER_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Cylinder> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("cylinder_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == CYLINDER_VECTOR)|  */




@q ****** (6) |CUBOID_VECTOR|.@>

@ |CUBOID_VECTOR|.
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == CUBOID_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Cuboid> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("cuboid_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == CUBOID_VECTOR)|  */


@q ****** (6) |ELLIPSOID_VECTOR|.@>

@ |ELLIPSOID_VECTOR|.
\initials{LDF 2005.05.26.}

\LOG
\initials{LDF 2005.05.26.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == ELLIPSOID_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Ellipsoid> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("ellipsoid_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == ELLIPSOID_VECTOR)|  */


@q ****** (6) |SPHERE_VECTOR|.@>

@ |SPHERE_VECTOR|.
\initials{LDF 2005.06.06.}

\LOG
\initials{LDF 2005.06.06.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == SPHERE_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Sphere> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("sphere_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == SPHERE_VECTOR)|  */

@q ****** (6) |PARABOLOID_VECTOR|.@>

@ |PARABOLOID_VECTOR|.
\initials{LDF 2006.01.23.}

\LOG
\initials{LDF 2006.01.23.}
Added this section.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

      else if (type == PARABOLOID_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Paraboloid> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("paraboloid_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == PARABOLOID_VECTOR)|  */

@q ****** (6) |HYPERBOLOID_VECTOR|.@>

@ |HYPERBOLOID_VECTOR|.
\initials{LDF 2006.01.23.}

\LOG
\initials{LDF 2006.01.23.}
Added this section.  It's currently commented-out.
\ENDLOG 

@<Define |Id_Map_Entry_Type| functions@>=

#if 0 
      else if (type == HYPERBOLOID_VECTOR)
        {
          if (verbose && object == static_cast<void*>(0))
            cerr_strm << "object == static_cast<void*>(0).";
              
          else
            {
               if (verbose)   
                  {
                     cerr_strm << "object != static_cast<void*>(0).";
              
                     log_message(cerr_strm); 
                     cerr << cerr_strm.str() << endl;
                     cerr_strm.str("");

                  } /* |if (verbose)|  */
              
                typedef Pointer_Vector<Hyperboloid> PV;
              
                PV*  pv = static_cast<PV*>(object);
              
                pv->show("hyperboloid_vector:");
             

            } /* |else| (|object != static_cast<void*>(0)|)  */
            
        } /* |else if (type == HYPERBOLOID_VECTOR)|  */
#endif 


@q ***** (5).@>
@ 
\initials{LDF 2004.08.24.}
@<Define |Id_Map_Entry_Type| functions@>=

      else
        {
          cerr_strm << "Can't show " << name_map[type] << " yet.";

          log_message(cerr_strm); 
          cerr << cerr_strm.str() << endl;
          cerr_strm.str("");
        }

    } /* |if (object != static_cast<void*>(0))|  */


@q **** (4) |object == static_cast<void*>(0)|.  Can't show it.@>

@ |object == static_cast<void*>(0)|.  Can't show it.
\initials{LDF 2004.10.26.}

@<Define |Id_Map_Entry_Type| functions@>=
 

   else if (verbose) /* (|object == static_cast<void*>(0)|)  */
      {    
         cerr_strm << "object == static_cast<void*>(0).  Can't show it.";
      
         log_message(cerr_strm); 
         cerr << cerr_strm.str() << endl;
         cerr_strm.str("");

      } /* |else if (verbose)| (|object == static_cast<void*>(0)|)  */

@q **** (4)@>
@ 
@<Define |Id_Map_Entry_Type| functions@>=


  if (verbose)
    {

      if (up == static_cast<Id_Map_Entry_Node>(0))
         cerr_strm << "up == 0";
      else 
         cerr_strm << "up != 0";

      log_message(cerr_strm); 
      cerr << cerr_strm.str() << endl;
      cerr_strm.str("");
 
      if (left == static_cast<Id_Map_Entry_Node>(0))
          cerr_strm << "left == 0";
      else
        {    
          cerr_strm << "left != 0";
#if 0 
          left->show("left:");
#endif 
        }
  

      log_message(cerr_strm); 
      cerr << cerr_strm.str() << endl;
      cerr_strm.str("");


     if (right == static_cast<Id_Map_Entry_Node>(0))
       cerr_strm << "right == 0";
     else
       {
           cerr_strm << "right != 0";
#if 0 
           right->show("right:");
#endif 
       }


     log_message(cerr_strm); 
     cerr << cerr_strm.str() << endl;
     cerr_strm.str("");


     if (superordinate_vector == static_cast<Id_Map_Entry_Node>(0))
       cerr_strm << "superordinate_vector == 0";

     else
       cerr_strm << "superordinate_vector != 0";

     cerr_strm << endl;


     if (subordinate_array == static_cast<Id_Map_Entry_Node>(0))
       cerr_strm << "subordinate_array == 0";

     else
       cerr_strm << "subordinate_array != 0";

     log_message(cerr_strm); 
     cerr << cerr_strm.str() << endl;
     cerr_strm.str("");

} /* |if (verbose)|  */

@q **** (4) |traverse == true|:  Traverse tree and show array entries.@>
@ |traverse == true|:  Traverse tree and show array entries.
@<Define |Id_Map_Entry_Type| functions@>=

  if (traverse && left != static_cast<Id_Map_Entry_Node>(0))
    {
      left->show(left->name, true);
    }

  if (traverse && right != static_cast<Id_Map_Entry_Node>(0))
    {
      right->show(right->name, true);
    }



@q **** (4)@>
@ 
@<Define |Id_Map_Entry_Type| functions@>=


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Id_Map_Entry_Type::show()'.";

      log_message(cerr_strm); 
      cerr << cerr_strm.str() << endl;
      cerr_strm.str("");
    }
#endif

   cerr << endl;

  return;

} /* End of |Id_Map_Entry_Type::show()| definition.  */





@q * Putting the |Id_Map_Entry_Type| functions together.@>
@ Putting the {\bf Id\_Map\_Entry\_Type} functions together.
  
@ This is what's compiled.
@c
@<Include files@>@;
@<Define |Id_Map_Entry_Type| functions@>@;
@<Define |Id_Map_Type| functions@>@;

@ This is what's written to \filename{imetfncs.h}.
@(imetfncs.h@>=


@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>




@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:70 @>
@q End: @>
 
