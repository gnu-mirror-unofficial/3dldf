@q sctpfncs.web @>
      
@q * Copyright and License.@>

@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) |Scanner_Type| functions.@>
@** {\bf Scanner\_Type} functions.\quad ({\tt sctpfncs\PERIOD web}).\hfil
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.04.20.}
Changed |Scanner_Node| to |Scanner_Type|.  

\initials{LDF 2004.07.18.}
Created this file.  Moved the function definitions in it 
from \filename{scan.web}.


\initials{LDF 2006.10.08.}
@:BUG FIX@> BUG FIX:  Now setting pointers to 0 after deleting them.  This is
unnecessary in some places.  I'm currently trying to find and fix a bug.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.12.21.}
Now including \filename{deftfncs.h}.  It contains function definitions for 
|Definition_Info_Node|.
\ENDLOG

@<Include files@>=

#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"
#include "imetfncs.h++"
#include "deftfncs.h++"
#include "sctpcrt.h++"  

@q *  (1) Destructor.  @>
@* Destructor.

\LOG
\initials{LDF 2004.07.01.}
Added this function definition.

\initials{LDF 2004.07.02.}
Moved some code from this function 
to the |Input_Struct| and |Output_Struct| destructors.  Now just
calling |delete| on |in| and |out[0] @t$\ldots$@> out[2]|. 
\ENDLOG 

@q ** Definition.    @>

@<Define |Scanner_Type| functions@>=
Scanner_Type::~Scanner_Type(void)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    cerr << "Entering `Scanner_Type' destructor."
         << endl; 
#endif /* |DEBUG_COMPILE|  */@; 


@q *** (3) Delete |pthread_t| pointers on |thread_vector| @>
@q *** (3) and clear the latter.                                 @>

@ Delete |pthread_t| pointers on |thread_vector| 
and clear the latter.                                 
\initials{LDF 2004.07.02.}

\LOG
\initials{LDF 2004.07.02.}
Added this section.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

  for (vector<pthread_t*>::iterator iter = thread_vector.begin();
       iter != thread_vector.end();
       ++iter)
    {
      if (*iter != 0)
        {
          delete *iter;
          *iter = 0;
        }
    }
  
  thread_vector.clear();
#endif /* |HAVE_PTHREAD_H|  */@; 


@q *** (3) Delete |in|. @>
@ Delete |in|.


\LOG
\initials{LDF 2004.09.14.}
Added |while| loop for traversing the linked list of |Input_Struct|
pointers and deleting all of them, i.e., |in|, |in->up|, |in->up->up|, etc.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  if (in == 0)
    {
#if DEBUG_COMPILE
        if (DEBUG) 
          cerr << "in == 0.\n";
#endif /* |DEBUG_COMPILE|  */@; 
      }

  else /* (|in != 0|)  */
    {

#if DEBUG_COMPILE
        if (DEBUG) 
          cerr << "in != 0.\n";
#endif /* |DEBUG_COMPILE|  */@; 

        Input_Struct* temp_input_struct = 0;

        while (in != 0)
          {
            if (in->up != 0)
              {
                temp_input_struct = in->up;
              }
            
            delete in;
            in = temp_input_struct;

          } /* |while|  */
        

    }  /* |else| (|in != 0|)  */
   

@q *** (3) Delete |out[]|. @>
@ Delete |out[]|.
@<Define |Scanner_Type| functions@>=


  for (int i = 0; i < 3; ++i)
    {

      if (out[i] == 0)
        {

#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "out[" << i << "] == 0.\n";
#endif /* |DEBUG_COMPILE|  */@; 
              
        }

      else /* |(out[i] != 0)| */
        {

#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "out[" << i << "] != 0.\n";            
#endif /* |DEBUG_COMPILE|  */@; 

          delete out[i]; 
          out[i] = 0;

        } /* |else| (|out[i] != 0|)  */@;

    } /* |for|  */@;
  
@q *** (3) Delete |id_map_node|. @>
@ Delete |id_map_node|.

@<Define |Scanner_Type| functions@>=


  if (id_map_node != 0)
    {
#if DEBUG_COMPILE
      if (DEBUG) 
        cerr << "Calling `delete id_map_node'."
             << endl;
#endif /* |DEBUG_COMPILE|  */@; 

      delete id_map_node;
      id_map_node = 0;
      
    } /* |if (id_map_node != 0)|  */


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr << "After call to `delete id_map_node'."
            << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 

  if (up != 0)
    {

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr << "In `Scanner_Type' destructor: Calling `delete' on `up'."
              << endl << "This will cause this function to be called recursively."
              << endl; 
     }
#endif /* |DEBUG_COMPILE|  */@; 

      delete up;
      up = 0;
    }

@q *** (3) Clear vectors.@>
@*2 Clear vectors.
\initials{LDF 2004.09.22.}

\LOG
\initials{LDF 2004.09.22.}
Now clearing |suffix_vector|.

\initials{LDF 2004.12.21.}
Now clearing |definition_parameter_vector|.

\initials{LDF 2004.12.29.}
Replaced |vector<string> definition_parameter_vector| with
|vector<string> macro_untyped_parameter_vector| and
|vector<Int_String> macro_typed_parameter_vector|.

\initials{LDF 2005.01.19.}
No longer clearing |vector<string> suffix_vector|, 
because I've gotten rid of it.

\initials{LDF 2007.11.25.}
Now clearing |numeric_list_real_vector|.
\ENDLOG 

@<Define |Scanner_Type| functions@>=


  token_string_bool_vector.clear();
  token_real_vector.clear();

  numeric_list_real_vector.clear();

  macro_typed_parameter_vector.clear();
  macro_untyped_parameter_vector.clear();

@q *** (3) Delete pointers and set them to 0.@>
@ Delete pointers and set them to 0.
\initials{LDF 2004.09.22.}

\LOG
\initials{LDF 2005.05.20.}
Now deleting |helix_set_option_struct| and setting it to 0.

\initials{LDF 2005.11.07.}
Now deleting 
|Parabola_Set_Option_Struct* parabola_set_option_struct|, 
|Ellipsoid_Set_Option_Struct* ellipsoid_set_option_struct|,
and
|Sphere_Set_Option_Struct* sphere_set_option_struct|,
and setting them to 0.

\initials{LDF 2005.11.14.}
Now deleting |Hyperbola_Set_Option_Struct* hyperbola_set_option_struct| and 
setting it to 0.

\initials{LDF 2006.01.25.}
Now deleting 
|Paraboloid_Set_Option_Struct* paraboloid_set_option_struct|
and setting it to 0.

\initials{LDF 2007.07.29.}
Now deleting 
|Conic_Section_Lattice_Options* conic_section_lattice_options|
and setting it to 0.

\initials{LDF 2007.09.19.}
Now deleting |Focus_Options* focus_options|
and setting it to 0. 

\initials{LDF 2007.10.12.}
Now deleting 
|Polyhedron_Options* polyhedron_options| and setting it to 0.

\initials{LDF 2007.11.25.} 
Now deleting |Arc_Options* arc_options| and setting it to 0.

\initials{LDF 2007.11.28.}
Now deleting |Matrix_Options* matrix_options|
and setting it to 0.
\ENDLOG 

@<Define |Scanner_Type| functions@>=


  delete parabola_set_option_struct;
  parabola_set_option_struct = 0;

  delete hyperbola_set_option_struct;
  hyperbola_set_option_struct = 0;

  delete conic_section_lattice_options;
  conic_section_lattice_options = 0;

  delete arc_options;

  arc_options = 0;

  delete helix_set_option_struct;
  helix_set_option_struct = 0;

  delete polyhedron_options;
  polyhedron_options = 0;

  delete ellipsoid_set_option_struct;
  ellipsoid_set_option_struct = 0;

  delete sphere_set_option_struct;
  sphere_set_option_struct = 0;
 
  delete paraboloid_set_option_struct;

  paraboloid_set_option_struct = 0;

  delete focus_options;
  focus_options = 0;

  delete matrix_options;
  matrix_options = 0;

  if (color_ptr != 0)
    {
      Color* c = static_cast<Color*>(color_ptr); 
      delete c;
      c = 0;
    }

  if (draw_color_ptr != 0)
    {
      Color* c = static_cast<Color*>(draw_color_ptr); 
      delete c;
      c = 0;
    }

  if (fill_color_ptr != 0)
    {
      Color* c = static_cast<Color*>(fill_color_ptr); 
      delete c;
      c = 0;
    }

  if (pen_ptr != 0)
    {
      Pen* p = static_cast<Pen*>(pen_ptr); 
      delete p;
      p = 0;
    }

@q **** (4) . @>
@ 
\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@<Define |Scanner_Type| functions@>=

  if (pen_vector_ptr != 0)
    {
      delete static_cast<Pointer_Vector<Pen>*>(pen_vector_ptr); 
      pen_vector_ptr = 0;
    }


@q **** (4) |color_vector_ptr|.@>
@ |color_vector_ptr|.  
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.

\initials{LDF 2005.03.18.}
Now deleting |color_vector_ptr|, if it's non-null.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  if (color_vector_ptr != 0)
    {
      delete static_cast<Pointer_Vector<Color>*>(color_vector_ptr);
      color_vector_ptr = 0;
    }


@q **** (4) |draw_color_vector_ptr|.@>
@ |draw_color_vector_ptr|.  
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.

\initials{LDF 2005.03.18.}
Now deleting |draw_color_vector_ptr|, if it's non-null.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  if (draw_color_vector_ptr != 0)
    {
      delete static_cast<Pointer_Vector<Color>*>(draw_color_vector_ptr);
      draw_color_vector_ptr = 0;
    }


@q **** (4) |fill_color_vector_ptr|.@>
@ |fill_color_vector_ptr|.
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.

\initials{LDF 2005.03.18.}
Now deleting |fill_color_vector_ptr|, if it's non-null.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  if (fill_color_vector_ptr != 0)
    {
      delete static_cast<Pointer_Vector<Color>*>(fill_color_vector_ptr);
      fill_color_vector_ptr = 0;
    }




@q **** (4) . @>
@ 

\LOG
\initials{LDF 2005.03.13.}
Now deleting |surface_hiding_value_ptr| and setting it to 0, if it's
not already 0.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  if (dash_pattern_ptr != 0)
    {
      Dash_Pattern* d = static_cast<Dash_Pattern*>(dash_pattern_ptr); 
      delete d;
      d = 0;
    }


@q **** (4) . @>
@ 
\LOG
\initials{LDF 2005.03.18.}
Added this section.

\initials{LDF 2005.10.26.}
Now deleting |tolerance| and setting it to 0.
\ENDLOG

@<Define |Scanner_Type| functions@>=

  if (dash_pattern_vector_ptr != 0)
    {
      delete static_cast<Pointer_Vector<Dash_Pattern>*>(dash_pattern_vector_ptr); 
      dash_pattern_vector_ptr = 0;
    }


@q **** (4) @>   

  if (picture_entry_ptr != 0)
    {

        picture_entry_ptr = 0;

    } /* |if (picture_entry_ptr != 0)|  */


  if (focus_ptr != 0)
    {
      Focus* p = static_cast<Focus*>(focus_ptr); 
      delete p;
      p = 0;
    }

  if (projection_ptr != 0)
    {
      int* p = static_cast<int*>(projection_ptr); 
      delete p;
      p = 0;
    }

  if (factor_ptr != 0)
    {
      real* p = static_cast<real*>(factor_ptr); 
      delete p;
      p = 0;
    }

  if (sort_value_ptr != 0)
    {
      int* p = static_cast<int*>(sort_value_ptr); 
      delete p;
      p = 0;
    }
 
  if (min_x_proj_ptr != 0)
    {
      real* p = static_cast<real*>(min_x_proj_ptr); 
      delete p;
      p = 0;
    }

  if (max_x_proj_ptr != 0)
    {
      real* p = static_cast<real*>(max_x_proj_ptr); 
      delete p;
      p = 0;
    }

  if (min_y_proj_ptr != 0)
    {
      real* p = static_cast<real*>(min_y_proj_ptr); 
      delete p;
      p = 0;
    }

  if (max_y_proj_ptr != 0)
    {
      real* p = static_cast<real*>(max_y_proj_ptr); 
      delete p;
      p = 0;
    }


  if (min_z_proj_ptr != 0)
    {
      real* p = static_cast<real*>(min_z_proj_ptr); 
      delete p;
      p = 0;
    }

  if (max_z_proj_ptr != 0)
    {
      real* p = static_cast<real*>(max_z_proj_ptr); 
      delete p;
      p = 0;
    }

  if (surface_hiding_value_ptr != 0)
    {
      real* p = static_cast<real*>(surface_hiding_value_ptr); 
      delete p;
      p = 0;
    }


  if (surface_hiding_value_ptr != 0)
    {
      real* p = static_cast<real*>(surface_hiding_value_ptr); 
      delete p;
      p = 0;
    }


  if (tolerance != 0)
    {
      delete tolerance;
      tolerance = 0;
    }




/* !! TO DO.  LDF 2004.07.02.  Figure out how to take care of 
   |rescan_stack|.  It should be empty.  */@; 

#if DEBUG_COMPILE
  if (DEBUG)
    cerr << "Exiting `Scanner_Type' destructor."
         << endl; 
#endif /* |DEBUG_COMPILE|  */@; 

  return;

}  /* End of |~Scanner_Type()| definition.  */

@q * (1) Assignment operator. @>
@* Assignment operator.

\LOG
\initials{LDF 2004.09.15.}
Added this function definition.  The declaration is in  
\filename{io.web}.
\ENDLOG 


@q ** (2) Definition.@> 

@<Define |Scanner_Type| functions@>=
const Scanner_Type&
Scanner_Type::operator=(const Scanner_Type& s)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @;
#endif /* |DEBUG_COMPILE|  */@; 
 
  using namespace Scan_Parse;

  stringstream cerr_strm;
 
  bool error_stop_value = (run_state.error_stop_mode == Run_State::STOPPING)
                     ? true : false;

  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  
  if (   run_state.multithread_input 
      || run_state.multithread_output
      || run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info(true);
      thread_name = Thread_Info_Type::get_thread_name(thread_info);
    }

  else
    {
      thread_info = 0;
      thread_name = "";
    }

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 


@q *** (3).@>

#if DEBUG_COMPILE
  if (DEBUG)
     {
        cerr_strm << thread_name
                  << "Entering `Scanner_Type::operator=(const Scanner_Type&)'.";
        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
     }

#endif


@q *** (3) Initialize data members.@>

@ Initialize data members.
There's no need to assign to |run_state|, because this is done in 
|Scanner_Type::create()|.
\initials{LDF 2004.09.15.}

\LOG
\initials{LDF 2005.03.13.}
Now setting |surface_hiding_value_ptr| to 0.

\initials{LDF 2005.03.18.}
Now setting |pen_vector_ptr| and |dash_pattern_vector_ptr| to 0.

\initials{LDF 2005.05.20.}
Now setting |Helix_Set_Option_Struct* helix_set_option_struct| to 0. 

\initials{LDF 2005.10.26.}
Now setting |tolerance = 0|.

\initials{LDF 2005.11.07.}
Now deleting |Helix_Set_Option_Struct* helix_set_option_struct| 
before setting it to 0. 

\initials{LDF 2005.11.07.}
Now deleting 
|Parabola_Set_Option_Struct* parabola_set_option_struct|,
|Ellipsoid_Set_Option_Struct* ellipsoid_set_option_struct|,
and 
|Sphere_Set_Option_Struct* sphere_set_option_struct|.
and setting them to 0.

\initials{LDF 2005.11.14.}
Now deleting 
|Hyperbola_Set_Option_Struct* hyperbola_set_option_struct|
and setting it to 0.

\initials{LDF 2006.01.25.}
Now deleting 
|Paraboloid_Set_Option_Struct* paraboloid_set_option_struct|
and setting it to 0.

\initials{LDF 2007.07.29.}
Now deleting 
|Conic_Section_Lattice_Options* conic_section_lattice_options|
and setting it to 0.

\initials{LDF 2007.09.19.}
Now deleting |Focus_Options* focus_options|
and setting it to 0.

\initials{LDF 2007.07.29.}
Now deleting |Polyhedron_Options* polyhedron_options|
and setting it to 0.

\initials{LDF 2007.11.28.}
Now deleting |Matrix_Options* matrix_options|
and setting it to 0.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
   thread_info = 0;
#endif /* |HAVE_PTHREAD_H|  */@; 

  up = 0;

  array_switch = false;
  known_switch = false;
  action_switch = false;
  first_call_yylex = false;

  if_ctr = 0;
  group_ctr = 0;

  token_string = "";

  loop_info_node = 0;  

  delete focus_options;
  focus_options = 0;

  delete matrix_options;
  matrix_options = 0;

  delete parabola_set_option_struct;
  parabola_set_option_struct = 0;

  delete hyperbola_set_option_struct;
  hyperbola_set_option_struct = 0;

  delete conic_section_lattice_options;
  conic_section_lattice_options = 0;

  delete helix_set_option_struct;
  helix_set_option_struct = 0; 

  delete polyhedron_options;
  polyhedron_options = 0;

  delete ellipsoid_set_option_struct;
  ellipsoid_set_option_struct = 0;

  delete sphere_set_option_struct;
  sphere_set_option_struct = 0;

  delete paraboloid_set_option_struct;
  paraboloid_set_option_struct = 0;

  color_ptr = 0;
  draw_color_ptr = 0;
  fill_color_ptr = 0;

  pen_ptr = 0;
  pen_vector_ptr = 0;

  dash_pattern_ptr = 0;
  dash_pattern_vector_ptr = 0;


  color_vector_ptr = 0;
  draw_color_vector_ptr = 0;
  fill_color_vector_ptr = 0;
  
  picture_entry_ptr = 0;

  clear_ptr = 0;
  endfig_ptr = 0;  


  focus_ptr = 0;
  projection_ptr = 0;
  factor_ptr = 0;
  sort_value_ptr = 0;
  min_x_proj_ptr = 0;
  max_x_proj_ptr = 0;
  min_y_proj_ptr = 0;
  max_y_proj_ptr = 0;
  min_z_proj_ptr = 0;
  max_z_proj_ptr = 0;

  surface_hiding_value_ptr = 0;

  tolerance = 0;

@q *** (3) Copy |s.id_map_node| to |id_map_node|.@>

@ Copy |s.id_map_node| to |id_map_node|.
\initials{LDF 2004.09.15.}

\LOG
\initials{LDF 2004.09.18.}
@:BUG FIX@> BUG FIX: 
Now setting |id_map_node->scanner_node| to |this|.
\ENDLOG 

@<Define |Scanner_Type| functions@>=
 
  id_map_node = new Id_Map_Type;

  id_map_node->scanner_node = this;

  id_map_node->up = 0;

  try
    {
      *id_map_node = *s.id_map_node;
    }
  catch (Bad_Assignment_Type)
    {
      cerr_strm << thread_name 
                << "ERROR! "
                << "In `Scanner_Type::operator=entry(const Scanner_Type&)':"
                << endl 
                << "`Id_Map_Type::operator=(const Id_Map_Type&)' failed."
                << endl << "Failed to assign to `id_map_node'."
                << endl 
                << "Deleting `id_map_node' and "
                << "throwing `Bad_Assignment_Type'.";
      
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      if (id_map_node != 0)
         {
            delete id_map_node;
            id_map_node = 0;
            
         }  /* |if (id_map_node != 0)|  */
      
     
      throw;

    } /* |catch (Bad_Assignment_Type)|  */


@q *** (3) Exit function, returning |s|.@>

@ Exit function, returning |s|.
\initials{LDF 2004.09.15.}

@<Define |Scanner_Type| functions@>=


#if DEBUG_COMPILE
  if (DEBUG)
     {
        cerr_strm << thread_name
                  << "Exiting `Scanner_Type::operator=(const Scanner_Type&)'.";
        log_message(cerr_strm); 
        cerr_message(cerr_strm, true); 
        cerr_strm.str(""); 
     }

#endif



  return s;

}

@q * (1) Add entry.  @>
@* Add entry.

\LOG
\initials{LDF 2004.04.20.}  Added this function.

\initials{LDF 2004.04.22.}  Changed arguments.  They now correspond to
those of |Id_Map_Entry_Type::set()|.

\initials{LDF 2004.04.28.}  Changed return value from |bool| to
|Id_Map_Entry_Node|.  This is used in the rule
``\§numeric assignment> $\longrightarrow$ \§variable> \.{ASSIGN} 
\§numeric expression>'' in \filename{parser.w}.

\initials{LDF 2004.04.29.}  Changed |bool sspark_flag| argument to 
|unsigned short ccategory|. 

\initials{LDF 2004.05.09.}  Added |cconst_flag| argument.  Changed |iis_array|
argument to |aarray_flag|. 

\initials{LDF 2004.08.20.}
Made debugging output thread-safe.

\initials{LDF 2004.08.20.}
Moved this definition from \filename{io.web} to 
this file (\filename{sctpfncs.web}).

\initials{LDF 2004.08.20.}
Now deleting an existing non-array entry before creating a new one.  
About to do the same thing for array entries.

\initials{LDF 2004.08.23.}
Now conditionally compiling the code that uses |Thread_Info_Type|.
If |HAVE_PTHREAD_H| is defined, 
now testing whether multithreading is being used 
when setting |thread_info| and |thread_name|.

\initials{LDF 2004.08.23.}
Now calling |Id_Map_Entry_Type::destroy_array_subentries()|.

\initials{LDF 2004.08.23.}
Made changes in debugging output.

\initials{LDF 2004.08.24.}
Added |Id_Map_Entry_Node ssuperordinate_vector| argument.
It will only be non-null when creating array entries by means 
of vector-type declarations.  It's passed to |Id_Map_Entry_Node::set_entry()|.


\initials{LDF 2004.08.25.}
Added |Id_Map_Entry_Node ssubordinate_array| argument.
It will only be non-null when creating array entries by means 
of vector-type declarations.  It's passed to |Id_Map_Entry_Node::set_entry()|.

\initials{LDF 2004.08.28.}
Added |Scanner_Node sscanner_node| argument.  It's passed to 
|Id_Map_Entry_Type::set_entry()|.

\initials{LDF 2004.08.29.}
Removed |Scanner_Node sscanner_node| argument.  Now passing
|id_map_type| as an |Id_Map_Node| argument in calls to 
|Id_Map_Entry_Node::set_entry()| rather than |sscanner_node| as a
|Scanner_Type| argument.
\ENDLOG 

@q ** (2) Definition.  @>
@
@<Define |Scanner_Type| functions@>=
Id_Map_Entry_Node
Scanner_Type::add_entry(string nname,
                        unsigned int ttype,
                        unsigned short ccategory,
                        bool cconst_flag,
                        bool aarray_flag,
                        unsigned short kknown_state,
                        void* oobject,
                        Id_Map_Entry_Node uup,
                        Id_Map_Entry_Node lleft,
                        Id_Map_Entry_Node rright,
                        Id_Map_Entry_Node ssuperordinate_vector,
                        Id_Map_Entry_Node ssubordinate_array)

{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @;
#endif /* |DEBUG_COMPILE|  */@; 
 
  using namespace Scan_Parse;

  stringstream cerr_strm;
 

  bool error_stop_value = (run_state.error_stop_mode == Run_State::STOPPING)
                     ? true : false;

  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  
  if (   run_state.multithread_input 
      || run_state.multithread_output
      || run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info(true);
      thread_name = Thread_Info_Type::get_thread_name(thread_info);
    }

  else
    {
      thread_info = 0;
      thread_name = "";
    }

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

#if DEBUG_COMPILE

  if (DEBUG)
     {
        cerr_strm << thread_name
                  << "Entering `Scanner_Type::add_entry()'.";
        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
     }

#endif

  int status;

  Id_Map_Iterator iter = 
    id_map_node->id_map.find(nname);

@q *** (3) No existing entry.  @>
@ No existing entry.
\initials{LDF 2004.08.20.}
@<Define |Scanner_Type| functions@>=

  if (iter == id_map_node->id_map.end())
    {
#if DEBUG_COMPILE
       if (DEBUG)
          {
              cerr_strm << thread_name << "In `Scanner_Type::add_entry()':"
                        << endl
                        << "No existing entry for " << nname << ".";
              log_message(cerr_strm); 
              cerr_message(cerr_strm); 
              cerr_strm.str(""); 
          }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |if (iter == id_map_node->id_map.end())|  */


@q *** (3) Entry exists already.  It must be destroyed.@>
@ Entry exists already.  It must be destroyed.
\initials{LDF 2004.08.20.}

\LOG
\initials{LDF 2004.08.20.}
Added code for handling this case.
\ENDLOG 

@<Define |Scanner_Type| functions@>=


  else /* (|iter != id_map_node->id_map.end()|)  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
            cerr_strm << thread_name 
                      << "In `Scanner_Type::add_entry()':"
                      << endl
                      << "Entry exists for " << nname
                      << ". Will destroy it.";

            log_message(cerr_strm); 
            cerr_message(cerr_strm, error_stop_value); 
            cerr_strm.str("");


            cerr_mutex.lock();
            cerr      << thread_name 
                      << "In `Scanner_Type::add_entry()':"
                      << endl
                      << "Showing " << iter->first << ": " 
                      << endl;
            iter->second->show("*iter->second:");
            cerr << "Type <RETURN> to continue: ";
            getchar(); 
            cerr_mutex.unlock();
            
 
        } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */


@q **** (4) Destroy array subentries, if any,              @>
@q **** (4) delete the |Id_Map_Entry_Node| |iter->second|, @>
@q **** (4) and erase the entry on |id_map_node->id_map|.  @>

@ Destroy array subentries, if any, delete the |Id_Map_Entry_Node|
|iter->second|, and erase the entry on |id_map_node->id_map|. 
\initials{LDF 2004.08.20.}

@<Define |Scanner_Type| functions@>=


#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::add_entry()':"
                    << "About to call "
                    << "`iter->second->destroy_array_subentries()'.";
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 


      status = iter->second->destroy_array_subentries(this);


@q ***** (5) |destroy_array_subentries()| failed.@>
@ |destroy_array_subentries()| failed.
\initials{LDF 2004.08.22.}

@<Define |Scanner_Type| functions@>=

      if (status != 0)
        {
          
          cerr_strm << thread_name 
                    << "ERROR! In `Scanner_Type::add_entry()':"
                    << "`iter->second->destroy_array_subentries()' "
                    << "failed."
                    << endl << "Not adding entry. "
                    << "Exiting function with return value "
                    << "`static_cast<Id_Map_Entry_Node>(0)'.";

              log_message(cerr_strm); 
              cerr_message(cerr_strm, error_stop_value); 
              cerr_strm.str("");
          
          return static_cast<Id_Map_Entry_Node>(0); 

        } /* |(if status != 0)|.  |destroy_array_subentries()| failed.  */
      

@q ***** (5) |destroy_array_subentries()| succeeded.@>
@ |destroy_array_subentries()| succeeded.
\initials{LDF 2004.08.22.}

@<Define |Scanner_Type| functions@>=


      else /* (|status == 0|).  |destroy_array_subentries()| succeeded.  */
      
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name 
                        << "In `Scanner_Type::add_entry()':"
                        << "`iter->second->destroy_array_subentries()' "
                        << "succeeded.";
              log_message(cerr_strm); 
              cerr_message(cerr_strm); 
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

        } /* |else| (|status == 0|).  |destroy_array_subentries()| succeeded.  */


@q ***** (5).@>
@ 
\LOG
\initials{LDF 2006.10.08.}
Now setting |iter->second| to 0 after deleting it.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::add_entry()':"
                    << "About to call  `delete iter->second'.";
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      delete iter->second;
      iter->second = 0;


#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::add_entry()':"
                    << "`delete iter->second' succeeded."
                    << endl
                    << "About to call `id_map_node->id_map.erase(iter)'.";
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 


      id_map_node->id_map.erase(iter);


#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::add_entry()':"
                    << "`id_map_node->id_map.erase(iter)' succeeded.";
          log_message(cerr_strm); 
          cerr_message(cerr_strm, true); 
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 


    } /* |else| (|iter != id_map_node->id_map.end()|) */

@q *** (3) Create new |Id_Map_Entry_Node|.@>
@ Create new |Id_Map_Entry_Node|.

@<Define |Scanner_Type| functions@>=


  Id_Map_Entry_Node entry = new Id_Map_Entry_Type;

#if DEBUG_COMPILE
  if (DEBUG) 
     {
        cerr_strm << thread_name << "In `Scanner_Type::add_entry()':"
                  << endl
                   << "`nname' == " << nname << ".";
        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str("");
     }
#endif


  entry->set_entry(nname,
                   ttype,
                   id_map_node,
                   ccategory,
                   cconst_flag,
                   aarray_flag,
                   kknown_state,
                   oobject,
                   uup,
                   lleft,
                   rright,
                   ssuperordinate_vector,
                   ssubordinate_array); 
                                        
  id_map_node->id_map[nname] = entry;


#if DEBUG_COMPILE
  if (DEBUG)
     {
        cerr_strm << thread_name << "In `Scanner_Type::add_entry()':"
                  << endl
                  << "Exiting Scanner_Type::add_entry() and returning `entry'.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return entry;
}



@q *  Add synonym.  @>
@* Add synonym.

\LOG
\initials{LDF 2004.07.01.}
Rewrote this function and moved this definition 
from \filename{io.web} to \filename{scan.web} 
(this file). 

\initials{LDF 2004.08.28.}
Now passing |this| as the |Scanner_Node| argument to 
|Id_Map_Entry_Type::set_entry()|.
\ENDLOG 

@q ** Definition.  @>

@
@<Define |Scanner_Type| functions@>=
Id_Map_Entry_Node
Scanner_Type::add_synonym(string synonym, string base_name)
{
#if DEBUG_COMPILE

  bool DEBUG = false; /* |true| */ @;

  if (DEBUG)
    cerr << "Entering Scanner_Type::add_synonym()." << "\n";

#endif
  


  Id_Map_Iterator iter =  id_map_node->id_map.find(synonym);


  if (iter != id_map_node->id_map.end())
    {
      cerr << "ERROR! In Scanner_Type::add_synonym():\n"
           << "Entry already exists for " << synonym 
           << ".Returning 0.\n"
           << "Type <RETURN> to continue.\n";

      getchar();  /* Don't delete this!  */@;  
      
      return static_cast<Id_Map_Entry_Node>(0);

    }

  iter = id_map_node->id_map.find(base_name);

  if (iter == id_map_node->id_map.end())
    {
      cerr << "ERROR! In Scanner_Type::add_synonym():\n"
           << "No existing entry for " << base_name << ", so I "
           << "can't add a synonym." << endl
           << "Returning 0.\n"
           << "Type <RETURN> to continue.\n";

      getchar();  /* Don't delete this!  */@;  
      
      return static_cast<Id_Map_Entry_Node>(0);

    }

#if DEBUG_COMPILE
      if (DEBUG)
        {
          iter->second->show("*iter:");
        }
#endif  


  Id_Map_Entry_Node entry = new(Id_Map_Entry_Type);
  
  string* s = new string;
  *s = base_name;

  entry->set_entry(synonym,
                   SYNONYM,
                   id_map_node,
                   Id_Map_Entry_Type::SPARK,
                   false,
                   false,
                   true, s, 0, 0, 0);

  id_map_node->id_map[synonym] = entry;

#if DEBUG_COMPILE
  if (DEBUG)  
    {
      cerr << "Exiting Scanner_Type::add_synonym() and returning `entry'."
         << "\n";
    }
#endif


  return entry;

}



@q * (1) Lookup.  @>
@* Lookup.
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.04.24.}  
Moved this definition from
\filename{io.web} to \filename{scan.web} because I'm
now using |name_map| in it.

\initials{LDF 2004.07.01.}
Modified this function to handle synonyms.  Synonyms are now different from the
way they were before.
\ENDLOG 

@<Define |Scanner_Type| functions@>=
Id_Map_Entry_Node
Scanner_Type::lookup(string s,
                     bool traverse,
                     unsigned short level,
                     Id_Map_Node local_id_map_node)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    cerr << "Entering Scanner_Type::lookup(). level == " << level
         << ".\n";
#endif

  if (local_id_map_node == 0)
    local_id_map_node = id_map_node;

  Id_Map_Const_Iterator iter = local_id_map_node->id_map.find(s);
  if (iter != local_id_map_node->id_map.end()) /* Found.  */
    {

      if (iter->second->type == SYNONYM)
        {

          string* base_name = static_cast<string*>(iter->second->object); 

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr << "In lookup(): Found " << s 
                   << ". It's a synonym for " << *base_name << "."
                   << endl << "Calling `lookup(" << *base_name
                   << ", ...)'." << endl;  
            }
#endif
      
          return lookup(*base_name, traverse, level, local_id_map_node);
          
        } /* |(iter->second->type == SYNONYM)|  */

      else /* |(iter->second->type != SYNONYM)|  */
        {

#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "In lookup(): Found " << s 
                 << ". Returning Id_Map_Entry_Node with `type' == " 
                << name_map[iter->second->type] << ".\n";
#endif

      return iter->second;
        }   /* |else| (|iter->second->type != SYNONYM|)  */

    } /* Found.  */
  

@ Found no |Id_Map_Entry_Node| on this level.  If |traverse == true|
and |local_id_map_node->up| isn't a null pointer, we call this function
recursively, using |local_id_map_node->up| as the |local_id_map_node| argument.
\initials{LDF 2004.04.22.}
@<Define |Scanner_Type| functions@>=
  else /* Not found.  */
    {
      
#if DEBUG_COMPILE
      if (DEBUG) 
        cerr << "In lookup(): Didn't find " << s << ". " << endl;
#endif
      
@ |traverse == false|.  Return 0.
\initials{LDF 2004.04.22.}
@<Define |Scanner_Type| functions@>=
      if (!traverse)
        {
          
#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "traverse == false.  Returning 0." << endl;
#endif
          
          return static_cast<Id_Map_Entry_Node>(0);
        }

@  |traverse == true| and |local_id_map_node->up| is a null pointer.  
Return 0.  This case is only separated from the case above for the
sake of the debugging output.
\initials{LDF 2004.04.22.}
@<Define |Scanner_Type| functions@>=
      else if (local_id_map_node->up == 0) 
        {

#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "traverse == true, but local_id_map_node->up  == 0. "
                 << "Returning 0." << endl;
#endif        
          
          return static_cast<Id_Map_Entry_Node>(0);
        }    
@  |traverse == true| and |local_id_map_node->up| is not a null pointer.  
Call this function recursively, incrementing |level| and using
|local_id_map_node->up| as the |local_id_map_node| argument.  
\initials{LDF 2004.04.22.}
@<Define |Scanner_Type| functions@>=
      else 
        {
          ++level;
#if DEBUG_COMPILE
          if (DEBUG) 
            cerr << "traverse == true and local_id_map_node->up  != 0. "
                 << "Calling this function recursively:" << endl 
                 << "`lookup(" << s << ", true, " << level
                 << ", local_id_map_node->up)'" << endl;
#endif        
          return lookup(s, true, level, local_id_map_node->up);
        }

@ End of definition of |Scanner_Type::lookup()|.  
@<Define |Scanner_Type| functions@>=
    } /* Not found.  */
}

@q * (1) Erase entry. @>
@* Erase entry.

\LOG
\initials{LDF 2004.08.25.}
Added this definition.  This function is declared in \filename{io.web}.
\ENDLOG 

@q ** (2) Definition. @>

@
@<Define |Scanner_Type| functions@>=
int 
Scanner_Type::erase_entry(string s)
{

  using namespace Scan_Parse;
  

  stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
     {
       cerr_strm << "Entering `Scanner_Type::erase_entry()'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  bool error_stop_value = (run_state.error_stop_mode == Run_State::STOPPING)
                     ? true : false;
 
  int status;


@q *** (3) Try to erase |Id_Map_Entry_Node|.@>  
@ Try to erase |Id_Map_Entry_Node|.
\initials{LDF 2004.08.25.}

@<Define |Scanner_Type| functions@>=


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "In `Scanner_Type::erase_entry()':"
                 << endl << "Trying to erase `Id_Map_Entry_Node' for `"  
                 << s << "'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

  status = id_map_node->id_map.erase(s);


@q **** (4) Failed to erase |Id_Map_Entry_Node|.  Will return 1.@>  

@ Failed to erase |Id_Map_Entry_Node|.  Will return 1.
\initials{LDF 2004.08.25.}

@<Define |Scanner_Type| functions@>=


  if (status == 0)
    {

      cerr_strm << "ERROR! In `Scanner_Type::erase_entry()':"
                << "Failed to erase `Id_Map_Entry_Node' for "
                << "`" << s << "'." << endl 
                << "Exiting function with return value 1.";
       
          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value); 
          cerr_strm.str(""); 

      return 1;
          
    }

@q **** (4) |status != 0|.  This shouldn't be possible.  Will return 1.@>  

@ |status != 0|.  This shouldn't be possible.  Will return 1.
\initials{LDF 2004.08.25.}

@<Define |Scanner_Type| functions@>=


  else if (status != 1)
    {

      cerr_strm << "ERROR! In `Scanner_Type::erase_entry()':"
                << "`id_map_node->id_map.erase(iter)' returned "
                << status << "." << endl
                << "This shouldn't be possible. "
                << "Exiting function with return value 1.";
       
          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value); 
          cerr_strm.str(""); 

      return 1;
    }



@q **** (4) Success! |status == 1|.@>  

@ Success! |status == 1|.
\initials{LDF 2004.08.25.}

@<Define |Scanner_Type| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "In `Scanner_Type::erase_entry()':"
                 << endl 
                 << "`id_map_node->id_map.erase()' succeeded "
                 << "in erasing `Id_Map_Entry_Node' for "
                 << "`" << s << "'." << endl 
                 << "Exiting function successfully with return value 0.";
       
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

      return 0;

} /* End of |Scanner_Type::erase_entry()| definition.  */




@q * Handle |numeric_list|.  @>
@* Handle |numeric_list|.

\LOG
\initials{LDF 2005.05.12.}  
Added this function.

\initials{LDF 2004.05.13.}  
Removed this code from the section 
``Common code for transformers using |numeric_list|'' and put it in the
function |Scanner_Type::handle_numeric_list()|.

\initials{LDF 2004.05.13.}  
Moved this function definition from
\filename{ptrnexpr.w} to \filename{scan.web}.

\initials{LDF 2004.05.13.}  
Debugged this function and added debugging output.

\initials{LDF 2004.09.24.}
Changed |w| from |Real_Pointer_Vector*| to |Pointer_Vector<real>*|.
Now calling |delete w| rather than including the section
|@<Clear |Real_Pointer_Vector|@>|, which I've removed.

\initials{LDF 2004.09.25.}
Added code for handling the tokens |ROTATE|, |SCALE|, |SHEAR|, 
and |SHIFT| for the transformation commands.

\initials{LDF 2004.09.25.}
Made debugging and error output thread-safe.
\ENDLOG

@q ** (2) Definition.  @>

@<Define |Scanner_Type| functions@>=
Bool_Void_Pointer
Scanner_Type::handle_numeric_list(int transform_token,
                                    void* r)
{

@q *** (3) Preliminaries.@> 

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @;
#endif /* |DEBUG_COMPILE|  */@; 
 
  using namespace Scan_Parse;

  stringstream cerr_strm;
 
  bool error_stop_value = (run_state.error_stop_mode == Run_State::STOPPING)
                     ? true : false;

  string thread_name;

#ifdef HAVE_PTHREAD_H  
  
  Thread_Info_Type* thread_info;
  
  if (   run_state.multithread_input 
      || run_state.multithread_output
      || run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info(true);
      thread_name = Thread_Info_Type::get_thread_name(thread_info);
    }

  else
    {
      thread_info = 0;
      thread_name = "";
    }

#else  /* |HAVE_PTHREAD_H| is undefined.  */@;  

  thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 


@q *** (3).@>
@
@<Define |Scanner_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
       cerr_strm << thread_name 
                 << "Entering `Scanner_Type::handle_numeric_list()'."; 

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  Bool_Void_Pointer bvp;

@q *** (3) Error handling:  |r == 0|.@>
@ Error handling:  |r == 0|.
\initials{LDF 2004.09.25.}

\LOG
\initials{LDF 2004.09.25.}
Added this section.

\initials{LDF 2004.09.28.}
@:BUG FIX@> BUG FIX:  Now returning in this case.  
\ENDLOG

@<Define |Scanner_Type| functions@>=

  if (r == 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::handle_numeric_list()': "
                << "`void* r' argument is a null pointer."
                << endl 
                << "Exiting function, returning `false' and a "
                << "pointer to `INVALID_TRANSFORM'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      bvp.first = false;
 
      Transform* t = new Transform;
      *t = INVALID_TRANSFORM;
      bvp.second = static_cast<void*>(t); 

      return bvp;

    } /* |if (r == 0)|  */

@q *** (3).@> 
@

\LOG
\initials{LDF 2004.10.25.}
@:BUG FIX@> BUG FIXES:  
Now testing for |transform_token == SHEAR| as well as 
|transform_token == SHEARED| when setting 
|MAX_TRANSFORMATION_ARGS| and for |transform_token == SCALE| as well
as |transform_token == SCALED| when setting 
|DEFAULT_TRANSFORMATION_ARG|.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  Pointer_Vector<real>* w = static_cast<Pointer_Vector<real>*>(r); 

  int MAX_TRANSFORMATION_ARGS;
  int DEFAULT_TRANSFORMATION_ARG;
  
  MAX_TRANSFORMATION_ARGS = (   transform_token == SHEAR 
                             || transform_token == SHEARED) 
           ? 6 : 3;

  DEFAULT_TRANSFORMATION_ARG = (   transform_token == SCALE
                                || transform_token == SCALED) 

                     ? 1 : 0;

  Transform* t = new (Transform);

  vector<real> args;

  for (int i = 0; i < MAX_TRANSFORMATION_ARGS; ++i)
    {
      args.push_back(DEFAULT_TRANSFORMATION_ARG);
    }

  int s = w->v.size();

@q *** Error handling for the case that |w->v.size() <= 0|.  @>
@ Error handling for the case that |w->v.size() <= 0|.
\initials{LDF 2004.05.12.}

\LOG
\initials{LDF 2006.10.08.}
@:BUG FIX@> BUG FIX:  Now setting |w| to 0 after deleting it.
\ENDLOG 

@<Define |Scanner_Type| functions@>=
  if (s <= 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::handle_numeric_list()':"
                << endl 
                << "`w->v.size()' <= 0. "
                << "No `real' values for specifying the transformation."
                << endl
                << "Exiting function, returning `false' and a "
                << "pointer to `INVALID_TRANSFORM'.";

      
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *t = INVALID_TRANSFORM;

      bvp.first = false;
      bvp.second = static_cast<void*>(t);
      
      delete w;
      w = 0;

      return bvp;

    } /* |if (s <= 0)|  */@;


@q *** Warning if |w->v.size() > MAX_TRANSFORMATION_ARGS|.  @>
@ Warning if |w->v.size() > MAX_TRANSFORMATION_ARGS|.
\initials{LDF 2004.05.12.}
@<Define |Scanner_Type| functions@>=
  if (s > MAX_TRANSFORMATION_ARGS)
    {
      cerr_strm << thread_name 
                << "WARNING! In `Scanner_Type::handle_numeric_list()':"
                << endl 
                << "`w->v.size()' > `MAX_TRANSFORMATION_ARGS'. "
                << "Too many `real' values specified. "
                << endl
                << "Ignoring the extra ones and will continue.";
        
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

    } /* |if (s > MAX_TRANSFORMATION_ARGS)|  */@;


@q *** Success!  @>
@ Success!  Get arguments.
\initials{LDF 2004.05.13.}
@<Define |Scanner_Type| functions@>=

  { /* Beginning of group.  */

    int i = 0;
    for (vector<real*>::const_iterator iter = w->v.begin();
         iter != w->v.end();
         ++iter)
      {
        args[i] = **iter;

#if DEBUG_COMPILE
        if (DEBUG)
          {
            cerr_strm << thread_name << "`args[" << i << "]' == " 
                      << args[i] << ".";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 

        ++i;

      } /* |for|  */

  }  /* End of group.  */

@q *** (3) Find out what transformation to perform.    @>
@ Find out what transformation to perform.
\initials{LDF 2004.05.13.}

\LOG
\initials{LDF 2004.05.13.}  Added the case for 
|transform_token == SHEARED|. 
\ENDLOG 

@<Define |Scanner_Type| functions@>=
#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "name_map[transform_token] == " 
                 << name_map[transform_token] << ".";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


@q **** (4) @>   

  if (transform_token == ROTATE || transform_token == ROTATED)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::handle_numeric_list()': Rotating.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 


      t->rotate(args[0], args[1], args[2]);

    } /* |if (transform_token == ROTATE || transform_token == ROTATED)|  */

@q **** (4) @>   

  else if (transform_token == SCALE || transform_token == SCALED)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::handle_numeric_list()': Scaling.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      t->scale(args[0], args[1], args[2]);
   
    } /* |else if (transform_token == SCALE || transform_token == SCALED)|  */

@q **** (4) @>   

  else if (transform_token == SHEAR || transform_token == SHEARED)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::handle_numeric_list()': Shearing.";
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      t->shear(args[0], args[1], args[2], args[3], args[4], args[5]);

    } /* |else if (transform_token == SHEAR || transform_token == SHEARED)|  */

@q **** (4) @>   

  else if (transform_token == SHIFT || transform_token == SHIFTED)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::handle_numeric_list()': Shifting.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      t->shift(args[0], args[1], args[2]);
   
    } /* |else if (transform_token == SHIFT || transform_token == SHIFTED)|  */


@q **** (4) Error handling:  |transform_token| has an invalid value. @>

@ Error handling for the case that |transform_token| has an 
invalid value. 
\initials{LDF 2004.05.13.}

@<Define |Scanner_Type| functions@>=

  else  /* Invalid value for |transform_token|.  */
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::handle_numeric_list()'."
                << endl 
                << "Invalid value for `transform_token': "
                << transform_token << "." << endl 
                << "Exiting function, returning `false' and a "
                << "pointer to `INVALID_TRANSFORM'.";


      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      bvp.first = false;
      *t = INVALID_TRANSFORM;
      bvp.second = static_cast<void*>(t); 

      delete w;
      w = 0;
      
      return bvp;

    } /* |else| (invalid value for |transform_token|).  */

@q *** (3) Finish up and exit function successfully with return value |bvp|.@>

@ Finish up and exit function successfully with return value |bvp|.
\initials{LDF 2004.05.13.}

@<Define |Scanner_Type| functions@>=

  bvp.first = true;
  bvp.second = static_cast<void*>(t); 

  delete w;
  w = 0;


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scanner_Type::handle_numeric_list()' "
                << "successfully.";  

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return bvp;

} /* End of |Scanner_Type::handle_numeric_list()| definition.  */


@q * (0) Extract |Picture| output arguments.@>
@* Extract |Picture| output arguments.
\initials{LDF 2004.07.12.}

\LOG
\initials{LDF 2004.07.12.}  
Added this function.

\initials{LDF 2004.07.13.}
Finished writing this function.

\initials{LDF 2004.07.13.}
Changed |Run_State* Picture_Output_Arg_Type::run_state| to
|Scanner_Node Picture_Output_Arg_Type::scanner_node|.

\initials{LDF 2004.07.16.}
Debugged this function.
\ENDLOG 

@q ** (2) Definition.  @>

@<Define |Scanner_Type| functions@>=

Scan_Parse::Picture_Output_Arg_Type*
Scanner_Type::extract_picture_output_args(void)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */

   using namespace Scan_Parse;

   stringstream cerr_strm;


   string thread_name;
   bool multithread_output = run_state.multithread_output;
   
   bool error_stop_value = (run_state.error_stop_mode == Run_State::STOPPING)
     ? true : false;
   
   int status;

@q *** (3) Set |thread_name|.  @>
@ Set |thread_name|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
  
   thread_name = Thread_Info_Type::get_thread_name(thread_info);

#else /* |HAVE_PTHREAD_H| is undefined.  */

   thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined. */@; 

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name << "Entering "
                  << "`Scanner_Type::extract_picture_output_args()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

        cerr_message(cerr_strm);
        cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q *** (3) Error handling:  |picture_entry_ptr == 0|.  @>
@ Error handling:  |picture_entry_ptr == 0|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

   if (picture_entry_ptr == 0)
     {

        cerr_strm << thread_name << "ERROR! "
                  << "In `Scanner_Type::extract_picture_output_args()':"
                  << endl << "`picture_entry_ptr' == 0. " 
                  << "Exiting function with return value 0."
                  << endl;

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

        return 0;       

     } /* |if (picture_entry_ptr == 0)|  */
   
   Id_Map_Entry_Node entry
     = static_cast<Id_Map_Entry_Node>(picture_entry_ptr); 

#if DEBUG_COMPILE
  if (DEBUG)
    {
      if (entry != static_cast<Id_Map_Entry_Node>(0))
        {
          cerr_mutex.lock();

          cerr << thread_name 
               << "In `Scanner_Type::extract_picture_output_args()':" 
               << endl;

          static_cast<Picture*>(entry->object)->show("entry->object:");

          cerr_mutex.unlock();

        } /* |if (entry != 0)|  */


      else /* (|entry == 0|)  */

        {

          
          cerr_mutex.lock();

          cerr << thread_name 
               << "In `Scanner_Type::extract_picture_output_args()':" 
               << endl
               << "`entry' == 0." << endl;

          cerr_mutex.unlock();

        } /* |else| (|entry == 0|)  */

    } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q *** (3) Try to lock |entry->mutex|.  @>
@ Try to lock |entry->mutex|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
  if (multithread_output)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "Trying to lock `entry->mutex'."
                    << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry->lock();
    
@q **** (4) Error handling:  |entry->lock()| failed.  @>
@ Error handling:  |entry->lock()| failed.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  if (status != 0)
    {
  
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                << endl << "`entry->lock()' failed."
                << "Exiting function with return value 0."
                << endl;
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      

      return 0;

    } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
        {
          
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`entry->lock()' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
  } /* |  if (multithread_output)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 


@q **** (4) Error handling:  |entry_object == 0|.  @>
@ Error handling:  |entry_object == 0|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

   if (entry->object == static_cast<void*>(0))
     {

      cerr_strm << thread_name << "ERROR! "
                << "In `Scanner_Type::extract_picture_output_args()':"
                << endl << "`entry_object' == 0. " 
                << "Will try to unlock `entry->mutex' "
                << "and exit function with return value 0."
                << endl;

      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      status = entry->unlock();

       return 0;       
    } /* |if (entry->object == 0)|  */
   

   Picture* entry_picture = static_cast<Picture*>(entry->object); 


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_mutex.lock();
      
      entry_picture->show("entry_picture first:");
      
      cerr_mutex.unlock();
      
    }
#endif /* |DEBUG_COMPILE|  */@; 



@q *** (3) Try to lock |entry_picture->mutex|.  @>
@ Try to lock |entry_picture->mutex|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
  if (multithread_output)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "Trying to lock `entry_picture->mutex'."
                    << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry_picture->lock();
    
@q **** (4) Error handling:  |entry_picture->lock()| failed.  @>
@ Error handling:  |entry_picture->lock()| failed.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  if (status != 0)
    {
  
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                << endl << "`entry_picture->lock()' failed."
                << "Will try to unlock `entry->mutex' "
                << "and exit function with return value 0."
                << endl;
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      entry->unlock();
      return 0;

    } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
        {
          
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`entry_picture->lock()' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
  } /* |  if (multithread_output)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *** (3) Allocate |Picture_Output_Arg_Type| and copy |entry_picture|.@>
@ Allocate |Picture_Output_Arg_Type| and copy |entry_picture|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  Picture_Output_Arg_Type* picture_arg = new Picture_Output_Arg_Type;
   

@q *** (3) Get |clear_ptr|.@>
@ Get |clear_ptr|.
\initials{LDF 2004.07.14.}

\LOG
\initials{LDF 2004.07.14.}
Added this section.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  bool* clear_bool_ptr = 0;


@q **** (4) |clear_ptr == 0|.@>
@ |clear_ptr == 0|.
\initials{LDF 2004.07.14.}

@<Define |Scanner_Type| functions@>=

   bool clear_bool_ptr_new = false;

   if (clear_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << "`clear_bool_ptr' (clear_ptr) == 0.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       clear_bool_ptr = new bool;
       *clear_bool_ptr = false;

       clear_bool_ptr_new = true;

     } /* |if (clear_ptr == 0)|  */
   

@q **** (4) |clear_ptr != 0|.@>
@ |clear_ptr != 0|.
\initials{LDF 2004.07.14.}

@<Define |Scanner_Type| functions@>=


   else /* (|clear_ptr != 0|)  */
   {
       clear_bool_ptr = static_cast<bool*>(clear_ptr); 

@q ***** (5) Error handling:  |clear_ptr != 0 && *clear_bool_ptr != true|.@>
@ Error handling:  |clear_ptr != 0 && *clear_bool_ptr != true|.
\initials{LDF 2004.07.14.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2006.11.06.}
Find out why I'm getting this warning!  I've turned it off, 
because it's annoying.
\ENDTODO 

@<Define |Scanner_Type| functions@>=


       if (*clear_bool_ptr != true)
         {

#if 0 

           cerr_strm << thread_name 
                     << "WARNING! In `Scanner_Type::extract_picture_output_args':"
                     << endl 
                     << "`clear_ptr' != 0 and "
                     << "`*clear_bool_ptr' == `*static_cast<bool*>(clear_ptr)' == `false'."
                     << endl 
                     << "This should never happen. Will try to continue, though.";   
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");
#endif 

         } /* |if (*clear_bool_ptr != true)|  */

@q ***** (5) |*clear_bool_ptr == true|.@>
@ |*clear_bool_ptr == true|.
\initials{LDF 2004.07.14.}

@<Define |Scanner_Type| functions@>=

       else /* (|*clear_bool_ptr == true|) */
         {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << "`*clear_bool_ptr' == `true'.";
           cerr_message(cerr_strm);
           cerr_strm.str("");

         }
#endif /* |DEBUG_COMPILE|  */@; 

     }         /* |else| (|*clear_bool_ptr == true|) */

 } /* |else| (|clear_ptr != 0|)  */


@q *** (3) Detach |entry_picture| if |*clear_bool_ptr == true|, otherwise copy it.@>
@ Detach |entry_picture| if |*clear_bool_ptr == true|, otherwise copy it.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   picture_arg->scanner_node = this;

   if (*clear_bool_ptr)
     {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "Detaching `Picture' from `entry'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
         
     }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->picture = entry_picture;

    
#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_mutex.lock();

       entry_picture->show("entry_picture second:");
       picture_arg->picture->show("picture_arg->picture:");
       cerr_mutex.unlock();
       
     }
#endif /* |DEBUG_COMPILE|  */@; 



@q **** (4) Try to unlock |entry_picture->mutex|.  @>
@ Try to unlock |entry_picture->mutex|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
  if (multithread_output)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "Trying to unlock `entry_picture->mutex'."
                    << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry_picture->unlock();
    
@q ***** (5) Error handling:  |entry_picture->unlock()| failed.  @>
@ Error handling:  |entry_picture->unlock()| failed.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  if (status != 0)
    {
  
      cerr_strm << thread_name << "ERROR! "
                << "In `Scanner_Type::extract_picture_output_args':"
                << endl << "`entry_picture->unlock()' failed."
                << "Will try to unlock `entry->mutex', delete `picture_arg', "
                << "and exit function with return value 0."
                << endl;
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      
      entry->unlock();

      delete picture_arg;
      picture_arg = 0;

      return 0;

    } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
        {
          
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`entry_picture->unlock()' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
  } /* |  if (multithread_output)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 





@q **** (4) Allocate new |Picture| for |entry_picture|.@>
@ Allocate new |Picture| for |entry_picture|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_mutex.lock();

       entry_picture->show("entry_picture third:");
       picture_arg->picture->show("picture_arg->picture second:");
       cerr_mutex.unlock();
     }
#endif /* |DEBUG_COMPILE|  */@; 

      entry->object = static_cast<void*>(new Picture);
 
#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_mutex.lock();
        entry_picture->show("entry_picture fourth:");
        static_cast<Picture*>(entry->object)->show("entry object:");
        picture_arg->picture->show("picture_arg->picture third:");
        cerr_mutex.unlock();
    }
#endif /* |DEBUG_COMPILE|  */@; 




     } /* |if (*clear_bool_ptr)|  */


   else /* (|!*clear_bool_ptr|)  */
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << thread_name << "Copying `Picture'.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->picture = new Picture;

       *(picture_arg->picture) = *entry_picture;
   

@q **** (4) Try to unlock |entry_picture->mutex|.  @>
@ Try to unlock |entry_picture->mutex|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
  if (multithread_output)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "Trying to unlock `entry_picture->mutex'."
                    << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry_picture->unlock();
    
@q ***** (5) Error handling:  |entry_picture->unlock()| failed.  @>
@ Error handling:  |entry_picture->unlock()| failed.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  if (status != 0)
    {
  
      cerr_strm << thread_name << "ERROR! "
                << "In `Scanner_Type::extract_picture_output_args':"
                << endl << "`entry_picture->unlock()' failed."
                << "Will try to unlock `entry->mutex', delete `picture_arg', "
                << "and exit function with return value 0."
                << endl;
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      
      entry->unlock();
      delete picture_arg;

      picture_arg = 0;

      return 0;

    } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
        {
          
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`entry_picture->unlock()' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
  } /* |  if (multithread_output)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 
  
  }     /* |else| (|!*clear_bool_ptr|)  */



@q *** (3) Delete |clear_bool_ptr| set it to 0.@>

@ Delete |clear_bool_ptr| set it to 0.
\initials{LDF 2004.07.14.}

\LOG
\initials{LDF 2006.10.08.}
@:BUG FIX@> BUG FIX:  Now setting |clear_bool_ptr| to 0.  Previously,
I set |clear_ptr| to 0.  This was a typo.

\initials{LDF 2010.10.08.}
Now checking if |clear_bool_ptr| is non-null before deleting.  Of course, if it's non-null
but doesn't point to a valid object, this will cause a segmentation fault.

\initials{LDF 2013.11.05.}
@:BUG FIX@> BUG FIX:  Now only deleting |clear_bool_ptr| if memory has been allocated 
for it above.  @:TODO@> !! TODO:  This isn't ideal.  The problem can probably be solved
in a better way.  However, I will have to review this function.  
The call to |delete| caused the following error:\hfil\break 
\.{*** glibc detected *** 3dldf: free(): invalid pointer: 0x0000000000c991a0 ***}\hfil\break 
Previously, it worked, so apparently it's a matter of the run-time system checking more 
carefully than it had in the past.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

   if (clear_bool_ptr && clear_bool_ptr_new)   
      delete clear_bool_ptr;

   clear_bool_ptr = 0;


@q *** (3) Try to unlock |entry->mutex|.  @>
@ Try to unlock |entry->mutex|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#ifdef HAVE_PTHREAD_H  
  if (multithread_output)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "Trying to unlock `entry->mutex'."
                    << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry->unlock();
    
@q **** (4) Error handling:  |entry->unlock()| failed.  @>
@ Error handling:  |entry->unlock()| failed.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

  if (status != 0)
    {
  
      cerr_strm << thread_name 
                << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                << endl << "`entry->unlock()' failed."
                << "Will try to delete `picture_arg' and exit "
                << "function with return value 0."
                << endl;
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete picture_arg;
      picture_arg = 0;

      return 0;

    } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
        {
          
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`entry->unlock()' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
  } /* |  if (multithread_output)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 


   picture_entry_ptr = 0;


@q *** (3) Set |picture_arg| members.  @>
@ Set |picture_arg| members.
\initials{LDF 2004.07.12.}


@q **** (4) |endfig_ptr|.  @>
@ |endfig_ptr|.
\initials{LDF 2004.07.14.}


@q ***** (5) |endfig_ptr == 0|.  @>

|endfig_ptr == 0|.
\initials{LDF 2004.07.14.}

@<Define |Scanner_Type| functions@>=

  
  if (endfig_ptr == 0)
    {


#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`endfig_ptr' == 0.";
           cerr_message(cerr_strm);
           cerr_strm.str("");

         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->endfig = false;


    } /* |if (endfig_ptr == 0)|  */


@q ***** (5) |endfig_ptr != 0|.  @>
@ |endfig_ptr != 0|.
\initials{LDF 2004.07.14.}

\LOG
\initials{LDF 2004.07.16.}
@:BUG FIX@> BUG FIX:  Now setting |endfig_ptr| to 0 after deleting it.
\ENDLOG 

@<Define |Scanner_Type| functions@>=

  else /* (|endfig_ptr != 0|)  */
    {


#if DEBUG_COMPILE
      if (DEBUG)
        {
           
          cerr_strm << thread_name 
                    << "In `Scanner_Type::extract_picture_output_args':"
                    << endl << "`endfig_ptr' != 0.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 


      picture_arg->endfig = *static_cast<bool*>(endfig_ptr);

      delete static_cast<bool*>(endfig_ptr);
      endfig_ptr = 0;
       
@q ****** (6) WARNING:  |endfig_ptr != true|.@>
@ WARNING:  |endfig_ptr != true|.
\initials{LDF 2004.07.14.}

@<Define |Scanner_Type| functions@>=

  if (picture_arg->endfig != true)
    {
      cerr_strm << thread_name << "WARNING! "
                << "In `Scanner_Type::extract_picture_output_args':"
                << endl << "`picture_arg->endfig' != `true'."
                << endl << "This shouldn't ever happen. Will try to continue.";
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
    }
       
    } /* |else| (|picture_arg->endfig != 0|)  */



@q **** (4) |focus_ptr|.  @>
@ |focus_ptr|.
\initials{LDF 2004.07.12.}

@q ***** (5) |focus_ptr == 0|.  @>
|focus_ptr == 0|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

   if (focus_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_ptr' == 0.";
           cerr_message(cerr_strm);
           cerr_strm.str("");

         }
#endif /* |DEBUG_COMPILE|  */@; 
       
       Id_Map_Entry_Node focus_entry = lookup("default_focus");
       

       if (focus_entry == static_cast<Id_Map_Entry_Node>(0) || focus_entry->object == 0)
         {
           
           cerr_strm << thread_name 
                     << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`default_focus()' not found."
                     << "Will try to delete `picture_arg' and exit "
                     << "function with return value 0."
                     << endl;
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete picture_arg;
           picture_arg = 0;

           return 0;

         } /* |if (focus_entry == 0)|  */

#if DEBUG_COMPILE
         else if (DEBUG)
           {
             cerr_strm << thread_name 
                       << "In `Scanner_Type::extract_picture_output_args':"
                       << endl << "`default_focus()' found."
                       << endl;
             cerr_message(cerr_strm);
             cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@;


@q ****** (6) Try to lock |focus_entry|.  Exit on error.  @>
@ Try to lock |focus_entry|.  Exit on error.
\initials{LDF 2004.07.12.}
@<Define |Scanner_Type| functions@>=

       status = focus_entry->lock();

       if (status != 0)
         {
           
           cerr_strm << thread_name 
                     << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_entry->lock()' failed."
                     << "Will try to delete `picture_arg' and exit "
                     << "function with return value 0."
                     << endl;
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete picture_arg;
           picture_arg = 0;

           return 0;

           
         } /* |if (status != 0)|  */
#if DEBUG_COMPILE

       else if (DEBUG) /* (|status != 0|)  */
         {
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_entry->lock()' succeeded."
                     << endl;
           cerr_message(cerr_strm);
           cerr_strm.str("");

         }  /* |else| (|status != 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 



@q ****** (6) Set |picture_arg->focus|.  @>
@ Set |picture_arg->focus|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


  picture_arg->focus = new Focus;
  *(picture_arg->focus) = *static_cast<Focus*>(focus_entry->object);  

#if DEBUG_COMPILE
   if (DEBUG)
     {
       picture_arg->focus->show("picture_arg_focus:");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) Try to unlock |focus_entry|.  Exit on error.  @>
@ Try to unlock |focus_entry|.  Exit on error.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

       status = focus_entry->unlock();

       if (status != 0)
         {
           
           cerr_strm << thread_name 
                     << "ERROR! In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_entry->unlock()' failed."
                     << "Will try to delete `picture_arg' and exit "
                     << "function with return value 0."
                     << endl;
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           delete picture_arg;
           picture_arg = 0;

           return 0;

           
         } /* |if (status != 0)|  */
#if DEBUG_COMPILE

       else if (DEBUG) /* (|status != 0|)  */
         {
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_entry->unlock()' succeeded."
                     << endl;
           cerr_message(cerr_strm);
           cerr_strm.str("");

         }  /* |else| (|status != 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 


     } /* |if (focus_ptr == 0)|  */


@q ***** (5) |focus_ptr != 0|.  @>
@ |focus_ptr != 0|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=



   else /* (|focus_ptr != 0|)  */

     {
       
#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`focus_ptr' != 0.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->focus = static_cast<Focus*>(focus_ptr);
       focus_ptr = 0;
#if DEBUG_COMPILE
   if (DEBUG)
     {
       picture_arg->focus->show("*(picture_arg->focus):");
     }
#endif /* |DEBUG_COMPILE|  */@; 
       
     } /* |else| (|focus_ptr != 0|)  */


@q **** (4) |projection_ptr|.  @>
@ |projection_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (projection_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`projection_ptr' == 0. "
                     << "Using `Projections::persp'.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 
       

       picture_arg->projection = Projections::persp;
       
     } /* |if (projection_ptr == 0)|  */

   else /* (|projection_ptr != 0|)  */
     {

       int* i = static_cast<int*>(projection_ptr);

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`projection_ptr' != 0. "
                     << "`*static_cast<int*>(projection_ptr)' == " 
                     << *i << ".";

           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

           picture_arg->projection = *i;
           delete i;
           i = 0;
           projection_ptr = 0;

     } /* |else | (|projection_ptr != 0|)  */

@q **** (4) |factor_ptr|.  @>
@ |factor_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (factor_ptr == 0)
     {
       
#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`factor_ptr' == 0. "
                     << "Using 1.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       
       picture_arg->factor = 1;
       
     } /* |if (factor_ptr == 0)|  */

   else /* (|factor_ptr != 0|)  */
     {
       real* r = static_cast<real*>(factor_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`factor_ptr' != 0. "
                     << "`*static_cast<real*>(factor_ptr)' == " 
                     << *r << ".";

           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->factor = *r;
       
       delete r;
       r = 0;
       factor_ptr = 0;
       
     } /* |else| (|factor_ptr != 0|)  */

@q **** (4) |sort_value__ptr|.  @>
@ |sort_value__ptr|.
\initials{LDF 2004.07.12.}

\LOG
\initials{LDF 2005.04.18.}
Now setting |picture_arg->sort_value = Sorting::MIN_Z|.
\ENDLOG 

@<Define |Scanner_Type| functions@>=


   if (sort_value_ptr == 0)
     {
       
#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`sort_value_ptr' == 0. "
                     << "Using `Sorting::MAX_Z'.";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->sort_value = Sorting::MIN_Z;

     } /* |if (sort_value_ptr == 0)|  */


   else /* (|sort_value_ptr != 0|)  */
     {

       int* i = static_cast<int*>(sort_value_ptr); 
      
#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`sort_value_ptr' != 0. "
                     << "`*static_cast<int*>(sort_value_ptr)' == "
                     << *i << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->sort_value = *i;

       delete i;
       i = 0;

       sort_value_ptr = 0;

     } /* |else | (|sort_value_ptr != 0|)  */



@q **** (4) Do warnings.  @>
@ Do warnings.
\initials{LDF 2004.07.13.}

@<Define |Scanner_Type| functions@>=

  picture_arg->do_warnings = (run_state.message_mode > Run_State::SILENT)
                                ? true : false;

#if DEBUG_COMPILE
   if (DEBUG)
     {

       cerr_strm << thread_name << "`do_warnings' == ";

       if (picture_arg->do_warnings)
           cerr_strm << "`true'";
       else
           cerr_strm << "`false'";
       
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Projection limits.  @>
@ Projection limits.
\initials{LDF 2004.07.12.}

\LOG
\initials{LDF 2004.07.15.}
@:BUG FIX@> BUG FIX:  If the pointers are 0, now setting the appropriate values
on |*picture_arg| to the defaults.
\ENDLOG 


@q ***** (5) |min_x_ptr|.  @>
@ |min_x_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

   if (min_x_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_x_proj_ptr' == 0. "
                     << "Using `Picture::default_min_x_proj' == "
                     << Picture::default_min_x_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->min_x_proj = Picture::default_min_x_proj;

     } /* |if (min_x_proj_ptr == 0)|  */

   else /* (|min_x_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(min_x_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_x_proj_ptr' != 0. "
                     << "`*static_cast<real*>(min_x_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->min_x_proj = *r;
       delete r;
       r = 0;
       min_x_proj_ptr = 0;


     } /* |else | (|min_x_proj_ptr != 0|)  */

@q ***** (5) |max_x_ptr|.  @>
@ |max_x_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (max_x_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_x_proj_ptr' == 0. "
                     << "Using `Picture::default_max_x_proj' == "
                     << Picture::default_max_x_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->max_x_proj = Picture::default_max_x_proj;

     } /* |if (max_x_proj_ptr == 0)|  */

   else /* (|max_x_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(max_x_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_x_proj_ptr' != 0. "
                     << "`*static_cast<real*>(max_x_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->max_x_proj = *r;
       delete r;
       r = 0;
       max_x_proj_ptr = 0;


     } /* |else | (|max_x_proj_ptr != 0|)  */


@q ***** (5) |min_y_ptr|.  @>
@ |min_y_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (min_y_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_y_proj_ptr' == 0. "
                     << "Using `Picture::default_min_y_proj' == "
                     << Picture::default_min_y_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->min_y_proj = Picture::default_min_y_proj;

     } /* |if (min_y_proj_ptr == 0)|  */

   else /* (|min_y_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(min_y_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_y_proj_ptr' != 0. "
                     << "`*static_cast<real*>(min_y_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->min_y_proj = *r;
       delete r;
       r = 0;
       min_y_proj_ptr = 0;


     } /* |else | (|min_y_proj_ptr != 0|)  */

@q ***** (5) |max_y_ptr|.  @>
@ |max_y_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (max_y_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_y_proj_ptr' == 0. "
                     << "Using `Picture::default_max_y_proj' == "
                     << Picture::default_max_y_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->max_y_proj = Picture::default_max_y_proj;


     } /* |if (max_y_proj_ptr == 0)|  */

   else /* (|max_y_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(max_y_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_y_proj_ptr' != 0. "
                     << "`*static_cast<real*>(max_y_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->max_y_proj = *r;
       delete r;
       r = 0;
       max_y_proj_ptr = 0;


     } /* |else | (|max_y_proj_ptr != 0|)  */


@q ***** (5) |min_z_ptr|.  @>
@ |min_z_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (min_z_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_z_proj_ptr' == 0. "
                     << "Using `Picture::default_min_z_proj' == "
                     << Picture::default_min_z_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->min_z_proj = Picture::default_min_z_proj;

     } /* |if (min_z_proj_ptr == 0)|  */

   else /* (|min_z_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(min_z_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`min_z_proj_ptr' != 0. "
                     << "`*static_cast<real*>(min_z_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->min_z_proj = *r;
       delete r;
       r = 0;
       min_z_proj_ptr = 0;


     } /* |else | (|min_z_proj_ptr != 0|)  */

@q ***** (5) |max_z_ptr|.  @>
@ |max_z_ptr|.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=


   if (max_z_proj_ptr == 0)
     {

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_z_proj_ptr' == 0. "
                     << "Using `Picture::default_max_z_proj' == "
                     << Picture::default_max_z_proj << ".";
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 


       picture_arg->max_z_proj = Picture::default_max_z_proj;

     } /* |if (max_z_proj_ptr == 0)|  */

   else /* (|max_z_proj_ptr != 0|)  */
     {
       
       real* r = static_cast<real*>(max_z_proj_ptr); 

#if DEBUG_COMPILE
       if (DEBUG)
         {
           
           cerr_strm << thread_name 
                     << "In `Scanner_Type::extract_picture_output_args':"
                     << endl << "`max_z_proj_ptr' != 0. "
                     << "`*static_cast<real*>(max_z_proj_ptr)' "
                     << "== " << *r;
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       picture_arg->max_z_proj = *r;
       delete r;
       r = 0;
       max_z_proj_ptr = 0;


     } /* |else | (|max_z_proj_ptr != 0|)  */


@q **** (4) |surface_hiding_value_ptr|.@>   
@ |surface_hiding_value_ptr|.
\initials{LDF 2005.03.14.}

\LOG
\initials{LDF 2005.03.14.}
Added this section.


\initials{LDF 2005.03.15.}
Now assigning 
|picture_arg->surface_hiding_value = static_cast<unsigned short>(floor(*r))|
instead of 
|picture_arg->surface_hiding_value = *r|, if |surface_hiding_value_ptr != 0)|.
This prevents a compiler warning.

\initials{LDF 2005.04.04.}
Now setting |picture_arg->surface_hiding_value = 0| 
if |surface_hiding_value_ptr == 0|.  This has the effect that 
the default behavior of |Picture::output()| is to {\it not\/} perform 
surface hiding.
\ENDLOG

@<Define |Scanner_Type| functions@>=

   if (surface_hiding_value_ptr == 0)
      picture_arg->surface_hiding_value = 0;
   else 
      {
         real* r = static_cast<real*>(surface_hiding_value_ptr); 
         picture_arg->surface_hiding_value = static_cast<unsigned short>(floor(*r));
         delete r;
         r = 0;
         surface_hiding_value_ptr = 0;
      }




@q *** (3) Exit function successfully.  @>
@ Exit function successfully.
\initials{LDF 2004.07.12.}

@<Define |Scanner_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "Exiting "
                << "`Scanner_Type::extract_picture_output_args()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 
  
   return picture_arg;

}


@q * Putting |Scanner_Type| functions together.@>
@* Putting {\bf Scanner\_Type} functions together.
  
@ This is what's compiled.
@c
@<Include files@>@;
@<Define |Scanner_Type| functions@>@;

@ This is what's written to \filename{scanner.h}.
@(sctpfncs.h@>=

; /* Nothing.  */


@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 70))    @>




@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-gxx-on-file:"main.c" @>
@q run-cweb-on-file:"main.web" @>
@q run-cweave-on-file:"3DLDF.web" @>
@q makefile:"makefile" @>
@q executable-name:"pp" @>
@q use-g++:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
 
