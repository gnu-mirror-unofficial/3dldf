@q scanprsf.web @>  
     
@q * Copyright and License.@>

@q This file is part of 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>



@q * Additional scanning and parsing functions.@>
@** Additional scanning and parsing functions\quad 
({\tt scanprsf\PERIOD web}).\hfil

\LOG
\initials{LDF 2004.08.16.}  
Added this file.
\ENDLOG 

@q * Include files.@>
@ Include files.

@<Include files@>=
#include "loader.h++"
#include <string.h>

#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"


@q * |Scan_Parse| functions.@>
@* {\bf Scan\_Parse} functions.

@q ** Declare |namespace Scan_Parse|.@>
@*1 Declare {\bf namespace Scan\_Parse} functions.

@<Declare |namespace Scan_Parse|@>=

namespace
Scan_Parse
{
  @<Declare |Scan_Parse| functions@>@;
};


@q ** (2) |variable_func|.@>
@*1 {\bf variable\_func}.

\LOG
\initials{LDF 2004.07.21.}
Added this function.

\initials{LDF 2004.08.16.}
Moved this function from \filename{scan.web} to 
\filename{scanprsf.web} (this file). 

\initials{LDF 2004.09.09.}
@:BUG FIX@> BUG FIX: 
Now testing |HAVE_PTHREAD_H|, |scanner_node->get_run_state()->multithread_input|, 
and |scanner_node->get_run_state()->multithread_output| when setting |thread_name|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
String_Bool
variable_func(Scanner_Node scanner_node,
              char* tag,
              char* suffix,
              int local_yychar,
              int local_YYEMPTY);

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
String_Bool
Scan_Parse::variable_func(Scanner_Node scanner_node,
                          char* tag,
                          char* suffix,
                          int local_yychar,
                          int local_YYEMPTY)
{


  string thread_name;
  
#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

  if (scanner_node == static_cast<Scanner_Node>(0) /* Assume we're using threads.  */

      || (scanner_node->get_run_state()->multithread_input 
          || scanner_node->get_run_state()->multithread_output)      

      /* Definitely using threads.  */

      ) /* Using threads.  */

    {

      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = Thread_Info_Type::get_thread_name(thread_info);

    } /* |if| (using threads).  */

  else /* Not using threads.  */
    
    {
      thread_info = 0;
      thread_name = "";

    } /* |else| (Not using threads).  */


#else /* |HAVE_PTHREAD_H| is undefined.  */@; 
  
  thread_name = "";

#endif /* |HAVE_PTHREAD_H|  is undefined.  */@; 
 
  stringstream cerr_strm;                                                          

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG) 
    {
      cerr_strm << thread_name << "Entering `Scan_Parse::variable_func()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 


  String_Bool return_value;

  return_value.second = false;

  return_value.first = tag;
  return_value.first += suffix;


  Id_Map_Entry_Node entry = scanner_node->lookup(return_value.first.c_str());

#if DEBUG_COMPILE
  if (DEBUG)
    {
      if (entry == static_cast<Id_Map_Entry_Node>(0))
        {
          cerr_strm << thread_name << "In `Scan_Parse::variable_func()':"
                    << endl << "   entry == 0";
          cerr_message(cerr_strm);
          cerr_strm.str("");

        } /* |if (entry == 0)|  */


      else /* (|entry != 0|)  */
        {

          cerr_strm << thread_name << "In `Scan_Parse::variable_func()':"
                    << endl << "   entry != 0";
          cerr_message(cerr_strm);
          cerr_strm.str("");

          if (entry->object == static_cast<void*>(0))
            {
              
              cerr_strm << thread_name << "In `Scan_Parse::variable_func()':"
                        << endl << "   `entry->object' == 0";
              cerr_message(cerr_strm);
              cerr_strm.str("");


            } /* |if (entry->object == 0)|  */

          else /* (|entry->object != 0|)  */
            {
              
              cerr_strm << thread_name << "In `Scan_Parse::variable_func()':"
                        << endl << "   `entry->object' != 0";
              cerr_message(cerr_strm);
              cerr_strm.str("");

            } /* |else| (|entry->object != 0|)  */

        }  /* |else| (|entry != 0|)  */

    } /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Test for look-ahead token.  @>
@ Test for look-ahead token.  If there is one, we call |yyclearin|.
Normally there should be one.  However, if there isn't, i.e., 
|local_yychar == local_YYEMPTY|, we don't. 
\initials{LDF 2004.05.03.}
@<Define |Scan_Parse| functions@>=

  if (local_yychar == local_YYEMPTY)
    {
#if DEBUG_COMPILE
      if (DEBUG)
         {
             cerr_strm << "local_yychar == local_YYEMPTY. Not calling `yyclearin'.";
             cerr_message(cerr_strm);
             cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 
 
   } /* |if (local_yychar == local_YYEMPTY)|  */@;
  
@q **** (4) There is a look-ahead token.  @>
@ There is a look-ahead token.  We must clear it.
\initials{LDF 2004.05.03.}

@<Define |Scan_Parse| functions@>=
  else /* |local_yychar != local_YYEMPTY|  */@;
    {

      return_value.second = true;

      int curr_type;
      
      if (entry == static_cast<Id_Map_Entry_Node>(0))
        {
          curr_type = UNDECLARED;
        }
      else if (entry->object == static_cast<void*>(0))
        {
          curr_type = entry->type;
        }
      else
        {
          curr_type = entry->type;
        }

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "curr_type == " << name_map[curr_type] << ".";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

      Int_Void_Ptr_Bool a(local_yychar, 0, true);
      scanner_node->rescan_stack.push(a);

      a.set(curr_type, entry, false);

      scanner_node->rescan_stack.push(a);

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "local_yychar == " << name_map[local_yychar] 
                    << endl << "Clearing it.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /*  |else| (|local_yychar != local_YYEMPTY|)  */@;

  return return_value;
}


@q ** (2) |label_point_command|.@>
@*1 {\bf label\_point\_command}.

\LOG
\initials{LDF 2004.08.16.}
Added this function.

\initials{LDF 2004.10.08.}
Removed the declaration.  It was redundant, because this function is
already declared in \filename{pspglb.web}.  Changed the name of this
function from |label_command| to |label_point_command|.

\initials{LDF 2004.10.09.}
@:BUG FIX@> BUG FIX:  
Now deleting |text_str| and |position|.

\initials{LDF 2005.01.29.}
Added |Color* text_color| and |Color* dot_color| 
arguments.

\initials{LDF 2005.01.31.}
Now passing |Color* text_color| and |Color* dot_color| to 
|Point::label|.

\initials{LDF 2005.08.14.}
Added |Transform* transform| argument.

\initials{LDF 2005.08.14.}
Now passing the |Transform* transform| to |Point::label|.

\initials{LDF 2005.12.01.}
@:BUG FIX@> BUG FIX:  Now exiting close to the beginning of the function, 
if |Point* position == 0|.
@:BUG FIX@> BUG FIX:  Now deleting all of the pointers before exiting.
\ENDLOG 

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=

int
Scan_Parse::label_point_command(Scanner_Node scanner_node,
                                int label_or_dotlabel,
                                int label_suffix,
                                string* text_str,
                                Point* position,
                                Transform* transform,
                                Color* text_color,
                                Color* dot_color,
                                Id_Map_Entry_Node entry)

{

@q **** (4) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;


  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);


@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::label_point_command()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  int status;


@q **** (4) Error handling.  |position == 0|.@> 
@ Error handling.  |position == 0|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (position == static_cast<Point*>(0))
      {
          cerr_strm << thread_name << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl 
                << "`Point* position == 0'.  Deleting other pointers"
                << endl 
                << "and exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete text_str;
          delete transform;
          delete text_color;
          delete dot_color;

          text_str = 0;
          transform = 0;
          text_color = 0;
          dot_color = 0;

          return 1;

      }  /* |if (position == 0)|  */



@q **** (4) Determine whether to use dot or not.@>
@ Determine whether to use dot or not.
\initials{LDF 2004.08.16.}

@<Define |Scan_Parse| functions@>=

  bool dot;

  if (label_or_dotlabel == LABEL)
    dot = false;

  else if (label_or_dotlabel == DOTLABEL)
    dot = true;

    else
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl << "Invalid value for `label_or_dotlabel': "
                << label_or_dotlabel << endl 
                << "Setting `dot' to `false' and continuing.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      dot = false;

    } /* |else| (Invalid value for |label_or_dotlabel|.)  */

 

@q **** (4) |!dot && dot_color|.  Delete |dot_color| and set it to 0.@>   
@ |!dot && dot_color|.  Delete |dot_color| and set it to 0.
\initials{LDF 2005.01.31.}

\LOG
\initials{LDF 2005.01.31.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   if (!dot && dot_color)
      {
         delete dot_color;
         dot_color = 0;
      }

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=


    
  string position_str;

  Picture* picture_ptr;



@q ***** (5) Error handling for |entry == 0 || entry->object == 0|.@>
@ Error handling for |entry == 0 || entry->object == 0|

@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl
                << "`entry' == 0 or `entry->object' == 0."
                << endl << "Deleting pointers and "
                << "exiting function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      delete text_str;
      delete transform;
      delete text_color;
      delete dot_color;
      delete position;

      text_str = 0;
      transform = 0;
      text_color = 0;
      dot_color = 0;
      position = 0;

      return 1;

    } /* |if (entry == 0 || entry->object == 0)|  */



@q **** (4) Set |position_str|.@>   
@ Set |position_str|.
\initials{LDF 2004.08.16.}

@<Define |Scan_Parse| functions@>=

  picture_ptr = static_cast<Picture*>(entry->object);

  switch (label_suffix)
    {
    case NULL_VALUE:
      position_str = "";
      break;
    case RT:
      position_str = "rt";
      break;
    case LFT:
      position_str = "lft";
      break;
    case TOP:
      position_str = "top";
      break;
    case BOT:
      position_str = "bot";
      break;
    case URT:
      position_str = "urt";
      break;
    case ULFT:
      position_str = "ulft";
      break;
    case LRT:
      position_str = "lrt";
      break;
    case LLFT:
      position_str = "llft";
      break;

    default:
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl
                << "Invalid `label_suffix': " << label_suffix
                << ". Will use \"\" and continue.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      break;
    }  /* |switch (label_suffix)|  */


@q **** (4) Try to lock |entry->mutex|.@>
@ Try to lock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.08.16.}
@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                << endl << "About to call `entry->lock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl << "`entry->lock()' failed. "
                << "Not making label, "
                << "deleting pointers,"
                << endl 
                << "and exiting function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
            
      delete text_str;
      delete transform;
      delete text_color;
      delete dot_color;
      delete position;

      text_str = 0;
      transform = 0;
      text_color = 0;
      dot_color = 0;
      position = 0;

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                 << endl << "`entry->lock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Try to lock |picture_ptr->mutex|.@>
@ Try to lock |picture_ptr->mutex|.  Exit function upon failure.
\initials{LDF 2004.08.16.}

\LOG
\initials{LDF 2007.10.14.}
@:BUG FIX@> BUG FIX:  Now setting |transform| to 0.
\ENDLOG 

@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                << endl << "About to call `picture_ptr->lock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = picture_ptr->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl << "`picture_ptr->lock()' failed. "
                << "Not making label, "
                << "deleting pointers,"
                << endl 
                << "and will try to unlock `entry->mutex' "
                << "and exit function, with return value 1.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete transform;
      delete text_color;
      delete dot_color;
      delete position;

      text_str = 0;
      transform = 0;
      text_color = 0;
      dot_color = 0;
      position = 0;

      entry->unlock();

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                 << endl << "`picture_ptr->lock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

    position->label(*picture_ptr, *text_str, position_str, transform, text_color,
                    dot_color, dot);

    transform = 0;

@q **** (4) Try to unlock |picture_ptr->mutex|.@>
@ Try to unlock |picture_ptr->mutex|.  Exit function upon failure.
\initials{LDF 2004.08.16.}
@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                << endl << "About to call `picture_ptr->unlock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = picture_ptr->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl << "`picture_ptr->unlock()' failed. "
                << "Deleting pointers and will try to unlock `entry->mutex'"
                << endl 
                << "and exit function with return value 1.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete transform;
      delete text_color;
      delete dot_color;
      delete position;


      text_str = 0;
      transform = 0;
      text_color = 0;
      dot_color = 0;
      position = 0;

      entry->unlock();

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                 << endl << "`picture_ptr->unlock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Try to unlock |entry->mutex|.@>
@ Try to unlock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.08.16.}
@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                << endl << "About to call `entry->unlock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl << "`entry->unlock()' failed."
                << endl 
                << "Deleting pointers and exiting function with return value 1.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete transform;
      delete text_color;
      delete dot_color;
      delete position;

      text_str = 0;
      transform = 0;
      text_color = 0;
      dot_color = 0;
      position = 0;

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_point_command()':"
                 << endl << "`entry->unlock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q **** (4) Exit |Scan_Parse::label_point_command| successfully.@>   
@ Exit |Scan_Parse::label_point_command| successfully.

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::label_point_command()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

   delete text_str;
   delete transform;
   delete text_color;
   delete dot_color;
   delete position;

   text_str = 0;
   transform = 0;
   text_color = 0;
   dot_color = 0;
   position = 0;

   return 0;

} /* End of |Scan_Parse::label_point_command| definition.  */



@q ** |label_path_command|.@>
@*1 {\bf label\_point\_command}.

\LOG
\initials{LDF 2004.10.08.}
Added this function.

\initials{LDF 2004.10.09.}
Changed the call to |Path::label| to reflect its new 
calling convention.

\initials{LDF 2004.10.09.}
@:BUG FIX@> BUG FIX:  
Now deleting |text_str| and |ppath|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* text_color| and |Color* dot_color|. 
Passing these arguments on to |Path::label|.

\initials{LDF 2005.02.01.}
@:BUG FIX@> BUG FIX:  Now deleting |text_color| and |dot_color| upon
error and before returning successfully.

\initials{LDF 2005.12.01.}
@:BUG FIX@> BUG FIX:  Now exiting close to the beginning of the function,
if |Path* ppath == 0|.
\ENDLOG 

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=

int
Scan_Parse::label_path_command(Scanner_Node scanner_node,
                                int label_or_dotlabel,
                                int label_suffix,
                                string* text_str,
                                Color* text_color,
                                Color* dot_color,
                                int start_ctr,
                                Path* ppath,
                                Id_Map_Entry_Node entry)

{

@q **** (4) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;


  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);




@q **** (4).@>


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::label_path_command()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  
  int status;

@q **** (4) Error handling:  |Path* ppath == 0|.@> 
@ Error handling:  |Path* ppath == 0|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (ppath == static_cast<Path*>(0))
      {
          cerr_strm << thread_name << "ERROR! In `Scan_Parse::label_point_command()':"
                << endl 
                << "`Path* ppath == 0'.  Deleting other pointers"
                << endl 
                << "and exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete text_str;
          delete text_color;
          delete dot_color;

          return 1;

      }  /* |if (ppath == 0)|  */


@q **** (4) Determine whether to use dot or not.@>
@ Determine whether to use dot or not.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=

  bool dot;

  if (label_or_dotlabel == LABEL)
    dot = false;

  else if (label_or_dotlabel == DOTLABEL)
    dot = true;

    else
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl << "Invalid value for `label_or_dotlabel': "
                << label_or_dotlabel << endl 
                << "Setting `dot' to `false' and continuing.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      dot = false;

    } /* |else| (Invalid value for |label_or_dotlabel|.)  */

 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=
    
  string position_str;

  Picture* picture_ptr;

@q ***** (5) Error handling for |entry == 0 || entry->object == 0|.@>
@ Error handling for |entry == 0 || entry->object == 0|
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl
                << "`entry' == 0 or `entry->object' == 0."
                << endl << "Deleting `text_str', `text_color', "
                << "`dot_color', and `ppath' and "
                << "exiting function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      delete text_str;
      delete text_color;
      delete dot_color;
      delete ppath;

      return 1;

    } /* |if (entry == 0 || entry->object == 0)|  */



@q **** (4) Set |position_str|.@>   
@ Set |position_str|.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=

  picture_ptr = static_cast<Picture*>(entry->object);

  switch (label_suffix)
    {
    case NULL_VALUE:
      position_str = "";
      break;
    case RT:
      position_str = "rt";
      break;
    case LFT:
      position_str = "lft";
      break;
    case TOP:
      position_str = "top";
      break;
    case BOT:
      position_str = "bot";
      break;
    case URT:
      position_str = "urt";
      break;
    case ULFT:
      position_str = "ulft";
      break;
    case LRT:
      position_str = "lrt";
      break;
    case LLFT:
      position_str = "llft";
      break;

    default:
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl
                << "Invalid `label_suffix': " << label_suffix
                << ". Will use \"\" and continue.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      break;
    }  /* |switch (label_suffix)|  */


@q **** (4) Try to lock |entry->mutex|.@>
@ Try to lock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                << endl << "About to call `entry->lock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl << "`entry->lock()' failed. "
                << "Not making label.  Deleting `text_str', "
                << "`text_color', `dot_color', and `ppath',"
                << endl 
                << "and exiting function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
            
      delete text_str;
      delete text_color;
      delete dot_color;
      delete ppath;

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                 << endl << "`entry->lock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Try to lock |picture_ptr->mutex|.@>
@ Try to lock |picture_ptr->mutex|.  Exit function upon failure.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                << endl << "About to call `picture_ptr->lock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = picture_ptr->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl << "`picture_ptr->lock()' failed. "
                << "Not making label."
                << endl 
                << "Will delete `text_str', "
                << "`text_color', `dot_color', and `ppath',"
                << "try to unlock `entry->mutex',"
                << endl 
                << "and exit function, returning 1.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete text_color;
      delete dot_color;
      delete ppath;

      entry->unlock();

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                 << endl << "`picture_ptr->lock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q **** (4) Make labels.@>   
@ Make labels.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=

  ppath->label(*picture_ptr,
               *text_str,
               start_ctr,
               position_str,
               text_color, 
               dot_color,
               dot,
               scanner_node);


@q **** (4) Try to unlock |picture_ptr->mutex|.@>

@ Try to unlock |picture_ptr->mutex|.  Exit function upon failure.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                << endl << "About to call `picture_ptr->unlock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = picture_ptr->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl << "`picture_ptr->unlock()' failed. "
                << "Deleting `text_str', "
                << "`text_color', `dot_color', and `ppath',"
                << endl 
                << "will try to unlock `entry->mutex', "
                << "and exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete text_color;
      delete dot_color;
      delete ppath;

      entry->unlock();

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "In `Scan_Parse::label_path_command()':"
                 << endl << "`picture_ptr->unlock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Try to unlock |entry->mutex|.@>

@ Try to unlock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                << endl << "About to call `entry->unlock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::label_path_command()':"
                << endl << "`entry->unlock()' failed. "
                << "Deleting `text_str', "
                << "`text_color', `dot_color', and `ppath',"
                << "and exiting function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      delete text_str;
      delete text_color;
      delete dot_color;
      delete ppath;

      return 1;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::label_path_command()':"
                 << endl << "`entry->unlock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q **** (4) Exit |Scan_Parse::label_path_command| successfully.@>   

@ Exit |Scan_Parse::label_path_command| successfully.
\initials{LDF 2004.10.08.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::label_path_command()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


  delete text_str;
  delete text_color;
  delete dot_color;
  delete ppath;

  return 0;

}  /* End of |Scan_Parse::label_path_command| definition.  */   



@q ** (2) |drawing_command_path|.@>
@*1 {\bf drawing\_command\_path}.
\initials{LDF 2004.08.17.}

\LOG
\initials{LDF 2004.08.17.}
Added this function.  It's used in the parser rule 
\§drawing command> $\longrightarrow$ \§basic drawing command> 
\§path-like expression> \§with clause draw list>.

\initials{LDF 2004.08.30.}
Changed the name of this function from |Scan_Parse::drawing_command| 
to |Scan_Parse::drawing_command_path|.

\initials{LDF 2004.11.08.}
Now calling |Scanner_Type::get_thread_name_and_stop_values|.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
int
drawing_command_path(Scanner_Node scanner_node,
                     int basic_drawing_command,
                     Path* ppath);


@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=

int
Scan_Parse::drawing_command_path(Scanner_Node scanner_node,
                                 int basic_drawing_command,
                                 Path* ppath)

{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::drawing_command_path()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ******* (7) Error handling for the case that |ppath == 0|.@>
@ Error handling for the case that |ppath == 0|.
\initials{LDF 2005.11.01.}

\LOG
\initials{LDF 2005.11.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

    if (ppath == static_cast<Path*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_path()':"
                  << endl << "`ppath' == 0.  "
                  << "Not executing drawing command."
                  << endl 
                  << "Resetting the pointers on `scanner_node', and exiting function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        @<Reset pointers on |scanner_node|@>@;
        
        return 1;

      } /* |if (ppath == 0)|  */@;

@q **** (4) @>   
@
\LOG
Added the variables |Pointer_Vector<Color>* ccolor_vector|
and |Pointer_Vector<Color>* ddraw_color_vector = 0|.

\initials{LDF 2005.03.15.}
Removed |Color* ddraw_color|.

\initials{LDF 2005.03.16.}
Added the variable |Pointer_Vector<Color>* ffill_color_vector = 0|.

\initials{LDF 2005.03.16.}
Put |Color* ddraw_color| back.

\initials{LDF 2005.03.18.}
Added |Pointer_Vector<Pen>* ppen_vector| 
and |Pointer_Vector<Dash_Pattern>* ddash_pattern_vector|
\ENDLOG 

@<Define |Scan_Parse| functions@>=
  
  int status;
 
  Id_Map_Entry_Node entry = 0;

  Picture* ppicture                         = 0;
  Pen* ppen                                 = 0;
  Pointer_Vector<Pen>* ppen_vector          = 0;

  Dash_Pattern* ddash_pattern                        = 0;
  Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0;

  Color* ccolor                             = 0;
  Color* ddraw_color                        = 0;
  Color* ffill_color                        = 0;   

  Pointer_Vector<Color>* ccolor_vector      = 0;
  Pointer_Vector<Color>* ddraw_color_vector = 0;
  Pointer_Vector<Color>* ffill_color_vector = 0;

@q **** (4) Check the pointers on |scanner_node|.@>

@ Check the pointers on |scanner_node|.  One or more may have been set in the
rules for the \§with clause list>.
\initials{LDF 2004.06.02.}

@q ***** (5) Check |scanner_node->picture_entry_ptr|.   @>

Check |scanner_node->picture_entry_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->picture_entry_ptr == 0|.   @>

|scanner_node->picture_entry_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=
if (scanner_node->picture_entry_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_path()':"
                  << endl
                  << "`scanner_node->picture_entry_ptr' == 0";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    entry = scanner_node->lookup("current_picture");

@q ******* (7) Error handling for the case that     @>
@q ******* (7) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_path()':"
                  << endl << "`current_picture' doesn't seem to exist."
                  << endl << "Not executing drawing command. "
                  << endl << "Will clear and delete `ppath' and reset "
                  << "the pointers on `scanner_node', and exit function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        ppath->clear();
        delete ppath;

        @<Reset pointers on |scanner_node|@>@;
        

        return 1;



      } /* |if (entry == 0)|  */@;

@q ******* (7) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2004.06.03.}
@<Define |Scan_Parse| functions@>=

  else
    {
      ppicture = static_cast<Picture*>(entry->object); 
    }

  } /* |if (scanner_node->picture_entry_ptr == 0)|  */@;

@q ****** (6) |scanner_node->picture_entry_ptr != 0|.   @>
@ |scanner_node->picture_entry_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

else /* |scanner_node->picture_entry_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_path()':"
                  << endl 
                  << "`scanner_node->picture_entry_ptr' != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ppicture = static_cast<Picture*>(scanner_node->picture_entry_ptr); 

  } /* |else| (|scanner_node->picture_entry_ptr != 0|)  */


  entry = 0;

@q ***** (5) Set |ddraw_color_vector| and |ffill_color|.@> 
@ Set |ddraw_color_vector| and |ffill_color|.

\LOG
\initials{LDF 2005.03.16.}
Added this section.

\initials{LDF 2005.03.16.}
@:BUG FIX@> BUG FIX:  Now setting |ffill_color_vector|
to 
|static_cast<Pointer_Vector<Color>*>(scanner_node->fill_color_vector_ptr)|.
Previously, it was set to 
|static_cast<Pointer_Vector<Color>*>(scanner_node->draw_color_vector_ptr)|.

\initials{LDF 2005.03.16.}
Debugged this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   ccolor        = static_cast<Color*>(scanner_node->color_ptr); 
   ccolor_vector = static_cast<Pointer_Vector<Color>*>(
                      scanner_node->color_vector_ptr); 


   ddraw_color        = static_cast<Color*>(scanner_node->draw_color_ptr); 
   ddraw_color_vector = static_cast<Pointer_Vector<Color>*>(
                           scanner_node->draw_color_vector_ptr); 

   ffill_color        = static_cast<Color*>(scanner_node->fill_color_ptr); 
   ffill_color_vector = static_cast<Pointer_Vector<Color>*>(
                           scanner_node->fill_color_vector_ptr); 

@q ****** (6) Set |ddraw_color_vector|.@> 

@ Set |ddraw_color_vector|.
\initials{LDF 2005.03.16.}

@<Define |Scan_Parse| functions@>=

   if (ddraw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      scanner_node->draw_color_vector_ptr = static_cast<void*>(0);

   else  /* |ddraw_color_vector == 0|  */ 
      {
          ddraw_color_vector = new Pointer_Vector<Color>;

         if (ddraw_color != static_cast<Color*>(0))
            {

               ddraw_color_vector->append_copy(ddraw_color); 
            }      


         else if (ccolor != static_cast<Color*>(0))
            {
                ddraw_color_vector->append_copy(ccolor);
            }  


         else if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0) 
                  && ccolor_vector->ctr > 0)
            {
                ddraw_color_vector->append_copy(*ccolor_vector);
            }  


          else 
             {

                 entry = scanner_node->lookup("default_color");

                 if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                     && entry->object != static_cast<void*>(0))
                    ddraw_color_vector->append_copy(
                       static_cast<Color*>(entry->object));

                 else  
                    ddraw_color_vector->append_copy(&Colors::black);
             }


      }  /* |else| (|ddraw_color_vector == 0|)  */ 

@q ****** (6) Set |ffill_color|.@> 

@ Set |ffill_color|.

@<Define |Scan_Parse| functions@>=
 
     if (ffill_color != static_cast<Color*>(0))
        scanner_node->fill_color_ptr = 0;


      else /* |ffill_color == 0|  */
         {

            ffill_color = create_new<Color>(0);

@q ******* (7) @> 

            if (   ffill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                && ffill_color_vector->ctr > 0)
               {


                   *ffill_color = *(ffill_color_vector->v[0]);
                   
               }

@q ******* (7) @> 

            else if (ccolor != static_cast<Color*>(0))
               {
                  *ffill_color = *ccolor;
               }

@q ******* (7) @> 


            else if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0)
                     && ccolor_vector->ctr > 0)
               {

                   *ffill_color = *(ccolor_vector->v[0]);

               }

@q ******* (7) @> 

            else if (basic_drawing_command == FILL) 
               {
                 
                   entry = scanner_node->lookup("default_color");

                   if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                       && entry->object != static_cast<void*>(0))
                      *ffill_color = *(static_cast<Color*>(entry->object));
                   else                     
                      *ffill_color = Colors::black;

               }

@q ******* (7) @> 

      else if (basic_drawing_command == FILLDRAW) 
         {
                 
              entry = scanner_node->lookup("background_color");

              if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                  && entry->object != static_cast<void*>(0))
                 *ffill_color = *(static_cast<Color*>(entry->object));
              else                     
                 *ffill_color = Colors::white;

         }

@q ******* (7) @> 

      }  /* |else| (|ffill_color == 0|)  */




@q ***** (5) Check |scanner_node->pen_vector_ptr|.  @>
@ Check |scanner_node->pen_vector_ptr|.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

  if (scanner_node->pen_vector_ptr != static_cast<void*>(0))
     ppen_vector = static_cast<Pointer_Vector<Pen>*>(scanner_node->pen_vector_ptr); 

@q ****** (6).@> 

  else /* |scanner_node->pen_vector_ptr == 0|  */
     {

@q ******* (7) Check |scanner_node->pen_ptr|.  @>
@ Check |scanner_node->pen_ptr|.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.11.12.}
Now setting |ppen = *(scanner_node->current_pen)|, if 
|scanner_node->pen_ptr == 0 && *(scanner_node->current_pen) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=

         if (scanner_node->pen_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 

                if (*(scanner_node->current_pen) != static_cast<Pen*>(0))
                   {
                       ppen = *(scanner_node->current_pen);

                   }  /* |if (*(scanner_node->current_pen) != 0)|  */

@q ******** (8) @> 

            } /* |if (scanner_node->pen_ptr == 0)|  */


@q ******* (7) @> 

         else /* (|scanner_node->pen_ptr != 0|)  */
            {

                 ppen = static_cast<Pen*>(scanner_node->pen_ptr); 

            }  /* |else| (|scanner_node->pen_ptr != 0|)  */

@q ******* (7) @> 

         if (ppen != static_cast<Pen*>(0))
            {
                ppen_vector = new Pointer_Vector<Pen>;
                *ppen_vector += ppen;
            }


@q ******* (7) @> 

     }     /* |else| (|scanner_node->pen_vector_ptr == 0|)  */


@q ***** (5) Check |scanner_node->dash_pattern_vector_ptr|.  @>
@ Check |scanner_node->dash_pattern_vector_ptr|.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

   if (scanner_node->dash_pattern_vector_ptr != static_cast<void*>(0))
      ddash_pattern_vector 
         = static_cast<Pointer_Vector<Dash_Pattern>*>(
              scanner_node->dash_pattern_vector_ptr);       

@q ****** (6).@> 

  else /* |scanner_node->dash_pattern_vector_ptr == 0|  */
     {

@q ******* (7) @> 

         if (scanner_node->dash_pattern_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 


                if (*(scanner_node->current_dash_pattern) != static_cast<Dash_Pattern*>(0))
                   {
                       ddash_pattern = *(scanner_node->current_dash_pattern);

                   }  /* |if (*(scanner_node->current_dash_pattern) != 0)|  */


@q ******** (8) @> 


             } /* |if (scanner_node->dash_pattern_ptr == 0)|  */

@q ******* (7) @> 

   else /* (|scanner_node->dash_pattern_ptr != 0|)  */
      {

        ddash_pattern = static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr); 

      } /* |else| (|scanner_node->dash_pattern_ptr != 0|)  */

@q ******* (7) @> 

        if (ddash_pattern != static_cast<Dash_Pattern*>(0))
           {
              ddash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
              *ddash_pattern_vector += ddash_pattern; 
           }
@q ******* (7) @> 


     }  /* |else| (|scanner_node->dash_pattern_vector_ptr == 0|)  */

@q **** (4) Check which drawing command to use.@>
@ Check which drawing command to use
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2005.03.18.}
Now passing |ppen_vector| to the drawing and filling functions for
|Path|, where appropriate, instead of |ppen|.
\ENDLOG 

@q ***** (5) DRAW.@>
\.{DRAW}.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.11.08.}
Now checking for |basic_drawing_command == DRAWARROW| and 
|basic_drawing_command == DRAWDBLARROW|.

\initials{LDF 2005.03.16.}
Now setting |ddraw_color_vector = 0|.
\ENDLOG 

@<Define |Scan_Parse| functions@>= 

  if (   basic_drawing_command == DRAW
      || basic_drawing_command == DRAWARROW
      || basic_drawing_command == DRAWDBLARROW)
    {


#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_path()':"
                 << endl
                 << "It's " << name_map[basic_drawing_command] << ".";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

       unsigned short arrow;
  
       if (basic_drawing_command == DRAW)
         arrow = Path::NO_ARROW;

       else if (basic_drawing_command == DRAWARROW)
         arrow = Path::SINGLE_ARROW;

       else if (basic_drawing_command == DRAWDBLARROW)
         arrow = Path::DOUBLE_ARROW;


       ppath->draw(*ppicture, ddraw_color_vector, ddash_pattern_vector, ppen_vector, arrow);

       delete ffill_color;
       ffill_color = 0;

       ddraw_color_vector = 0;


    } /* |if (basic_drawing_command == DRAW)|  */


@q ***** (5) FILL@>
@ \.{FILL}.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2005.03.16.}
Now setting |ffill_color_vector = 0|.
\ENDLOG 

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILL)
    {
#if DEBUG_COMPILE
      if (DEBUG) 
        {
          cerr_strm << thread_name << "In `Scan_Parse::drawing_command_path()':"
                    << endl
                    << "It's FILL.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
         ppath->fill(*ppicture, ffill_color);

         delete ddraw_color_vector;
         ddraw_color_vector = 0;

         ffill_color = 0;

    } /* |else if (basic_drawing_command == FILL)|  */

@q ***** (5) FILLDRAW.@>
@ \.{FILLDRAW}.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2005.03.15.}
Now passing |ddraw_color_vector| to |Path::filldraw| 
instead of |ddraw_color|.

\initials{LDF 2005.03.16.}
Now setting |ddraw_color_vector = 0| and |ffill_color_vector = 0|.
\ENDLOG 

@<Define |Scan_Parse| functions@>= 

  else if (basic_drawing_command == FILLDRAW)
    {
#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_path()':"
                 << endl
                 << "It's FILLDRAW.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


   ppath->filldraw(*ppicture, ddraw_color_vector, ffill_color,
                   ddash_pattern_vector, ppen_vector);


   ddraw_color_vector = 0;
   ffill_color        = 0;


 } /* |else if (basic_drawing_command == FILLDRAW)|  */

  
@q ***** (5) UNDRAW.@>
@ \.{UNDRAW}.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

 else if (basic_drawing_command == UNDRAW)
   {
#if DEBUG_COMPILE
     if (DEBUG) 
       {
         cerr_strm << thread_name << "In `Scan_Parse::drawing_command_path()':"
                   << endl
                   << "It's UNDRAW.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm);
         cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */@; 

     ppath->undraw(*ppicture, ddash_pattern_vector, ppen_vector);

     delete ddraw_color_vector;
     ddraw_color_vector = 0;

     delete ffill_color; 
     ffill_color = 0;

     
   } /* |else if (basic_drawing_command == UNDRAW)|  */
  
@q ***** (5) UNFILL.@>
@ |UNFILL|.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

   else if (basic_drawing_command == UNFILL)
     {
#if DEBUG_COMPILE
       if (DEBUG) 
         {
           cerr_strm << thread_name << "In `Scan_Parse::drawing_command_path()':"
                     << endl
                     << "It's UNFILL.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       ppath->unfill(*ppicture);

       delete ddraw_color_vector;
       ddraw_color_vector = 0;

       delete ffill_color; 
       ffill_color = 0;


     } /* |else if (basic_drawing_command == UNFILL)|  */


@q ***** (5) UNFILLDRAW.@>
@ |UNFILLDRAW|.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2005.03.15.}
Now passing |ddraw_color_vector| to |Path::filldraw| 
instead of |ddraw_color|.
\ENDLOG 

@<Define |Scan_Parse| functions@>= 

     else if (basic_drawing_command == UNFILLDRAW)
       {
#if DEBUG_COMPILE
         if (DEBUG) 
           {
             cerr_strm << thread_name 
                       << "In `Scan_Parse::drawing_command_path()':"
                       << endl
                       << "It's UNFILLDRAW.";

             log_message(cerr_strm); 
             cerr_message(cerr_strm);
             cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 

         ppath->unfilldraw(*ppicture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);

 
         delete ffill_color; 
         ffill_color = 0;

       } /* |else if (basic_drawing_command == UNFILLDRAW)|  */

@q ***** (5) Error handling for invalid |basic_drawing_command|.@>
@ Error handling for invalid \§basic drawing command>.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

  else /* Invalid |basic_drawing_command|.  */
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::drawing_command_path()':"
                << endl << "Invalid `basic_drawing_command': " 
                << basic_drawing_command
                << endl << "Will clear and delete `ppath' and reset "
                << "the pointers on `scanner_node', and exit function "
                << "with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      ppath->clear();
      delete ppath;


      delete ddraw_color_vector;
      ddraw_color_vector = 0;

      delete ffill_color; 
      ffill_color = 0;

      @<Reset pointers on |scanner_node|@>@;

      return 1;
      
    }  /* |else| (invalid |basic_drawing_command|).  */

@q **** (4) Exit function successfully with return value 0.@> 
@ Exit function successfully with return value 0.
\initials{LDF 2004.08.17.}

@<Define |Scan_Parse| functions@>= 
  
  ppath->clear();
  delete ppath;

  @<Reset pointers on |scanner_node|@>@;


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::drawing_command_path()' "
                << "successfully with return value 0.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;

} /* End of |Scan_Parse::drawing_command_path| definition.  */

@q ** (2) |drawing_command_solid|.@>
@*1 {\bf drawing\_command\_solid}.

\LOG
\initials{LDF 2004.08.30.}
Added this function.  It's used in the parser rule 
\§drawing command> $\longrightarrow$ \§basic drawing command> 
\§solid-like expression> \§with clause list>.

\initials{LDF 2004.08.30.}
Changed |typedef Pvc Point_Vector<Color>| to 
|typedef Pvc Point_Vector<const Color>| because 
the |Solid| drawing functions require arguments of type
|vector<const Color*>|.  This affects
|ccolor_vector_ptr|, |ddraw_color_vector_ptr|, and 
|ffill_color_vector_ptr|, which are of type |Pvc*|.

\initials{LDF 2004.09.05.}
@:BUG FIX@> BUG FIXES:  Some |#endifs| were formerly placed incorrectly, 
so that some code would not have been compiled when |DEBUG_COMPILE| 
was undefined. 
\ENDLOG 

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::drawing_command_solid(Scanner_Node scanner_node,
                                  int basic_drawing_command,
                                  Solid* ssolid)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>



#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::drawing_command_solid()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Error handling:  |s == 0|.@> 
@ Error handling:  |s == 0|.
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (ssolid == static_cast<Solid*>(0))
     {
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::drawing_command_solid()':"       
                   << endl 
                   << "`Solid* ssolid' is null.  Exiting function "
                   << "with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
 
         return 1;
     }  

@q **** (4).@> 
@
@<Define |Scan_Parse| functions@>=

  int status;
 
  Id_Map_Entry_Node entry = 0;

  Picture* ppicture  = 0;
  Pen* ppen          = 0;
  Dash_Pattern* ddash_pattern = 0;

  typedef Pointer_Vector<Color> Pvc;
   
  Pvc* ccolor_vector_ptr      = 0;
  Pvc* ddraw_color_vector_ptr = 0;
  Pvc* ffill_color_vector_ptr = 0;

  bool delete_ddraw_color_vector_ptr      = false;
  bool delete_ffill_color_vector_ptr      = false;

@q **** (4) Check the pointers on |scanner_node|.@>

@ Check the pointers on |scanner_node|.  One or more may have been set in the
rules for the \§with clause list>.
\initials{LDF 2004.06.02.}

@q ***** (5) Check |scanner_node->picture_entry_ptr|.   @>

Check |scanner_node->picture_entry_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->picture_entry_ptr == 0|.   @>

|scanner_node->picture_entry_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=
  if (scanner_node->picture_entry_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_solid()':"
                  << endl
                  << "`scanner_node->picture_entry_ptr' == 0";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    entry = scanner_node->lookup("current_picture");

@q ******* (7) Error handling for the case that     @>
@q ******* (7) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_solid()':"
                  << endl << "`current_picture' doesn't seem to exist."
                  << endl << "Not executing drawing command. "
                  << endl << "Will clear and delete `ssolid' and reset "
                  << "the pointers on `scanner_node', and exit function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        ssolid->clear();
        delete ssolid;

        @<Reset pointers on |scanner_node|@>@;
        

        return 1;



      } /* |if (entry == 0)|  */@;

@q ******* (7) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2004.06.03.}
@<Define |Scan_Parse| functions@>=

  else
    {
      ppicture = static_cast<Picture*>(entry->object); 
    }

  } /* |if (scanner_node->picture_entry_ptr == 0)|  */@;

@q ****** (6) |scanner_node->picture_entry_ptr != 0|.   @>
@ |scanner_node->picture_entry_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

else /* |scanner_node->picture_entry_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_solid()':"
                  << endl 
                  << "`scanner_node->picture_entry_ptr' != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ppicture = static_cast<Picture*>(scanner_node->picture_entry_ptr); 

  } /* |else| (|scanner_node->picture_entry_ptr != 0|)  */


  entry = 0;


@q ***** (5) Check |scanner_node->color_vector_ptr|.  @>
@ Check |scanner_node->color_vector_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->color_vector_ptr == 0|.  @>
@ |scanner_node->color_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

  if (scanner_node->color_vector_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                  << endl
                  << "scanner_node->color_vector_ptr == 0";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

@q ******* (7) Check |scanner_node->color_ptr|.@> 

@ Check |scanner_node->color_ptr|.
If it's non-null, try to allocate memory 
for |ccolor_vector_ptr| and push |scanner_node->color_ptr| 
onto it.  
\initials{LDF 2004.12.15.}

\LOG
\initials{LDF 2004.12.15.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (scanner_node->color_ptr != static_cast<void*>(0))
      {

         try 
            {
               ccolor_vector_ptr = new Pvc;
            }
          
@q ******** (8) Error handling:  |new Pvc| failed.@> 

@ Error handling:  |new Pvc| failed.
\initials{LDF 2004.12.15.}

\LOG
\initials{LDF 2004.12.15.}
Added this section.
\ENDLOG


@<Define |Scan_Parse| functions@>=

         catch (bad_alloc)
            {
                cerr_strm << thread_name 
                          << "ERROR! `Scan_Parse::drawing_command_solid()':"
                          << endl << "`new Pvc' failed.  "
                          << endl << "Not executing drawing command. "
                          << endl 
                          << "Will clear and delete `ssolid' and reset "
                          << "the pointers on `scanner_node', and "
                          << "rethrow `bad_alloc'.";

                log_message(cerr_strm); 
                cerr_message(cerr_strm, error_stop_value); 
                cerr_strm.str(""); 

                ssolid->clear();
                delete ssolid;

                @<Reset pointers on |scanner_node|@>@;
        
                throw;


            }  /* |catch (bad_alloc)|  */

@q ******** (8) @> 


/* !! Porting:  LDF 2008.10.09.  */
     
     Color* temp_color_ptr = new Color;
     *temp_color_ptr       =  *static_cast<Color*>(scanner_node->color_ptr); 


     *ccolor_vector_ptr += temp_color_ptr;


     scanner_node->color_ptr = 0;

     } /* |if (scanner_node->color_ptr == 0)|  */@;

@q ******* (7) @> 

  } /* |if (scanner_node->color_vector_ptr == 0)|  */@;


@q ****** (6) |scanner_node->color_vector_ptr != 0|.  @>
@ |scanner_node->color_vector_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

   else /* |scanner_node->color_vector_ptr != 0|  */
      {

#if DEBUG_COMPILE
         if (DEBUG) 
            {
                cerr_strm << thread_name 
                          << "In `Scan_Parse::drawing_command_solid()':"
                          << endl  
                          << "scanner_node->color_vector_ptr != 0."
                          << endl 
                          << "`scanner_node->color_vector_ptr->v.size()' == "
                          << static_cast<Pvc*>(
                                scanner_node->color_vector_ptr)->v.size() 
                          << ".";

                log_message(cerr_strm); 
                cerr_message(cerr_strm);
                cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@;  

    ccolor_vector_ptr
      = static_cast<Pvc*>(scanner_node->color_vector_ptr);

    scanner_node->color_vector_ptr = 0;

   }  /* |else| (|scanner_node->color_vector_ptr != 0|)  */@;


@q ***** (5) Check |scanner_node->draw_color_vector_ptr|.  @>
@ Check |scanner_node->draw_color_vector_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->draw_color_vector_ptr == 0|.  @>
@ |scanner_node->color_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->draw_color_vector_ptr == static_cast<void*>(0))
      {

#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name 
                          << "In `Scan_Parse::drawing_command_solid()':"
                          << endl
                          << "scanner_node->draw_color_vector_ptr == 0";

                log_message(cerr_strm); 
                cerr_message(cerr_strm); 
                cerr_strm.str(""); 
            }
#endif /* |DEBUG_COMPILE|  */@;  

@q ******* (7) Check |scanner_node->draw_color_ptr|.@> 

@ Check |scanner_node->draw_color_ptr|.
If it's non-null, try to allocate memory 
for |ddraw_color_vector_ptr| and push |scanner_node->draw_color_ptr| 
onto it.  
\initials{LDF 2004.12.16.}

\LOG
\initials{LDF 2004.12.16.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (scanner_node->draw_color_ptr != static_cast<void*>(0))
      {

         try 
            {
               ddraw_color_vector_ptr = new Pvc;
            }
          
@q ******** (8) Error handling:  |new Pvc| failed.@> 

@ Error handling:  |new Pvc| failed.
\initials{LDF 2004.12.16.}

\LOG
\initials{LDF 2004.12.16.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

         catch (bad_alloc)
            {
                cerr_strm << thread_name 
                          << "ERROR! `Scan_Parse::drawing_command_solid()':"
                          << endl << "`new Pvc' failed.  "
                          << endl << "Not executing drawing command. "
                          << endl 
                          << "Will clear and delete `ssolid' and reset "
                          << "the pointers on `scanner_node', and "
                          << "rethrow `bad_alloc'.";

                log_message(cerr_strm); 
                cerr_message(cerr_strm, error_stop_value); 
                cerr_strm.str(""); 

                ssolid->clear();
                delete ssolid;

                @<Reset pointers on |scanner_node|@>@;
        
                throw;


            }  /* |catch (bad_alloc)|  */

@q ******** (8) @> 


/* !! Porting:  LDF 2008.10.09.  */

         *ddraw_color_vector_ptr += static_cast<Color*>(
                                       scanner_node->draw_color_ptr); 

         scanner_node->draw_color_ptr = 0;

     } /* |if (scanner_node->draw_color_ptr == 0)|  */@;

@q ******* (7) @> 

  } /* |if (scanner_node->draw_color_vector_ptr == 0)|  */@;


@q ****** (6) |scanner_node->draw_color_vector_ptr != 0|.  @>
@ |scanner_node->draw_color_vector_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

else /* |scanner_node->draw_color_vector_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG) 
      {
          cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                    << endl
                    << "scanner_node->draw_color_vector_ptr != 0.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }

    ddraw_color_vector_ptr
      = static_cast<Pvc*>(scanner_node->draw_color_vector_ptr);


#if DEBUG_COMPILE
    if (DEBUG)
      {
          cerr_mutex.lock(); 
          cerr << thread_name 
               << "In `Scan_Parse::drawing_command_solid()':" 
               << endl;

          int i = 0;
          stringstream i_strm;

          for (vector<Color*>::const_iterator iter 
                  = ddraw_color_vector_ptr->v.begin();
               iter != ddraw_color_vector_ptr->v.end();
               iter++)
            {
              i_strm << "Color: ";
              i_strm << i++;
              (**iter).show(i_strm.str());
              i_strm.str("");
            }
          cerr << "Type <RETURN> to continue. ";
          getchar(); 
          cerr_mutex.unlock(); 
        
      }
#endif /* |DEBUG_COMPILE|  */@; 
 
    scanner_node->draw_color_vector_ptr = 0;
      
#endif /* |DEBUG_COMPILE|  */@;  


  }  /* |else| (|scanner_node->draw_color_vector_ptr != 0|)  */@;


@q ***** (5) Check |scanner_node->fill_color_vector_ptr|.  @>
@ Check |scanner_node->fill_color_vector_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->fill_color_vector_ptr == 0|.  @>
@ |scanner_node->color_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->fill_color_vector_ptr == static_cast<void*>(0))
      {

#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name 
                          << "In `Scan_Parse::drawing_command_solid()':"
                          << endl
                          << "scanner_node->fill_color_vector_ptr == 0";

                log_message(cerr_strm); 
                cerr_message(cerr_strm); 
                cerr_strm.str(""); 
            }
#endif /* |DEBUG_COMPILE|  */@;  


@q ******* (7) Check |scanner_node->fill_color_ptr|.@> 

@ Check |scanner_node->fill_color_ptr|.
If it's non-null, try to allocate memory 
for |ffill_color_vector_ptr| and push |scanner_node->fill_color_ptr| 
onto it.  
\initials{LDF 2004.12.16.}

\LOG
\initials{LDF 2004.12.16.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (scanner_node->fill_color_ptr != static_cast<void*>(0))
      {

         try 
            {
               ffill_color_vector_ptr = new Pvc;
            }
          
@q ******** (8) Error handling:  |new Pvc| failed.@> 

@ Error handling:  |new Pvc| failed.
\initials{LDF 2004.12.16.}

\LOG
\initials{LDF 2004.12.16.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

         catch (bad_alloc)
            {
                cerr_strm << thread_name 
                          << "ERROR! `Scan_Parse::drawing_command_solid()':"
                          << endl << "`new Pvc' failed.  "
                          << endl << "Not executing drawing command. "
                          << endl 
                          << "Will clear and delete `ssolid' and reset "
                          << "the pointers on `scanner_node', and "
                          << "rethrow `bad_alloc'.";

                log_message(cerr_strm); 
                cerr_message(cerr_strm, error_stop_value); 
                cerr_strm.str(""); 

                ssolid->clear();
                delete ssolid;

                @<Reset pointers on |scanner_node|@>@;
        
                throw;


            }  /* |catch (bad_alloc)|  */

@q ******** (8) @> 


/* !! Porting:  LDF 2008.10.09.  */

         *ffill_color_vector_ptr += static_cast<Color*>(
                                       scanner_node->fill_color_ptr); 

         scanner_node->fill_color_ptr = 0;

     } /* |if (scanner_node->fill_color_ptr == 0)|  */@;

@q ******* (7) @> 

  } /* |if (scanner_node->fill_color_vector_ptr == 0)|  */@;


@q ****** (6) |scanner_node->fill_color_vector_ptr != 0|.  @>
@ |scanner_node->fill_color_vector_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

   else /* |scanner_node->fill_color_vector_ptr != 0|  */
      {

#if DEBUG_COMPILE
         if (DEBUG) 
            {
               cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                         << endl
                         << "scanner_node->fill_color_vector_ptr != 0.";

               log_message(cerr_strm); 
               cerr_message(cerr_strm);
               cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@;  


         ffill_color_vector_ptr
            = static_cast<Pvc*>(scanner_node->fill_color_vector_ptr);
 

         scanner_node->fill_color_vector_ptr = 0;
      
     }  /* |else| (|scanner_node->fill_color_vector_ptr != 0|)  */@;


@q ***** (5) Check |ddraw_color_vector| and |ffill_color_vector| @>
@q ***** (5) and set to |ccolor_vector|, if necessary.           @>
@ Check |ddraw_color_vector| and |ffill_color_vector| 
and set to |ccolor_vector|, if necessary.  
\initials{LDF 2004.06.04.}

@<Define |Scan_Parse| functions@>=

  if (   ddraw_color_vector_ptr == static_cast<void*>(0) 
      && ccolor_vector_ptr != static_cast<void*>(0))
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
         
          cerr_strm << thread_name 
                    << "In `Scan_Parse::drawing_command_solid()':"
                    << endl
                    << "`ddraw_color_vector_ptr' == 0 "
                    << "&& `ccolor_vector_ptr' != 0"
                    << endl 
                    << "Setting `ddraw_color_vector_ptr' to `ccolor_vector_ptr'.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm, DEBUG);
          cerr_strm.str("");
                    
        }
#endif /* |DEBUG_COMPILE|  */@; 
 

      ddraw_color_vector_ptr = ccolor_vector_ptr;

#if DEBUG_COMPILE
      if (DEBUG)
        {
         
          cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                    << endl
                    << "`(ddraw_color_vector_ptr == 0)' is "
                    << (ddraw_color_vector_ptr == 0) << ".";

          log_message(cerr_strm);
          cerr_message(cerr_strm, DEBUG);
          cerr_strm.str("");
                    
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |if (ddraw_color_vector_ptr == 0 && ccolor_vector_ptr != 0)|  */

  if (   ffill_color_vector_ptr == static_cast<void*>(0) 
      && ccolor_vector_ptr != static_cast<void*>(0))
    {
      ffill_color_vector_ptr = ccolor_vector_ptr;
    }

@q ***** (5) If |ddraw_color_vector_ptr| and/or |ffill_color_vector_ptr| @>
@q ***** (5) is still null, set defaults.                        @>
@ If |ddraw_color_vector_ptr| and/or |ffill_color_vector_ptr|
is still null, set defaults.                        
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG


@q ****** (6) |ddraw_color_vector_ptr|.@>
@ |ddraw_color_vector_ptr|.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  if (   ddraw_color_vector_ptr == static_cast<void*>(0) 
      && (   basic_drawing_command == DRAW
          || basic_drawing_command == FILLDRAW
          || basic_drawing_command == UNFILLDRAW))

{

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                 << endl
                 << "`ddraw_color_vector_ptr' == 0. "
                 << "Will look up `default_color_vector'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   entry = scanner_node->lookup("default_color_vector");

@q ******* (7) |lookup| failed.@> 
@ |lookup| failed.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                << endl
                << "Didn't find `default_color_vector'."
                << endl << "Creating a new `Pointer_Vector<Color>' "
                << "and putting `Colors::black' on it."
                << endl << "It will have to be deleted later.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

      delete_ddraw_color_vector_ptr = true;

      ddraw_color_vector_ptr = new Pvc;
      
      ddraw_color_vector_ptr->v.push_back(const_cast<Color*>(&Colors::black));
      

    } /* |if (entry == 0)|  */


@q ******* (7) |lookup| succeeded.@> 
@ |lookup| succeeded.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else /* |entry != 0|  */
    {

#if DEBUG_COMPILE
   if (DEBUG)
     {

 
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_solid()':"
                  << endl
                  << "Found `default_color_vector'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
      
     }
#endif /* |DEBUG_COMPILE|  */@; 

      ddraw_color_vector_ptr = static_cast<Pvc*>(entry->object);
      
    }   /* |else| (|entry != 0|)  */


@q ******* (7) End of code for setting |ddraw_color_vector_ptr|, @>  
@q ******* (7) if necessary.                                     @>  

@ End of code for setting |ddraw_color_vector_ptr|, 
if necessary.
\initials{LDF 2004.08.30.}

@<Define |Scan_Parse| functions@>=

 } /* |if (   ddraw_color_vector_ptr == 0 
              && (   basic_drawing_command == DRAW
                  || basic_drawing_command == FILLDRAW
                  || basic_drawing_command == UNFILLDRAW))|  */




@q ****** (6) |ffill_color_vector_ptr|.@>
@ |ffill_color_vector_ptr|.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.

\initials{LDF 2004.08.30.}
@:BUG FIX@> BUG FIX: 
Now trying to set |ffill_color_vector_ptr| to 
|default_color_vector| when 
|basic_drawing_command == FILL| and 
to |background_color_vector| when 
|basic_drawing_command == FILLDRAW|.
Previously, I tried to set it to 
|background_color_vector| in both cases.
\ENDLOG

@q ******* (7) |basic_drawing_command == FILL|.@>  
@ |basic_drawing_command == FILL|.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  if (   ffill_color_vector_ptr == static_cast<void*>(0) 
      && basic_drawing_command == FILL)

   {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                 << endl
                 << "`ffill_color_vector_ptr' == 0. "
                 << "Will look up `default_color_vector'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   entry = scanner_node->lookup("default_color_vector");

@q ******** (8) |lookup| failed.@> 
@ |lookup| failed.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                << endl
                << "Didn't find `default_color_vector'."
                << endl << "Creating a new `Pointer_Vector<Color>' "
                << "and putting `Colors::black' on it."
                << endl << "It will have to be deleted later.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

      delete_ffill_color_vector_ptr = true;

      ffill_color_vector_ptr = new Pvc;
      
      ffill_color_vector_ptr->v.push_back(const_cast<Color*>(&Colors::black));
      

    } /* |if (entry == 0)|  */


@q ******** (8) |lookup| succeeded.@> 
@ |lookup| succeeded.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else /* |entry != 0|  */
    {


      cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                << endl
                << "Found `default_color_vector'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
      ffill_color_vector_ptr = static_cast<Pvc*>(entry->object);
      
    }   /* |else| (|entry != 0|)  */


@q ******** (8) End of code for setting |ffill_color_vector_ptr|, @>  
@q ******** (8) if |basic_drawing_command == FILL|.               @>  

@ End of code for setting |ffill_color_vector_ptr|, 
if |basic_drawing_command == FILL|.
\initials{LDF 2004.08.30.}

@<Define |Scan_Parse| functions@>=

 }  /* |if (   ffill_color_vector_ptr == 0 
            && basic_drawing_command == FILL)|  */


@q ******* (7) |basic_drawing_command == FILLDRAW|.@>  
@ |basic_drawing_command == FILLDRAW|.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  if (   ffill_color_vector_ptr == static_cast<void*>(0)
      && basic_drawing_command == FILLDRAW)

   {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                 << endl
                 << "`ffill_color_vector_ptr' == 0. "
                 << "Will look up `background_color_vector'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   entry = scanner_node->lookup("background_color_vector");

@q ******** (8) |lookup| failed.@> 
@ |lookup| failed.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                << endl
                << "Didn't find `background_color_vector'."
                << endl << "Creating a new `Pointer_Vector<Color>' "
                << "and putting `Colors::white' on it."
                << endl << "It will have to be deleted later.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

      delete_ffill_color_vector_ptr = true;

      ffill_color_vector_ptr = new Pvc;
      
      ffill_color_vector_ptr->v.push_back(const_cast<Color*>(&Colors::white));
      

    } /* |if (entry == 0)|  */


@q ******** (8) |lookup| succeeded.@> 
@ |lookup| succeeded.
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else /* |entry != 0|  */
    {


      cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                << endl
                << "Found `background_color_vector'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
      ffill_color_vector_ptr = static_cast<Pvc*>(entry->object);
      
    }   /* |else| (|entry != 0|)  */


@q ******** (8) End of code for setting |ffill_color_vector_ptr|, @>  
@q ******** (8) if |basic_drawing_command == FILLDRAW|.               @>  

@ End of code for setting |ffill_color_vector_ptr|, 
if |basic_drawing_command == FILLDRAW|.
\initials{LDF 2004.08.30.}

@<Define |Scan_Parse| functions@>=

 }  /* |if (   ffill_color_vector_ptr == 0 
            && basic_drawing_command == FILLDRAW)|  */

@q ***** (5) Check |scanner_node->pen_ptr|.  @>
@ Check |scanner_node->pen_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->pen_ptr == 0|.@> 

|scanner_node->pen_ptr == 0|.
\initials{LDF 2004.11.12.}

\LOG
\initials{LDF 2004.11.12.}
Now setting |ppen = *(scanner_node->current_pen)|, if 
|scanner_node->pen_ptr == 0 && *(scanner_node->current_pen) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=
  if (scanner_node->pen_ptr == static_cast<void*>(0))
    {
#if DEBUG_COMPILE
      if (DEBUG) 
        {
          cerr_strm << thread_name
                    << "In `Scan_Parse::drawing_command_solid()':"
                    << endl
                    << "scanner_node->pen_ptr == 0.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@;  
    

     if (*(scanner_node->current_pen) != static_cast<Pen*>(0))
        {
            ppen = *(scanner_node->current_pen);

        }  /* |if (*(scanner_node->current_pen) != 0)|  */


    } /* |if (scanner_node->pen_ptr == 0)|  */

@q ****** (6) |scanner_node->pen_ptr != 0|.@> 

@ |scanner_node->pen_ptr != 0|.
\initials{LDF 2004.11.12.}

@<Define |Scan_Parse| functions@>=

   else /* (|scanner_node->pen_ptr != 0|)  */
     {

#if DEBUG_COMPILE
        if (DEBUG) 
          {   
              cerr_strm << thread_name 
                        << "In `Scan_Parse::drawing_command_solid()':"
                        << endl
                        <<  "scanner_node->pen_ptr != 0.";

              log_message(cerr_strm); 
              cerr_message(cerr_strm);
              cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@;  

        ppen = static_cast<Pen*>(scanner_node->pen_ptr); 

   } /* |else| (|scanner_node->pen_ptr != 0|)  */


@q ***** (5) Check |scanner_node->dash_pattern_ptr|.  @>
@ Check |scanner_node->dash_pattern_ptr|.
\initials{LDF 2004.06.02.}


\LOG
\initials{LDF 2004.11.13.}
Now setting |ddash_pattern = *(scanner_node->current_dash_pattern)|, if 
|scanner_node->dash_pattern_ptr == 0 && *(scanner_node->current_dash_pattern) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=
if (scanner_node->dash_pattern_ptr == static_cast<void*>(0))
  {
#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                  << endl
                  << "scanner_node->dash_pattern_ptr == 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm);
        cerr_strm.str("");

      }
#endif /* |DEBUG_COMPILE|  */@;  
    
       if (*(scanner_node->current_dash_pattern) != static_cast<Dash_Pattern*>(0))
         {
             ddash_pattern = *(scanner_node->current_dash_pattern);

         }  /* |if (*(scanner_node->current_dash_pattern) != 0)|  */



  } /* |if (scanner_node->dash_pattern_ptr == 0)|  */


else /* (|scanner_node->dash_pattern_ptr != 0|)  */
  {
#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                  << endl
                  << "scanner_node->dash_pattern_ptr != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm);
        cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ddash_pattern = static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr); 

  } /* |else| (|scanner_node->dash_pattern_ptr != 0|)  */


@q **** (4) Check which drawing command to use.@>
@ Check which drawing command to use
\initials{LDF 2004.06.02.}

@q ***** (5) DRAW.@>
\.{DRAW}.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.09.05.}
Now passing |scanner_node| as an argument to |Solid::draw|.
\ENDLOG 


@<Define |Scan_Parse| functions@>= 

  if (basic_drawing_command == DRAW)
    {

#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                 << endl
                 << "It's DRAW.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   ssolid->draw(*ppicture,
                ddraw_color_vector_ptr->v,
                ddash_pattern,
                ppen,
                scanner_node);

 } /* |if (basic_drawing_command == DRAW)|  */


@q ***** (5) FILL@>
@ \.{FILL}.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILL)
    {
#if DEBUG_COMPILE
      if (DEBUG) 
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::drawing_command_solid()':"
                    << endl
                    << "It's FILL.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      ssolid->fill(*ppicture, ffill_color_vector_ptr->v);

    } /* |else if (basic_drawing_command == FILL)|  */

@q ***** (5) FILLDRAW.@>
@ \.{FILLDRAW}.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILLDRAW)
    {
#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                 << endl
                 << "It's FILLDRAW.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


   ssolid->filldraw(*ppicture,
                    ddraw_color_vector_ptr->v,
                    ffill_color_vector_ptr->v,
                    ddash_pattern,
                    ppen);

 } /* |else if (basic_drawing_command == FILLDRAW)|  */

  
@q ***** (5) UNDRAW.@>
@ \.{UNDRAW}.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

 else if (basic_drawing_command == UNDRAW)
   {
#if DEBUG_COMPILE
     if (DEBUG) 
       {
         cerr_strm << thread_name << "In `Scan_Parse::drawing_command_solid()':"
                   << endl
                   << "It's UNDRAW.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm);
         cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */@; 

     ssolid->undraw(*ppicture, ddash_pattern, ppen);
     
   } /* |else if (basic_drawing_command == UNDRAW)|  */
  
@q ***** (5) UNFILL.@>
@ |UNFILL|.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

   else if (basic_drawing_command == UNFILL)
     {
#if DEBUG_COMPILE
       if (DEBUG) 
         {
           cerr_strm << thread_name
             << "In `Scan_Parse::drawing_command_solid()':"
                     << endl
                     << "It's UNFILL.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

       ssolid->unfill(*ppicture);

     } /* |else if (basic_drawing_command == UNFILL)|  */


@q ***** (5) UNFILLDRAW.@>
@ |UNFILLDRAW|.
\initials{LDF 2004.06.02.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.08.30.}
|Solid::unfilldraw| currently doesn't take a 
|vector<const Color*>| argument for drawing.  
Make it do so!  
|ddraw_color_ptr| has been set if 
|basic_drawing_command == UNFILLDRAW|, so it's available here. 
\ENDTODO 

@<Define |Scan_Parse| functions@>= 

     else if (basic_drawing_command == UNFILLDRAW)
       {
#if DEBUG_COMPILE
         if (DEBUG) 
           {
             cerr_strm << thread_name
                       << "In `Scan_Parse::drawing_command_solid()':"
                       << endl
                       << "It's UNFILLDRAW.";

             log_message(cerr_strm); 
             cerr_message(cerr_strm);
             cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 

         ssolid->unfilldraw(*ppicture,
                            ddash_pattern,
                            ppen);

       } /* |else if (basic_drawing_command == UNFILLDRAW)|  */

@q ***** (5) Error handling for invalid |basic_drawing_command|.@>
@ Error handling for invalid \§basic drawing command>.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

  else /* Invalid |basic_drawing_command|.  */
    {

      cerr_strm << thread_name << "ERROR! In "
                << "`Scan_Parse::drawing_command_solid()':"
                << endl << "Invalid `basic_drawing_command': " 
                << basic_drawing_command
                << endl << "Will clear and delete `ssolid' and reset "
                << "the pointers on `scanner_node', and exit function "
                << "with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      ssolid->clear();
      delete ssolid;

      @<Reset pointers on |scanner_node|@>@;

      return 1;
      
    }  /* |else| (invalid |basic_drawing_command|).  */


@q ***** (5) Delete |ddraw_color_vector_ptr| and/or @>   
@q ***** (5) |ffill_color_vector_ptr|, if necessary.@>   

@ Delete |ddraw_color_vector_ptr| and/or       
|ffill_color_vector_ptr|, if necessary.   
\initials{LDF 2004.08.30.}

\LOG
\initials{LDF 2004.08.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   if (delete_ddraw_color_vector_ptr)
      {
        ddraw_color_vector_ptr->v.clear();
        delete ddraw_color_vector_ptr;
        ddraw_color_vector_ptr = 0;
      }

   if (delete_ffill_color_vector_ptr)
      {
        ffill_color_vector_ptr->v.clear();
        delete ffill_color_vector_ptr;
        ffill_color_vector_ptr = 0;
      }
     


@q **** (4) Exit function successfully.@> 
@ Exit function successfully.
\initials{LDF 2004.08.17.}

@<Define |Scan_Parse| functions@>= 
  
  ssolid->clear();
  delete ssolid;

  @<Reset pointers on |scanner_node|@>@;

  return 0;

} /* End of |Scan_Parse::drawing_command_solid| definition.  */

@q ** (2) |drawing_command_sphere_development|.@>
@*1 {\bf drawing\_command\_sphere\_development}.
\initials{LDF 2004.08.17.}

\LOG
\initials{LDF 2009.11.16.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
int
drawing_command_sphere_development(Scanner_Node scanner_node,
                                   int basic_drawing_command,
                                   Sphere_Development*  sd);


@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=

int
Scan_Parse::drawing_command_sphere_development(Scanner_Node scanner_node,
                                               int basic_drawing_command,
                                               Sphere_Development* sd)

{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::drawing_command_sphere_development()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ******* (7) Error handling for the case that |sd == 0|.@>
@ Error handling for the case that |sd == 0|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

    if (sd == static_cast<Sphere_Development*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_sphere_development()':"
                  << endl << "`sd' == 0.  "
                  << "Not executing drawing command."
                  << endl 
                  << "Resetting the pointers on `scanner_node', and exiting function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        @<Reset pointers on |scanner_node|@>@;
        
        return 1;

      } /* |if (sd == 0)|  */@;

@q **** (4) @>   
@

@<Define |Scan_Parse| functions@>=
  
  int status;
 
  Id_Map_Entry_Node entry = 0;

  Picture* ppicture                         = 0;
  Pen* ppen                                 = 0;
  Pointer_Vector<Pen>* ppen_vector          = 0;

  Dash_Pattern* ddash_pattern                        = 0;
  Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0;

  Color* ccolor                             = 0;
  Color* ddraw_color                        = 0;
  Color* ffill_color                        = 0;   

  Pointer_Vector<Color>* ccolor_vector      = 0;
  Pointer_Vector<Color>* ddraw_color_vector = 0;
  Pointer_Vector<Color>* ffill_color_vector = 0;

@q **** (4) Check the pointers on |scanner_node|.@>

@ Check the pointers on |scanner_node|.  One or more may have been set in the
rules for the \§with clause list>.
\initials{LDF 2009.11.16.}

@q ***** (5) Check |scanner_node->picture_entry_ptr|.   @>

Check |scanner_node->picture_entry_ptr|.
\initials{LDF 2009.11.16.}

@q ****** (6) |scanner_node->picture_entry_ptr == 0|.   @>

|scanner_node->picture_entry_ptr == 0|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=
if (scanner_node->picture_entry_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_sphere_development()':"
                  << endl
                  << "`scanner_node->picture_entry_ptr' == 0";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    entry = scanner_node->lookup("current_picture");

@q ******* (7) Error handling for the case that     @>
@q ******* (7) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_sphere_development()':"
                  << endl << "`current_picture' doesn't seem to exist."
                  << endl << "Not executing drawing command. "
                  << endl << "Will delete `sd' and reset "
                  << "the pointers on `scanner_node', and exit function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        delete sd;
        sd = 0;

        @<Reset pointers on |scanner_node|@>@;
        

        return 1;

      } /* |if (entry == 0)|  */@;

@q ******* (7) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2009.11.16.}
@<Define |Scan_Parse| functions@>=

  else
    {
      ppicture = static_cast<Picture*>(entry->object); 
    }

  } /* |if (scanner_node->picture_entry_ptr == 0)|  */@;

@q ****** (6) |scanner_node->picture_entry_ptr != 0|.   @>
@ |scanner_node->picture_entry_ptr != 0|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

else /* |scanner_node->picture_entry_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_sphere_development()':"
                  << endl 
                  << "`scanner_node->picture_entry_ptr' != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ppicture = static_cast<Picture*>(scanner_node->picture_entry_ptr); 

  } /* |else| (|scanner_node->picture_entry_ptr != 0|)  */


  entry = 0;

@q ***** (5) Set |ddraw_color_vector| and |ffill_color|.@> 
@ Set |ddraw_color_vector| and |ffill_color|.

@<Define |Scan_Parse| functions@>=

   ccolor        = static_cast<Color*>(scanner_node->color_ptr); 
   ccolor_vector = static_cast<Pointer_Vector<Color>*>(
                      scanner_node->color_vector_ptr); 


   ddraw_color        = static_cast<Color*>(scanner_node->draw_color_ptr); 
   ddraw_color_vector = static_cast<Pointer_Vector<Color>*>(
                           scanner_node->draw_color_vector_ptr); 

   ffill_color        = static_cast<Color*>(scanner_node->fill_color_ptr); 
   ffill_color_vector = static_cast<Pointer_Vector<Color>*>(
                           scanner_node->fill_color_vector_ptr); 

@q ****** (6) Set |ddraw_color_vector|.@> 

@ Set |ddraw_color_vector|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

   if (ddraw_color_vector != static_cast<Pointer_Vector<Color>*>(0))
      scanner_node->draw_color_vector_ptr = static_cast<void*>(0);

   else  /* |ddraw_color_vector == 0|  */ 
      {
          ddraw_color_vector = new Pointer_Vector<Color>;

         if (ddraw_color != static_cast<Color*>(0))
            {

               ddraw_color_vector->append_copy(ddraw_color); 
            }      


         else if (ccolor != static_cast<Color*>(0))
            {
                ddraw_color_vector->append_copy(ccolor);
            }  


         else if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0) 
                  && ccolor_vector->ctr > 0)
            {
                ddraw_color_vector->append_copy(*ccolor_vector);
            }  


          else 
             {

                 entry = scanner_node->lookup("default_color");

                 if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                     && entry->object != static_cast<void*>(0))
                    ddraw_color_vector->append_copy(
                       static_cast<Color*>(entry->object));

                 else  
                    ddraw_color_vector->append_copy(&Colors::black);
             }


      }  /* |else| (|ddraw_color_vector == 0|)  */ 

@q ****** (6) Set |ffill_color|.@> 

@ Set |ffill_color|.

@<Define |Scan_Parse| functions@>=
 
     if (ffill_color != static_cast<Color*>(0))
        scanner_node->fill_color_ptr = 0;


      else /* |ffill_color == 0|  */
         {

            ffill_color = create_new<Color>(0);

@q ******* (7) @> 

            if (   ffill_color_vector != static_cast<Pointer_Vector<Color>*>(0) 
                && ffill_color_vector->ctr > 0)
               {


                   *ffill_color = *(ffill_color_vector->v[0]);
                   
               }

@q ******* (7) @> 

            else if (ccolor != static_cast<Color*>(0))
               {
                  *ffill_color = *ccolor;
               }

@q ******* (7) @> 


            else if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0) 
                     && ccolor_vector->ctr > 0)
               {

                   *ffill_color = *(ccolor_vector->v[0]);

               }

@q ******* (7) @> 

            else if (basic_drawing_command == FILL) 
               {
                 
                   entry = scanner_node->lookup("default_color");

                   if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                       && entry->object != static_cast<void*>(0))
                      *ffill_color = *(static_cast<Color*>(entry->object));
                   else                     
                      *ffill_color = Colors::black;

               }

@q ******* (7) @> 

      else if (basic_drawing_command == FILLDRAW) 
         {
                 
              entry = scanner_node->lookup("background_color");

              if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                  && entry->object != static_cast<void*>(0))
                 *ffill_color = *(static_cast<Color*>(entry->object));
              else                     
                 *ffill_color = Colors::white;

         }

@q ******* (7) @> 

      }  /* |else| (|ffill_color == 0|)  */

@q ***** (5) Check |scanner_node->pen_vector_ptr|.  @>
@ Check |scanner_node->pen_vector_ptr|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

  if (scanner_node->pen_vector_ptr != static_cast<void*>(0))
     ppen_vector = static_cast<Pointer_Vector<Pen>*>(scanner_node->pen_vector_ptr); 

@q ****** (6).@> 

  else /* |scanner_node->pen_vector_ptr == 0|  */
     {

@q ******* (7) Check |scanner_node->pen_ptr|.  @>
@ Check |scanner_node->pen_ptr|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

         if (scanner_node->pen_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 

                if (*(scanner_node->current_pen) != static_cast<Pen*>(0))
                   {
                       ppen = *(scanner_node->current_pen);

                   }  /* |if (*(scanner_node->current_pen) != 0)|  */

@q ******** (8) @> 

            } /* |if (scanner_node->pen_ptr == 0)|  */


@q ******* (7) @> 

         else /* (|scanner_node->pen_ptr != 0|)  */
            {

                 ppen = static_cast<Pen*>(scanner_node->pen_ptr); 

            }  /* |else| (|scanner_node->pen_ptr != 0|)  */

@q ******* (7) @> 

         if (ppen != static_cast<Pen*>(0))
            {
                ppen_vector = new Pointer_Vector<Pen>;
                *ppen_vector += ppen;
            }


@q ******* (7) @> 

     }     /* |else| (|scanner_node->pen_vector_ptr == 0|)  */


@q ***** (5) Check |scanner_node->dash_pattern_vector_ptr|.  @>
@ Check |scanner_node->dash_pattern_vector_ptr|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

   if (scanner_node->dash_pattern_vector_ptr != static_cast<void*>(0))
      ddash_pattern_vector 
         = static_cast<Pointer_Vector<Dash_Pattern>*>(
              scanner_node->dash_pattern_vector_ptr);       

@q ****** (6).@> 

  else /* |scanner_node->dash_pattern_vector_ptr == 0|  */
     {

@q ******* (7) @> 

         if (scanner_node->dash_pattern_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 


                if (*(scanner_node->current_dash_pattern) != static_cast<Dash_Pattern*>(0))
                   {
                       ddash_pattern = *(scanner_node->current_dash_pattern);

                   }  /* |if (*(scanner_node->current_dash_pattern) != 0)|  */


@q ******** (8) @> 


             } /* |if (scanner_node->dash_pattern_ptr == 0)|  */

@q ******* (7) @> 

   else /* (|scanner_node->dash_pattern_ptr != 0|)  */
      {

        ddash_pattern = static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr); 

      } /* |else| (|scanner_node->dash_pattern_ptr != 0|)  */

@q ******* (7) @> 

        if (ddash_pattern != static_cast<Dash_Pattern*>(0))
           {
              ddash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
              *ddash_pattern_vector += ddash_pattern; 
           }
@q ******* (7) @> 


     }  /* |else| (|scanner_node->dash_pattern_vector_ptr == 0|)  */

@q **** (4) Check which drawing command to use.@>
@ Check which drawing command to use
\initials{LDF 2009.11.16.}

@q ***** (5) DRAW.@>
\.{DRAW}.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

  if (   basic_drawing_command == DRAW)
    {


#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_sphere_development()':"
                 << endl
                 << "It's " << name_map[basic_drawing_command] << ".";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


       sd->draw(*ppicture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);

       delete ffill_color;
       ffill_color = 0;

       ddraw_color_vector = 0;

    } /* |if (basic_drawing_command == DRAW)|  */


@q ***** (5) FILL@>
@ \.{FILL}.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILL)
    {
#if DEBUG_COMPILE
      if (DEBUG) 
        {
          cerr_strm << thread_name << "In `Scan_Parse::drawing_command_sphere_development()':"
                    << endl
                    << "It's FILL.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0 

/* !! START HERE: LDF 2009.11.16.  */
      
         sd->fill(*ppicture, ffill_color);
#endif 

         delete ddraw_color_vector;
         ddraw_color_vector = 0;

         ffill_color = 0;

    } /* |else if (basic_drawing_command == FILL)|  */

@q ***** (5) FILLDRAW.@>
@ \.{FILLDRAW}.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

  else if (basic_drawing_command == FILLDRAW)
    {
#if DEBUG_COMPILE
   if (DEBUG) 
     {
       cerr_strm << thread_name << "In `Scan_Parse::drawing_command_sphere_development()':"
                 << endl
                 << "It's FILLDRAW.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0

/* !! START HERE: LDF 2009.11.16.  */

   sd->filldraw(*ppicture, ddraw_color_vector, ffill_color,
                   ddash_pattern_vector, ppen_vector);
#endif 


   ddraw_color_vector = 0;
   ffill_color        = 0;


 } /* |else if (basic_drawing_command == FILLDRAW)|  */

  
@q ***** (5) UNDRAW.@>
@ \.{UNDRAW}.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

 else if (basic_drawing_command == UNDRAW)
   {
#if DEBUG_COMPILE
     if (DEBUG) 
       {
         cerr_strm << thread_name << "In `Scan_Parse::drawing_command_sphere_development()':"
                   << endl
                   << "It's UNDRAW.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm);
         cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0 

/* !! START HERE: LDF 2009.11.16.  */

     sd->undraw(*ppicture, ddash_pattern_vector, ppen_vector);

#endif 

     delete ddraw_color_vector;
     ddraw_color_vector = 0;

     delete ffill_color; 
     ffill_color = 0;

     
   } /* |else if (basic_drawing_command == UNDRAW)|  */
  
@q ***** (5) UNFILL.@>
@ |UNFILL|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

   else if (basic_drawing_command == UNFILL)
     {
#if DEBUG_COMPILE
       if (DEBUG) 
         {
           cerr_strm << thread_name << "In `Scan_Parse::drawing_command_sphere_development()':"
                     << endl
                     << "It's UNFILL.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm);
           cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0 
/* !! START HERE: LDF 2009.11.16.  */

       sd->unfill(*ppicture);

#endif 

       delete ddraw_color_vector;
       ddraw_color_vector = 0;

       delete ffill_color; 
       ffill_color = 0;


     } /* |else if (basic_drawing_command == UNFILL)|  */


@q ***** (5) UNFILLDRAW.@>
@ |UNFILLDRAW|.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

     else if (basic_drawing_command == UNFILLDRAW)
       {
#if DEBUG_COMPILE
         if (DEBUG) 
           {
             cerr_strm << thread_name 
                       << "In `Scan_Parse::drawing_command_sphere_development()':"
                       << endl
                       << "It's UNFILLDRAW.";

             log_message(cerr_strm); 
             cerr_message(cerr_strm);
             cerr_strm.str("");
           }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0 

/* !! START HERE: LDF 2009.11.16.  */

         sd->unfilldraw(*ppicture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);

#endif 

 
         delete ffill_color; 
         ffill_color = 0;

       } /* |else if (basic_drawing_command == UNFILLDRAW)|  */

@q ***** (5) Error handling for invalid |basic_drawing_command|.@>
@ Error handling for invalid \§basic drawing command>.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 

  else /* Invalid |basic_drawing_command|.  */
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::drawing_command_sphere_development()':"
                << endl << "Invalid `basic_drawing_command': " 
                << basic_drawing_command
                << endl << "Will delete `sd' and reset "
                << "the pointers on `scanner_node', and exit function "
                << "with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete sd;
      sd = 0;

      delete ddraw_color_vector;
      ddraw_color_vector = 0;

      delete ffill_color; 
      ffill_color = 0;

      @<Reset pointers on |scanner_node|@>@;

      return 1;
      
    }  /* |else| (invalid |basic_drawing_command|).  */

@q **** (4) Exit function successfully with return value 0.@> 
@ Exit function successfully with return value 0.
\initials{LDF 2009.11.16.}

@<Define |Scan_Parse| functions@>= 
  
#if 0 

/* !! START HERE: LDF 2009.11.16.  */

  delete sd;
  sd = 0;

#endif 

  @<Reset pointers on |scanner_node|@>@;


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::drawing_command_sphere_development()' "
                << "successfully with return value 0.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;

} /* End of |Scan_Parse::drawing_command_sphere_development| definition.  */



@q ** (2) |drawing_command_path_vector|.@>
@*1 {\bf drawing\_command\_path\_vector}.
\initials{LDF 2005.03.10.}

\LOG
\initials{LDF 2005.03.10.}
Added this function.

\initials{LDF 2005.03.15.}
Removed |bool delete_ffill_color_vector_ptr| and 
|bool delete_ddraw_color_vector_ptr|.
Now always deleting |ddraw_color_vector_ptr| and |ffill_color_vector_ptr| 
and setting them to 0 at the end of this function.

\initials{LDF 2005.03.15.}
Rewrote this function.

\initials{LDF 2005.03.18.}
Added |Pointer_Vector<Pen>* ppen_vector| 
and |Pointer_Vector<Dash_Pattern>* ddash_pattern_vector|.
\ENDLOG

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
int
drawing_command_path_vector(Scanner_Node scanner_node,
                            int basic_drawing_command,
                            Pointer_Vector<Path>* pv);


@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::drawing_command_path_vector(Scanner_Node scanner_node,
                                        int basic_drawing_command,
                                        Pointer_Vector<Path>* pv)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::drawing_command_path_vector()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=
  
  int status;
 
  Id_Map_Entry_Node entry = 0;

  Picture* ppicture                         = 0;
  Pen* ppen                                 = 0;
  Pointer_Vector<Pen>* ppen_vector                          = 0;

  Dash_Pattern* ddash_pattern                               = 0;
  Pointer_Vector<Dash_Pattern>* ddash_pattern_vector        = 0;

  Color* ccolor                             = 0;

  Pointer_Vector<Color>* ccolor_vector      = 0;
  Pointer_Vector<Color>* ddraw_color_vector = 0;
  Pointer_Vector<Color>* ffill_color_vector = 0;

@q **** (4) Check the pointers on |scanner_node|.@>

@ Check the pointers on |scanner_node|.  One or more may have been set in the
rules for the \§with clause list>.
\initials{LDF 2004.06.02.}

@q ***** (5) Check |scanner_node->picture_entry_ptr|.   @>
@ Check |scanner_node->picture_entry_ptr|.
\initials{LDF 2004.06.02.}

@q ****** (6) |scanner_node->picture_entry_ptr == 0|.   @>
@ |scanner_node->picture_entry_ptr == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->picture_entry_ptr == static_cast<void*>(0))
     {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_path_vector()':"
                  << endl
                  << "`scanner_node->picture_entry_ptr' == 0";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    entry = scanner_node->lookup("current_picture");

@q ******* (7) Error handling for the case that     @>
@q ******* (7) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! `Scan_Parse::drawing_command_path_vector()':"
                  << endl << "`current_picture' doesn't seem to exist."
                  << endl << "Not executing drawing command. "
                  << endl << "Will clear and delete `pv' and reset "
                  << "the pointers on `scanner_node', and exit function "
                  << "with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 

        pv->clear();
        delete pv;
        pv = 0;

        @<Reset pointers on |scanner_node|@>@;
        

        return 1;



      } /* |if (entry == 0)|  */@;

@q ******* (7) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2004.06.03.}
@<Define |Scan_Parse| functions@>=

  else
    {
      ppicture = static_cast<Picture*>(entry->object); 
    }

  } /* |if (scanner_node->picture_entry_ptr == 0)|  */@;

@q ****** (6) |scanner_node->picture_entry_ptr != 0|.   @>
@ |scanner_node->picture_entry_ptr != 0|.
\initials{LDF 2004.06.03.}

@<Define |Scan_Parse| functions@>=

else /* |scanner_node->picture_entry_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::drawing_command_path_vector()':"
                  << endl 
                  << "`scanner_node->picture_entry_ptr' != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ppicture = static_cast<Picture*>(scanner_node->picture_entry_ptr); 

  } /* |else| (|scanner_node->picture_entry_ptr != 0|)  */


  entry = 0;


@q ***** (5) Check |scanner_node->color_vector_ptr|.  @>
@ Check |scanner_node->color_vector_ptr|.
\initials{LDF 2005.03.15.}

@q ****** (6) |scanner_node->color_vector_ptr != 0|.  @>
@ |scanner_node->color_vector_ptr != 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->color_vector_ptr != static_cast<void*>(0))
      {
          ccolor_vector 
             = static_cast<Pointer_Vector<Color>*>(scanner_node->color_vector_ptr);  

      }  /* |if (scanner_node->color_vector_ptr != 0)|  */


@q ****** (6) |scanner_node->color_vector_ptr == 0|.  @>
@ |scanner_node->color_vector_ptr == 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   else /* |scanner_node->color_vector_ptr == 0|  */
      {

@q ******* (7) @> 

         if (   scanner_node->color_ptr != static_cast<void*>(0) 
             || *(scanner_node->current_color) != static_cast<Color*>(0))
            {

@q ******** (8) @> 

                try 
                   {
                       ccolor_vector = new Pointer_Vector<Color>;
                   }

@q ******** (8) @> 

                 catch (bad_alloc)
                    {
                        cerr_strm << thread_name 
                                  << "ERROR!  In `Scan_Parse::drawing_command_path_vector()':"
                                  << endl << "`new Pointer_Vector<Color>' failed, "
                                  << "throwing `bad_alloc'."
                                  << endl 
                                  << endl << "Clearing and deleting `pv', resetting "
                                  << "the pointers on `scanner_node', and rethrowing "
                                  << "`bad_alloc'.";

                          log_message(cerr_strm); 
                          cerr_message(cerr_strm, error_stop_value); 
                          cerr_strm.str(""); 

                          pv->clear();
                          delete pv;
                          pv = 0;
 
                          @<Reset pointers on |scanner_node|@>@;
        
                          throw;
      
                      }  /* |catch (bad_alloc)| */

@q ******** (8) @> 

            }  /* |if (   scanner_node->color_ptr != 0 
                       || *(scanner_node->current_color) != 0)|  */

@q ******* (7) @> 


          if (scanner_node->color_ptr != static_cast<void*>(0))
             {

                 ccolor_vector->append_copy(static_cast<Color*>(scanner_node->color_ptr));  
                   
             }  /* |if (scanner_node->color_ptr != 0)|  */


@q ******* (7) @> 
            
          else if (*(scanner_node->current_color) != static_cast<Color*>(0))
             {
                 ccolor_vector->append_copy(*scanner_node->current_color);  

             } /* |else if (*(scanner_node->current_color) != 0)|  */

@q ******* (7) @> 

      }   /* |else| (|scanner_node->color_vector_ptr == 0|)  */


@q ***** (5) Check |scanner_node->draw_color_vector_ptr|.  @>
@ Check |scanner_node->draw_color_vector_ptr|.
\initials{LDF 2005.03.15.}

@q ****** (6) |scanner_node->draw_color_vector_ptr != 0|.  @>
@ |scanner_node->draw_color_vector_ptr != 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->draw_color_vector_ptr != static_cast<void*>(0))
      {
          ddraw_color_vector 
             = static_cast<Pointer_Vector<Color>*>(scanner_node->draw_color_vector_ptr);  

      }  /* |if (scanner_node->draw_color_vector_ptr != 0)|  */


@q ****** (6) |scanner_node->draw_color_vector_ptr == 0|.  @>
@ |scanner_node->draw_color_vector_ptr == 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   else /* |scanner_node->draw_color_vector_ptr == 0|  */
      {

@q ******* (7) @> 

            try 
               {
                   ddraw_color_vector = new Pointer_Vector<Color>;
               }

@q ******* (7) @> 

             catch (bad_alloc)
                {
                    cerr_strm << thread_name 
                              << "ERROR!  In `Scan_Parse::drawing_command_path_vector()':"
                              << endl << "`new Pointer_Vector<Color>' failed, "
                              << "throwing `bad_alloc'."
                              << endl 
                              << endl << "Clearing and deleting `pv', resetting "
                              << "the pointers on `scanner_node', and rethrowing "
                              << "`bad_alloc'.";

                      log_message(cerr_strm); 
                      cerr_message(cerr_strm, error_stop_value); 
                      cerr_strm.str(""); 

                      pv->clear();
                      delete pv;
                      pv = 0;

                      @<Reset pointers on |scanner_node|@>@;
    
                      throw;
  
                  }  /* |catch (bad_alloc)|  */

@q ******* (7) @> 

          if (scanner_node->draw_color_ptr != static_cast<void*>(0))
             {

                 ddraw_color_vector->append_copy(
                    static_cast<Color*>(scanner_node->draw_color_ptr));  
                   
             }  /* |if (scanner_node->draw_color_ptr != 0)|  */


@q ******* (7) @> 
            
          else if (*(scanner_node->current_draw_color) != 0)
             {
                 ddraw_color_vector->append_copy(*scanner_node->current_draw_color);  

             } /* |else if (*(scanner_node->current_draw_color) != 0)|  */

@q ******* (7) @> 

      }   /* |else| (|scanner_node->draw_color_vector_ptr == 0|)  */


@q ***** (5) Check |scanner_node->fill_color_vector_ptr|.  @>
@ Check |scanner_node->fill_color_vector_ptr|.
\initials{LDF 2005.03.15.}

@q ****** (6) |scanner_node->fill_color_vector_ptr != 0|.  @>
@ |scanner_node->fill_color_vector_ptr != 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   if (scanner_node->fill_color_vector_ptr != static_cast<void*>(0))
      {
          ffill_color_vector 
             = static_cast<Pointer_Vector<Color>*>(scanner_node->fill_color_vector_ptr);  

      }  /* |if (scanner_node->fill_color_vector_ptr != 0)|  */


@q ****** (6) |scanner_node->fill_color_vector_ptr == 0|.  @>
@ |scanner_node->fill_color_vector_ptr == 0|.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>=

   else /* |scanner_node->fill_color_vector_ptr == 0|  */
      {

@q ******* (7) @> 

            try 
               {
                   ffill_color_vector = new Pointer_Vector<Color>;
               }

@q ******* (7) @> 

             catch (bad_alloc)
                {
                    cerr_strm << thread_name 
                              << "ERROR!  In `Scan_Parse::drawing_command_path_vector()':"
                              << endl << "`new Pointer_Vector<Color>' failed, "
                              << "throwing `bad_alloc'."
                              << endl 
                              << endl << "Clearing and deleting `pv', resetting "
                              << "the pointers on `scanner_node', and rethrowing "
                              << "`bad_alloc'.";

                      log_message(cerr_strm); 
                      cerr_message(cerr_strm, error_stop_value); 
                      cerr_strm.str(""); 

                      pv->clear();
                      delete pv;
                      pv = 0;

                      @<Reset pointers on |scanner_node|@>@;
    
                      throw;
  
                  }  /* |catch (bad_alloc)|  */

@q ******* (7) @> 

          if (scanner_node->fill_color_ptr != static_cast<void*>(0))
             {

                 ffill_color_vector->append_copy(
                    static_cast<Color*>(scanner_node->fill_color_ptr));  
                   
             }  /* |if (scanner_node->fill_color_ptr != 0)|  */


@q ******* (7) @> 
            
          else if (*(scanner_node->current_fill_color) != 0)
             {
                 ffill_color_vector->append_copy(*scanner_node->current_fill_color);  

             } /* |else if (*(scanner_node->current_fill_color) != 0)|  */

@q ******* (7) @> 

      }   /* |else| (|scanner_node->fill_color_vector_ptr == 0|)  */


@q ***** (5).@>
@
@<Define |Scan_Parse| functions@>=

   if (scanner_node->color_ptr != static_cast<void*>(0))
      ccolor = static_cast<Color*>(scanner_node->color_ptr); 


@q ****** (6).@> 

   if (ddraw_color_vector->ctr == 0)
      {
          if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0) 
              && ccolor_vector->ctr > 0)
             {
                 delete ddraw_color_vector;
                 ddraw_color_vector = ccolor_vector;
             }
          else if (ccolor != static_cast<Color*>(0))
             {
                 ddraw_color_vector->append_copy(ccolor);
             }   

          else
             {
                 entry = scanner_node->lookup("default_color");

                 if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                     && entry->object != static_cast<void*>(0))
                    ddraw_color_vector->append_copy(static_cast<Color*>(entry->object));

                 else
                    ddraw_color_vector->append_copy(&Colors::black);

             }

      }  /* |if (ddraw_color_vector->ctr == 0)|  */

@q ****** (6).@> 

   if (ffill_color_vector->ctr == 0)
      {
          if (   ccolor_vector != static_cast<Pointer_Vector<Color>*>(0) 
              && ccolor_vector->ctr > 0)
             {
                 *ffill_color_vector = *ccolor_vector;
             }
          else if (ccolor != static_cast<Color*>(0))
             {
                 ffill_color_vector->append_copy(ccolor);
             }   

          else if (basic_drawing_command == FILLDRAW)
             {
                 entry = scanner_node->lookup("background_color");

                 if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                     && entry->object != static_cast<void*>(0))
                    ffill_color_vector->append_copy(static_cast<Color*>(entry->object));

                 else
                    ffill_color_vector->append_copy(&Colors::white);

             }

          else 
             {
                 entry = scanner_node->lookup("default_color");

                 if (   entry != static_cast<Id_Map_Entry_Node>(0) 
                     && entry->object != static_cast<void*>(0))
                    ffill_color_vector->append_copy(static_cast<Color*>(entry->object));

                 else
                    ffill_color_vector->append_copy(&Colors::black);

             }



      }  /* |if (ffill_color_vector->ctr == 0)|  */


@q ***** (5) Check |scanner_node->pen_vector_ptr|.  @>
@ Check |scanner_node->pen_vector_ptr|.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG


@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

  if (scanner_node->pen_vector_ptr != static_cast<void*>(0))
     ppen_vector = static_cast<Pointer_Vector<Pen>*>(scanner_node->pen_vector_ptr); 

@q ****** (6).@> 

  else /* |scanner_node->pen_vector_ptr == 0|  */
     {

@q ******* (7) Check |scanner_node->pen_ptr|.  @>
@ Check |scanner_node->pen_ptr|.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.11.12.}
Now setting |ppen = *(scanner_node->current_pen)|, if 
|scanner_node->pen_ptr == 0 && *(scanner_node->current_pen) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=

         if (scanner_node->pen_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 

                if (*(scanner_node->current_pen) != static_cast<Pen*>(0))
                   {
                       ppen = *(scanner_node->current_pen);

                   }  /* |if (*(scanner_node->current_pen) != 0)|  */

@q ******** (8) @> 

            } /* |if (scanner_node->pen_ptr == 0)|  */


@q ******* (7) @> 

         else /* (|scanner_node->pen_ptr != 0|)  */
            {

                 ppen = static_cast<Pen*>(scanner_node->pen_ptr); 

            }  /* |else| (|scanner_node->pen_ptr != 0|)  */

@q ******* (7) @> 

         if (ppen != static_cast<Pen*>(0))
            {
                ppen_vector = new Pointer_Vector<Pen>;
                *ppen_vector += ppen;
            }


@q ******* (7) @> 

     }     /* |else| (|scanner_node->pen_vector_ptr == 0|)  */


@q ***** (5) Check |scanner_node->dash_pattern_ptr|.  @>
@ Check |scanner_node->dash_pattern_ptr|.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

@q ****** (6).@> 

   if (scanner_node->dash_pattern_vector_ptr != static_cast<void*>(0))
      ddash_pattern_vector 
         = static_cast<Pointer_Vector<Dash_Pattern>*>(
              scanner_node->dash_pattern_vector_ptr);       

@q ****** (6).@> 

  else /* |scanner_node->dash_pattern_vector_ptr == 0|  */
     {

@q ******* (7) @> 

         if (scanner_node->dash_pattern_ptr == static_cast<void*>(0))
            {

@q ******** (8) @> 


                if (*(scanner_node->current_dash_pattern) != static_cast<Dash_Pattern*>(0))
                   {
                       ddash_pattern = *(scanner_node->current_dash_pattern);

                   }  /* |if (*(scanner_node->current_dash_pattern) != 0)|  */


@q ******** (8) @> 


             } /* |if (scanner_node->dash_pattern_ptr == 0)|  */

@q ******* (7) @> 

   else /* (|scanner_node->dash_pattern_ptr != 0|)  */
      {

        ddash_pattern = static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr); 

      } /* |else| (|scanner_node->dash_pattern_ptr != 0|)  */

@q ******* (7) @> 

        if (ddash_pattern != static_cast<Dash_Pattern*>(0))
           {
              ddash_pattern_vector = new Pointer_Vector<Dash_Pattern>;
              *ddash_pattern_vector += ddash_pattern; 
           }
@q ******* (7) @> 


     }  /* |else| (|scanner_node->dash_pattern_vector_ptr == 0|)  */


@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>= 

        vector<Color*>::const_iterator draw_color_iter;
        vector<Color*>::const_iterator fill_color_iter;

        Pointer_Vector<Color>* temp_draw_color_vector; 


        Color* temp_fill_color;


        vector<Path*>::const_iterator path_iter;


@q **** (4) Check which drawing command to use.@>
@ Check which drawing command to use
\initials{LDF 2004.06.02.}

@q ***** (5) DRAW.@>
\.{DRAW}.
\initials{LDF 2004.06.02.}

\LOG
\initials{LDF 2004.11.08.}
Now checking for |basic_drawing_command == DRAWARROW| and 
|basic_drawing_command == DRAWDBLARROW|.
\ENDLOG 

@<Define |Scan_Parse| functions@>= 

  if (   basic_drawing_command == DRAW
      || basic_drawing_command == DRAWARROW
      || basic_drawing_command == DRAWDBLARROW)
    {


       unsigned short arrow;
  
       if (basic_drawing_command == DRAW)
         arrow = Path::NO_ARROW;

       else if (basic_drawing_command == DRAWARROW)
         arrow = Path::SINGLE_ARROW;

       else if (basic_drawing_command == DRAWDBLARROW)
         arrow = Path::DOUBLE_ARROW;

        draw_color_iter = ddraw_color_vector->v.begin();

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {

               temp_draw_color_vector = new Pointer_Vector<Color> ;

               temp_draw_color_vector->append_copy(*draw_color_iter);


               (**path_iter).draw(*ppicture, temp_draw_color_vector, 
                                  ddash_pattern_vector, ppen_vector, arrow);

               temp_draw_color_vector = 0;

               ++draw_color_iter;

               if (draw_color_iter == ddraw_color_vector->v.end())
                  draw_color_iter = ddraw_color_vector->v.begin();

           }  /* |for|  */

         delete ffill_color_vector;
         ffill_color_vector = 0;

    } /* |if (basic_drawing_command == DRAW)|  */


@q ***** (5) FILL@>
@ \.{FILL}.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILL)
    {

        fill_color_iter = ffill_color_vector->v.begin();

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {


               temp_fill_color = new Color;
            
               *temp_fill_color = **fill_color_iter;
  
               (**path_iter).fill(*ppicture, temp_fill_color);

               temp_fill_color = 0;

               ++fill_color_iter;

               if (fill_color_iter == ffill_color_vector->v.end())
                  fill_color_iter = ffill_color_vector->v.begin();
 
           }  /* |for|  */


         delete ddraw_color_vector;
         ddraw_color_vector = 0;


    } /* |else if (basic_drawing_command == FILL)|  */

@q ***** (5) FILLDRAW.@>
@ \.{FILLDRAW}.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>= 


  else if (basic_drawing_command == FILLDRAW)
    {

        draw_color_iter = ddraw_color_vector->v.begin();
        fill_color_iter = ffill_color_vector->v.begin();

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {

               temp_fill_color = new Color;
            
               *temp_fill_color = **fill_color_iter;

               temp_draw_color_vector = new Pointer_Vector<Color> ;

               temp_draw_color_vector->append_copy(*draw_color_iter);

               (**path_iter).filldraw(*ppicture, temp_draw_color_vector, 
                                      temp_fill_color,
                                      ddash_pattern_vector, ppen_vector);

               temp_draw_color_vector = 0;

               ++draw_color_iter;

               if (draw_color_iter == ddraw_color_vector->v.end())
                  draw_color_iter = ddraw_color_vector->v.begin();

               temp_fill_color = 0;

               ++fill_color_iter;

               if (fill_color_iter == ffill_color_vector->v.end())
                  fill_color_iter = ffill_color_vector->v.begin();

           }  /* |for|  */

    } /* |else if (basic_drawing_command == FILLDRAW)|  */

  
@q ***** (5) UNDRAW.@>
@ \.{UNDRAW}.
\initials{LDF 2005.03.15.}

@<Define |Scan_Parse| functions@>= 

 else if (basic_drawing_command == UNDRAW)
   {

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {

               (**path_iter).undraw(*ppicture, ddash_pattern_vector, ppen_vector);

           }  /* |for|  */



         delete ddraw_color_vector;
         ddraw_color_vector = 0;

         delete ffill_color_vector;
         ffill_color_vector = 0;

   } /* |else if (basic_drawing_command == UNDRAW)|  */
  
@q ***** (5) UNFILL.@>
@ |UNFILL|.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

   else if (basic_drawing_command == UNFILL)
     {

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {


               (**path_iter).unfilldraw(*ppicture);

           }  /* |for|  */


         delete ddraw_color_vector;
         ddraw_color_vector = 0;

         delete ffill_color_vector;
         ffill_color_vector = 0;

     } /* |else if (basic_drawing_command == UNFILL)|  */


@q ***** (5) UNFILLDRAW.@>
@ |UNFILLDRAW|.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

     else if (basic_drawing_command == UNFILLDRAW)
       {

        draw_color_iter = ddraw_color_vector->v.begin();

        path_iter       = pv->v.begin();

        for(; path_iter != pv->v.end(); ++path_iter)
           {

            
               temp_draw_color_vector = new Pointer_Vector<Color> ;

               temp_draw_color_vector->append_copy(*draw_color_iter);


               (**path_iter).unfilldraw(*ppicture, temp_draw_color_vector, 
                                        ddash_pattern_vector, ppen_vector);

               temp_draw_color_vector = 0;

               ++draw_color_iter;

               if (draw_color_iter == ddraw_color_vector->v.end())
                  draw_color_iter = ddraw_color_vector->v.begin();

           }  /* |for|  */


         delete ffill_color_vector;
         ffill_color_vector = 0;

       } /* |else if (basic_drawing_command == UNFILLDRAW)|  */

@q ***** (5) Error handling for invalid |basic_drawing_command|.@>
@ Error handling for invalid \§basic drawing command>.
\initials{LDF 2004.06.02.}

@<Define |Scan_Parse| functions@>= 

  else /* Invalid |basic_drawing_command|.  */
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::drawing_command_path_vector()':"
                << endl << "Invalid `basic_drawing_command': " 
                << basic_drawing_command
                << endl << "Will clear and delete `pv' and reset "
                << "the pointers on `scanner_node', and exit function "
                << "with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      pv->clear();
      delete pv;
      pv = 0;

      @<Reset pointers on |scanner_node|@>@;

      return 1;
      
    }  /* |else| (invalid |basic_drawing_command|).  */

@q **** (4) Exit function successfully with return value 0.@> 
@ Exit function successfully with return value 0.
\initials{LDF 2004.08.17.}

@<Define |Scan_Parse| functions@>= 
  
  pv->clear();
  delete pv;
  pv = 0;

  @<Reset pointers on |scanner_node|@>@;

  return 0;

} /* End of |Scan_Parse::drawing_command_path_vector| definition.  */

@q ** (2) |conditional|.@>
@*1 {\bf conditional}.

\LOG
LDF 2004.09.10.
Added this function.

\initials{LDF 2004.09.10.}
Changed |bool bool_value| argument to |int arg|.
It can have the following values:\hfil\break
\item{0} Condition is |false|.
\smallskip
\item{1} Condition is |true|.
\smallskip
\item{2} Condition is |false| and |else| clause, if present, 
should be discarded.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>= 


int 
Scan_Parse::conditional(Scanner_Node scanner_node,
                        int arg)
{
#if DEBUG_COMPILE
    bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

    stringstream cerr_strm;

    string thread_name = "";

    bool error_stop_value = (scanner_node->run_state.error_stop_mode
                       == Run_State::STOPPING)
      ? true : false;

#ifdef HAVE_PTHREAD_H

    Thread_Info_Type* thread_info;
    if ( scanner_node->run_state.multithread_input
        || scanner_node->run_state.multithread_output
        || scanner_node->run_state.multithread_include)
      {
          thread_info = Thread_Info_Type::get_thread_info();
          thread_name = thread_info->name;
      }
    else
      {
          thread_info = 0;
          thread_name = "";
      } 

#endif /* |HAVE_PTHREAD_H| */@;


@q **** (4) @> 
@ 
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>= 


#if DEBUG_COMPILE
    if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "Entering `Scan_Parse::conditional()'.";
          
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@; 


#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr << "`scanner_node->if_ctr' == " << scanner_node->if_ctr 
               << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

    int save_if_ctr = scanner_node->if_ctr;


@q ***** (5) |arg == 0 || arg == 2|.@> 
@q ***** (5) Eat tokens. @> 

@ |bool_value == 0|.  Eat tokens.  
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=

  if (arg == 0 || arg == 2)
    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::conditional()':"
                    << endl << "Eating tokens.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
        }
#endif /* |DEBUG_COMPILE|  */@; 
 
      YYSTYPE value; 
#if 0 
      YYLTYPE location; 
#endif 

      int curr_catcode;

@q ****** (6) Beginning of |for| loop.@> 

@ Beginning of |for| loop.  
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=

      for(;;)
        {

#if 0 
          curr_catcode = yylex(&value, &location, scanner_node); 
#else
          curr_catcode = yylex(&value, scanner_node); 
#endif 

#if DEBUG_COMPILE
          if (DEBUG)
            {

              cerr_strm << thread_name 
                        << "In `Scan_Parse::conditional()':"
                        << endl 
                        << "`curr_catcode' == " << name_map[curr_catcode]
                        << ".";
                    
              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) |curr_catcode == IF|.@> 

@ |curr_catcode == IF|.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=


  if (curr_catcode == IF)
    {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "In `Scan_Parse::conditional()':"
                 << endl 
                 << "`curr_catcode' == `IF'. " 
                 << "Incrementing `scanner_node->if_ctr'.";
      
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   scanner_node->if_ctr++;

 } /* |if (curr_catcode == IF)|  */



@q ******* (7) |curr_catcode == FI|.@> 

@ |curr_catcode == FI|.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=

          if (curr_catcode == FI)
            {

#if DEBUG_COMPILE
              if (DEBUG)
                {

                  cerr_strm << thread_name 
                            << "In `Scan_Parse::conditional()':"
                            << endl 
                            << "`curr_catcode' == `FI'. "
                            << "Decrementing `scanner_node->if_ctr'.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");

                }
#endif /* |DEBUG_COMPILE|  */@; 

              scanner_node->if_ctr--;

@q ******** (8) |scanner_node->if_ctr < save_if_ctr|.@> 
@q ******** (8) Return 0.@> 

@ |scanner_node->if_ctr < save_if_ctr|.  Return 0.
\initials{LDF 2004.09.10.}

\LOG
\initials{LDF 2005.04.08.}
@:BUG FIX@> BUG FIX:  Changed |<=| to |<|.
\ENDLOG 


@<Define |Scan_Parse| functions@>=

              if (scanner_node->if_ctr < save_if_ctr)
                {

#if DEBUG_COMPILE
                  if (DEBUG)
                    {
 

                      cerr_strm << thread_name 
                                << "In `Scan_Parse::conditional()':"
                                << endl 
                                << "`scanner_node->if_ctr' < `save_if_ctr'."
                                << endl << "Returning 0.";
                      
                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");


                    }
#endif /* |DEBUG_COMPILE|  */@; 
                  
                  return 0;

                 
                } /* |if (if_ctr < save_if_ctr)|  */
   
@q ******** (8) |scanner_node->if_ctr >= save_if_ctr|.@> 
@q ******** (8) Continue.@> 

@ |scanner_node->if_ctr >= save_if_ctr|.  Continue.
\initials{LDF 2004.09.10.}


\LOG
\initials{LDF 2005.04.08.}
@:BUG FIX@> BUG FIX:  Changed |>| to |>=|.
\ENDLOG 
@<Define |Scan_Parse| functions@>=

  else /* |scanner_node->if_ctr >= save_if_ctr|  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
 
          
          cerr_strm << thread_name 
                    << "In `Scan_Parse::conditional()':"
                    << endl 
                    << "`scanner_node->if_ctr' >= `save_if_ctr'."
                    << endl << "Continuing.";
 
          
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");


        }
#endif /* |DEBUG_COMPILE|  */@; 


      continue;
      

    }    /* |else| (|scanner_node->if_ctr >= save_if_ctr|)  */


@q ******** (8) End of |curr_catcode == FI)| case.@> 
@ End of |curr_catcode == FI)| case.
\initials{LDF 2004.09.10.}
@<Define |Scan_Parse| functions@>=

            } /* |if (curr_catcode == FI)|  */
          
@q ******* (7) |curr_catcode == ELSE|.@> 

@ |curr_catcode == ELSE|.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=


          else if (curr_catcode == ELSE && arg == 0)
            {

#if DEBUG_COMPILE
              if (DEBUG)
                {

                  cerr_strm << thread_name 
                            << "In `Scan_Parse::conditional()':"
                            << endl 
                            << "`curr_catcode' == `ELSE'. " 
                            << "Scanning next token.";
                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
                }
#endif /* |DEBUG_COMPILE|  */@; 

#if 0 
              curr_catcode = yylex(&value, &location, scanner_node);
#else
              curr_catcode = yylex(&value, scanner_node); 
#endif 


@q ******** (8) Error handling:  |curr_catcode != COLON|.@> 

@ Error handling:  |curr_catcode != COLON|.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=
 
              if (curr_catcode != COLON)
                {
                  cerr_strm << thread_name 
                            << "ERROR! In `Scan_Parse::conditional()':"
                            << endl << "`else' not followed by `COLON'."
                            << endl << "Returning 1."; 

                  log_message(cerr_strm); 
                  cerr_message(cerr_strm, error_stop_value); 
                  cerr_strm.str(""); 
                  
                  return 1;
                }
             
@q ******** (8) |curr_catcode == COLON|.@> 

@ |curr_catcode == COLON|.
\initials{LDF 2004.09.10.}

\LOG
\initials{LDF 2005.04.08.}
@:BUG FIX@> BUG FIX:  Now continuing if |scanner_node->if_ctr > save_if_ctr|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

              else /* |curr_catcode == COLON|  */
                {

@q ********* (9) @> 

                  if (scanner_node->if_ctr > save_if_ctr)
                     {
                         continue;
                     }


@q ********* (9) @> 

                  else  /* |scanner_node->if_ctr <= save_if_ctr|  */
                     {
#if DEBUG_COMPILE
                        if (DEBUG) 
                          {
                              cerr_strm << thread_name 
                                        << "In `Scan_Parse::conditional()':"
                                        << endl << "`else' is followed by `COLON'. "
                                        << "Returning 0."; 

                              log_message(cerr_strm); 
                              cerr_message(cerr_strm); 
                              cerr_strm.str(""); 

                         }  /* |else if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

                      return 0;

                  }   /* |else| (|scanner_node->if_ctr <= save_if_ctr|)  */
 
@q ********* (9) @> 

             } /* |else| (|curr_catcode == COLON|)  */


@q ******** (8) @> 

            } /* |else if (curr_catcode == ELSE)|  */


@q ******* (7) |curr_catcode == ELSEIF|.@> 

@ |curr_catcode == ELSEIF|.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=



          else if (curr_catcode == ELSEIF && arg == 0)
            {


#if DEBUG_COMPILE
              if (DEBUG) 
                {
                  cerr_strm << thread_name 
                            << "In `Scan_Parse::conditional()':"
                            << endl << "`curr_catcode' == `ELSEIF'."
                            << "Pushing `IF' onto `scanner_node->rescan_stack' "
                            << "and returning 0."; 

                      log_message(cerr_strm); 
                      cerr_message(cerr_strm); 
                      cerr_strm.str(""); 

                    }  /* |else if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

              Int_Void_Ptr_Bool ivp(IF, 0, false);
              scanner_node->rescan_stack.push(ivp);
              return 0;

            } /* |else if (curr_catcode == ELSEIF)|  */

@q ******* (7) |curr_catcode| is some other token.@> 
@ |curr_catcode| is some other token.
@<Define |Scan_Parse| functions@>=

            else
              {
#if DEBUG_COMPILE
                if (DEBUG) 
                  {
                    cerr_strm << thread_name 
                              << "In `Scan_Parse::conditional()':"
                              << endl << "`curr_catcode' == "
                              << name_map[curr_catcode] << ". Continuing."; 
                    
                    log_message(cerr_strm); 
                    cerr_message(cerr_strm); 
                    cerr_strm.str(""); 

                  }  /* |else if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 
                
                continue;


              } /* |else|  */

@q ******* (7) End of |for| loop.@> 

@ End of |for| loop.  
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=

        } /* |for|  */
      
@q ****** (6) End of the |arg == 0 || arg == 2| case.@> 

@ End of the |bool_value == 0| case.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>=

    } /* |if (arg == 0 || arg == 2)|  */


@q ***** (5) |arg == 1|.  Continue parsing.@> 

@ |arg == 1|.  Continue parsing.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>= 

#if DEBUG_COMPILE
   else if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::conditional()':"
                   << endl << "Will continue parsing.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm); 
         cerr_strm.str("");          
       }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Exit function successfully with return value 0.@> 
@ Exit function successfully with return value 0.
\initials{LDF 2004.09.10.}

@<Define |Scan_Parse| functions@>= 

    return 0;

} /* End of |Scan_Parse::conditional| definition.  */



@q ** (2) |input_command|.@>
@*1 {\bf input\_command}.

\LOG
LDF 2004.09.10.
Added this function.

\initials{LDF 2004.09.20.}
Programmed the case that 
|scanner_node->run_state.multithread_include| is |false|, 
i.e., that single-threaded inclusion is being used.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>= 


int 
Scan_Parse::input_command(Scanner_Node scanner_node,
                          string* filename)
{

#if DEBUG_COMPILE
    bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

    stringstream cerr_strm;

    string thread_name = "";

    bool error_stop_value = (scanner_node->run_state.error_stop_mode
                       == Run_State::STOPPING)
      ? true : false;

#ifdef HAVE_PTHREAD_H

    Thread_Info_Type* thread_info;
    if ( scanner_node->run_state.multithread_input
        || scanner_node->run_state.multithread_output
        || scanner_node->run_state.multithread_include)
      {
          thread_info = Thread_Info_Type::get_thread_info();
          thread_name = thread_info->name;
      }
    else
      {
          thread_info = 0;
          thread_name = "";
      } 

#endif /* |HAVE_PTHREAD_H| */@;


@q **** (4) @> 
@ 
\initials{LDF 2004.09.10.}

\LOG
\initials{LDF 2004.09.20.}
Now declaring the automatic variable |int status|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


#if DEBUG_COMPILE
    if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "Entering `Scan_Parse::input_command()'.";
          
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@; 

    int status;


@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

  if (filename == static_cast<string*>(0) || filename->size() == 0)
    {

      cerr_strm << thread_name 
                << "ERROR: In `Scan_Parse::input_command()':"
                << endl << "Invalid `filename'. Exiting function "
                << "with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      return 1;

    } /* |if (filename == 0 || filename->size() == 0)|  */

@q **** (4) Multithreaded include.@>   
@ Multithreaded include.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=

  if (scanner_node->run_state.multithread_include)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                << "In `Scan_Parse::input_command()':"
                << endl << "`scanner_node->multithread_include' == `true'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 


@q ***** (5) Try to create new |Scanner_Node|.@> 

@ Try to create new |Scanner_Node|.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=



  Scanner_Node new_scanner_node = Scanner_Type::create(*filename,
                                                       scanner_node->run_state,
                                                       false);

@q ****** (6) |new_scanner_node == 0|.@> 

@ |new_scanner_node == 0|.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=

  if (new_scanner_node == static_cast<Scanner_Node>(0))
    {
      cerr_strm << thread_name 
                << "ERROR: In `Scan_Parse::input_command()':"
                << endl 
                << "`Scanner_Type::create()' for " << *filename 
                << " failed." << endl 
                << "Not inputting file. Exiting function with "
                << "return value 1.";
          
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      return 1;

    } /* |if (new_scanner_node == 0)|  */


@q ****** (6) |new_scanner_node != 0|@> 

@ |new_scanner_node != 0|.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=

      
  else /* |new_scanner_node != 0|  */

    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::input_command()':"
                    << endl
                    << "`Scanner_Type::create()' for \"" << *filename 
                    << "\" succeeded.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
 
       

    }  /* |else| (|new_scanner_node != 0|)  */



@q ***** (5) Assign to |*new_scanner_node| from |*scanner_node|.@> 

@ Assign to  |new_scanner_node| from |scanner_node|.
Exit upon error.
\initials{LDF 2004.09.15.}


\LOG
\initials{LDF 2004.09.20.}
@:BUG FIX@> BUG FIX:  Now clearing |current_picture| on
|new_scanner_node|, if it exists.  This ensures that |current_picture|
is empty, even if the ``{\bf input}'' command is used within a
figure. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  try
    {
      *new_scanner_node = *scanner_node;
    }
  catch (Bad_Assignment_Type)
    {
      cerr_strm << thread_name 
                << "ERROR: In `Scan_Parse::input_command()':"
                << endl << "`Scanner_Type::operator=()' failed."
                << endl << "Deleting `new_scanner_node' and "
                << "exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");


      delete new_scanner_node;

      new_scanner_node = 0;
      
      return 1;

    } /* |catch (Bad_Assignment_Type)|  */


#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                << "In `Scan_Parse::input_command()':"
                << endl << "`Scanner_Type::operator=()' succeeded.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 


      Id_Map_Entry_Node entry = new_scanner_node->lookup("current_picture");

      if (entry != static_cast<Id_Map_Entry_Node>(0) && entry->object != static_cast<void*>(0))
        static_cast<Picture*>(entry->object)->clear(); 

      scanner_node->thread_vector.push_back(new pthread_t);

      status = pthread_create(scanner_node->thread_vector.back(),
                              0,
                              Scan_Parse::parse_func,
                              static_cast<void*>(new_scanner_node));

      if (status != 0)
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::input_command()':"
                    << endl << "`pthread_create()' failed.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

        } /* |if (status != 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG) /* |status == 0|  */
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::input_command()':"
                    << endl << "`pthread_create()' succeeded.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }  /* |else| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) @>   
@ 
@<Define |Scan_Parse| functions@>=

    } /* |if (scanner_node->run_state.multithread_include)|  */

@q **** (4) Single-threaded include.@>   
@ Single-threaded include.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=

  else /* |!scanner_node->run_state.multithread_include|  */

    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                << "In `Scan_Parse::input_command()':"
                << endl << "`scanner_node->multithread_include' == `false'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Set input filename.@>      
@  Set input filename.
\initials{LDF 2004.09.20.}


\LOG
\initials{LDF 2004.09.20.}
Added code for resolving the filename.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

      ifstream* new_ifstream = new ifstream;

      string save_filename = *filename;


 string::size_type s = filename->find('.');
      if (s == string::npos)
        {
#if DEBUG_COMPILE
          if (DEBUG)
            {

              cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                        << endl
                        << "No period in `" << *filename << "'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif

@q ****** (6)    @>      

@  Try |*filename| $+$ ``\.{.ldf}'' first.   
\initials{LDF 2004.09.20.}

@<Define |Scan_Parse| functions@>=

  *filename += ".ldf";

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                        << endl
                        << "Trying `" << *filename << "'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif
          
          new_ifstream->open(filename->c_str());
          if (*new_ifstream)
            {
#if DEBUG_COMPILE
              if (DEBUG)
                {
                  cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                            << endl << "`"
                            << *filename << "' exists!";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
                }
#endif
            } /* |if (*new_ifstream)|  */

@q ****** (6)     @>      

@ If |*filename| $+$ ``\.{.ldf}'' can't be opened, try  
|*filename| with no extension.
\initials{LDF 2004.09.20.}

@<Define |Scan_Parse| functions@>=

          else  /* |!(*new_ifstream)|  */
            {
#if DEBUG_COMPILE
              if (DEBUG)
                {
                  cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                            << endl << "`"
                            << *filename << "' doesn't exist!";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
                }
#endif
              *filename = save_filename;
              new_ifstream->open(filename->c_str());
              
              if (!(*new_ifstream))
                {
              
                  cerr_strm << "ERROR! In Scan_Parse::input_command():"
                            << endl << "The file `" 
                            << *filename << "' doesn't exist!"
                            << endl << "Deleting `new_ifstream' and "
                            << "exiting function with return value 1.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");
                  
                  delete new_ifstream;
                  new_ifstream = 0;
                  return 1;

                } /* |if (!(*new_ifstream))|  */

            } /* |else | (|!(*new_ifstream)|)  */

        } /* |if (s == string::npos)|  */

@q ****** (6)     @>          

@ There's at least one period in |*filename|, so we use it literally as the
input filename.
\initials{LDF 2004.09.20.}

@<Define |Scan_Parse| functions@>=

      else /* |s != string::npos|  */ 

        {
#if DEBUG_COMPILE
          if (DEBUG) 
            {
              cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                        << endl
                        << "`s' == " << s << ".";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif

          new_ifstream->open(filename->c_str());

          if (*new_ifstream)
            {
#if DEBUG_COMPILE
              if (DEBUG)
                {
                  cerr_strm << thread_name << "In `Scan_Parse::input_command()':"
                            << endl << "`"
                            << *filename << "' exists!";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
                }
#endif

            } /* |if (*new_ifstream)| */

          else /* |!(*new_ifstream)| */
            {
              cerr_strm << "ERROR! In Scan_Parse::input_command():\n"
                        << *filename << " doesn't exist! "
                        << endl 
                        << "Deleting `new_ifstream' and exiting function "
                        << "with return value 1.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              delete new_ifstream;
              new_ifstream = 0;

              return 1;

            }  /* |else| (|!(*new_ifstream)|) */

        }  /* |else| (|s != string::npos|)  */ 
  
      
@q ***** (5) Push |new_input_struct| onto |scanner_node->in|.@> 
@ Push |new_input_struct| onto |scanner_node->in|.
We must push a |SEMI_COLON| onto |scanner_node->rescan_stack|, because
the semi-colon that follows the {\bf input} command isn't read until
after the new file is read.  It doesn't cause a problem when it,
because empty statements are valid.
\initials{LDF 2004.09.20.}

@<Define |Scan_Parse| functions@>=

      Input_Struct* new_input_struct = new Input_Struct;

      new_input_struct->filename = *filename;

      new_input_struct->type = Io_Struct::FILE_TYPE;

      new_input_struct->stream_ptr = static_cast<istream*>(new_ifstream); 

      new_input_struct->up = scanner_node->in;

      scanner_node->in = new_input_struct;
      
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                << "In `Scan_Parse::input_command()':"
                << endl << "`scanner_node->multithread_include' == `false'."
                << endl 
                << "Set `scanner_node->in' to `new_input_struct' successfully.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

      Int_Void_Ptr_Bool ivpb(SEMI_COLON, 0, false);

      scanner_node->rescan_stack.push(ivpb);

    }  /* |else| (|!scanner_node->run_state.multithread_include|)  */


@q **** (4) Exit function successfully with return value 0.@>   

@ Exit function successfully with return value 0.
\initials{LDF 2004.09.15.}

@<Define |Scan_Parse| functions@>=
  

    return 0;

}  /* End of |Scan_Parse::input_command| definition.  */
                           

@q ** |drawdot_command|.@>
@*1 {\bf drawdot\_command}.

\LOG
\initials{LDF 2004.08.17.}
Added this function.  It's used in the parser rule 
\§drawing command> $\longrightarrow$ \§drawdot or undrawdot>
\§point expression> \§with clause draw list>.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
int
drawdot_command(Scanner_Node scanner_node,
                int drawdot_or_undrawdot,
                Point* ppoint);


@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::drawdot_command(Scanner_Node scanner_node,
                            int drawdot_or_undrawdot,
                            Point* ppoint)

{


@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::drawdot_command()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 
  
  int status;
 
  Id_Map_Entry_Node entry = 0;

  Picture* ppicture  = 0;
  Pen* ppen          = 0;
  Color* ccolor      = 0;
  Color* ddraw_color = 0;
  Color* ffill_color = 0;

@q **** (4) Error handling:  |Point* ppoint == 0|.@> 
@ Error handling:  |Point* ppoint == 0|.
\initials{LDF 2005.11.21.}

\LOG
\initials{LDF 2005.11.21.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (ppoint == static_cast<Point*>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR! In `drawdot_command()':"
                    << endl << "`Point* ppoint' == 0."
                    << endl << "Not drawing or undrawing dot. "
                    << "Will delete pointers on `scanner_node' "
                    << "and exit function with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value); 
          cerr_strm.str(""); 

          @<Reset pointers on |scanner_node|@>@;

          return 1;
      }

@q **** (4) Check the pointers on |scanner_node|.@>

@ Check the pointers on |scanner_node|.  One or more may have been set in the
rules for the \§with clause list>.
\initials{LDF 2004.06.21.}

@q ***** (5) Check |scanner_node->picture_entry_ptr|.   @>

Check |scanner_node->picture_entry_ptr|.
\initials{LDF 2004.06.21.}

@q ****** (6) |scanner_node->picture_entry_ptr == 0|.   @>

|scanner_node->picture_entry_ptr == 0|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=
if (scanner_node->picture_entry_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << "scanner_node->picture_entry_ptr == 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

    entry = scanner_node->lookup("current_picture");

@q ******* (7) Error handling for the case that     @>
@q ******* (7) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=  

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {
          cerr_strm << thread_name 
                    << "ERROR! In `drawdot_command()':"
                    << endl << "`current_picture' doesn't seem to exist."
                    << endl << "Not drawing or undrawing dot. "
                    << "Will delete `ppoint' and pointers on `scanner_node' "
                    << "and exit function with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value); 
          cerr_strm.str(""); 

          ppoint->clear();
          delete ppoint;

          @<Reset pointers on |scanner_node|@>@;
          
          return 1;


      } /* |if (entry == 0 || entry->object == 0)|  */@;


@q ******* (7) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2004.06.21.}
@<Define |Scan_Parse| functions@>=  

  else
    {
      ppicture = static_cast<Picture*>(entry->object); 
    }

  } /* |if (scanner_node->picture_entry_ptr == 0)|  */@;


@q ****** (6) |scanner_node->picture_entry_ptr != 0|.   @>
@ |scanner_node->picture_entry_ptr != 0|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=  

else /* |scanner_node->picture_entry_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG)
      {

        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << endl
                  << "scanner_node->picture_entry_ptr != 0.";
        
        log_message(cerr_strm); 
        cerr_message(cerr_strm);
        cerr_strm.str(""); 

      }
#endif /* |DEBUG_COMPILE|  */@;  

    ppicture = static_cast<Picture*>(scanner_node->picture_entry_ptr); 

  } /* |else| (|scanner_node->picture_entry_ptr != 0|)  */


  entry = 0;


@q ***** (5) Check |scanner_node->color_ptr|.  @>
@ Check |scanner_node->color_ptr|.
\initials{LDF 2004.06.21.}

@q ****** (6) |scanner_node->color_ptr == 0|.  @>
@ |scanner_node->color_ptr == 0|.
\initials{LDF 2004.06.21.}

\LOG
\initials{LDF 2004.11.12.}
Now setting |ccolor = *(scanner_node->current_color)|, if 
|scanner_node->color_ptr == 0 && *(scanner_node->current_color) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=  

if (scanner_node->color_ptr == static_cast<void*>(0))
  {

#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << "scanner_node->color_ptr == 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }

#endif /* |DEBUG_COMPILE|  */@;  

     if (*(scanner_node->current_color) != static_cast<Color*>(0))
 
        ccolor = *(scanner_node->current_color);
 

  } /* |if (scanner_node->color_ptr == 0)|  */@;

@q ****** (6) |scanner_node->color_ptr != 0|.  @>
@ |scanner_node->color_ptr != 0|.
\initials{LDF 2004.06.21.}


@<Define |Scan_Parse| functions@>=  

else /* |scanner_node->color_ptr != 0|  */
  {

#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << "scanner_node->color_ptr != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
        
      }
#endif /* |DEBUG_COMPILE|  */@;  

    ccolor = static_cast<Color*>(scanner_node->color_ptr); 


  }  /* |else| (|scanner_node->color_ptr != 0|)  */@;

@q ***** (5) @>
@ Check |scanner_node->draw_color_ptr|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=  
if (scanner_node->draw_color_ptr == static_cast<void*>(0))
  {
#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << "scanner_node->draw_color_ptr == 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@;  

  } /* |if (scanner_node->draw_color_ptr == 0)|  */

else
  {

#if DEBUG_COMPILE
    if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `drawdot_command()':"
                  << "scanner_node->draw_color_ptr != 0.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
      }

#endif /* |DEBUG_COMPILE|  */@;  

    ddraw_color = static_cast<Color*>(scanner_node->draw_color_ptr); 


  }


@q ***** (5) Check |ddraw_color| and set to |ccolor|, @>
@q ***** (5) if necessary.                            @>
@ Check |ddraw_color| and set to |ccolor|, 
if necessary.  
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=  

  if (ddraw_color == static_cast<Color*>(0) && ccolor != static_cast<Color*>(0))
    ddraw_color = ccolor;

@q ***** (5) Check |scanner_node->pen_ptr|.@>
@ Check |scanner_node->pen_ptr|.
\initials{LDF 2004.06.21.}

@q ****** (6) |scanner_node->pen_ptr == 0|.@> 

|scanner_node->pen_ptr == 0|.
\initials{LDF 2004.11.12.}

\LOG
\initials{LDF 2004.11.12.}
Now setting |ppen = *(scanner_node->current_pen)|, if 
|scanner_node->pen_ptr == 0 && *(scanner_node->current_pen) != 0|. 
\ENDLOG 

@<Define |Scan_Parse| functions@>=  

   if (scanner_node->pen_ptr == static_cast<void*>(0))
      {
#if DEBUG_COMPILE
         if (DEBUG) 
            {
               cerr_strm << thread_name 
                         << "In `drawdot_command()':" 
                         << "scanner_node->pen_ptr == 0.";

               log_message(cerr_strm); 
               cerr_message(cerr_strm); 
               cerr_strm.str(""); 
         }
#endif /* |DEBUG_COMPILE|  */@;  

@q ******* (7).@> 
          
           if (*(scanner_node->current_pen) != static_cast<Pen*>(0))
              ppen = *(scanner_node->current_pen);


     }  /* |if (scanner_node->pen_ptr == 0)|  */

@q ****** (6) |scanner_node->pen_ptr != 0|.@> 

@ |scanner_node->pen_ptr != 0|.
\initials{LDF 2004.11.12.}

@<Define |Scan_Parse| functions@>=  

   else  /* |scanner_node->pen_ptr != 0|  */
      {
#if DEBUG_COMPILE
         if (DEBUG) 
            {
                cerr_strm << thread_name 
                          << "In `drawdot_command()':"
                          << "scanner_node->pen_ptr != 0.";

                log_message(cerr_strm); 
                cerr_message(cerr_strm); 
                cerr_strm.str(""); 
            }     
#endif /* |DEBUG_COMPILE|  */@;  


      ppen = static_cast<Pen*>(scanner_node->pen_ptr); 

  }  /* |else| (|scanner_node->pen_ptr != 0|)  */


@q **** (4) Invoke |drawdot| or |undrawdot|.@>
@ Invoke |drawdot| or |undrawdot|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>= 
  
  if (drawdot_or_undrawdot == DRAWDOT)
    {
      ppoint->drawdot(*ppicture, ddraw_color, ppen);
    }

  else if (drawdot_or_undrawdot == UNDRAWDOT)
    {
      ppoint->undrawdot(*ppicture, ppen);
    }


@q ***** (5) Error handling for invalid |basic_drawing_command|.@>
@ Error handling for invalid \§basic drawing command>.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>= 
  else
    {
      cerr_strm << thread_name 
                << "ERROR! In `drawdot_command()':"
                << endl << "Invalid `drawdot_or_undrawdot': " 
                << drawdot_or_undrawdot
                << "Will delete `ppoint' and pointers on `scanner_node' "
                << "and exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ppoint->clear();
      delete ppoint;
      
      @<Reset pointers on |scanner_node|@>@;
      
      return 1;

    }
  

  
@q **** (4) Clear and delete |ppoint|,           @>
@q **** (4) reset the pointers on|scanner_node|, @>
@q **** (4) and exit function successfully.      @>

@ Clear and delete |ppoint|,           
reset the pointers on|scanner_node|, 
and exit function successfully.      
\initials{LDF 2004.08.17.}

@<Define |Scan_Parse| functions@>= 

  ppoint->clear();
  delete ppoint;

  @<Reset pointers on |scanner_node|@>@;

  return 0;

} /* End of |Scan_Parse::drawdot_command| definition.  */


@q *** (3) Reset pointers on |scanner_node|.@> 
@*2 Reset pointers on |scanner_node|.
This section is used in |Scan_Parse::drawing_command_path|
and |Scan_Parse::drawdot_command|.
\initials{LDF 2004.08.17.}

|ppicture| isn't deleted, because because |Pictures| are persistent, 
i.e., they shouldn't be copied and deleted in rules that use 
|picture_primaries|, |picture_secondaries|, |picture_tertiaries|, 
or |picture_expressions|.
\initials{LDF 2004.06.04.}

\LOG
\initials{LDF 2004.06.07.}  
Now setting |scanner_node->picture_entry_ptr = 0|.

\initials{LDF 2004.08.17.}
Removed this code from the parser rule
\§drawing command> $\longrightarrow$ \§basic drawing command> 
\§path like expression> \§with clause draw list> and put it into this section.   
(|@<Clear |ppath| and delete pointers@>|).

\initials{LDF 2004.08.17.}
Renamed this section 
from |@<Clear |ppath| and delete pointers@>|
to |@<Reset pointers on |scanner_node|@>|. 
Also no longer clearing and deleting |ppath| in it.  This makes it possible to
include this section in |Scan_Parse::drawdot_command| as well as 
|Scan_Parse::drawing_command_path|.  |ppath| is now cleared and deleted in the
latter function.
\ENDLOG 

@<Reset pointers on |scanner_node|@>=

  scanner_node->picture_entry_ptr = 0;

  if (scanner_node->color_ptr != static_cast<void*>(0))
    {
      Color* c = static_cast<Color*>(scanner_node->color_ptr);
      delete c;
      scanner_node->color_ptr = 0;
    }

  if (scanner_node->draw_color_ptr != static_cast<void*>(0))
    {
      delete static_cast<Color*>(scanner_node->draw_color_ptr);
      scanner_node->draw_color_ptr = 0;
    }


  if (scanner_node->fill_color_ptr != static_cast<void*>(0))
    {
      delete static_cast<Color*>(scanner_node->fill_color_ptr);
      scanner_node->fill_color_ptr = 0;
    }

  if (scanner_node->pen_ptr != static_cast<void*>(0))
    {
      delete static_cast<Pen*>(scanner_node->pen_ptr);
      scanner_node->pen_ptr = 0;
    }

  if (scanner_node->dash_pattern_ptr != static_cast<void*>(0))
    {
      delete static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr);
      scanner_node->dash_pattern_ptr = 0;

    }

@q **** (4) |color_vector_ptr|.@> 
@ |color_vector_ptr| is persistent, so it's not deleted.
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.
\ENDLOG 

@<Reset pointers on |scanner_node|@>=

  if (scanner_node->color_vector_ptr != static_cast<void*>(0))
    {

      scanner_node->color_vector_ptr = 0;
    }


@q **** (4) |draw_color_vector_ptr|.@> 
@ |draw_color_vector_ptr| is persistent, so it's not deleted.
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.
\ENDLOG 

@<Reset pointers on |scanner_node|@>=

  if (scanner_node->draw_color_vector_ptr != static_cast<void*>(0))
    {

      scanner_node->draw_color_vector_ptr = 0;
    }


@q **** (4) |fill_color_vector_ptr|.@> 
@ |fill_color_vector_ptr| is persistent, so it's not deleted.
\initials{LDF 2004.08.29.}

\LOG
\initials{LDF 2004.08.29.}
Added this section.
\ENDLOG 

@<Reset pointers on |scanner_node|@>=

  if (scanner_node->fill_color_vector_ptr != static_cast<void*>(0))
    {

      scanner_node->fill_color_vector_ptr = 0;
    }



@q ** (2) |variable_type|.@>
@*1 {\bf variable\_type}.

\LOG
\initials{LDF 2004.08.18.}
Added this function.  It's used in the parser rules for
variable types in \filename{pvariabl.w}.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
Int_Void_Ptr
variable_type(Scanner_Node scanner_node,
              Id_Map_Entry_Node entry,
              string curr_name,
              int curr_type);

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
Int_Void_Ptr
Scan_Parse::variable_type(Scanner_Node scanner_node,
                          Id_Map_Entry_Node entry,
                          string curr_name,
                          int curr_type)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::variable_type'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 





@q **** (4) |entry| is an array.@>

@ |entry| is an array.
\initials{LDF 2004.08.18.}

@<Define |Scan_Parse| functions@>=


  if (entry != static_cast<Id_Map_Entry_Node>(0) && entry->array_flag)
    {

#if DEBUG_COMPILE
      if (DEBUG) 
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::variable_type()':"
                    << endl
                    << curr_name << " is array.";
          
          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str(""); 
        }
#endif /* |DEBUG_COMPILE|  */@; 


      curr_name = scanner_node->resolve_array_name(curr_name);

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::variable_type()':"
                    << endl
                    << "curr_name == " << curr_name << ".";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str(""); 
        }
#endif /* |DEBUG_COMPILE|  */@; 

      
      entry = scanner_node->get_array_entry(curr_name, entry);

    } /* |if (entry != 0 && entry->array_flag)|  */

  else if (entry == static_cast<Id_Map_Entry_Node>(0))
    entry = scanner_node->lookup(curr_name);

#if DEBUG_COMPILE
  if (DEBUG) 
    {
      if (entry == static_cast<Id_Map_Entry_Node>(0))
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::variable_type()':"
                    << endl
                    << "`entry' is still == 0.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str(""); 

        } /* |if (entry == 0)|  */

      else /* (|entry != 0|)  */
        {
          cerr_mutex.lock();
          cerr << thread_name 
               << "In `Scan_Parse::variable_type()':"
               << endl;
          entry->show("entry:");
          cerr_mutex.unlock();

        } /* |else| (|entry != 0|)  */

    }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Error handling for the case that |entry == 0|.@>

@ Error handling for the case that |entry == 0|.
Exit with |ivp.i == 1| and |ivp.v == static_cast<void*>(0)|.
\initials{LDF 2004.08.18.}

@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::variable_type()':"
                << endl 
                << "`entry' == 0. Exiting and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);

      return ivp;

    } /* |if (entry == 0)|  */


@q **** (4) Error handling for the case that |entry->type != curr_type|.@>

@ Error handling for the case that |entry->type != curr_type|.
Issue warning and try to continue.
\initials{LDF 2004.08.18.}

@<Define |Scan_Parse| functions@>=

  if (entry != static_cast<Id_Map_Entry_Node>(0) && entry->type != curr_type)
    {

      cerr_strm << thread_name 
                << "WARNING! In `Scan_Parse::variable_type()':"
                << endl << "(entry->type == " << name_map[entry->type]
                << ") != " << "(curr_type == " << name_map[curr_type]
                << ")." << endl << "Will try to continue.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str(""); 


    } /* |if (entry != 0 && entry->type != curr_type)|  */

  ivp.v = static_cast<void*>(entry); 
  ivp.i = 0;

  return ivp;

} /* End of |Scan_Parse::variable_type| definition.  */


@q ** (2) |transformation_command_func|.@>
@*1 {\bf transformation\_command\_func}.

\LOG
\initials{LDF 2004.09.24.}
Added this function.  It's used in the parser rules for
|transformation_commands| in \filename{ptrfcmnd.w}.

\initials{LDF 2004.09.25.}
Changed |Pointer_Vector<real>* pvr| argument to |void* v|.
Removed code for handling the |numeric_list|.  Now calling 
|Scanner_Type::handle_numeric_list| to do this instead.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |Scan_Parse| functions@>=
int
transformation_command_func(Scanner_Node scanner_node,
                            int transformation_type,
                            Id_Map_Entry_Node entry,
                            void* v);

@q *** (3) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::transformation_command_func(Scanner_Node scanner_node,
                                        int transformation_type,
                                        Id_Map_Entry_Node entry,
                                        void* v)

{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::transformation_command_func()'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Error handling:  |entry == 0|.@>

@ Error handling:  |entry == 0|.
\initials{LDF 2004.09.24.}

@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::transformation_command_func()':"
                << endl << "`entry' == 0. Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      return 1;
                  
    } /* |if (entry == 0)|  */

@q **** (4) Error handling:  |entry->object == 0|.@>

@ Error handling:  |entry->object == 0|.
\initials{LDF 2004.09.24.}

@<Define |Scan_Parse| functions@>=

  if (entry->object == static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::transformation_command_func()':"
                << endl << "`entry->object' == 0. "
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      return 1;
                  
    } /* |if (entry == 0)|  */

@q **** (4) @>   


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_mutex.lock(); 
       cerr << thread_name 
            << "In `Scan_Parse::transformation_command_func()':";
       
       entry->show("entry:");

       cerr << "Type <RETURN> to continue. ";
       getchar(); 
       cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   Bool_Void_Pointer bvp
     = scanner_node->handle_numeric_list(transformation_type, v);

@q **** (4) Error handling:  |Scanner_Type::handle_numeric_list| failed.@>   

@ Error handling:  |Scanner_Type::handle_numeric_list| failed.
\initials{LDF 2004.09.25.}

@<Define |Scan_Parse| functions@>=

  if (bvp.first == false)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::transformation_command_func()':"
                << endl << "`Scanner_Type::handle_numeric_list()' failed. "
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      return 1;

    } /* |if (bvp.first == false)|  */
                                                                 

@q **** (4) |Scanner_Type::handle_numeric_list| succeeded.@>   

@ |Scanner_Type::handle_numeric_list|  succeeded.
\initials{LDF 2004.09.25.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
     else if (DEBUG)  /* |bvp.first == true|  */
       {

         cerr_strm << thread_name 
                   << "In `Scan_Parse::transformation_command_func()':"
                   << endl << "`Scanner_Type::handle_numeric_list()' succeeded.";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
       
       } /* |else if (DEBUG)| (|bvp.first == true|)  */
                                                                
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4).@>
@
@<Define |Scan_Parse| functions@>=                               

  Transform* t = static_cast<Transform*>(bvp.second); 


@q **** (4) Handle |Shapes|.@> 
@ Handle |Shapes|.
\initials{LDF 2004.09.24.}

@<Define |Scan_Parse| functions@>=
      

      if (entry->is_shape())
        {

          Shape* s = static_cast<Shape*>(entry->object);
          
          *s *= *t;

#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr_mutex.lock(); 
          cerr << thread_name 
               << "In `Scan_Parse::transformation_command_func()':";
          s->show("s:");
          cerr << "Type <RETURN> to continue. ";
          getchar(); 
          cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
          
        } /* |if (entry->is_shape())|  */


@q **** (4) Handle other types.@> 
@ Handle other types..
\initials{LDF 2004.09.24.}


\LOG
\initials{LDF 2004.12.02.}
Added code for handling |Pictures|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


@q ***** (5)@>  

  else if (entry->type == TRANSFORM)
    {
           
      Transform* u = static_cast<Transform*>(entry->object); 
      
      *u *= *t;

    } /* |else if (entry->type == TRANSFORM)|  */

@q ***** (5)@>  

  else if (entry->type == PEN)
    {
           
      Pen* p = static_cast<Pen*>(entry->object); 
      
      *p *= *t;

    } /* |else if (entry->type == PEN)|  */

@q ***** (5)@>  

  else if (entry->type == DASH_PATTERN)
    {
      Dash_Pattern* d = static_cast<Dash_Pattern*>(entry->object);
      
      *d *= *t;


    } /* |else if (entry->type == DASH_PATTERN)|  */

@q ***** (5)@>  

  else if (entry->type == PICTURE)
    {
           
      Picture* p = static_cast<Picture*>(entry->object); 
      
      *p *= *t;

    } /* |else if (entry->type == TRANSFORM)|  */

@q ***** (5)@>  
@
\LOG
\initials{LDF 2007.08.21.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == CONIC_SECTION_LATTICE)
    {
           
      Conic_Section_Lattice* c 
         = static_cast<Conic_Section_Lattice*>(entry->object); 
      
      *c *= *t;

    } /* |else if (entry->type == CONIC_SECTION_LATTICE)|  */

@q ***** (5)@>
@
@<Define |Scan_Parse| functions@>=

  else
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::transformation_command_func()':"
                << endl << "`entry->type' == `" << name_map[entry->type]
                << "'. Haven't programmed this case yet.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
    } /* |else|  */


@q ***** (5)@>

@q **** (4) Delete |Transform* t| and set it to null.@> 
@q **** (4) Exit function successfully with return value 0.@> 
@ Delete |t| and set it to null.  Exit function successfully with
return value 0. 
\initials{LDF 2004.09.27.}

\LOG
\initials{LDF 2004.09.27.}
@:BUG FIX@> BUG FIX: 
Now deleting |Transform* t| and setting it to 0.
\ENDLOG 

@<Define |Scan_Parse| functions@>=



  delete t;
  t = 0;

  return 0;

} /* End of |Scan_Parse::transformation_command_func|  
     definition.  */

@q ** (2) |rotate_around_func|.@>
@*1 {\bf rotate\_around\_func}.

\LOG
\initials{LDF 2004.09.29.}
Added this function.
\ENDLOG

@q *** (3) Definition.@>

@<Define |Scan_Parse| functions@>=
Transform* 
Scan_Parse::rotate_around_func(Scanner_Node scanner_node,
                               Point* p,
                               Point* q,
                               real r)
{
@q **** (4) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value
    = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Try to allocate memory for a |Transform|.@>

@ Try to allocate memory for a |Transform|.
Signal an error and exit with return value 0 upon failure.
\initials{LDF 2004.09.29.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::rotate_around_func()'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  Transform* t = 0;

  try 
    {
        t = new Transform;  
    }
  catch (bad_alloc)
    {
       cerr_strm << thread_name << "ERROR! "
                 << "In `Scan_Parse::rotate_around()':"
                 << endl
                 << "Failed to allocate memory for a `Transform'."
                 << endl 
                 << "Exiting function with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");       

      return 0;

    } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  One or more arguments are invalid.@>   

@ Error handling:  One or more arguments are invalid.
\initials{LDF 2004.09.29.}

@<Define |Scan_Parse| functions@>=

  if (   p  == static_cast<Point*>(0) 
      || q  == static_cast<Point*>(0) 
      || *p == INVALID_POINT 
      || *q == INVALID_POINT
      || r  == INVALID_REAL)
    {
      
      cerr_strm << thread_name << "ERROR! "
                << "In `Scan_Parse::rotate_around()':"
                << endl
                << "One or more arguments are invalid."
                << endl 
                << "Exiting function with return value 0.";


      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete t;

      return 0;
      

    } /* |if (   p == 0 || q == 0
              || *p == INVALID_POINT || *q == INVALID_POINT)|   */@;

@q **** (4) Arguments are valid.  Perform rotation.@>   

@ Arguments are valid.  Perform rotation.
\initials{LDF 2004.09.29.}

@<Define |Scan_Parse| functions@>=

  else /* |!(    p == 0 || q == 0
             || *p == INVALID_POINT || *q == INVALID_POINT)|   */@;
    {
      t->rotate(*p, *q, r);

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_mutex.lock(); 
          cerr << thread_name 
               << "In `Scan_Parse::rotate_around()':"
               << endl;
          t->show("t:");
          cerr_mutex.unlock(); 
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |else| (|!(    p == 0 || q == 0
             || *p == INVALID_POINT || *q == INVALID_POINT)|)   */@;
  
@q **** (4) Delete |p| and |q| and exit function, returning |t|.@>   

@ Delete |p| and |q| and exit function, returning |t|.
\initials{LDF 2004.09.29.}

@<Define |Scan_Parse| functions@>=

  if (p)
    delete p;

  if (q)
    delete q;

  return t;

} /* End of |Scan_Parse::rotate_around_func| definition.  */

@q ** (2) |transform_assignment_command_func|.@>
@*1 {\bf transform\_assignment\_command\_func}.

\LOG
\initials{LDF 2004.10.01.}
Added this function.  It's used in the parser rules
``\§transformation assignment command> $\longrightarrow$ 
\§any variable> \.{TIMES\_ASSIGN} \§transform expression>''
and 
``\§transformation assignment command> $\longrightarrow$ 
\§any variable> \.{TIMES\_ASSIGN} 
\§transformation assignment command>''
in \filename{ptrfcmnd.w}.
\ENDLOG


@q *** (3) Definition.@>

@<Define |Scan_Parse| functions@>=

Transform*
Scan_Parse::transformation_assignment_command_func(Scanner_Node scanner_node,
                                                   Id_Map_Entry_Node entry,
                                                   Transform* t)
{

@q **** (4) Preliminaries.@>

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value
    = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Error handling: (|entry == 0 || entry->object == 0|) @>
@q **** (4) (|any_variable| is invalid).                         @>

@ Error handling:  |entry == 0 || entry->object == 0|
(|any_variable| is invalid).
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::transformation_assignment_command_func()':"
                << endl 
                << endl << "`entry' is invalid.  Can't transform it."
                << endl 
                << "Deleting `t' and exiting function with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete t;

      return 0;

    }  /* |if (entry == 0 || entry->object == 0)|  */


@q **** (4) |!(entry == 0 || entry->object == 0)| @>   
@q **** (4) (|any_variable| is valid).            @>   

@ |!(entry == 0 || entry->object == 0)| (|any_variable| is valid).
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  else  /* |!(entry == 0 || entry->object == 0)|  */
    {
      
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl 
                    << "`entry' is valid.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 

      
@q ***** (5) Error handling:  |t == 0|.@> 

@ Error handling:  |t == 0|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=      
  
  if (t == static_cast<Transform*>(0))
    {

      cerr_strm << thread_name << "ERROR! "
                << "In `Scan_Parse::transformation_assignment_command_func()':"
                << endl << "`t' is invalid. "
                << "Can't transform `entry->object'."
                << endl 
                << "Exiting function with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 0;


    } /* |if (t == 0)|  */



@q ***** (5) |t| is valid.@> 

@ |t| is valid.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=      

  else /* |t != 0|  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`t' is valid.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
 
      

@q ****** (6) |entry->type == TRANSFORM|.@> 

@ |entry->type == TRANSFORM|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  if (entry->type == TRANSFORM)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`entry->type' == `TRANSFORM'.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      *(static_cast<Transform*>(entry->object)) *= *t;


    }  /* |if (entry->type == TRANSFORM)|  */

@q ****** (6) |entry->type == PEN|.@> 

@ |entry->type == PEN|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  else if (entry->type == PEN)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`entry->type' == `PEN'.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      *(static_cast<Pen*>(entry->object)) *= *t;


    }  /* |else if (entry->type == PEN)|  */


@q ****** (6) |entry->type == DASH_PATTERN|.@> 

@ |entry->type == DASH_PATTERN|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  else if (entry->type == DASH_PATTERN)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`entry->type' == `DASH_PATTERN'.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      *(static_cast<Dash_Pattern*>(entry->object)) *= *t;


    }  /* |else if (entry->type == DASH_PATTERN)|  */


@q ****** (6) |entry->type == PICTURE|.@> 

@ |entry->type == PICTURE|.
\initials{LDF 2007.11.08.}

\LOG
\initials{LDF 2007.11.08.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == PICTURE)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`entry->type' == `PICTURE'.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      *(static_cast<Picture*>(entry->object)) *= *t;


    }  /* |else if (entry->type == PICTURE)|  */





@q ****** (6) |entry->type == CONIC_SECTION_LATTICE|.@> 
@ |entry->type == CONIC_SECTION_LATTICE|.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == CONIC_SECTION_LATTICE)
  {

#if DEBUG_COMPILE
     if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "In `Scan_Parse::transformation_assignment_command_func()':"
                 << endl << "`entry->type' == `CONIC_SECTION_LATTICE'.";
    
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
       
     }
#endif /* |DEBUG_COMPILE|  */@; 
      
  *(static_cast<Conic_Section_Lattice*>(entry->object)) *= *t;


  }  /* |else if (entry->type == CONIC_SECTION_LATTICE)|  */ 

@q ****** (6) |entry->is_shape == true|.@> 

@ |entry->is_shape == true|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  else if (entry->is_shape())
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::transformation_assignment_command_func()':"
                    << endl << "`entry->is_shape()' == `true'.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
          
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      (static_cast<Shape*>(entry->object))->operator*=(*t);


    }  /* |else if (entry->is_shape())|  */


@q ****** (6) Error handling:  Invalid |entry->type|.@> 

@ Error handling:  Invalid |entry->type|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  else  /* Invalid |entry->type|  */
    {

      cerr_strm << thread_name << "ERROR! "
                << "In `Scan_Parse::transformation_assignment_command_func()':"
                << endl << "Invalid `entry->type': "
                << name_map[entry->type] << "." << endl 
                << "Can't transform. Deleting `t' and exiting function "
                << "with return value 0.";
      
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

      delete t;
      
      return 0;
      
    }   /* |else| (Invalid |entry->type|)  */


@q ****** (6).@> 


    }   /* |else| (|t != 0|)  */
     

@q ***** (5).@> 



    }    /* |else| (|!(entry == 0 || entry->object == 0)|)  */

@q **** (4) Exit function successfully with return value |t|.@>
@ Exit function successfully with return value |t|.
\initials{LDF 2004.10.01.}

@<Define |Scan_Parse| functions@>=

  return t;

} /* End of |Scan_Parse::transformation_assignment_command_func|
     definition.  */

@q ** (2) |align_path_func|.@>
@*1 {\bf align\_path\_func}.
\initials{LDF 2007.10.02.}

\LOG
\initials{LDF 2007.10.02.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::align_path_func(void* v, int ax, void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);



   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   Path* p = static_cast<Path*>(v); 

@q **** (4)@>

   if (!p) 
   {
      return 0;
   }

@q **** (4)@>

   else  /* |p != 0|  */
   {

@q ***** (5)@>

      char axis;

      if (ax == X_AXIS)
         axis = 'x';
      else if (ax == Y_AXIS)
         axis = 'y';
      else if (ax == Z_AXIS)
         axis = 'z';
      else 
      {
          cerr_strm << thread_name << "ERROR!  In `Scan_Parse::align_path_func:"
                    << endl 
                    << "Invalid value for `ax': " << ax
                    << endl 
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete p;
          return 0;

      }  /* |else|  */

@q ***** (5)@>

      Transform t = p->align_with_axis(axis, scanner_node);

@q ***** (5)@>

      if (t == INVALID_TRANSFORM)
      {
          cerr_strm << thread_name << "ERROR!  In `Scan_Parse::align_path_func:"
                    << endl 
                    << "`Path::align_with_axis' returned `INVALID_TRANSFORM'."
                    << endl 
                    << "Exiting function unsuccessfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete p;
          return 0;

      }  /* |if|  */

@q ***** (5)@>
      else
      {
          delete p;
          
          return static_cast<void*>(create_new<Transform>(t)); 
      }  

@q ***** (5)@>

   }  /* |else| (|p != 0|)  */

@q **** (4)@>

}  /* End of |Scan_Parse::align_path_func| definition.  */










@q ** (2) |for_loop_func|.@>
@*1 {\bf for\_loop\_func}.
\initials{LDF 2004.10.28.}

\LOG
\initials{LDF 2004.10.28.}
Added this function.

\initials{LDF 2004.10.28.}
@:BUG FIX@> BUG FIX:  No longer using 
|curr_loop_info_node->start_value| because I've removed
|Loop_Info_Type::start_value|.  I now use
|*static_cast<real*>(scanner_node->loop_info_node->entry->object)| 
instead of |scanner_node->loop_info_node->start_value|
in the parser rule 
\§end-loop> $\longrightarrow$ \.{END\_FOR} \.{SEMI\_COLON}.
This makes it possible to change the value of 
the variable declared in the loop header within the loop.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::for_loop_func(Scanner_Node scanner_node,
                          const unsigned short loop_type,
                          string curr_symbol,
                          real start_value,
                          real step_value,
                          real limit_value)

{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;


  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);


@q **** (4).@>

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::for_loop_func()'.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


  
  int status;

@q **** (4) Try to allocate memory for a new |Loop_Info_Type|.@>   
@ Try to allocate memory for a new |Loop_Info_Type|.
\initials{LDF 2004.10.28.}

@<Define |Scan_Parse| functions@>=

  Loop_Info_Node curr_loop_info_node;

  try 
    {
       curr_loop_info_node = new Loop_Info_Type;
    }
  

@q ***** (5) Error handling:  |new Loop_Info_Type| failed.@> 
@q ***** (5) Rethrow |bad_alloc|.                         @> 

@ Error handling:  |new Loop_Info_Type| failed.
Rethrow |bad_alloc|.
\initials{LDF 2004.10.28.}

@<Define |Scan_Parse| functions@>=

  catch (bad_alloc)
    {

       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::for_loop_func()':"
                 << endl 
                 << "`new Loop_Info_Type' failed. Rethrowing `bad_alloc'.";
 
       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

    }   /* |catch (bad_alloc)|  */


@q ***** (5) |new Loop_Info_Type| succeeded.@> 
@ |new Loop_Info_Type| succeeded.
\initials{LDF 2004.10.28.}

@q **** (4) @>   

@<Define |Scan_Parse| functions@>=

  curr_loop_info_node->type = loop_type;

  curr_loop_info_node->up = scanner_node->loop_info_node;

  scanner_node->loop_info_node = curr_loop_info_node;

  if (loop_type == Loop_Info_Type::FOR_TYPE)
    {

       curr_loop_info_node->step_value    = step_value;   
       curr_loop_info_node->limit_value   = limit_value;  


#if DEBUG_COMPILE
       if (DEBUG)
          {
              cerr_strm << thread_name 
                        << "In `Scan_Parse::for_loop_func()':"
                        << endl  
                        << "`curr_symbol' == " << curr_symbol << endl
                        << "`curr_loop_info_node->step_value' == " 
                        << curr_loop_info_node->step_value << endl
                        << "`curr_loop_info_node->limit_value' == " 
                        << curr_loop_info_node->limit_value << endl;

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |if (loop_type == Loop_Info_Type::FOR_TYPE)|  */

@q **** (4) @>

  int curr_token = NULL_VALUE;

  YYSTYPE value;
#if 0
  YYLTYPE location;
#endif 

  scanner_node->group_ctr++;

@q **** (4) Try to allocate memory for a new |Id_Map_Type|.@>   

@ Try to allocate memory for a new |Id_Map_Type|.
\initials{LDF 2004.10.28.}

@<Define |Scan_Parse| functions@>=

  Id_Map_Node id_map_node;

  try
     {
        id_map_node = new Id_Map_Type;
     }

@q ***** (5) Error handling:  |new Id_Map_Type| failed.           @>
@q ***** (5) Delete |curr_loop_info_node| and rethrow |bad_alloc|.@>

@ Error handling:  |new Id_Map_Type| failed.
Delete |curr_loop_info_node| and rethrow |bad_alloc|.
\initials{LDF 2004.10.28.}

@<Define |Scan_Parse| functions@>=


  catch (bad_alloc)
    {
    
       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::for_loop_func()':"
                 << endl 
                 << "`new Id_Map_Type' failed. "
                 << "Deleting `curr_loop_info_node' and "
                 << "rethrowing `bad_alloc'.";
 
       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete curr_loop_info_node;
       curr_loop_info_node = 0;

       throw;


    }  /* |catch (bad_alloc)|  */

@q ***** (5) |new Id_Map_Type| succeeded.@> 
@ |new Id_Map_Type| succeeded.
\initials{LDF 2004.10.28.}

@q **** (4) @>   

@<Define |Scan_Parse| functions@>=

  id_map_node->up = scanner_node->id_map_node;

  scanner_node->id_map_node = id_map_node;


@q **** (4) If |loop_type == Loop_Info_Type::FOR_TYPE|, @>   
@q **** (4) try to allocate memory for a new |real|.    @>   

@ If |loop_type == Loop_Info_Type::FOR_TYPE|, 
try to allocate memory for a new |real|.
\initials{LDF 2004.10.28.}


\LOG
\initials{LDF 2004.10.28.}
Now only using |real* r| to create an |Id_Map_Entry_Node| 
if |loop_type == Loop_Info_Type::FOR_TYPE|.  It's not needed if
|loop_type == Loop_Info_Type::FOREVER_TYPE|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  real* r = 0;

  if (loop_type == Loop_Info_Type::FOR_TYPE)
     {
         try
            {
               r = new real;
            }   



@q ***** (5) Error handling:  |new real| failed.   @>
@q ***** (5) Delete |curr_loop_info_node| and      @>
@q ***** (5) |id_map_node| and rethrow |bad_alloc|.@>

@ Error handling:  |new real| failed.   
Delete |curr_loop_info_node| and |id_map_node| and 
rethrow |bad_alloc|.
\initials{LDF 2004.10.28.}

@<Define |Scan_Parse| functions@>=

  catch (bad_alloc)
    {
    
       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::for_loop_func()':"
                 << endl 
                 << "`new real' failed. "
                 << "Deleting `curr_loop_info_node' and "
                 << "`id_map_node' and rethrowing `bad_alloc'.";
 
       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete curr_loop_info_node;
       curr_loop_info_node = 0;

       delete id_map_node;
       id_map_node = 0;

       throw;

    }  /* |catch (bad_alloc)|  */

@q ***** (5) |new real| succeeded.@> 
@ |new real| succeeded.
\initials{LDF 2004.10.28.}

@q **** (4) @>   

@<Define |Scan_Parse| functions@>=

  *r = start_value;

  scanner_node->loop_info_node->entry 
    =  scanner_node->add_entry(curr_symbol,
                               NUMERIC,
                               Id_Map_Entry_Type::REGULAR,
                               false,
                               false,
                               Id_Map_Entry_Type::KNOWN,
                               static_cast<void*>(r)); 
 
   } /* |if (loop_type == Loop_Info_Type::FOR_TYPE)|  */

 
  unsigned int nest_ctr = 0;

@q ***** (5) Beginning of |for| loop.@>

@ Beginning of |for| loop.
\initials{LDF 2004.09.13.}

\LOG
\initials{LDF 2004.10.28.}
Added |int prev_token|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  int prev_token;

  for (;;)
    {
      
      prev_token = curr_token;

#if 0 
      curr_token = yylex(&value, &location, scanner_node);
#else
      curr_token = yylex(&value, scanner_node); 
#endif 
      

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::for_loop_func()':"
                    << endl
                    << "`curr_token' == " << name_map[curr_token]
                    << endl << "`scanner_node->token_string' == "
                    << scanner_node->token_string;

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 

@q ****** (6) |curr_token == END_FOR && nest_ctr == 0|.@>

@ |curr_token == END_FOR && nest_ctr == 0|.
\initials{LDF 2004.09.13.}

@<Define |Scan_Parse| functions@>=  

    if (curr_token == END_FOR && nest_ctr == 0)
        {

#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::for_loop_func()':"
                    << endl
                    << "Got outer `END_FOR'. Breaking.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 
 

      *(scanner_node->loop_info_node->loop_strm_ptr) << " end_for;";

      break;
   
   } /* |if (curr_token == END_FOR && nest_ctr == 0)|  */


@q ****** (6) |curr_token == END_FOR && nest_ctr > 0|.@>

@ |curr_token == END_FOR && nest_ctr > 0|.
\initials{LDF 2004.09.13.}

@<Define |Scan_Parse| functions@>=  

    else if (curr_token == END_FOR && nest_ctr > 0)
        {

#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::for_loop_func()':"
                    << endl
                    << "Inner `END_FOR'. Decrementing `nest_ctr' and continuing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 
 

      nest_ctr--;

      *(scanner_node->loop_info_node->loop_strm_ptr) << " end_for";

      continue;

   } /* |else if (curr_token == END_FOR && nest_ctr > 0)|  */

@q ****** (6) |curr_token == FOR || curr_token == FOR_SUFFIXES @>
@q ****** (6)  || curr_token == FOREVER|.                      @>

@ |curr_token == FOR || curr_token == FOR_SUFFIXES || curr_token == FOREVER|.
\initials{LDF 2004.09.13.}

@<Define |Scan_Parse| functions@>=  

    else if (   curr_token == FOR
             || curr_token == FOR_SUFFIXES
             || curr_token == FOREVER)
      {
          
#if DEBUG_COMPILE
        if (DEBUG)
          {
            cerr_strm << thread_name 
                      << "In `Scan_Parse::for_loop_func()':"
                      << endl
                      << "Inner `" << name_map[curr_token] << "'. "
                      << "Incrementing `nest_ctr' and continuing.";

            log_message(cerr_strm);
            cerr_message(cerr_strm);
            cerr_strm.str("");

          }
#endif /* |DEBUG_COMPILE|  */@; 
 


        string s;

        if (curr_token == FOR)
          s = " for";

        else if (curr_token == FOR_SUFFIXES)
          s = " for_suffixes";

        else if (curr_token == FOREVER)
          s = " forever";

        nest_ctr++;
        
        *(scanner_node->loop_info_node->loop_strm_ptr) << s;

        continue;

      } /* |else if (   curr_token == FOR
                     || curr_token == FOR_SUFFIXES
                     || curr_token == FOREVER)|  */
      

@q ****** (6) Other tokens.@>

@ Other tokens.
\initials{LDF 2004.09.13.}

\LOG
\initials{LDF 2004.10.27.}
@:BUG FIX@> BUG FIX:  
Added special handling for more tokens.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

      else /* Other tokens.  */
        {

#if DEBUG_COMPILE
           if (DEBUG)
              {
                  cerr_strm << thread_name 
                            << "In `Scan_Parse::for_loop_func()':"
                            << endl
                            << "`curr_token' == " << name_map[curr_token]
                            << endl 
                            << "`scanner_node->token_string' == " 
                            << scanner_node->token_string
                            << ". Continuing.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
              }
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) Put |scanner_node->token_string| onto             @> 
@q ******* (7) |*(scanner_node->loop_info_node->loop_strm_ptr)|, @> 
@q ******* (7) preceded by a space character, if necessary.      @> 

@ Put |scanner_node->token_string| onto              
|*(scanner_node->loop_info_node->loop_strm_ptr)|,  
preceded by a space character, if necessary.       
\initials{LDF 2004.10.28.}

\LOG
\initials{LDF 2004.10.28.}
Added this section.  It reduces the number of space characters 
in |*(scanner_node->loop_info_node->loop_strm_ptr)|.

\initials{LDF 2004.10.28.}
@:BUG FIX@> BUG FIX:  Added special handling for |strings|.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   switch (curr_token)
     {
        case LEFT_PARENTHESIS:
        case RIGHT_PARENTHESIS:
        case LEFT_BRACKET:
        case RIGHT_BRACKET:
        case SEMI_COLON:
        case COLON:
        case COMMA:
        case ASSIGN:
        case PLUS_ASSIGN:
        case MINUS_ASSIGN:
        case TIMES_ASSIGN:
        case DIVIDE_ASSIGN:
        case PLUS:
        case MINUS:
        case TIMES:
        case OVER:
                      
          break;  /* Do nothing.  */@; 

        case PERIOD_PAIR:
        case PERIOD_TRIPLE:
        case HYPHEN_PAIR:
        case HYPHEN_TRIPLE:

          *(scanner_node->loop_info_node->loop_strm_ptr) << " ";     
 

        default:
          switch (prev_token)
             {
   
                   case LEFT_PARENTHESIS:
                   case RIGHT_PARENTHESIS:
                   case LEFT_BRACKET:
                   case RIGHT_BRACKET:
                   case SEMI_COLON:
                   case COLON:
                   case COMMA:
                   case ASSIGN:
                   case PLUS_ASSIGN:
                   case MINUS_ASSIGN:
                   case TIMES_ASSIGN:
                   case DIVIDE_ASSIGN:
                   case PLUS:
                   case MINUS:
                   case TIMES:
                   case OVER:               
        
                      break;  /* Do nothing.  */@; 
   
                   default:
      
                      *(scanner_node->loop_info_node->loop_strm_ptr) << " ";     

             } /* |switch (prev_token)|  */
 
     }  /* |switch (curr_token)|  */

   if (curr_token == STRING)
     *(scanner_node->loop_info_node->loop_strm_ptr) << "\"";

   *(scanner_node->loop_info_node->loop_strm_ptr) 
     << scanner_node->token_string;

   if (curr_token == STRING)
     *(scanner_node->loop_info_node->loop_strm_ptr) << "\"";

@q ******* (7) @> 
      
   continue;

 }  /* |else| (Other tokens.)  */


@q ****** (6) End of |for| loop.@> 

@ End of |for| loop.
\initials{LDF 2004.09.13.}

@<Define |Scan_Parse| functions@>=

    } /* |for|  */
 
@q ***** (5) @>   
@
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "In `Scan_Parse::for_loop_func()':"
                << endl
                << "`scanner_node->loop_info_node->loop_strm_ptr->str()' == " 
                << scanner_node->loop_info_node->loop_strm_ptr->str();

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 

  Input_Struct* curr_input_struct = new Input_Struct;
  curr_input_struct->up = scanner_node->in;
  curr_input_struct->stream_ptr 
    = static_cast<istream*>(scanner_node->loop_info_node->loop_strm_ptr);

  curr_input_struct->type = Io_Struct::LOOP_STRING_TYPE;
  
  
 
  scanner_node->in = curr_input_struct;

  return 0;

} /* End of |Scan_Parse::for_loop_func| definition.  */


@q ** (2) |for_suffixes_loop_func|.@>
@*1 {\bf for\_suffixes\_loop\_func}.
\initials{LDF 2005.01.18.}

\LOG
\initials{LDF 2005.01.18.}
Started working on this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::for_suffixes_loop_func(Scanner_Node scanner_node,
                                   string curr_symbol)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::for_suffixes_loop_func()'.";
  
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;


@q **** (4) Try to allocate memory for a new |Loop_Info_Type|.@>   
@ Try to allocate memory for a new |Loop_Info_Type|.
\initials{LDF 2005.01.18.}

@<Define |Scan_Parse| functions@>=

   Loop_Info_Node curr_loop_info_node;

   try 
      {
         curr_loop_info_node = new Loop_Info_Type;
      }
  

@q ***** (5) Error handling:  |new Loop_Info_Type| failed.@> 
@q ***** (5) Rethrow |bad_alloc|.                         @> 

@ Error handling:  |new Loop_Info_Type| failed.
Rethrow |bad_alloc|.
\initials{LDF 2005.01.18.}

@<Define |Scan_Parse| functions@>=

   catch (bad_alloc)
      {

         cerr_strm << thread_name 
                   << "ERROR! In `Scan_Parse::for_suffixes_loop_func()':"
                   << endl 
                   << "`new Loop_Info_Type' failed. Rethrowing `bad_alloc'.";
  
         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         throw;

      }   /* |catch (bad_alloc)|  */


@q ***** (5) |new Loop_Info_Type| succeeded.@> 
@ |new Loop_Info_Type| succeeded.
\initials{LDF 2005.01.18.}

@q **** (4) @>   

@<Define |Scan_Parse| functions@>=

   curr_loop_info_node->suffix_parameter = curr_symbol;

   curr_loop_info_node->type = Loop_Info_Type::FOR_SUFFIXES_TYPE;

   curr_loop_info_node->up = scanner_node->loop_info_node;

   scanner_node->loop_info_node = curr_loop_info_node;

@q **** (4) @>   

   YYSTYPE value; 
#if 0 
   YYLTYPE location; 
#endif 

   int curr_catcode = NULL_VALUE;

   string curr_suffix = "";


@q **** (4).@>


   for(;;)
      {
    
   
@q ***** (5).@> 

#if 0 
         curr_catcode = yylex(&value, &location, scanner_node); 
#else
         curr_catcode = yylex(&value, scanner_node); 
#endif 

#if DEBUG_COMPILE
         if (DEBUG)
           {
               cerr << "After `yylex()':  "
                    << "`scanner_node->token_string' == "                
                    << scanner_node->token_string << endl;
           }
#endif /* |DEBUG_COMPILE|  */
  
         if (curr_catcode == COLON)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr << "Got a colon.  Pushing `" << curr_suffix
                           << "' onto `suffix_list' and breaking." 
                           << endl;

                  }
#endif /* |DEBUG_COMPILE|  */@; 

                curr_loop_info_node->suffix_list.push_back(curr_suffix);  
                curr_suffix = "";

                break;
            }

         else if (curr_catcode == COMMA)
            {
#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr << "Got a comma.  Pushing `" << curr_suffix 
                           << "' onto `suffix_list'." << endl;
                  }
#endif /* |DEBUG_COMPILE|  */@; 

                curr_loop_info_node->suffix_list.push_back(curr_suffix);  
                curr_suffix = "";
            }

         else
            {
#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr << "`curr_catcode' == " << name_map[curr_catcode] 
                            << ".  Appending `" << scanner_node->token_string
                            << "' to `curr_suffix'." << endl;
                  }
#endif /* |DEBUG_COMPILE|  */@; 


                curr_suffix += scanner_node->token_string;                
            }

@q ***** (5).@> 

      }  /* |for(;;)| */

@q **** (4).@>

@
\LOG
Changed |Loop_Info_Type::vector<string> suffix_vector| to 
|list<string> suffix_list|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     { 
         int i = 0;

         cerr << "curr_loop_info_node->suffix_list.size() == "
              << curr_loop_info_node->suffix_list.size() << endl;
 
         for(list<string>::const_iterator iter 
                = curr_loop_info_node->suffix_list.begin();
             iter != curr_loop_info_node->suffix_list.end();
             ++iter)
            {
                cerr << "suffix " << i++ << ": " << *iter << endl;
            }  /* |for|  */
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4).@>


   /* Move this to where I use |begingroup|!  
      LDF 2005.01.20. */

   int nest_ctr = 0;

   for(;;)
      {

@q ***** (5).@> 

#if 0 
         curr_catcode = yylex(&value, &location, scanner_node); 
#else
         curr_catcode = yylex(&value, scanner_node); 
#endif 

         if (curr_catcode == END_FOR && nest_ctr == 0)
            {
               *(curr_loop_info_node->loop_strm_ptr) << "end_for;";
               break;
            }

         else if (curr_catcode == END_FOR && nest_ctr > 0)
            {
               *(curr_loop_info_node->loop_strm_ptr) << "end_for;";
               --nest_ctr;
            }
         else if (   curr_catcode == FOR || curr_catcode == FOREVER
                  || curr_catcode == FOR_SUFFIXES)
            {
                *(curr_loop_info_node->loop_strm_ptr) << scanner_node->token_string
                                                      << " ";
                ++nest_ctr;
            }

         else if (curr_catcode == STRING)
            {
                *(curr_loop_info_node->loop_strm_ptr) << "\""
                     << scanner_node->token_string
                     << "\" ";
            }

         else if (is_symbolic_token(curr_catcode)
                  && scanner_node->token_string == curr_symbol)
            {
                *(curr_loop_info_node->loop_strm_ptr) << "¥"
                     << scanner_node->token_string << "¥";
            }

         else
           {
              *(curr_loop_info_node->loop_strm_ptr) << scanner_node->token_string
                                                    << " ";
           }

      }  /* |for(;;)|  */


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr << "`curr_loop_info_node->loop_strm_ptr->str()' == "
              << curr_loop_info_node->loop_strm_ptr->str() << endl;

         cerr << "Type <RETURN> to continue. ";
         getchar(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4).@>

   

@q **** (4).@>

   Int_Void_Ptr_Bool ivpb(SEMI_COLON, 0, false);
   scanner_node->rescan_stack.push(ivpb);
   ivpb.set(FOR_SUFFIXES_INTERNAL_START, 0, false);
   scanner_node->rescan_stack.push(ivpb);

   return 0;

}  /* |Scan_Parse::for_suffixes_loop_func|  */

@q ** (2) |for_suffixes_internal_func|.@>
@*1 {\bf for\_suffixes\_internal\_func}.
\initials{LDF 2005.01.19.}

\LOG
\initials{LDF 2005.01.19.}
Added this function and started working on it.

\initials{LDF 2005.01.19.}
Added |unsigned short ctr| argument.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::for_suffixes_internal_func(Scanner_Node scanner_node,
                                       unsigned int ctr)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::for_suffixes_internal_func()'.";
  
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

   stringstream* curr_stringstream;
   Input_Struct* curr_input_struct;

@q **** (4) @>   

   if (ctr == 0)
      {

#if DEBUG_COMPILE
          if (DEBUG)
            {
               cerr_strm << thread_name 
                         << "In `Scan_Parse::for_suffixes_internal_func()':"
                         << endl 
                         << "First call.";

   
               log_message(cerr_strm); 
               cerr_message(cerr_strm); 
               cerr_strm.str(""); 

            }
#endif /* |DEBUG_COMPILE|  */@; 

    try 
       {
           curr_input_struct = new Input_Struct;
           curr_stringstream = new stringstream;
       }

    catch (bad_alloc)
       {
           cerr_strm << thread_name << "ERROR!  "
                     << "In `Scan_Parse::for_suffixes_internal_func()':"
                     << endl 
                     << "`new Input_Struct' or `new stringstream' failed, "
                     << "throwing `bad_alloc'.  "
                     << "Rethrowing.";
   
           log_message(cerr_strm); 
           cerr_message(cerr_strm); 
           cerr_strm.str(""); 

           throw;
         
       }  /* |catch (bad_alloc)|  */


@q ***** (5).@> 


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Scan_Parse::for_suffixes_internal_func()':"
                   << endl 
                   << "`scanner_node->loop_info_node->suffix_parameter' == "
                   << scanner_node->loop_info_node->suffix_parameter;

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
         

@q ***** (5).@> 



       curr_input_struct->up = scanner_node->in;

       curr_input_struct->type = Io_Struct::LOOP_STRING_TYPE;
       
       scanner_node->in = curr_input_struct;

       curr_input_struct->stream_ptr 
           = static_cast<istream*>(curr_stringstream);


   }  /* |if (ctr == 0)|  */

@q **** (4) @>   

   else /* |ctr != 0|  */
      {
#if DEBUG_COMPILE
          if (DEBUG)
            {
               cerr_strm << thread_name 
                         << "In `Scan_Parse::for_suffixes_internal_func()':"
                         << endl 
                         << "Not first call.";
   
               log_message(cerr_strm); 
               cerr_message(cerr_strm); 
               cerr_strm.str(""); 

            }
#endif /* |DEBUG_COMPILE|  */@; 

        curr_input_struct = scanner_node->in;        

        curr_stringstream 
           = static_cast<stringstream*>(curr_input_struct->stream_ptr);

        curr_stringstream->str("");

      }  /* |else| (|ctr != 0|)  */


@q **** (4) @>   

      *curr_stringstream 
         << scanner_node->loop_info_node->loop_strm_ptr->str();


      stringstream placeholder_strm;
      placeholder_strm << "¥" 
                       << scanner_node->loop_info_node->suffix_parameter 
                       << "¥";



      string::size_type curr_position = 0;
      string::size_type old_position;

      string curr_placeholder = placeholder_strm.str();

      string::size_type curr_placeholder_size = curr_placeholder.size();

      string curr_suffix = scanner_node->loop_info_node->suffix_list.front();

      scanner_node->loop_info_node->suffix_list.pop_front();

      string replacement = curr_stringstream->str();

      for (;;)
         {
            
             old_position = curr_position;

             curr_position = replacement.find(curr_placeholder, 
                                              old_position);

             if (curr_position == string::npos)
                break;

             replacement.replace(curr_position,
                                 curr_placeholder_size,
                                 curr_suffix);


         }  /* |while (curr_position != string::npos)|  */

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr << "`placeholder_strm.str()' == " << placeholder_strm.str()
              << endl
              << "`replacement' == " << replacement << endl;

         cerr << "Type <RETURN> to continue. ";
         getchar(); 

     }
#endif /* |DEBUG_COMPILE|  */@; 

   curr_stringstream->str("");

   if (ctr == 0)
      {
          *curr_stringstream << "begingroup;";
      }

   *curr_stringstream << replacement;


   if(scanner_node->loop_info_node->suffix_list.size() == 0)
      *curr_stringstream << "endgroup;";

   static_cast<stringstream*>(
      scanner_node->in->stream_ptr)->str(curr_stringstream->str());

   scanner_node->in->stream_ptr->seekg(0);


@q **** (4) @>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr << "`curr_stringstream->str()' == " 
             << curr_stringstream->str()  << endl
             << "`static_cast<stringstream*>(scanner_node->in->stream_ptr)->str()"
             << " == " 
             << static_cast<stringstream*>(scanner_node->in->stream_ptr)->str()
             << endl;


        cerr << "Type <RETURN> to continue. ";
        getchar(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   


#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::for_suffixes_internal_func()':"
                  << endl << "`scanner_node->loop_info_node->suffix_list':"
                  << endl;

        int i = 0;
        for (list<string>::const_iterator iter 
                = scanner_node->loop_info_node->suffix_list.begin();
             iter != scanner_node->loop_info_node->suffix_list.end();
             ++iter)
            {
               cerr_strm << i << ": " << *iter << endl;
            }
  
       log_message(cerr_strm); 
       cerr_message(cerr_strm, true); 
       cerr_strm.str(""); 

     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   return 0;

}  /* |Scan_Parse::for_suffixes_internal_func|  */


@q ** (2) |verbatim_metapost_func|.@>
@*1 {\bf verbatim\_metapost\_func}.

\LOG
\initials{LDF 2004.12.13.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::verbatim_metapost_func(Scanner_Node scanner_node, 
                                   const string* s)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  using namespace Scan_Parse;

@q ***** (5) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::verbatim_metapost_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;
   bool multithread_output  = scanner_node->run_state.multithread_output;


@q ***** (5) If we're using multithreaded output,       @>
@q ***** (5) @>

@ If we're using multithreading
\initials{LDF 2004.12.13.}
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H    

  if (multithread_output)

    {


@q ****** (6) Try to lock |scanner_node->output_pending|, set       @>  
@q ****** (6) |scanner_node->output_pending.value_0| to |true|,     @>  
@q ****** (6) and increment |scanner_node->output_pending.value_1|. @>  

@ Try to lock |scanner_node->output_pending|, set       
|scanner_node->output_pending.value_0| to |true|,     
and increment |scanner_node->output_pending.value_1|. 
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>= 

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << "In `Scan_Parse::verbatim_metapost_func()':"
                << endl
                  << "About to call `scanner_node->output_pending.lock()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

      status = scanner_node->output_pending.lock();

@q ******* (7) Error handling.  |output_pending.lock| failed.@>

@ Error handling:  |output_pending.lock| failed.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=

      if (status != 0)
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::verbatim_metapost_func()':"
                    << endl
                    << "`scanner_node->output_pending.lock()' failed. "
                    << "Not writing to output file."
                    << endl << "Exiting function with return value 1.";

          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

        } /* |if (status != 0)|  */


@q ******* (7) |output_pending.lock| succeeded.@>

@ |output_pending.lock| succeeded.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>=


      else /* |scanner_node->output_pending.lock| succeeded.  */
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name 
                        << "In `Scan_Parse::verbatim_metapost_func()':"
                        << endl 
                        << "`scanner_node->output_pending.lock()' succeeded!";

              log_message(cerr_strm); 
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 


@q ******** (8) Check whether an output operation is pending.@>
@ Check whether an output operation is pending.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>=

  while (scanner_node->output_pending.value_0)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {

          cerr_strm << thread_name 
                    << "In `Scan_Parse::verbatim_metapost_func()':"
                    << endl << "Output pending.  Going to sleep.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 


      timespec timeout;

      timeout.tv_sec = time (0) + 300; /* Five minutes.  */
      timeout.tv_nsec = 0;
        
      status = scanner_node->output_pending.timedwait(&timeout);
        


@q ********* (9) Error handling:  Timout.@>
@ Error handling:  Timout.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>=


  if (status == ETIMEDOUT)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::verbatim_metapost_func()':" 
                << endl
                << "`scanner_node->output_pending.timedwait(&timeout)' "
                << "timed out after " << timeout.tv_sec << "seconds." 
                << endl
                << "Not performing output." << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      return 1;

    } /* |if (status == ETIMEDOUT)|  */


@q ********* (9) Error handling:  |scanner_node->output_pending.timedwait| @>
@q ********* (9) failed.                                                     @>

@ Error handling:  |scanner_node->output_pending.timedwait| failed.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>=


  else if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::verbatim_metapost_func()':"
                << endl << "`scanner_node->output_pending.timedwait()' failed. "
                << "Not performing output." << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      return 1;

    } /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::verbatim_metapost_func()':"
                 << endl << "`scanner_node->output_pending.timedwait()' "
                 << "succeeded.";

       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 
       

    } /* |while (scanner_node->output_pending.value_0)|  */

#if DEBUG_COMPILE
          if (DEBUG)
            {

              cerr_strm << thread_name 
                        << "`Scan_Parse::verbatim_metapost_func()':"
                        << endl << "Output not pending. "
                        << "Setting `output_pending->value' to `true' "
                        << "and continuing.";

              cerr_message(cerr_strm);
              cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@; 

          scanner_node->output_pending.value_0 = true;
          scanner_node->output_pending.value_1++;

        } /* |else| (|scanner_node->output_pending.lock| succeeded.)  */


@q ***** (5) Write output.@> 

@ Write output.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  
   scanner_node->out[Run_State::METAPOST]->lock();
#endif /* |HAVE_PTHREAD_H|  */@; 
  
     *(scanner_node->out[Run_State::METAPOST]->stream_ptr) 
           << *s << endl << flush;
            

#ifdef HAVE_PTHREAD_H  
   scanner_node->out[Run_State::METAPOST]->unlock();
#endif /* |HAVE_PTHREAD_H|  */@; 

   scanner_node->output_pending.value_0 = false;
   scanner_node->output_pending.value_1--;

@q ****** (6) Try to unlock |scanner_node->output_pending|.@>  
@ Try to unlock |scanner_node->output_pending|.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>= 

  status = scanner_node->output_pending.unlock();


@q ******* (7) Error handling.  |output_pending.unlock| failed.@>

@ Error handling:  |output_pending.unlock| failed.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=

      if (status != 0)
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::verbatim_metapost_func()':"
                    << endl
                    << "`scanner_node->output_pending.unlock()' failed. "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

        } /* |if (status != 0)|  */


@q ******* (7) |output_pending.unlock| succeeded.@>

@ |output_pending.unlock| succeeded.
\initials{LDF 2004.12.13.}

@<Define |Scan_Parse| functions@>=


      else /* |scanner_node->output_pending.unlock| succeeded.  */
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name << "In `Scan_Parse::verbatim_metapost_func()':"
                        << endl
                        << "`scanner_node->output_pending.unlock()' succeeded!";
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

        } /* |else| (|scanner_node->output_pending.unlock| succeeded.)  */



    } /* |if (multithread_output)|  */


@q ***** (5) Not using multithreaded output.@>

@ Not using multithreaded output.


@<Define |Scan_Parse| functions@>=

#else
  if (0)  /* Dummy conditional.  */
    ;
#endif /* |HAVE_PTHREAD_H|  */@; 

  else  /* (|!multithread_output|)  */

    {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "In `Scan_Parse::verbatim_metapost_func()':"
                 << endl << "Non-multithreaded output.";
       
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

#ifdef HAVE_PTHREAD_H  
   scanner_node->out[Run_State::METAPOST]->lock();
#endif /* |HAVE_PTHREAD_H|  */@; 
  
     *(scanner_node->out[Run_State::METAPOST]->stream_ptr) 
           << *s << endl << flush;
            

#ifdef HAVE_PTHREAD_H  
   scanner_node->out[Run_State::METAPOST]->unlock();
#endif /* |HAVE_PTHREAD_H|  */@; 


    }     /* |else | (|!multithread_output|)  */


@q ***** (5) Exit function successfully with return value 0.@>   

@ Exit function successfully with return value 0.
\initials{LDF 2004.09.09.}

@<Define |Scan_Parse| functions@>=

                                                                
#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << "Exiting `Scan_Parse::verbatim_metapost_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;

}  /* End of |Scan_Parse::verbatim_metapost_func|
     definition.  */


@q ** (2) |end_group_func|.@>
@*1 {\bf end\_group\_func}.
\initials{LDF 2007.10.09.}

\LOG
\initials{LDF 2007.10.09.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Scan_Parse| functions@>=
void
Scan_Parse::end_group_func(void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>
  
  if (scanner_node->group_ctr <= 0)

    {

       cerr_strm << thread_name << "ERROR! In `Scan_Parse::end_group_func':"
                 << endl << "Unmatched `end_group', i.e., "
                 << "`scanner_node->group_ctr' <= 0."
                 << endl 
                 << "Not decrementing `scanner_node->group_ctr' "
                 << "and continuing.";


      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

    } /* |if (scanner_node->group_ctr <= 0)|  */
  
@q ** (2).@>

  else /* |scanner_node->group_ctr > 0|  */
    {
#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::end_group_func':"
                 << endl 
                 << "Decrementing `scanner_node->group_ctr'. "
                 << "New value: " << (scanner_node->group_ctr - 1) << ".";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

   Id_Map_Node curr_id_map_node = scanner_node->id_map_node;
     
   scanner_node->id_map_node = scanner_node->id_map_node->up;

   curr_id_map_node->up = 0;   

   delete curr_id_map_node;

   scanner_node->group_ctr--;

   return;

 }  /* |else| (|scanner_node->group_ctr > 0|)  */


}  /* End of |Scan_Parse::end_group_func| definition.  */


@q ** (2) |macro_definition_func|.@>
@*1 {\bf macro\_definition\_func}.

\LOG
\initials{LDF 2004.12.29.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::macro_definition_func(Scanner_Node scanner_node, 
                                  Id_Map_Entry_Node entry)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;


@q ***** (5) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::macro_definition_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling:  |entry == 0|.@>    
@ Error handling:  |entry == 0|.
\initials{LDF 2004.12.29.}


\LOG
\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX:  Now clearing 
|scanner_node->macro_untyped_parameter_vector| and 
|scanner_node->macro_typed_parameter_vector|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
          cerr_strm << thread_name << "ERROR!  "
                    << "In `Scan_Parse::macro_definition_func()':"
                    << endl << "`entry' is invalid.  Not assigning "
                    << "to `macro' variable.  Returning 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          scanner_node->macro_untyped_parameter_vector.clear();
          scanner_node->macro_typed_parameter_vector.clear();

          return 1;

      }  /* |if (entry == 0)|  */


@q ***** (5) |entry->object == 0|.@> 

@ |entry->object == 0|.  Try to allocate memory for a new
|Definition_Info_Type|.
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

   Definition_Info_Node din;

   if (entry->object == static_cast<void*>(0))
      {
         try
            {
               din = new Definition_Info_Type;
            }

@q ****** (6) Error handling:  |new Definition_Info_Type| failed.@> 

@ Error handling:  |new Definition_Info_Type| failed.
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

         catch (bad_alloc)
            {
                cerr_strm << thread_name << "ERROR!  "
                          << "In `Scan_Parse::macro_definition_func()':"
                          << endl << "`new Definition_Info_Type' failed, "
                          << "throwing `bad_alloc'.  Rethrowing.";

                log_message(cerr_strm);
                cerr_message(cerr_strm, error_stop_value);
                cerr_strm.str("");

                throw;

            }  /* |catch (bad_alloc)|  */
         
@q ****** (6) |new Definition_Info_Type| succeeded.@> 

@ |new Definition_Info_Type| succeeded.
\initials{LDF 2004.12.29.}

\LOG
\initials{LDF 2005.01.03.}
Now setting |din->type = MACRO|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=
    
       entry->object = static_cast<void*>(din); 

@q ****** (6).@> 

      }  /* |if (entry->object == 0)|  */
  

@q ***** (5) |entry->object != 0|.@> 
@ |entry->object != 0|.
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

   else  /* |entry->object != 0|  */
      {
         din = static_cast<Definition_Info_Node>(entry->object);

         din->clear();

      }  /* |else| (|entry->object != 0|)  */

       din->type = MACRO;

@q ***** (5) Handle typed parameter vector.@> 

@ Handle typed parameter vector.
\initials{LDF 2005.01.02.}

\LOG
\initials{LDF 2005.01.03.}
Now prefixing the names of typed parameters with the ``\copyright''
character (octal 251).  This is so that they don't interfere with any
arguments with the same name that might be passed to the macro.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::macro_definition_func()':"
                  << endl 
                  << "Showing `scanner_node->macro_typed_parameter_vector':"
                  << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   din->untyped_parameter_ctr = scanner_node->macro_untyped_parameter_vector.size();
   din->typed_parameter_ctr   = scanner_node->macro_typed_parameter_vector.size();

   int parameter_ctr = scanner_node->macro_untyped_parameter_vector.size();

   for (  vector<Int_String>::const_iterator iter 
        = scanner_node->macro_typed_parameter_vector.begin();
        iter != scanner_node->macro_typed_parameter_vector.end();
        ++iter)
      {
         
#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << type_name_map[iter->first] << " : "
                          << iter->second << endl;
            }
#endif /* |DEBUG_COMPILE|  */@; 

         *(din->definition_strm_ptr[0]) << type_name_map[iter->first] 
                                        << " " << "©" << iter->second << "; "
                                        << "©" << iter->second << " := "
                                        << "¥" << parameter_ctr++ << "¥; ";
 
      }  /* |for|  */


#if DEBUG_COMPILE
   if (DEBUG)
     {
        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5).@> 

#if DEBUG_COMPILE
   if (DEBUG)
     {

        cerr_strm << thread_name 
                  << "In `Scan_Parse::macro_definition_func()':"
                  << endl 
                  << "Showing `scanner_node->macro_untyped_parameter_vector':"
                  << endl;
 
        for (  vector<string>::const_iterator iter 
             = scanner_node->macro_untyped_parameter_vector.begin();
             iter != scanner_node->macro_untyped_parameter_vector.end();
             ++iter)
           {
         
               cerr_strm << *iter << endl;
           }

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5).@> 

   parameter_ctr = 0;

   YYSTYPE value; 
#if 0 
   YYLTYPE location; 
#endif 

   int prev_token;
   int curr_token = NULL_VALUE;

   int nest_ctr = 0;

   bool is_parameter = false;

   vector<string>::const_iterator untyped_parameter_iter; 

@q ***** (5) Beginning of |for| loop.@>

@ Beginning of |for| loop.
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

   for (;;)
      {
      
         prev_token = curr_token;

#if 0 
         curr_token = yylex(&value, &location, scanner_node);
#else
         curr_token = yylex(&value, scanner_node); 
#endif 

      
#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name 
                          << "In `Scan_Parse::macro_definition_func()':"
                          << endl
                          << "`curr_token' == " << name_map[curr_token]
                          << endl << "`scanner_node->token_string' == "
                          << scanner_node->token_string;

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ******* (7) @> 
@
@<Define |Scan_Parse| functions@>=

         if (curr_token == ENDDEF && nest_ctr == 0)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr_strm << thread_name 
                                << "In `Scan_Parse::macro_definition_func()':"
                                << endl
                                << "`curr_token' == `ENDDEF' and `nest_ctr' == 0."
                                << endl << "Got outer `ENDDEF'.  Breaking.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");
                  }
#endif /* |DEBUG_COMPILE|  */@; 
 
               break;

            } /* |if (curr_token == ENDDEF && nest_ctr == 0)|  */


@q ******* (7) @> 
@
@<Define |Scan_Parse| functions@>=

         else if (curr_token == ENDDEF)
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr_strm << thread_name 
                                << "In `Scan_Parse::macro_definition_func()':"
                                << endl
                                << "`curr_token' == `ENDDEF' and `nest_ctr' > 0."
                                << endl << "Decrementing `nest_ctr' and continuing.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");
                  }
#endif /* |DEBUG_COMPILE|  */@; 
 
               *(din->definition_strm_ptr[1]) << "enddef";
               --nest_ctr;
 
               continue;

            } /* |else if (curr_token == ENDDEF)|  */


@q ******* (7) @> 
@
@<Define |Scan_Parse| functions@>=
       
         else if (   curr_token == DEF || curr_token == PRIMARYDEF
                  || curr_token == SECONDARYDEF || curr_token == TERTIARYDEF)

            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr_strm << thread_name 
                                << "In `Scan_Parse::macro_definition_func()':"
                                << endl
                                << "`curr_token' == " << name_map[curr_token] << "."
                                << endl << "Incrementing `nest_ctr'.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");
                  }
#endif /* |DEBUG_COMPILE|  */@; 

               *(din->definition_strm_ptr[1]) << scanner_node->token_string;

               ++nest_ctr;

            }  /* |else if (   curr_token == DEF 
                            || curr_token == PRIMARYDEF
                            || curr_token == SECONDARYDEF 
                            || curr_token == TERTIARYDEF)|  */


@q ******* (7) @> 

@q ****** (6) Other tokens.@>

@ Other tokens.
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

      else /* Other tokens.  */
        {

#if DEBUG_COMPILE
           if (DEBUG)
              {
                  cerr_strm << thread_name 
                            << "In `Scan_Parse::macro_definition_func()':"
                            << endl
                            << "`curr_token' == " << name_map[curr_token]
                            << endl 
                            << "`scanner_node->token_string' == " 
                            << scanner_node->token_string
                            << ". Continuing.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm);
                  cerr_strm.str("");
              }
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) Put |scanner_node->token_string| onto             @> 
@q ******* (7) |*(din->definition_strm_ptr[1])|,                 @> 
@q ******* (7) preceded by a space character, if necessary.      @> 

@ Put |scanner_node->token_string| onto              
|*(din->definition_strm_ptr[1])|,  
preceded by a space character, if necessary.       
\initials{LDF 2004.12.29.}

@<Define |Scan_Parse| functions@>=

   switch (curr_token)
     {
        case LEFT_PARENTHESIS:
        case RIGHT_PARENTHESIS:
        case LEFT_BRACKET:
        case RIGHT_BRACKET:
        case SEMI_COLON:
        case COLON:
        case COMMA:
        case ASSIGN:
        case PLUS_ASSIGN:
        case MINUS_ASSIGN:
        case TIMES_ASSIGN:
        case DIVIDE_ASSIGN:
        case PLUS:
        case MINUS:
        case TIMES:
        case OVER:
                      
          break;  /* Do nothing.  */@; 

        case PERIOD_PAIR:
        case PERIOD_TRIPLE:
        case HYPHEN_PAIR:
        case HYPHEN_TRIPLE:

          *(din->definition_strm_ptr[1]) << " ";     
 

        default:
          switch (prev_token)
             {
   
                   case LEFT_PARENTHESIS:
                   case RIGHT_PARENTHESIS:
                   case LEFT_BRACKET:
                   case RIGHT_BRACKET:
                   case SEMI_COLON:
                   case COLON:
                   case COMMA:
                   case ASSIGN:
                   case PLUS_ASSIGN:
                   case MINUS_ASSIGN:
                   case TIMES_ASSIGN:
                   case DIVIDE_ASSIGN:
                   case PLUS:
                   case MINUS:
                   case TIMES:
                   case OVER:               
        
                      break;  /* Do nothing.  */@; 
   
                   default:
      
                      *(din->definition_strm_ptr[1]) << " ";     

             } /* |switch (prev_token)|  */
 
     }  /* |switch (curr_token)|  */

   if (curr_token == STRING)
      {
          *(din->definition_strm_ptr[1]) << "\""
                                         << scanner_node->token_string
                                         << "\"";
      }


    else if (is_symbolic_token(curr_token))
       {
#if DEBUG_COMPILE
          if (DEBUG)
             {
                cerr_strm << thread_name << "In `Scan_Parse::macro_definition_func()':"
                          << endl << "It's symbolic: " << scanner_node->token_string;

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
             }
#endif /* |DEBUG_COMPILE|  */@; 
           

@q ******** (8) @> 

          is_parameter = false;
          parameter_ctr = 0;

          for (untyped_parameter_iter 
                  = scanner_node->macro_untyped_parameter_vector.begin();
               untyped_parameter_iter 
                  != scanner_node->macro_untyped_parameter_vector.end();
               ++untyped_parameter_iter)
              {
                 if (scanner_node->token_string == *untyped_parameter_iter)
                    {
                       *(din->definition_strm_ptr[1]) << "¥"
                                                      << parameter_ctr
                                                      << "¥";
                       is_parameter = true;
                       break;

                    } /* |if (   scanner_node->token_string 
                              == *untyped_parameter_iter)|  */
                     
                 else /* |   scanner_node->token_string 
                          != *untyped_parameter_iter|  */
                    {
                       ++parameter_ctr;
                       continue;

                    }  /* |else| (|   scanner_node->token_string 
                                   != *untyped_parameter_iter|)  */
       
              }  /* |for|  */

@q ******** (8) @> 

   if (!is_parameter)
      {
          for (vector<Int_String>::const_iterator typed_parameter_iter 
                  = scanner_node->macro_typed_parameter_vector.begin();
               typed_parameter_iter 
                  != scanner_node->macro_typed_parameter_vector.end();
               ++typed_parameter_iter)
              {
                 if (scanner_node->token_string == typed_parameter_iter->second)
                    {
                       *(din->definition_strm_ptr[1]) << "©"
                                                      << typed_parameter_iter->second;

                       is_parameter = true;
                       break;

                    } /* |if (   scanner_node->token_string 
                              == typed_parameter_iter->second)|  */
                     
                 else /* |   scanner_node->token_string 
                          != typed_parameter_iter->second|  */
                    {
                       ++parameter_ctr;
                       continue;

                    }  /* |else| (|   scanner_node->token_string 
                                   != *untyped_parameter_iter|)  */
       
              }  /* |for|  */

      }  /* |if (!is_parameter)|  */

@q ******** (8) @> 

          if (!is_parameter)
             *(din->definition_strm_ptr[1]) << scanner_node->token_string;


       }  /* |else if (is_symbolic_token(curr_token))|  */

    else      
       *(din->definition_strm_ptr[1]) << scanner_node->token_string;

@q ******* (7) @> 
      
   continue;

 }  /* |else| (Other tokens.)  */

@q ******* (7) @> 
 
      } /* |for|  */


@q **** (4) @>   

@
\LOG
\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX:  Now clearing 
|scanner_node->macro_untyped_parameter_vector| and 
|scanner_node->macro_typed_parameter_vector|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Scan_Parse::macro_definition_func()':"
                   << endl
                   << "`din->definition_strm_ptr[1]->str()' == " 
                   << din->definition_strm_ptr[1]->str();

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   scanner_node->macro_untyped_parameter_vector.clear();
   scanner_node->macro_typed_parameter_vector.clear();

   return 0;


@q **** (4) @>   

}  /* End of |Scan_Parse::macro_definition_func| definition.  */


@q ** (2) |macro_vector_definition_func|.@>
@*1 {\bf macro\_vector\_definition\_func}.
\initials{LDF 2005.01.03.}

\LOG
\initials{LDF 2005.01.03.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::macro_vector_definition_func(Scanner_Node scanner_node, 
                                         Id_Map_Entry_Node entry)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

  

   using namespace Scan_Parse;

   int status;

@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::macro_vector_definition_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4).@> 


   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                   << endl << "`entry' == 0.  "
                   << "Clearing `scanner_node->macro_untyped_parameter_vector' "
                   << "and `scanner_node->macro_typed_parameter_vector',"
                   << endl << "and exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
         
         scanner_node->macro_untyped_parameter_vector.clear();
         scanner_node->macro_typed_parameter_vector.clear();

         return 1;

      }  /* |if (entry == 0)|  */


@q **** (4) @>   

            Id_Map_Entry_Node temp_entry;
            Definition_Info_Node d;

            try 
               {
                  temp_entry = new Id_Map_Entry_Type;
                  d          = new Definition_Info_Type;
               }

@q **** (4) @>   

            catch (bad_alloc)
               {
                  cerr_strm << thread_name 
                            << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                            << endl << "`new Id_Map_Entry_Type' or "
                            << "`new Definition_Info_Type' failed, "
                            << "throwing `bad_alloc'."
                            << endl 
                            << "Clearing "
                            << "`scanner_node->macro_untyped_parameter_vector' "
                            << endl 
                            << "and `scanner_node->macro_typed_parameter_vector' "
                            << "and rethrowing `bad_alloc'.";

                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

                  scanner_node->macro_untyped_parameter_vector.clear();
                  scanner_node->macro_typed_parameter_vector.clear();

                  throw;

              }  /* |catch (bad_alloc)|  */

@q **** (4) @>   

      temp_entry->object = static_cast<void*>(d);


      try 
         {
            status = macro_definition_func(scanner_node, temp_entry);
         }

      catch (bad_alloc)
         {
               cerr_strm << thread_name 
                         << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                         << endl << "`macro_definition_func()' failed, throwing `bad_alloc'."
                         << endl 
                         << "Clearing "
                         << "`scanner_node->macro_untyped_parameter_vector' "
                         << endl 
                         << "and `scanner_node->macro_typed_parameter_vector' "
                         << "and rethrowing `bad_alloc'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm, error_stop_value);
               cerr_strm.str("");

               scanner_node->macro_untyped_parameter_vector.clear();
               scanner_node->macro_typed_parameter_vector.clear();

               throw;
         
         }  /* |catch (bad_alloc)|  */
       
@q **** (4) @>   

   if (status != 0)
      {
            cerr_strm << thread_name 
                      << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                      << endl << "`macro_definition_func()' failed, returning "
                      << status << "."
                      << endl 
                      << "Clearing "
                      << "`scanner_node->macro_untyped_parameter_vector' "
                      << endl 
                      << "and `scanner_node->macro_typed_parameter_vector' "
                      << "and exiting function with return value 1.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            scanner_node->macro_untyped_parameter_vector.clear();
            scanner_node->macro_typed_parameter_vector.clear();

            return 1;

  
      }  /* |if (status != 0)|  */


@q **** (4) @>   


   else /* |status == 0|  */
      {
#if DEBUG_COMPILE
          if (DEBUG)
            {
               cerr_strm << thread_name 
                         << "In `Scan_Parse::macro_vector_definition_func()':"
                         << endl << "`macro_definition_func()' succeeded.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");

            }    
#endif /* |DEBUG_COMPILE|  */@; 
 

      }  /* |else| (|status == 0|)  */

@q **** (4) @>   

      temp_entry->object = 0;
      delete temp_entry;


      try
         {
            status = vector_type_plus_assign<Definition_Info_Type>(scanner_node,
                                             entry, 
                                             MACRO_VECTOR,
                                             MACRO,
                                             static_cast<Definition_Info_Node>(d),
                                             false);
         }

@q **** (4) @>   

      catch (bad_alloc)
         {
             cerr_strm << thread_name 
                       << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                       << endl 
                       << "`Scan_Parse::vector_type_plus_assign()' failed, "
                       << "throwing `bad_alloc'." 
                       << endl 
                       << "Clearing `scanner_node->macro_untyped_parameter_vector' "
                       << "and `scanner_node->macro_typed_parameter_vector',"
                       << endl << "and rethrowing `bad_alloc'.";

             log_message(cerr_strm);
             cerr_message(cerr_strm, error_stop_value);
             cerr_strm.str("");
         
             scanner_node->macro_untyped_parameter_vector.clear();
             scanner_node->macro_typed_parameter_vector.clear();

             throw;
     
         }  /* |catch (bad_alloc)|  */


@q **** (4) @>   

   if (status != 0)
      {
          cerr_strm << thread_name 
                    << "ERROR!  In `Scan_Parse::macro_vector_definition_func()':"
                    << endl 
                    << "`Scan_Parse::vector_type_plus_assign()' failed, "
                    << "returning " << status << "."
                    << endl 
                    << "Clearing `scanner_node->macro_untyped_parameter_vector' "
                    << "and `scanner_node->macro_typed_parameter_vector',"
                    << endl << "and exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
         
          scanner_node->macro_untyped_parameter_vector.clear();
          scanner_node->macro_typed_parameter_vector.clear();

          return 1;
 
      }  /* |if (status != 0)|  */

@q **** (4) @>   

   else  /* |status == 0|  */
      {
#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name 
                          << "In `Scan_Parse::macro_vector_definition_func()':"
                          << endl 
                          << "`Scan_Parse::vector_type_plus_assign()' succeeded.";

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
             
            }      
#endif /* |DEBUG_COMPILE|  */@; 
    
      } /* |else| (|status == 0|)  */
  
@q **** (4) @>   

   return 0;

}  /* End of |Scan_Parse::macro_vector_definition_func| definition.  */


@q ** (2) |macro_call_func|.@>
@*1 {\bf macro\_call\_func}.

A `picture' can't be passed to a macro as a typed parameter, 
because |@=:=@>| is used to assign to the variable used within the macro.
In addition, if a `point' (and presumably any other data type without a default value) 
is passed as a typed parameter, an assignment to this object must already have been 
performed.  Otherwise, the assignment to the variable within the macro will fail.
@:TODO@> !! TODO:  Fix these problems!
\initials{LDF 2010.12.29.}

\LOG
\initials{LDF 2005.01.02.}
Added this function.

\initials{LDF 2005.01.03.}
Added |bool left_brace_predicate| argument.
\ENDLOG

@q *** (3) Definition.@> 

@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::macro_call_func(Scanner_Node scanner_node, 
                            Id_Map_Entry_Node entry,
                            bool left_brace_predicate)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::macro_call_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

   if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {
          cerr_strm << "ERROR!  In Scan_Parse::macro_call_func()':"
                    << endl << "Invalid `macro_variable'.  Can't call macro.  "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
      
          scanner_node->macro_untyped_parameter_vector.clear();
          scanner_node->macro_typed_parameter_vector.clear();

          return 1;
         
   
      }  /* |if (entry == 0 || entry->object == 0)|  */

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

   else /* |entry != 0 && entry->object != 0|  */ 
      {


          Definition_Info_Node d 
             = static_cast<Definition_Info_Node>(entry->object);


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_mutex.lock(); 
         cerr << thread_name << "In Scan_Parse::macro_call_func()':"
              << endl; 
         d->show("d:");

         cerr << "Showing `scanner_node->macro_untyped_parameter_vector':" 
              << endl;

         for (vector<string>::const_iterator iter 
                = scanner_node->macro_untyped_parameter_vector.begin();
              iter != scanner_node->macro_untyped_parameter_vector.end();         
              ++iter)
            { 
               cerr << *iter << endl;
            }  /* |for|  */

         cerr << "Done showing `scanner_node->macro_untyped_parameter_vector'." 
              << endl; 

         cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5).@> 
@
@<Define |Scan_Parse| functions@>=


   if (   scanner_node->macro_untyped_parameter_vector.size()
       != d->untyped_parameter_ctr)
      {

          cerr_strm << "ERROR!  In Scan_Parse::macro_call_func()':"
                    << endl << "Number of untyped arguments does not match number "
                    << "of untyped parameters required by `" << entry->name << "'."
                    << endl << "`scanner_node->macro_untyped_parameter_vector.size()' " 
                    << "== " << scanner_node->macro_untyped_parameter_vector.size()
                    << endl 
                    << "`d->untyped_parameter_ctr' === "
                    << d->untyped_parameter_ctr 
                    << endl 
                    << "Not calling macro.  Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
      

          scanner_node->macro_untyped_parameter_vector.clear();
          scanner_node->macro_typed_parameter_vector.clear();

          return 1;

      }  /* |if (   scanner_node->macro_untyped_parameter_vector.size()
                 != d->untyped_parameter_ctr)|  */
    
@q ***** (5).@> 
@

\LOG
\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX:  Now copying 
|scanner_node->macro_untyped_parameter_vector| to 
|vector<string> curr_untyped_parameter_vector| and clearing 
|scanner_node->macro_untyped_parameter_vector| and 
|scanner_node->macro_typed_parameter_vector|.  Before, calls to nested
macros failed.

\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX:  Now only executing the code for replacing untyped 
parameters with arguments if the macro has untyped parameters, i.e.,
|d->untyped_parameter_ctr > 0|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=   

   else /* |   scanner_node->macro_untyped_parameter_vector.size()
            == d->untyped_parameter_ctr|  */
      {
          string replacement_1;
          string::size_type curr_position;
          stringstream      curr_placeholder_strm;
          string            curr_placeholder;
          string::size_type curr_placeholder_size;
          string::size_type old_position;
          int ctr;

          replacement_1 = d->definition_strm_ptr[1]->str();

          if (d->untyped_parameter_ctr > 0)
             {
                 vector<string> curr_untyped_parameter_vector;

                 for(vector<string>::const_iterator iter 
                        = scanner_node->macro_untyped_parameter_vector.begin();
                     iter != scanner_node->macro_untyped_parameter_vector.end();
                     ++iter)
                    { 
                       curr_untyped_parameter_vector.push_back(*iter);
                    }

                 scanner_node->macro_untyped_parameter_vector.clear();
                 scanner_node->macro_typed_parameter_vector.clear();

                 old_position = 0;

                 ctr = 0;

                 for (vector<string>::const_iterator iter
                         = curr_untyped_parameter_vector.begin();
                      iter != curr_untyped_parameter_vector.end();
                      ++iter)
                     {
                       curr_placeholder_strm.str("");
                       curr_placeholder_strm << "¥" << ctr << "¥";

                       curr_placeholder = curr_placeholder_strm.str();

                       curr_placeholder_size =  curr_placeholder.size();

                       curr_position = replacement_1.find(curr_placeholder);

                       while (curr_position != string::npos)
                          {
                              replacement_1.replace(curr_position, 
                                                  curr_placeholder_size,
                                                  *iter);  

                              old_position = curr_position + curr_placeholder_size;

                              curr_position = replacement_1.find(curr_placeholder, 
                                                               old_position);
                          }  /* |while|  */

                       ++ctr;

                   } /* |for|  */ 

             } /* |if (d->untyped_parameter_ctr > 0)|  */

#if DEBUG_COMPILE
                if (DEBUG)
                   {
                      cerr << "replacement_1 == " << replacement_1 << endl;
                      cerr << "Type <RETURN> to continue. ";
                      getchar(); 
                   }       
#endif /* |DEBUG_COMPILE|  */@; 
 


@q ****** (6).@> 
@

\LOG
\initials{LDF 2005.01.03.}
Removed the |while| loops for replacing the placeholders for the
values of the typed parameters.  They only occur once in 
|d->definition_strm_ptr[0]->str|, so the loops aren't needed.


\initials{LDF 2005.01.03.}
Added |int bracket_nest_ctr| and code for handling brackets.

\initials{LDF 2005.01.03.}
Now setting |curr_token = LEFT_BRACE| 
if |left_brace_predicate == true|.  This is for the case that the
macro has typed arguments, but no untyped ones.

\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX:   Now only executing the code for replacing typed 
parameters with arguments if the macro has typed parameters, i.e.,
|d->typed_parameter_ctr > 0|.

\initials{LDF 2005.01.03.}
@:BUG FIX@> BUG FIX: 
Now adding a space character after |scanner_node->token_string| 
in the |else| case of the conditional testing |curr_token|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

   string replacement_0;

   if (d->typed_parameter_ctr > 0)
      {

          replacement_0 = d->definition_strm_ptr[0]->str();

          stringstream curr_argument_strm;

          ctr = d->untyped_parameter_ctr;

          curr_placeholder_strm.str("");
          curr_placeholder_strm << "¥" << ctr << "¥";

          YYSTYPE value; 
#if 0 
          YYLTYPE location; 
#endif 

          int prev_token;
          int curr_token = NULL_VALUE;

          int brace_nest_ctr       = 0;
          int bracket_nest_ctr = 0;
          int parenthesis_nest_ctr = 0;

          if (left_brace_predicate)
             curr_token = LEFT_BRACE;
          else
          {

#if 0 
             curr_token = yylex(&value, &location, scanner_node);
#else
             curr_token = yylex(&value, scanner_node); 
#endif 
          }  /* |else|  */
   
          if (curr_token == LEFT_BRACE)
             {

#if DEBUG_COMPILE
                  if (DEBUG)
                     {
                         cerr_strm << thread_name 
                                   << "In `Scan_Parse::macro_call_func()':"
                                   << endl 
                                   << "`left_brace_predicate' == `true' || "
                                   << "`curr_token' == `LEFT_BRACE'.";

                         log_message(cerr_strm);
                         cerr_message(cerr_strm);
                         cerr_strm.str("");
                      }
#endif /* |DEBUG_COMPILE|  */@; 

         curr_placeholder_strm.str("");

         curr_placeholder_strm << "¥" << ctr << "¥";

         curr_placeholder = curr_placeholder_strm.str();

         curr_placeholder_size =  curr_placeholder.size();


         for (;;)
            {
         
                 prev_token = curr_token;

#if 0 
                 curr_token = yylex(&value, &location, scanner_node);
#else
                 curr_token = yylex(&value, scanner_node); 
#endif 


                 if (curr_token == RIGHT_BRACE && brace_nest_ctr == 0)
                       {
#if DEBUG_COMPILE
                          if (DEBUG)
                             {
                                 cerr_strm << "In Scan_Parse::macro_call_func()':"
                                           << endl << "Got last argument:  "
                                           << "`curr_argument_strm.str()' == "
                                           << curr_argument_strm.str();

                                 log_message(cerr_strm);
                                 cerr_message(cerr_strm);
                                 cerr_strm.str("");         
                             }
#endif /* |DEBUG_COMPILE|  */@; 

                           curr_position = replacement_0.find(curr_placeholder);

                           replacement_0.replace(curr_position, 
                                                 curr_placeholder_size,
                                                 curr_argument_strm.str());  

                           ++ctr;

                           curr_placeholder_strm.str("");
 
                           curr_placeholder_strm << "¥" << ctr << "¥";
 
                           curr_placeholder = curr_placeholder_strm.str();

                           curr_placeholder_size =  curr_placeholder.size();

                           curr_argument_strm.str("");

                           break;
                       }

                    else if (curr_token == RIGHT_BRACE && brace_nest_ctr > 0)
                       {
                          curr_argument_strm << "}";
                          --brace_nest_ctr;
                       }

                    else if (curr_token == RIGHT_BRACE && brace_nest_ctr < 0)
                       {
                           cerr_strm << "ERROR!  In Scan_Parse::macro_call_func()':"
                                     << endl << "Unmatched `RIGHT_BRACE'.  "
                                     << "Ignoring it, and will try to continue.";

                           log_message(cerr_strm);
                           cerr_message(cerr_strm, error_stop_value);
                           cerr_strm.str("");         

                       }

                    else if (curr_token == LEFT_BRACE)
                       {
                          curr_argument_strm << "{";
                          ++brace_nest_ctr;
                       }


                    else if (curr_token == LEFT_PARENTHESIS)
                       {
                          curr_argument_strm << "(";
                          ++parenthesis_nest_ctr;
                       }

                    else if (   curr_token == RIGHT_PARENTHESIS 
                             && parenthesis_nest_ctr == 0)
                       {
                          curr_argument_strm << ")";

                       }

                    else if (   curr_token == RIGHT_PARENTHESIS 
                             && parenthesis_nest_ctr > 0)
                       {
                          curr_argument_strm << ")";
                          --parenthesis_nest_ctr;
                       }  

                    else if (   curr_token == RIGHT_PARENTHESIS 
                             && parenthesis_nest_ctr < 0)
                       {
                           cerr_strm << "ERROR!  In Scan_Parse::macro_call_func()':"
                                     << endl << "Unmatched `RIGHT_PARENTHESIS'.  "
                                     << "Ignoring it, and will try to continue.";

                           log_message(cerr_strm);
                           cerr_message(cerr_strm, error_stop_value);
                           cerr_strm.str("");         

                       }

                    else if (curr_token == LEFT_BRACKET)
                       {
                          curr_argument_strm << "[";
                          ++bracket_nest_ctr;
                       }

                    else if (   curr_token == RIGHT_BRACKET 
                             && bracket_nest_ctr == 0)
                       {
                          curr_argument_strm << "]";

                       }

                    else if (   curr_token == RIGHT_BRACKET 
                             && bracket_nest_ctr > 0)
                       {
                          curr_argument_strm << "]";
                          --bracket_nest_ctr;
                       }  

                    else if (   curr_token == RIGHT_BRACKET 
                             && bracket_nest_ctr < 0)
                       {
                           cerr_strm << "ERROR!  In Scan_Parse::macro_call_func()':"
                                     << endl << "Unmatched `RIGHT_BRACKET'.  "
                                     << "Ignoring it, and will try to continue.";

                           log_message(cerr_strm);
                           cerr_message(cerr_strm, error_stop_value);
                           cerr_strm.str("");         

                       }

                    else if (   curr_token == COMMA 
                             && (   parenthesis_nest_ctr > 0 
                                 || bracket_nest_ctr > 0      ))

                       {
                          curr_argument_strm << ", ";
                       }

                    else if (   curr_token == COMMA 
                             && parenthesis_nest_ctr == 0
                             && bracket_nest_ctr == 0     )
                       {
#if DEBUG_COMPILE
                           if (DEBUG)
                              {
                                  cerr_strm << "In Scan_Parse::macro_call_func()':"
                                             << endl << "Got an argument:  "
                                             << "`curr_argument_strm.str()' == "
                                             << curr_argument_strm.str();

                                   log_message(cerr_strm);
                                   cerr_message(cerr_strm);
                                   cerr_strm.str("");         
                              }
#endif /* |DEBUG_COMPILE|  */@; 
 
 

                           curr_position = replacement_0.find(curr_placeholder);

                           replacement_0.replace(curr_position, 
                                                 curr_placeholder_size,
                                                 curr_argument_strm.str());  

                           ++ctr;

                           curr_placeholder_strm.str("");
 
                           curr_placeholder_strm << "¥" << ctr << "¥";
 
                           curr_placeholder = curr_placeholder_strm.str();

                           curr_placeholder_size =  curr_placeholder.size();

                           curr_argument_strm.str("");

                           continue;

                       }  /* |else if (   curr_token == COMMA 
                                       && parenthesis_nest_ctr == 0)|  */
                    else 
                       {

                           curr_argument_strm << scanner_node->token_string << " ";

#if DEBUG_COMPILE
                           if (DEBUG)
                              {

                                  cerr_strm << thread_name 
                                            << "In `Scan_Parse::macro_call_func()':"
                                            << endl 
                                            << "`scanner_node->token_string' == " 
                                            << scanner_node->token_string;

                                  log_message(cerr_strm);
                                  cerr_message(cerr_strm);
                                  cerr_strm.str("");          
                             }
#endif /* |DEBUG_COMPILE|  */@; 
 

                       }  /* |else|  */

                 }  /* |for|  */



#if DEBUG_COMPILE
              if (DEBUG)
                 {
                     cerr_strm << thread_name 
                               << "In `Scan_Parse::macro_call_func()':"
                               << endl 
                               << "`replacement_0'  == " << replacement_0;

                     log_message(cerr_strm);
                     cerr_message(cerr_strm);
                     cerr_strm.str("");          
                             }
#endif /* |DEBUG_COMPILE|  */@; 

            }  /* |if (curr_token == LEFT_BRACE)|  */

@q ****** (6).@> 
@
@<Define |Scan_Parse| functions@>=

         else /* |curr_token != LEFT_BRACE|  */
            {

#if DEBUG_COMPILE
               if (DEBUG)
                  {
                      cerr_strm << thread_name << "In `Scan_Parse::macro_call_func()':"
                                << endl << "`curr_token' != `LEFT_BRACE'.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");

                  }
#endif /* |DEBUG_COMPILE|  */@; 

            }  /* |else| (|curr_token != LEFT_BRACE|)  */

   }  /* |if (d->typed_parameter_ctr > 0)|  */

@q ****** (6).@> 
@
@<Define |Scan_Parse| functions@>=

         Input_Struct* curr_input_struct;
         stringstream* curr_stringstream; 

         try
            {
               curr_input_struct = new Input_Struct;
               curr_stringstream = new stringstream;

            }

@q ****** (6) Error handling:  |new Input_Struct| or @> 
@q ****** (6) |new stringstream| failed.             @> 

@ Error handling:  |new Input_Struct| or |new stringstream| failed.              
\initials{LDF 2005.01.02.}

\LOG
\initials{LDF 2005.01.03.}
No longer clearing |scanner_node->macro_untyped_parameter_vector|
and |scanner_node->macro_typed_parameter_vector|.  
This is now done above anyway.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


         catch (bad_alloc)
            {
               cerr_strm << thread_name 
                         << "ERROR!  In `Scan_Parse::macro_call_func()':"
                         << endl 
                         << "`new Input_Struct' or `new stringstream' failed.  "
                         << "Rethrowing `bad_alloc'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm, error_stop_value);
               cerr_strm.str("");

               throw;

            }  /* |catch (bad_alloc)|  */

@q ****** (6).@> 
@

\LOG
\initials{LDF 2005.01.03.}
Now putting |begingroup| and |endgroup| onto |*curr_stringstream|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

      *curr_stringstream << "begingroup; " << replacement_0 
                         << replacement_1 << "endgroup;";

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::macro_call_func()':"
                   << endl 
                   << "`curr_stringstream->str()' == " 
                   << curr_stringstream->str();

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
       curr_input_struct->up = scanner_node->in;
       curr_input_struct->stream_ptr 
          = static_cast<istream*>(curr_stringstream);

       curr_input_struct->type = Io_Struct::MACRO_STRING_TYPE;
 
       scanner_node->in = curr_input_struct;


@q ****** (6).@> 
@
\LOG
\initials{LDF 2005.01.03.}
No longer clearing |scanner_node->macro_untyped_parameter_vector|
and |scanner_node->macro_typed_parameter_vector|.  
This is now done above anyway.
\ENDLOG  

@<Define |Scan_Parse| functions@>=

          return 0;

@q ****** (6).@> 


      }  /* |else| (|   scanner_node->macro_untyped_parameter_vector.size()
                     == d->untyped_parameter_ctr|)  */


@q ***** (5).@> 


      }  /* |else | (|entry != 0 && entry->object != 0|)  */ 


@q **** (4) @>   

}  /* End of |Scan_Parse::macro_call_func| definition.  */



@q ** (2) |is_symbolic_token|.@>
@*1 {\bf is\_symbolic\_token}.
\initials{LDF 2005.01.02.}

\LOG
\initials{LDF 2005.01.02.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
bool
Scan_Parse::is_symbolic_token(int curr_token)
{
   return (curr_token >= SYMBOL_0 && curr_token <= SYMBOL_7) ? true : false;
}


@q ** (2) |clear_vector_func|.@>
@*1 {\bf clear\_vector\_func}.
\initials{LDF 2005.01.03.}

\LOG
\initials{LDF 2005.01.03.}
Added this function.

\initials{LDF 2007.07.29.}
Added code for handling |conic_section_lattice_vectors|.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.01.03.}
Add code for handling more vector-types.
\ENDTODO 

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::clear_vector_func(Scanner_Node scanner_node, 
                              Id_Map_Entry_Node entry)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::clear_vector_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::clear_vector_func':"
                << endl
                << "`entry' == 0."
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (entry == 0)|  */

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

  if (entry->subordinate_array == static_cast<Id_Map_Entry_Node>(0))
    {
      

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::clear_vector_func':"
                << endl
                << "`entry->subordinate_array' == 0."
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (entry->subordinate_array == 0)|  */


@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

      status
        = entry->subordinate_array->destroy_array_subentries();


@q **** (4) @> 
@
@<Define |Scan_Parse| functions@>=

      if (status != 0)
        {
          cerr_strm << thread_name << "ERROR! In `Scan_Parse::clear_vector_func':"
                    << endl
                    << "`entry->subordinate_array->"
                    << "destroy_array_subentries()' failed."
                    << endl
                    << "Exiting function with return value 1.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

        } /* |if (status != 0)|  */


@q **** (4) @> 
@
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG) /* |status == 0|  */
     {

          cerr_strm << thread_name << "In `Scan_Parse::clear_vector_func':"
                    << endl
                    << "`entry->subordinate_array->"
                    << "destroy_array_subentries()' succeeded.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }   /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Non-Shape types.@>   
@ Non-|Shape| types.
\initials{LDF 2005.01.07.}

\LOG
\initials{LDF 2005.01.07.}
Added this section.
\ENDLOG


@q ***** (5) |BOOLEAN_VECTOR|.@> 

@ |BOOLEAN_VECTOR|.
\initials{LDF 2005.01.07.}

\LOG
\initials{LDF 2005.01.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  if (entry->type == BOOLEAN_VECTOR)
    {
      typedef Pointer_Vector<bool> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == BOOLEAN_VECTOR)|  */


@q ***** (5) |NUMERIC_VECTOR|.@> 

@ |NUMERIC_VECTOR|.
\initials{LDF 2005.01.07.}

\LOG
\initials{LDF 2005.01.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == NUMERIC_VECTOR)
    {
      typedef Pointer_Vector<real> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == NUMERIC_VECTOR)|  */



@q ***** (5) |ULONG_LONG_VECTOR|.@> 

@ |ULONG_LONG_VECTOR|.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == ULONG_LONG_VECTOR)
    {
      typedef Pointer_Vector<ulong_long> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == ULONG_LONG_VECTOR)|  */

@q ***** (5) |STRING_VECTOR|.@> 

@ |STRING_VECTOR|.
\initials{LDF 2005.01.09.}

\LOG
\initials{LDF 2005.01.09.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == STRING_VECTOR)
    {
      typedef Pointer_Vector<string> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == STRING_VECTOR)|  */



@q ***** (5) |PEN_VECTOR|.@> 

@ |PEN_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PEN_VECTOR)
    {
      typedef Pointer_Vector<Pen> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == PEN_VECTOR)|  */

@q ***** (5) |DASH_PATTERN_VECTOR|.@> 

@ |DASH_PATTERN_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == DASH_PATTERN_VECTOR)
    {
      typedef Pointer_Vector<Dash_Pattern> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == DASH_PATTERN_VECTOR)|  */





@q ***** (5) |COLOR_VECTOR|.@> 

@ |COLOR_VECTOR|.
\initials{LDF Undated.}

@<Define |Scan_Parse| functions@>=


  else if (entry->type == COLOR_VECTOR)
    {
      typedef Pointer_Vector<Color> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == COLOR_VECTOR)|  */


@q ***** (5) |TRANSFORM_VECTOR|.@> 

@ |TRANSFORM_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == TRANSFORM_VECTOR)
    {
      typedef Pointer_Vector<Transform> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == TRANSFORM_VECTOR)|  */


@q ***** (5) |FOCUS_VECTOR|.@> 

@ |FOCUS_VECTOR|.
\initials{LDF 2005.01.18.}

\LOG
\initials{LDF 2005.01.18.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == FOCUS_VECTOR)
    {
      typedef Pointer_Vector<Focus> PV;
      PV* pv = static_cast<PV*>(entry->object);

      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }

    } /* |if (entry->type == FOCUS_VECTOR)|  */




@q ***** (5) |PICTURE_VECTOR|.@>   

@ |PICTURE_VECTOR|.
\initials{LDF 2005.01.17.}

\LOG
\initials{LDF 2005.01.17.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == PICTURE_VECTOR)
    {
      typedef Pointer_Vector<Picture> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == PICTURE_VECTOR)|  */


@q ***** (5) |MACRO_VECTOR|.@>   

@ |MACRO_VECTOR|.
\initials{LDF 2005.01.03.}

\LOG
\initials{LDF 2005.01.03.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == MACRO_VECTOR)
    {
      typedef Pointer_Vector<Definition_Info_Type> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == MACRO_VECTOR)|  */


@q ***** (5) |CONIC_SECTION_LATTICE_VECTOR|.@>   

@ |CONIC_SECTION_LATTICE_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CONIC_SECTION_LATTICE_VECTOR)
    {
      typedef Pointer_Vector<Conic_Section_Lattice> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == CONIC_SECTION_LATTICE_VECTOR)|  */


@q **** (4) Shape types.@>   
@ |Shape| types.
\initials{LDF 2005.01.07.}

\LOG
\initials{LDF 2005.01.07.}
Added this section.

\initials{LDF 2005.12.01.}
Added code for handling |parabola_vectors|, |hyperbola_vectors|, 
|ellipsoid_vectors|, and |sphere_vectors|.
\ENDLOG


@q ***** (5) |POINT_VECTOR|.@>   

@ |POINT_VECTOR|.
\initials{LDF Undated.}

@<Define |Scan_Parse| functions@>=


  else if (entry->type == POINT_VECTOR)
    {
      typedef Pointer_Vector<Point> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == POINT_VECTOR)|  */


@q ***** (5) |BOOL_POINT_VECTOR|.@>   

@ |BOOL_POINT_VECTOR|.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == BOOL_POINT_VECTOR)
    {
      typedef Pointer_Vector<Bool_Point> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == BOOL_POINT_VECTOR)|  */


@q ***** (5) |PATH_VECTOR|.@>   

@ |PATH_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PATH_VECTOR)
    {
      typedef Pointer_Vector<Path> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == PATH_VECTOR)|  */



@q ***** (5) |ELLIPSE_VECTOR|.@>   

@ |ELLIPSE_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == ELLIPSE_VECTOR)
    {
      typedef Pointer_Vector<Ellipse> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == ELLIPSE_VECTOR)|  */


@q ***** (5) |CIRCLE_VECTOR|.@>   

@ |CIRCLE_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CIRCLE_VECTOR)
    {
      typedef Pointer_Vector<Circle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == CIRCLE_VECTOR)|  */



@q ***** (5) |PARABOLA_VECTOR|.@>   

@ |PARABOLA_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PARABOLA_VECTOR)
    {
      typedef Pointer_Vector<Parabola> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == PARABOLA_VECTOR)|  */

@q ***** (5) |HYPERBOLA_VECTOR|.@>   

@ |HYPERBOLA_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == HYPERBOLA_VECTOR)
    {
      typedef Pointer_Vector<Hyperbola> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == HYPERBOLA_VECTOR)|  */





@q ***** (5) |POLYGON_VECTOR|.@>   

@ |POLYGON_VECTOR|.
\initials{LDF 2005.03.01.}

\LOG
\initials{LDF 2005.03.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  else if (entry->type == POLYGON_VECTOR)
    {
      typedef Pointer_Vector<Polygon> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == POLYGON_VECTOR)|  */

@q ***** (5) |TRIANGLE_VECTOR|.@>   

@ |TRIANGLE_VECTOR|.
\initials{LDF 2005.01.25.}

\LOG
\initials{LDF 2005.01.25.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == TRIANGLE_VECTOR)
    {
      typedef Pointer_Vector<Triangle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == TRIANGLE_VECTOR)|  */



@q ***** (5) |RECTANGLE_VECTOR|.@>   

@ |RECTANGLE_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == RECTANGLE_VECTOR)
    {
      typedef Pointer_Vector<Rectangle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == RECTANGLE_VECTOR)|  */

@q ***** (5) |REG_POLYGON_VECTOR|.@>   

@ |REG_POLYGON_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == REG_POLYGON_VECTOR)
    {
      typedef Pointer_Vector<Reg_Polygon> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == REG_POLYGON_VECTOR)|  */



@q ***** (5) |ELLIPSOID_VECTOR|.@>   

@ |ELLIPSOID_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == ELLIPSOID_VECTOR)
    {
      typedef Pointer_Vector<Ellipsoid> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == ELLIPSOID_VECTOR)|  */

@q ***** (5) |SPHERE_VECTOR|.@>   

@ |SPHERE_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == SPHERE_VECTOR)
    {
      typedef Pointer_Vector<Sphere> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == SPHERE_VECTOR)|  */




@q ***** (5) |CUBOID_VECTOR|.@>   

@ |CUBOID_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CUBOID_VECTOR)
    {
      typedef Pointer_Vector<Cuboid> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == CUBOID_VECTOR)|  */


@q ***** (5) |POLYHEDRON_VECTOR|.@>   

@ |POLYHEDRON_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == POLYHEDRON_VECTOR)
    {
      typedef Pointer_Vector<Polyhedron> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
          pv->v.clear();
          pv->ctr = 0;
        }
      
    } /* |if (entry->type == POLYHEDRON_VECTOR)|  */


@q **** (4) Invalid |entry->type|.@>   

@ Invalid |entry->type|.
\initials{LDF Undated.}

@<Define |Scan_Parse| functions@>=


  else /* Invalid |entry->type|.  */
    {

          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::clear_vector_func':"
                    << endl
                    << "Invalid `entry->type'. Not clearing vector."
                    << endl
                    << "Exiting function with return value 1.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
      
          return 1;

    } /* |else| (Invalid |entry->type|.)  */

   return 0;

}  /* End of |Scan_Parse::clear_vector_func| definition.  */


@q ** (2) |pop_back_func|.@>
@*1 {\bf pop\_back\_func}.
\initials{LDF 2005.01.05.}

\LOG
\initials{LDF 2005.01.05.}
Added this function.

\initials{LDF 2005.12.01.}
Added code for handling |parabola_vectors|, |hyperbola_vectors|, 
|ellipsoid_vectors|, and |sphere_vectors|.

\initials{LDF 2007.07.29.}
Added code for handling |conic_section_lattice_vectors|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::pop_back_func(Scanner_Node scanner_node, 
                          Id_Map_Entry_Node entry)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::pop_back_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::pop_back_func':"
                << endl
                << "`entry' == 0."
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (entry == 0)|  */

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

  if (entry->subordinate_array == static_cast<Id_Map_Entry_Node>(0))
    {
      

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::pop_back_func':"
                << endl
                << "`entry->subordinate_array' == 0."
                << "Exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (entry->subordinate_array == 0)|  */


@q **** (4).@>   
@
@<Define |Scan_Parse| functions@>=

   stringstream name_strm;
   stringstream root_strm;
   Id_Map_Entry_Node root;
   Id_Map_Entry_Node temp_entry;

@q **** (4).@>   
@

\LOG
\initials{LDF 2005.01.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   if (entry->type == BOOLEAN_VECTOR)
    {
      typedef Pointer_Vector<bool> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == BOOLEAN_VECTOR)|  */


@q **** (4) |entry->type == NUMERIC_VECTOR|.@>   
@ |entry->type == NUMERIC_VECTOR|.
\initials{LDF 2005.01.07.}

\LOG
\initials{LDF 2005.01.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == NUMERIC_VECTOR)
    {
      typedef Pointer_Vector<real> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == NUMERIC_VECTOR)|  */


@q **** (4) |entry->type == ULONG_LONG_VECTOR|.@>   
@ |entry->type == ULONG_LONG_VECTOR|.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == ULONG_LONG_VECTOR)
    {
      typedef Pointer_Vector<ulong_long> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == ULONG_LONG_VECTOR)|  */


@q **** (4) |entry->type == STRING_VECTOR|.@>   
@ |entry->type == STRING_VECTOR|.
\initials{LDF 2005.01.09.}

\LOG
\initials{LDF 2005.01.09.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == STRING_VECTOR)
    {
      typedef Pointer_Vector<string> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == STRING_VECTOR)|  */


@q **** (4) |entry->type == PEN_VECTOR|.@>   
@ |entry->type == PEN_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == PEN_VECTOR)
    {
      typedef Pointer_Vector<Pen> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == PEN_VECTOR)|  */




@q **** (4) |entry->type == DASH_PATTERN_VECTOR|.@>   
@ |entry->type == DASH_PATTERN_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == DASH_PATTERN_VECTOR)
    {
      typedef Pointer_Vector<Dash_Pattern> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == DASH_PATTERN_VECTOR)|  */

@q **** (4) |entry->type == COLOR_VECTOR|.@>   
@ |entry->type == COLOR_VECTOR|.
@<Define |Scan_Parse| functions@>=

   else if (entry->type == COLOR_VECTOR)
    {
      typedef Pointer_Vector<Color> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == COLOR_VECTOR)|  */

@q **** (4) |entry->type == TRANSFORM_VECTOR|.@>   
@ |entry->type == TRANSFORM_VECTOR|.
\initials{LDF 2005.01.13.}

\LOG
\initials{LDF 2005.01.13.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == TRANSFORM_VECTOR)
    {
      typedef Pointer_Vector<Transform> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == TRANSFORM_VECTOR)|  */

@q **** (4) |entry->type == FOCUS_VECTOR|.@>   
@ |entry->type == FOCUS_VECTOR|.
\initials{LDF 2005.01.18.}

\LOG
\initials{LDF 2005.01.18.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


   else if (entry->type == FOCUS_VECTOR)
    {
      typedef Pointer_Vector<Focus> PV;
      PV* pv = static_cast<PV*>(entry->object);

      @<Common code for popping objects@>@;

    } /* |if (entry->type == FOCUS_VECTOR)|  */



@q **** (4).@>   
@
@<Define |Scan_Parse| functions@>=


  else if (entry->type == POINT_VECTOR)
    {
      typedef Pointer_Vector<Point> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == POINT_VECTOR)|  */


@q **** (4) |BOOL_POINT_VECTOR|.@>   

@ |BOOL_POINT_VECTOR|.
\initials{LDF 2005.01.05.}

@<Define |Scan_Parse| functions@>=


  else if (entry->type == BOOL_POINT_VECTOR)
    {
      typedef Pointer_Vector<Bool_Point> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == BOOL_POINT_VECTOR)|  */

@q **** (4) |PICTURE_VECTOR|.@>   

@ |PICTURE_VECTOR|.
\initials{LDF 2005.01.05.}

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PICTURE_VECTOR)
    {
      typedef Pointer_Vector<Picture> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == PICTURE_VECTOR)|  */


@q **** (4) |MACRO_VECTOR|.@>   

@ |MACRO_VECTOR|.
\initials{LDF 2005.01.05.}

@<Define |Scan_Parse| functions@>=


  else if (entry->type == MACRO_VECTOR)
    {
      typedef Pointer_Vector<Definition_Info_Type> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == MACRO_VECTOR)|  */


@q **** (4) |PATH_VECTOR|.@>   

@ |PATH_VECTOR|.
\initials{LDF 2005.01.06.}

\LOG
\initials{LDF 2005.01.06.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PATH_VECTOR)
    {
      typedef Pointer_Vector<Path> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == PATH_VECTOR)|  */

@q **** (4) |ELLIPSE_VECTOR|.@>   

@ |ELLIPSE_VECTOR|.
\initials{LDF 2005.01.06.}

\LOG
\initials{LDF 2005.01.06.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == ELLIPSE_VECTOR)
    {
      typedef Pointer_Vector<Ellipse> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == ELLIPSE_VECTOR)|  */


@q **** (4) |CIRCLE_VECTOR|.@>   

@ |CIRCLE_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CIRCLE_VECTOR)
    {
      typedef Pointer_Vector<Circle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == CIRCLE_VECTOR)|  */


@q **** (4) |PARABOLA_VECTOR|.@>   

@ |PARABOLA_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == PARABOLA_VECTOR)
    {
      typedef Pointer_Vector<Parabola> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == PARABOLA_VECTOR)|  */


@q **** (4) |HYPERBOLA_VECTOR|.@>   

@ |HYPERBOLA_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == HYPERBOLA_VECTOR)
    {
      typedef Pointer_Vector<Hyperbola> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == HYPERBOLA_VECTOR)|  */


@q **** (4) |CONIC_SECTION_LATTICE_VECTOR|.@>   

@ |CONIC_SECTION_LATTICE_VECTOR|.
\initials{LDF 2007.07.29.}

\LOG
\initials{LDF 2007.07.29.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CONIC_SECTION_LATTICE_VECTOR)
    {
      typedef Pointer_Vector<Conic_Section_Lattice> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == CONIC_SECTION_LATTICE_VECTOR)|  */





@q **** (4) |TRIANGLE_VECTOR|.@>   

@ |TRIANGLE_VECTOR|.
\initials{LDF 2005.01.25.}

\LOG
\initials{LDF 2005.01.25.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == TRIANGLE_VECTOR)
    {
      typedef Pointer_Vector<Triangle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == TRIANGLE_VECTOR)|  */




@q **** (4) |RECTANGLE_VECTOR|.@>   

@ |RECTANGLE_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == RECTANGLE_VECTOR)
    {
      typedef Pointer_Vector<Rectangle> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == RECTANGLE_VECTOR)|  */


@q **** (4) |REG_POLYGON_VECTOR|.@>   

@ |REG_POLYGON_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == REG_POLYGON_VECTOR)
    {
      typedef Pointer_Vector<Reg_Polygon> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == REG_POLYGON_VECTOR)|  */


@q **** (4) |ELLIPSOID_VECTOR|.@>   

@ |ELLIPSOID_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == ELLIPSOID_VECTOR)
    {
      typedef Pointer_Vector<Ellipsoid> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == ELLIPSOID_VECTOR)|  */

@q **** (4) |SPHERE_VECTOR|.@>   

@ |SPHERE_VECTOR|.
\initials{LDF 2005.12.01.}

\LOG
\initials{LDF 2005.12.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == SPHERE_VECTOR)
    {
      typedef Pointer_Vector<Sphere> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == SPHERE_VECTOR)|  */


@q **** (4) |CUBOID_VECTOR|.@>   

@ |CUBOID_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == CUBOID_VECTOR)
    {
      typedef Pointer_Vector<Cuboid> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == CUBOID_VECTOR)|  */



@q **** (4) |POLYHEDRON_VECTOR|.@>   

@ |POLYHEDRON_VECTOR|.
\initials{LDF 2005.01.14.}

\LOG
\initials{LDF 2005.01.14.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=


  else if (entry->type == POLYHEDRON_VECTOR)
    {
      typedef Pointer_Vector<Polyhedron> PV;
      PV* pv = static_cast<PV*>(entry->object);
      
      if (pv != static_cast<PV*>(0))
        {
            @<Common code for popping objects@>@;
        }
      
    } /* |if (entry->type == POLYHEDRON_VECTOR)|  */

@q **** (4) Invalid |entry->type|.@>   
@ Invalid |entry->type|.
\initials{LDF Undated.}

@<Define |Scan_Parse| functions@>=


  else /* Invalid |entry->type|.  */
    {

          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::pop_back_func':"
                    << endl
                    << "Invalid `entry->type':  "  
                    << name_map[entry->type] << "."
                    << endl << "Not popping last element.  "
                    << "Exiting function with return value 1.";
          
          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
      
          return 1;

    } /* |else| (Invalid |entry->type|.)  */

   return 0;

}  /* End of |Scan_Parse::pop_back_func| definition.  */

@q *** (3) Common code for popping objects.@>
@*2 Common code for popping objects.
\initials{LDF 2005.01.05.}

\LOG
\initials{LDF 2005.01.05.}
Added this section.  It's used in the 
|Scan_Parse::pop_back_func| definition, above.

\initials{LDF 2005.01.06.}
Minor changes.


\initials{LDF 2005.01.15.}
@:BUG FIX@> BUG FIX:
Now calling |Scanner_Type::get_array_entry| with |false| 
as the |create_if_none| argument.
\ENDLOG

@q **** (4) Code.@> 


@<Common code for popping objects@>=

   if (pv != static_cast<PV*>(0))
      {

          name_strm << entry->name << "[" << pv->ctr - 1
                    << "]";

          root_strm << entry->name << "£";

          root = scanner_node->lookup(root_strm.str());

          if (root == static_cast<Id_Map_Entry_Node>(0))
             {
                 cerr_strm << thread_name 
                           << "ERROR! In `Scan_Parse::pop_back_func':"
                           << endl
                           << "root' == 0, i.e., no `Id_Map_Entry_Node' exists "
                           << "for `" << root_strm.str() << "'."
                           << endl 
                           << "Exiting function with return value 1.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 return 1;   

             }  /* |if (root == 0)|  */


          temp_entry 
             = scanner_node->get_array_entry(name_strm.str(), 
                                             root, 
                                             false);

          if (temp_entry == static_cast<Id_Map_Entry_Node>(0))
             {
                 cerr_strm << thread_name 
                           << "ERROR! In `Scan_Parse::pop_back_func':"
                           << endl
                           << "temp_entry' == 0, i.e., no "
                           << "`Id_Map_Entry_Node' exists "
                           << "for `" << name_strm.str() << "'."
                           << endl 
                           << "Exiting function with return value 1.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 return 1;   

             }  /* |if (temp_entry == static_cast<Id_Map_Entry_Node>(0))|  */


          temp_entry->object = 0;

          delete pv->v.back();
          pv->v.pop_back();
          --pv->ctr;
      
      }  /* |if (pv != static_cast<PV*>(0))|  */

@q ** (2) |let_func|.@>
@*1 {\bf let\_func}.
\initials{LDF 2005.01.26.}

\LOG
\initials{LDF 2005.01.26.}
Added this function.

\initials{LDF 2005.01.26.}
Removed the second |string| argument.  Now collecting the |string|
by calling |yylex| and pushing |SEMI_COLON| onto 
|scanner_node->rescan_stack|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::let_func(Scanner_Node scanner_node, 
                     string s)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Entering `Scan_Parse::let_func()'."
                  << endl
                  << "`s' == " << s << ".";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

   YYSTYPE value; 
#if 0 
   YYLTYPE location; 
#endif 

   int curr_catcode;

   string t;

   for(;;)
      {

#if 0 
          curr_catcode = yylex(&value, &location, scanner_node); 
#else
          curr_catcode = yylex(&value, scanner_node); 
#endif 
         
          if (curr_catcode == SEMI_COLON)
             break;

          else
             t += scanner_node->token_string;             

      }  /* |for|  */


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name
                   << "Entering `Scan_Parse::let_func()'."
                   << endl
                   << "`t' == " << t << ".";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

      Id_Map_Entry_Node entry_0 = scanner_node->lookup(s);
      Id_Map_Entry_Node entry_1 = scanner_node->lookup(t);

      Int_Void_Ptr_Bool a(SEMI_COLON, 0, false);
      scanner_node->rescan_stack.push(a);

@q **** (4) Error handling:  |entry_1 == 0|.@>    
@ Error handling:  |entry_1 == 0|.   
\initials{LDF 2005.01.26.}

@<Define |Scan_Parse| functions@>=

   if (entry_1 == static_cast<Id_Map_Entry_Node>(0))
      {
         cerr_strm << thread_name << "ERROR!  In `Scan_Parse::let_func()':"
                   << endl << "`" << t << "' doesn't reference an "
                   << "`Id_Map_Entry_Node'." 
                   << endl << "Exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
                 
      }  /* |if (entry_1 == 0)|  */


#if DEBUG_COMPILE
   if (DEBUG)
     { 
        cerr_mutex.lock();
        entry_1->show("entry_1:", true, true);
        cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 


@q **** (4) |entry_0 != 0|.  Must discard old value.@>   
@ |entry_0 != 0|.  Must discard old value.
\initials{LDF 2005.01.26.}

@<Define |Scan_Parse| functions@>=

   if (entry_0 != static_cast<Id_Map_Entry_Node>(0))
      {
#if DEBUG_COMPILE
         if (DEBUG)
            {
               cerr_strm << thread_name << "`" << s 
                         << "' already references an `Id_Map_Entry_Node'.  "
                         << "Will discard the latter.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");

               cerr_mutex.lock(); 
               cerr << "`entry_0' before calling destructor:"
                    << endl;
               entry_0->show("entry_0:", true, true);
               cerr_mutex.unlock(); 

            }      
#endif /* |DEBUG_COMPILE|  */@; 

          entry_0->~Id_Map_Entry_Type();

      }  /* |if (entry_0 != 0)|  */

@q **** (4).@>
@ 
@<Define |Scan_Parse| functions@>=

          try 
             {
                 entry_0 = new Id_Map_Entry_Type;
             }

@q ***** (5) Error handling:  |new Id_Map_Entry_Type| failed.@> 

@ Error handling:  |new Id_Map_Entry_Type| failed.
\initials{LDF 2005.01.26.}

@<Define |Scan_Parse| functions@>=

          catch (bad_alloc)
             {
                 cerr_strm << thread_name << "ERROR!  In `Scan_Parse::let_func()':"
                           << endl << "`new Id_Map_Entry_Type' failed, "
                           << "throwing `bad_alloc'.  Rethrowing.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 throw;

             }  /* |catch (bad_alloc)|  */

@q ***** (5).@> 

         *entry_0 = *entry_1;
         entry_0->name = s;

         scanner_node->id_map_node->id_map[entry_0->name] = entry_0;


#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_mutex.lock(); 
                cerr << "`entry_0' after assignment:"
                     << endl;
                entry_0->show("entry_0:", true, true);
                cerr_mutex.unlock(); 
            }
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
   

   return 0;


}  /* End of |Scan_Parse::let_func| definition.  */

@q ** (2) |decompose_func|.@>
@*1 {\bf decompose\_func}.
\initials{LDF 2005.02.23.}

\LOG
\initials{LDF 2005.02.23.}
Started working on this function.

\initials{LDF 2005.02.24.}
Rewrote this function.  It now works.

\initials{LDF 2007.06.19.}
Added code for decomposing a |Polygon| using a |Path|.  
If the |Path| is linear, the end points are extracted, and this 
function is called recursively with the |Points| as arguments.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::decompose_func(Scanner_Node scanner_node, 
                           void* object_0, 
                           int type_0, 
                           void* object_1, 
                           int type_1,
                           void* object_2, 
                           int type_2,
                           void* vector_object,
                           int vector_type)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Entering `Scan_Parse::decompose_func()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Decompose a |Path| using a |Point|.@>   
@ Decompose a |Polygon| using a |Point|.
\initials{LDF 2007.06.19.}

\LOG
\initials{LDF 2007.06.19.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (   type_0 == PATH && type_1 == POINT 
       && type_2 == NULL_VALUE && vector_type == PATH_VECTOR)
   {
         
      cerr_strm << "In `Scan_Parse::decompose_func':"
                << endl 
                << "Decomposing a `Path' using a `Point'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

      Path*  q = static_cast<Path*>(object_0);
      Point* p = static_cast<Point*>(object_1);

@q ***** (5) Error handling:  |p == 0 || q == 0|.@> 
@ Error handling:  |p == 0 || q == 0|.
\initials{LDF 2007.06.19.}

@<Define |Scan_Parse| functions@>=

     if (p == static_cast<Point*>(0) || q == static_cast<Path*>(0))
     {
     
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::decompose_func()':"
                   << endl 
                   << "`Point* p' and/or `Path* q' is null."
                   << endl  
                   << "Deleting `p' and `q', "
                   << "setting them to 0, "
                   << "and exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         delete p;
         delete q;

         p = 0;
         q = 0;
         
         return 1;

     }  /* |if (p == 0 || q == 0)|  */

@q ***** (5)@> 

   else
   {

        /* START HERE!!  LDF 2007.06.19.  Working on this.  */ 

        status = q->decompose(p, 
                              static_cast<Pointer_Vector<Path>*>(vector_object),
                              scanner_node);

@q ****** (6)@> 

        if (status != 0)
        {
            cerr_strm << "ERROR!  In `Scan_Parse::decompose_func':"
                      << endl 
                      << "`Path::decompose' failed.";
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");


/* START HERE!!  LDF 2007.06.19.  */ 

           return 1;

        }  /* |if (status != 0)|  */

@q ****** (6)@> 

        else /* |status == 0|  */
        {
#if DEBUG_COMPILE
   if (DEBUG)
   {
            cerr_strm << "In `Scan_Parse::decompose_func':"
                      << endl 
                      << "`Path::decompose' succeeded.";
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

            return 0;
        }


   }  /* |else| */

@q ***** (5)@> 

   }  /* Decompose a |Polygon| using a |Point|  */

@q **** (4) Decompose a |Polygon| using two |Points|.@>   
@ Decompose a |Polygon| using two |Points|.
\initials{LDF Undated.}

\LOG
\initials{LDF 2007.06.19.}
@:BUG FIX@> BUG FIX:  Changed duplicate |type_1| to |type_2| 
in conditional.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   if (   type_0 == POLYGON && type_1 == POINT 
       && type_2 == POINT && vector_type == POLYGON_VECTOR)
   {
         

      Polygon* r = static_cast<Polygon*>(object_0);
      Point* p0;
      Point* p1;
      p0 = static_cast<Point*>(object_1); 
      p1 = static_cast<Point*>(object_2); 


@q ***** (5) Error handling:  |r == 0 || p0 == 0 || p1 == 0|.@>   

@ Error handling:  |r == 0 || p0 == 0 || p1 == 0|.
\initials{LDF 2005.02.21.}

@<Define |Scan_Parse| functions@>=

          if (   r == static_cast<Polygon*>(0) 
              || p0 == static_cast<Point*>(0) 
              || p1 == static_cast<Point*>(0))
             {
                 cerr_strm << thread_name 
                           << "ERROR!  In `Scan_Parse::decompose_func()':"
                           << endl 
                           << "`Polygon* r', `Point* p0', and/or "
                           << "`Point* p1' is null."
                           << endl  
                           << "Deleting `r', `p0', and `p1', "
                           << "setting them to 0, "
                           << "and exiting function with return value 1.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 delete r;
                 delete p0;
                 delete p1;

                 r = 0;
                 p1 = p0 = 0;
                 
                 return 1;

             }  /* |if (r == 0 || p0 == 0 || p1 == 0|)  */


@q ***** (5) |r != 0 && p0 != 0 && p1 != 0|.@>   

@ |r != 0 && p0 != 0 && p1 != 0|.
\initials{LDF 2005.02.21.}   

@<Define |Scan_Parse| functions@>=

   else  /* |r != 0 && p != 0 && p1 != 0|.  */ 
      {
   

         Pointer_Vector<Polygon>* pv 
            = static_cast<Pointer_Vector<Polygon>*>(vector_object); 

          try 
             {
                r->Polygon::decompose(p0, p1, pv, scanner_node);
             }

@q ****** (6).@> 

          catch (bad_alloc)
             {

                 cerr_strm << thread_name 
                           << "ERROR!  In `Scan_Parse::decompose_func()':"
                           << endl 
                           << "`Polygon::decompose()' failed, throwing "
                           << "`bad_alloc'."
                           << endl 
                           << "Deleting `Polygon* r', `Point* p0', "
                           << "`Point* p1' and `Pointer_Vector<Polygon>* pv',"
                           << endl 
                           << "setting them to 0, "
                           << "and rethrowing `bad_alloc'.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 delete r;
                 delete p0;
                 delete p1;

                 delete pv;
            

                 r = 0;
                 p1 = p0 = 0;

                 pv = 0;

                 throw;
                 
             }  /* |catch (bad_alloc)|  */


@q ****** (6).@> 

          if (pv == static_cast<Pointer_Vector<Polygon>*>(0))
             {
                 cerr_strm << thread_name 
                           << "ERROR!  In `Scan_Parse::decompose_func()':"
                           << endl 
                           << "`Polygon::decompose()' failed, returning 0.  "
                           << "Deleting `Polygon* r', `Point* p0', and "
                           << "`Point* p1', setting them to 0,"
                           << endl 
                           << "and exiting function with return value 1.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");

                 delete r;
                 delete p0;
                 delete p1;

                 r = 0;
                 p1 = p0 = 0;

                 return 1;

             }  /* |if (pv == 0)|  */

@q ****** (6).@> 

         else  /* |pv != static_cast<PV*>(0)|  */
            {

                delete r;
                delete p0;
                delete p1;

                return 0;
 
            }  /* |else | (|pv != static_cast<PV*>(0)|)  */

@q ****** (6).@> 

      }    /* |else| (|r != 0 && p0 != 0 && p1 != 0|).  */ 

@q ***** (5).@> 

  }  /* |if (   type_0 == POLYGON && type_1 == POINT 
             && type_1 == POINT && vector_type == POLYGON_VECTOR)|  */


@q **** (4) Decompose a |Polygon| using a |Path|.@> 
@ Decompose a |Polygon| using a |Path|.
\initials{LDF 2007.06.19.}

\LOG
\initials{LDF 2007.06.19.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

   else if (   type_0 == POLYGON && type_1 == PATH
       && type_2 == NULL_VALUE && vector_type == POLYGON_VECTOR)
   {

@q ***** (5)@> 

#if DEBUG_COMPILE
          if (DEBUG)
             {
                 cerr_strm << thread_name 
                           << "In `Scan_Parse::decompose_func()':"
                           << endl 
                           << "Decomposing a `Polygon' using a `Path'.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm);
                 cerr_strm.str("");
             }       
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@> 

   Polygon* r = static_cast<Polygon*>(object_0);
   Path* p = static_cast<Path*>(object_1); 

@q ***** (5) Error handling:  |r == 0 || p == 0|.@>   

@ Error handling:  |r == 0 || p == 0|.
\initials{LDF 2007.06.19.}

@<Define |Scan_Parse| functions@>=

   if (r == static_cast<Polygon*>(0) || p == static_cast<Path*>(0))
   {
       cerr_strm << thread_name 
                 << "ERROR!  In `Scan_Parse::decompose_func()':"
                 << endl 
                 << "`Polygon* r' and/or `Path* p' is null."
                 << endl  
                 << "Deleting `r' and `p', setting them to 0, "
                 << "and exiting function with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete r;
       delete p;

       r = 0;
       p = 0;
       
       return 1;

   }  /* |if (r == 0 || p == 0|)  */

@q ***** (5)@> 

   else if (!p->is_linear())
   {
       cerr_strm << thread_name 
                 << "ERROR!  In `Scan_Parse::decompose_func()':"
                 << endl 
                 << "`Path* p' points to a non-linear `Path'."
                 << endl  
                 << "Deleting `r' and `p', setting them to 0, "
                 << "and exiting function with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete r;
       delete p;

       r = 0;
       p = 0;
       
       return 1;

   }  /* |else if (!p->is_linear())|  */

@q ***** (5)@> 

   else
   {

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "In `Scan_Parse::decompose_func()':"
                 << endl 
                 << "Calling |decompose_func| recursively.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
   }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;       

     Point* p0 = create_new<Point>(p->get_point(0));
     Point* p1 = create_new<Point>(p->get_last_point());

     delete p;
     p = 0;

     return decompose_func(scanner_node, 
                           object_0,
                           type_0,
                           static_cast<void*>(p0),
                           POINT,
                           static_cast<void*>(p1),
                           POINT,
                           vector_object,
                           POLYGON_VECTOR);

   }    /* |else| */

@q ***** (5)@> 

   }  /* |else if| (Decompose a |Polygon| using a |Path|)  */
 

@q **** (4) Decompose two |Polygons|.@>   
@ Decompose two |Polygons|.
\initials{LDF Undated.}

@<Define |Scan_Parse| functions@>=

   else if (   type_0 == POLYGON && type_1 == POLYGON 
            && type_2 == NULL_VALUE && vector_type == POLYGON_VECTOR)
   {


#if DEBUG_COMPILE
       if (DEBUG)
       {
           cerr_strm << thread_name 
                     << "In `Scan_Parse::decompose_func()':"
                     << endl 
                     << "Decomposing two `Polygons'.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }       
#endif /* |DEBUG_COMPILE|  */@; 


       Polygon* p0 = static_cast<Polygon*>(object_0); 
       Polygon* p1 = static_cast<Polygon*>(object_1); 
       Pointer_Vector<Polygon>* pv 
          = static_cast<Pointer_Vector<Polygon>*>(vector_object);

@q ***** (5).@> 
 
@
\LOG
\initials{LDF 2005.02.25.}
Now calling the version of |Polygon::decompose| with a |Polygon*|
argument with |true| as the |bool top_level| argument.

\initials{LDF 2005.02.28.}
Now testing return value of |Polygon::decompose|.  Deleting |pv| and
setting it to 0 if it returns a non-zero value.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

     status = p0->decompose(p1, pv, true, scanner_node);

     if (status != 0)
     {
        delete pv;
        pv = 0;
        return 1;
     }

     else 
        return 0;


@q ***** (5).@> 

   }  /* |else if (   type_0 == POLYGON && type_1 == POLYGON  
                   && type_2 == NULL_VALUE && vector_type == POLYGON_VECTOR)|  */

@q **** (4) @>   


   return 1;

}  /* End of |Scan_Parse::decompose_func| definition.  */


@q ** (2) |clip_to_func|.@>
@*1 {\bf clip\_to\_func}.
\initials{LDF 2005.08.16.}

\LOG
\initials{LDF 2005.08.16.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::clip_to_func(void* arg1,
                         void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Entering 'Scan_Parse::clip_to_func()'.";


        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   

   Output_Struct* os = scanner_node->out[Run_State::METAPOST];
   ofstream* out_stream  = static_cast<ofstream*>(os->stream_ptr);

   Path* p = static_cast<Path*>(arg1); 


@q **** (4) Error handling:  |p == 0|.@>   

@ Error handling:  |p == 0|.
\initials{LDF 2005.08.16.}

@<Define |Scan_Parse| functions@>=

   if (p == static_cast<Path*>(0))
      {
          cerr_strm << thread_name
                    << "ERROR!  In 'Scan_Parse::clip_to_func()':"
                    << endl << "'Path* p' is null.  Not clipping."
                    << endl << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      } /* |if (p == 0)|  */


@q **** (4) Error handling:  |!p->is_cycle|.@>   

@ Error handling:  |!p->is_cycle|.
\initials{LDF 2005.08.16.}

@<Define |Scan_Parse| functions@>=


   if (!p->is_cycle())
      {
          cerr_strm << thread_name
                    << "ERROR!  In 'Scan_Parse::clip_to_func()':"
                    << endl << "The clipping 'Path' isn't a cycle.  "
                    << "Not clipping."
                    << endl << "Exiting function with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 0;

      } /* |if (!p->is_cycle())|  */

@q **** (4) @>   


   p->apply_transform();  
  
   vector<Point*>::const_iterator point_iter = p->points.begin();
   vector <string>::iterator connector_iter = p->connectors.begin();

  string connector_string;

  if (p->connectors.size() > 0)
      connector_string = *connector_iter++;
    else
      connector_string = "--";

  *out_stream << "clip currentpicture to "
              << "(" << (*point_iter)->get_x('w', false, false)
              << "cm, "
              << (*point_iter)->get_y('w', false, false)
              << "cm)";

  ++point_iter;

  for (unsigned short counter = 2; 
       point_iter != p->points.end(); 
       ++point_iter)
      {

          *out_stream << " " << connector_string << " " 
                      << "(" << (*point_iter)->get_x('w', false, false)
                      << "cm, "
                      << (*point_iter)->get_y('w', false, false)
                      << "cm)";


          /* This breaks the line and indents after two points */
        
          if  (counter == 2 && point_iter != p->points.end())
            {
              *out_stream << "\n  ";
              counter = 1;
            }
          else
            {
              ++counter;
            }
          if (connector_iter != p->connectors.end())
            connector_string = *connector_iter++;
      }

@q ***** (5)@>  

@ Double-checking here.  |p| should always be a cycle.
\initials{LDF 2005.08.16.}

@<Define |Scan_Parse| functions@>=


    if (p->is_cycle())
      *out_stream << "   " << connector_string 
                  << " cycle";

@q ***** (5)@>  

   *out_stream << ";" << endl << flush;

@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Exiting 'Scan_Parse::clip_to_func()'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   

   return 0;

}  /* End of |Scan_Parse::clip_to_func| definition.  */


@q ** (2) |measure_text_func|.@>
@*1 {\bf measure\_text\_func}.
\initials{LDF 2005.08.29.}

\LOG
\initials{LDF 2005.08.29.}
Added this function.

\initials{LDF 2005.08.30.}
Replaced the argument |real* r| with |Pointer_Vector<real>* pv|.

\initials{LDF 2005.08.31.}
Now looking up the predefined |Id_Map_Entry_Node|
|measure_text_header|.  If it exists, and its |object| element is non-null,
the |string| it refers to is written to |tex_file| following
the \.{\char`\\batchmode} and \.{\char`\\newlinechar} commands, but before
setting the hbox containing |*s|.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::measure_text_func(Scanner_Node scanner_node,
                              void* v,
                              Pointer_Vector<real>* pv)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   int status;

@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Entering 'Scan_Parse::measure_text_func()'.";


        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

   string* s = static_cast<string*>(v); 

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                   << "`s' == " << *s << endl;

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   int fd; 
   char tex_file_name[] = "aXXXXXX";
   fd = mkstemp(tex_file_name);
   close(fd);

@q **** (4) @>   

   char measurement_file_name[12];
   char dvi_file_name[12];
   char log_file_name[12];

   ifstream measurement_file;

   while (true)
      {
          strcpy(measurement_file_name, "bXXXXXX");
          fd = mkstemp(measurement_file_name);
          close(fd);
          remove(measurement_file_name);
          strcat(measurement_file_name, ".tex");  
          measurement_file.open(measurement_file_name);

@q ***** (5)@>  

          if (measurement_file.is_open())
             {
#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                           cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                                     << endl 
                                     << measurement_file_name << " exists.  Will try new name." 
                                     << endl;

                           log_message(cerr_strm);
                           cerr_message(cerr_strm);
                           cerr_strm.str("");          
                   }      
#endif /* |DEBUG_COMPILE|  */@; 

                measurement_file.close();
                remove(measurement_file_name);

             }  /* |if (measurement_file.is_open())|  */

@q ***** (5)@>  

          else /* |!measurement_file.is_open|  */
             {

#if DEBUG_COMPILE
                 if (DEBUG)
                   {
                           cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                                     << endl 
                                     << measurement_file_name << " isn't open.  Breaking." 
                                     << endl;

                           log_message(cerr_strm);
                           cerr_message(cerr_strm);
                           cerr_strm.str("");         
                   }      
#endif /* |DEBUG_COMPILE|  */@; 
 
                 measurement_file.close();

                 break;

             }  /* |else| (|!measurement_file.is_open|)  */

      }  /* |while (true)|  */


@q **** (4) @>   

   strcpy(dvi_file_name, tex_file_name);
   strcat(dvi_file_name, ".dvi");

   strcpy(log_file_name, tex_file_name);
   strcat(log_file_name, ".log");

@q **** (4) @>   

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                   << "tex_file_name == " 
                   << tex_file_name << endl
                   << "dvi_file_name == " 
                   << dvi_file_name << endl
                   << "log_file_name == " 
                   << log_file_name << endl
                   << "measurement_file_name == " 
                   << measurement_file_name << endl;

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

   Id_Map_Entry_Node header_entry = scanner_node->lookup("measure_text_header");

   string header_string = "";


   if (header_entry && header_entry->object)
      {
          header_string = *static_cast<string*>(header_entry->object);
      }

@q **** (4) @>   

   ofstream tex_file;
   tex_file.open(tex_file_name);

   tex_file << "\\batchmode" << endl 
            << "\\newlinechar=`^^J" << endl 
            << header_string << endl      
            << "\\newbox\\TTEXTBOX" << endl 
            << "\\setbox\\TTEXTBOX=\\hbox{"
            << *s << "}" << endl 
            << "\\newwrite\\outfile" << endl 
            << "\\openout\\outfile="
            << measurement_file_name
            << endl
            << "\\write\\outfile{\\the\\wd\\TTEXTBOX^^J"
            << "\\the\\ht\\TTEXTBOX^^J\\the\\dp\\TTEXTBOX}"
            << endl << "\\closeout\\outfile" << endl
            << "\\bye" << endl;

   tex_file.close();


   stringstream command_string;

   command_string << "tex " << tex_file_name << " > /dev/null";


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                   << endl 
                   << "`command_string.str().c_str()' == " 
                   << command_string.str().c_str() << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q **** (4) @>   

   status = system(command_string.str().c_str());

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                   << endl 
                   << "`status'  == " << status << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Error handling:  |system| failed.@>  
@ Error handling:  |system| failed.
\initials{LDF 2005.08.30.}

@<Define |Scan_Parse| functions@>=

   if (status != 0)
      {
          cerr_strm << thread_name << "ERROR!  In `Scan_Parse::measure_text_func()':"
                    << endl 
                    << "`system(" << command_string.str() << ")' failed, returning " 
                    << status << "." << endl
                    << endl << "Deleting `pv', setting it to 0, and exiting function "
                    << "unsuccessfully with return value 1.";

          delete pv;
          pv = 0;
          delete s;
          s = 0;
          v = 0;

          remove(tex_file_name);
          remove(measurement_file_name);

          remove(dvi_file_name);
          remove(log_file_name);

          return 1;
 
      }   /* |if (status != 0)|  */


@q **** (4) @>   
@
@<Define |Scan_Parse| functions@>=

    measurement_file.clear();

    measurement_file.open(measurement_file_name);

@q ***** (5)@>  

   if (measurement_file.is_open())
      {
   
#if DEBUG_COMPILE
          if (DEBUG)
            {
                cerr_strm << thread_name << "In `Scan_Parse::measure_text_func()':"
                          << endl 
                          << measurement_file_name << " is open.  Will read.";

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
            }    
#endif /* |DEBUG_COMPILE|  */@; 
 

          real* wd = new real;
          real* ht = new real;
          real* dp = new real;

          string discard_string;

          measurement_file >> *wd >> discard_string >> *ht >> discard_string >> *dp;

          *wd *= 2.54 / 72.27;
          *ht *= 2.54 / 72.27;
          *dp *= 2.54 / 72.27;

          *pv += wd; 
          *pv += ht;
          *pv += dp;

          measurement_file.close();                   

      }  /* |if (measurement_file.is_open())|  */

@q ***** (5)@>  

   else /* |!measurement_file.is_open|  */
      {

          cerr_strm << thread_name << "ERROR!  In `Scan_Parse::measure_text_func()':"
                    << endl 
                    << measurement_file_name << " isn't open.  "
                    << "Can't read measurements."
                    << endl << "Deleting `pv', setting it to 0, and exiting function "
                    << "unsuccessfully with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          delete pv;
          pv = 0;
          delete s;
          s = 0;
          v = 0;

          remove(tex_file_name);
          remove(measurement_file_name);

          remove(dvi_file_name);
          remove(log_file_name);

          return 1;
                         
      }  /* |else|  (|!measurement_file.is_open|)  */


@q **** (4) @>   


#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Exiting 'Scan_Parse::measure_text_func()' "
                  << "successfully with return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   

   delete s;
   s = 0;
   v = 0;

   remove(tex_file_name);
   remove(measurement_file_name);

   remove(dvi_file_name);
   remove(log_file_name);

    return 0;

}  /* End of |Scan_Parse::measure_text_func| definition.  */


@q ** (2) |numeric_vector_assignment_func|.@>
@*1 {\bf numeric\_vector\_assignment\_func}.
\initials{LDF 2005.08.30.}

\LOG
\initials{LDF 2005.08.30.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

void*
Scan_Parse::numeric_vector_assignment_func(Scanner_Node scanner_node,
                                           void* v,
                                           void* w)

{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   int status;

   using namespace Scan_Parse;

@q **** (4).@>

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(v); 

@q ****** (6) Error handling for the case that |entry == 0|.@>

@ Error handling for the case that |entry == 0 |.
\initials{LDF 2005.01.07.}

@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name 
                << "ERROR!  In `numeric_vector_assignment_func()':"
                << endl 
                << "`entry' is invalid. "
                << "Can't assign to it."
                << endl << "Returning 0.";
                
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 0;

    } /* |if (entry == 0)|  */

@q ****** (6) |entry != 0|.@>   

@ |entry != 0|.
\initials{LDF 2005.01.07.}

@<Define |Scan_Parse| functions@>=

  else /* |entry != 0|  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `numeric_vector_assignment_func()':"
                    << endl 
                    << "`entry' is valid.";
                
          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

   typedef Pointer_Vector<real> PV;
 
   PV* pv = static_cast<PV*>(w);

   PV* entry_pv = static_cast<PV*>(entry->object);

   if (entry_pv)
      {
         entry_pv->clear(true);
      }

   
   status = vector_type_assign<real, real>(scanner_node,
                                           entry,
                                           pv);

@q ******* (7) Error handling:                           @> 
@q ******* (7) |Scan_Parse::vector_type_assign| failed.@> 

@ Error handling:  |Scan_Parse::vector_type_assign| 
failed. 
\initials{LDF 2005.01.07.}

@<Define |Scan_Parse| functions@>=
                            

    if (status != 0)
         {
            cerr_strm << thread_name 
                      << "ERROR!  In `numeric_vector_assignment_func()':"
                      << endl 
                      << "`Scan_Parse::vector_type_assign()' failed."
                      << endl << "Deleting `pv' "
                      << "and returning 0.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            delete pv;

            return 0;

         } /* |if (status != 0)|  */

@q ******* (7) |Scan_Parse::vector_type_assign| succeeded.@> 

@ |Scan_Parse::vector_type_assign| succeeded. 
\initials{LDF 2005.01.07.}

@<Define |Scan_Parse| functions@>=

   else /* |status == 0|  */
      {
         delete pv;

         return static_cast<void*>(entry->object); 
 
      }  /* |else| (|status == 0|)  */


   }   /* |else| (|entry != 0|)  */


@q ****** (6).@> 

}  /* End of |Scan_Parse::numeric_vector_assignment_func| definition.  */



@q ** (2) |binary_number_string_func|.@>
@*1 {\bf binary\_number\_string\_func}.
\initials{LDF 2005.09.09.}

\LOG
\initials{LDF 2005.09.09.}
Added this function.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.09.09.}
I'm having problems with this.  Find out why.
|bitsets| seem not to work correctly for |long longs|. 
It also seems that converting floating point type numbers to 
integral types is causing problems.
\ENDTODO 

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

string*
Scan_Parse::binary_number_string_func(real r, Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   int status;

   using namespace Scan_Parse;

@q **** (4).@>

  numeric_limits<short> s;
  numeric_limits<int> i;
  numeric_limits< long> l;
  numeric_limits<long long> ll;

@q **** (4) @>   

/* !! START HERE.  LDF 2005.09.10.  Get code from ttemp.web.  */@; 


   short sign = (r >= 0) ? 1 : -1;

   double e = fabs(r);

   if (e != floor(e))
      {
          e += .5;
          e = floor(e);
      }

    e *= sign;

@q **** (4) @>   

    if (e > ll.max() || e < ll.min()) 
       {
           cerr_strm << thread_name 
                     << "ERROR!  "
                     << "In `Scan_Parse::binary_number_string_func()':"
                     << endl 
                     << "The magnitude of `r' is "
                     << "too large."
                     << endl 
                     << "Exiting function with return value 0.";

           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           return 0;
       }

@q **** (4) @>   

  string* str = 0;

@q ***** (5)@>  

  if ((e >= 0 && e <= s.max()) || (e < 0 && e >= s.min()))
     {

#if DEBUG_COMPILE
        if (DEBUG)
          {
               cerr_strm << thread_name 
                          << "In `Scan_Parse::binary_number_string_func()':"
                          << endl 
                          << "Using `short'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }  
#endif /* |DEBUG_COMPILE|  */@; 
 



         str = sub_binary_number_string_func<short>(static_cast<short>(e), 
                                             scanner_node);
     }

@q ***** (5)@>  

  else if ((e >= 0 && e <= i.max()) || (e < 0 && e >= i.min()))
     {


#if DEBUG_COMPILE
        if (DEBUG)
          {
               cerr_strm << thread_name 
                          << "In `Scan_Parse::binary_number_string_func()':"
                          << endl 
                          << "Using `int'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }  
#endif /* |DEBUG_COMPILE|  */@; 
 


         str = sub_binary_number_string_func<int>(static_cast<int>(e),
                                             scanner_node);

     }

@q ***** (5)@>  

  else if ((e >= 0 && e <= l.max()) || (e < 0 && e >= l.min()))
     {


#if DEBUG_COMPILE
        if (DEBUG)
          {
               cerr_strm << thread_name 
                          << "In `Scan_Parse::binary_number_string_func()':"
                          << endl 
                          << "Using `long'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }  
#endif /* |DEBUG_COMPILE|  */@; 


         str = sub_binary_number_string_func<long>(static_cast<long>(e),
                                             scanner_node);

     }

@q ***** (5)@>  
@ 
\LOG
\initials{LDF 2005.09.10.}
Now passing |true| as the |oversize_switch| argument to
|sub_binary_number_string_func|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


  else if ((e >= 0 && e <= ll.max()) || (e < 0 && e >= ll.min()))
     {

#if DEBUG_COMPILE
        if (DEBUG)
          {
               cerr_strm << thread_name 
                          << "In `Scan_Parse::binary_number_string_func()':"
                          << endl 
                          << "Using `long long'.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");
          }  
#endif /* |DEBUG_COMPILE|  */@; 



         str = sub_binary_number_string_func<long long>(
                                             static_cast<long long>(e),
                                             true,
                                             scanner_node);
     }

@q ***** (5)@>  
@
@<Define |Scan_Parse| functions@>=

  else
     {
         cerr_strm << thread_name << "ERROR!  "
                   << "In `Scan_Parse::binary_number_string_func()':"
                   << endl 
                   << "`e' has Invalid type.  "
                   << "Exiting function with return value 0.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         return 0;

     }

@q **** (4) @>   

   if (str == static_cast<string*>(0))
      {
          cerr_strm << thread_name << "WARNING!  "
                    << "In `Scan_Parse::binary_number_string_func()':"
                    << endl 
                    << "`Scan_Parse::sub_binary_number_string_func()' " 
                    << "failed, returning 0."
                    << "Returning the empty `string' "
                    << "and continuing.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str("");

          str = new string("");
      }  /* |if (str == 0)|  */

@q **** (4) @>   

  return str;

}  /* End of 
      |Scan_Parse::binary_number_string_func| definition.  */

@q ** (2) |is_cycle_func|.@>
@*1 {\bf is\_cycle\_func}.
\initials{LDF 2005.10.24.}

\LOG
\initials{LDF 2005.10.24.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::is_cycle_func(void* arg1,
                          void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);
   using namespace Scan_Parse;

   int status;


@q **** (4) @>   

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr_strm << thread_name
                  << "Entering 'Scan_Parse::is_cycle_func()'.";


        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>   

    Path* p = static_cast<Path*>(arg1);

    bool* b = new bool;
      
@q **** (4) Error handling:  |p == 0|.@> 
@ Error handling:  |p == 0|.
\initials{LDF 2004.10.02.}

@<Define |Scan_Parse| functions@>=
   
   if (p == static_cast<Path*>(0))
      {

        cerr_strm << thread_name << "ERROR! In `Scan_Parse::is_cycle_func()':"
                  << endl 
                  << "`Path* p' is null."
                  << endl 
                  << "Returning `bool* b' (cast to `void*') with `*b == 0'.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        *b = 0;

        return static_cast<void*>(b);

      } /* |if (p == 0)|  */
  
@q **** (4) |p != 0|.@> 
@ |p != 0|.
\initials{LDF 2004.10.02.}

@<Define |Scan_Parse| functions@>=


   else /* |p != 0|  */
      {
         *b = p->is_cycle() ? 1 : 0;
                
         delete p;

#if DEBUG_COMPILE
        if (DEBUG)
          {
              cerr_strm << thread_name
                        << "Exiting 'Scan_Parse::is_cycle_func()'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm);
              cerr_strm.str("");
          }   

#endif /* |DEBUG_COMPILE|  */@; 

         return static_cast<void*>(b);
 
  }   /* |else| (|p != 0|)  */

@q **** (4) @>   

}  /* End of |Scan_Parse::is_cycle_func| definition.  */

@q ** (2) |is_on_sphere_func|.@>
@*1 {\bf is\_on\_sphere\_func}.
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

void*
Scan_Parse::is_on_sphere_func(void* ppoint, 
                              void* ssphere, 
                              void* parameter,
                              real tolerance)
{
   bool* b = new bool;
   Point*  p = static_cast<Point*>(ppoint);
   Sphere* s = static_cast<Sphere*>(ssphere);


   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (tolerance < 0 && scanner_node->tolerance)
      {
         tolerance = *(scanner_node->tolerance);
         delete scanner_node->tolerance;
         scanner_node->tolerance = 0;
      }

   *b = (p && s && s->is_on_sphere(p, 
                                   scanner_node, 
                                   tolerance));

   return static_cast<void*>(b); 

}  /* End of |Scan_Parse::is_on_sphere_func| definition.  */


@q ** (2) |rotate_focus_func|.@>
@*1 {\bf rotate\_focus\_func}.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this function.

\initials{LDF 2007.09.19.}
Added optional |real tolerance| argument.  The default is $-1$.

\initials{LDF 2007.09.24.}
Removed the |real tolerance| argument.  Added code.

\initials{LDF 2007.09.24.}
@:BUG FIX@> BUG FIX:  Fixed the way |axes| is set.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
int
Scan_Parse::rotate_focus_func(void* id, 
                              void* num, 
                              int axes, 
                              void* parameter)
{

    Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(id);

    real tolerance        = -1;

    if (scanner_node && scanner_node->focus_options)
    {
       if (axes == 0)
       {
           if (scanner_node->focus_options->axes != 0)
             axes = scanner_node->focus_options->axes;
           else 
             axes = Focus::FOCUS_AXES;
       }
       
       tolerance = scanner_node->focus_options->tolerance;

       delete scanner_node->focus_options;
       scanner_node->focus_options = 0;
    }

    Pointer_Vector<real>* rpv = static_cast<Pointer_Vector<real>*>(num); 

    real x = 0;
    real y = 0;
    real z = 0;

    if (rpv)
    {
       if (rpv->ctr > 0)
          x = *rpv->v[0];
       if (rpv->ctr > 1)
          y = *rpv->v[1];
       if (rpv->ctr > 2)
          z = *rpv->v[2];

       delete rpv;

    }  /* |if (rpv)|  */

    if (entry && entry->object)
    {
        static_cast<Focus*>(entry->object)->rotate(x, 
                                                   y, 
                                                   z, 
                                                   axes, 
                                                   tolerance,
                                                   static_cast<Scanner_Node>(parameter));
    } /* |if (entry && entry->object)|  */

}  /* |Scan_Parse::rotate_focus_func|  */

@q ** (2) |sphere_line_intersection_func|.@> 
@*1  {\bf sphere\_line\_intersection\_func}.
\initials{LDF 2005.10.28.}

\LOG
\initials{LDF 2005.10.28.}
Added this function.

\initials{LDF 2005.10.29.}
Finished this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

void*
Scan_Parse::sphere_line_intersection_func(Sphere* s, Path* p, void* parameter)
{

#if 0 
    cerr << "Entering `Scan_Parse::sphere_line_intersection_func()'." << endl;
#endif 

    if (!(p && s && p->is_linear()))
       {
          delete s;
          s = 0;
          delete p;
          p = 0;

          return 0;
       }

     Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);
    
     Bool_Point_Pair bpp = s->intersection_points(*p, scanner_node);

     Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;

     Bool_Point* bp = new Bool_Point;

     *bp = bpp.first;
     *bpv += bp;

     bp = new Bool_Point;
     *bp = bpp.second;
     *bpv += bp;  

     delete s;
     s = 0;

     delete p;
     p = 0;

#if 0 
    cerr << "Exiting `Scan_Parse::sphere_line_intersection_func()'." << endl;
#endif 

    return static_cast<void*>(bpv);

}  /* End of |Scan_Parse::sphere_line_intersection_func| definition.  */

@q ** (2) |plane_intersection_func|.@> 
@*1  {\bf plane\_intersection\_func}.
\initials{LDF 2007.10.06.}

\LOG
\initials{LDF 2007.10.06.}
Added this function.
\ENDLOG

@q ** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::plane_intersection_func(void* v, void* w, void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4)@>

   Plane* p = static_cast<Plane*>(v);
   Plane* q = static_cast<Plane*>(w);

@q **** (4) Error handling:  |p == 0 || q == 0|.@>
@ Error handling:  |p == 0 || q == 0|.
\initials{LDF 2007.10.06.}
@<Define |Scan_Parse| functions@>=

  if (p == static_cast<Plane*>(0) || q == static_cast<Plane*>(0))
  {
      cerr_strm << "ERROR!  In `Scan_Parse::plane_intersection_func:'"
                << endl 
                << "At least one argument is null."
                << endl
                << "Exiting function unsuccessfully with return value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      delete p;
      delete q;

      return 0;
                
  } /* |if (!p || !q)|  */


@q **** (4)@>

   Line L = p->intersection_line(*q, scanner_node);

@q **** (4) Error handling:  |Plane::intersection_line| returned |INVALID_LINE|.@>
@ Error handling:  |Plane::intersection_line| returned |INVALID_LINE|.
\initials{LDF 2007.10.06.}
@<Define |Scan_Parse| functions@>=

   if (L == INVALID_LINE)
   {

       cerr_strm << "ERROR!  In `Scan_Parse::plane_intersection_func:'"
                 << endl 
                 << "At least one argument is null."
                 << endl
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete p;
       delete q;

       return 0;

   }  /* |if (L == INVALID_LINE)|  */

@q **** (4)@>
@
@<Define |Scan_Parse| functions@>=
   
   else /* |L != INVALID_LINE|  */

      return static_cast<void*>(create_new<Path>(L.get_path())); 

}  /* End of |Scan_Parse::plane_intersection_func| definition.  */

@q ** (2) |polyhedron_get_net_func|.@> 
@*1 {\bf polyhedron\_get\_net\_func}.
\initials{LDF 2005.12.20.}

\LOG
\initials{LDF 2005.12.20.}
Added this function.

\initials{2008.12.30.}
Added code for |Icosahedron|.
\ENDLOG

@q ** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

void*
Scan_Parse::polyhedron_get_net_func(int type,
                                    real diameter,
                                    int do_half, 
                                    void* parameter)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

   vector<Reg_Polygon*> v;

@q ***** (5) |Dodecahedron|.@>
@ |Dodecahedron|.
\initials{LDF 2007.10.11.}

\LOG
\initials{LDF 2007.10.11.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

    if (type == DODECAHEDRON)
    {
        v = Dodecahedron::get_net(diameter, 
                                  static_cast<bool>(do_half),
                                  scanner_node);
    }


@q ***** (5) |Icosahedron|.@>
@ |Icosahedron|.
\initials{2008.12.30.}

\LOG
\initials{2008.12.30.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

    else if (type == ICOSAHEDRON)
    {
        v = Icosahedron::get_net(diameter, 
                                 static_cast<bool>(do_half),
                                 scanner_node);
    }


@q ***** (5) |Great_Rhombicosidodecahedron|@>
@ |Great_Rhombicosidodecahedron|.
@
@<Define |Scan_Parse| functions@>=

    else if (type == GREAT_RHOMBICOSIDODECAHEDRON)
    {

        v = Great_Rhombicosidodecahedron::get_net(
                                 diameter, 
                                 static_cast<bool>(do_half),
                                 scanner_node);
    }


@q ***** (5) |Rhombic_Triacontahedron|@>
@ |Rhombic_Triacontahedron|.
\initials{LDF 2007.10.22.}

\LOG
\initials{LDF 2007.10.22.}
Added this section.  
\ENDLOG

@<Define |Scan_Parse| functions@>=

    else if (type == RHOMBIC_TRIACONTAHEDRON)
    {
  
        Pointer_Vector<Polygon>* pv = 
           Rhombic_Triacontahedron::get_net(0,
                                            static_cast<bool>(do_half),
                                            scanner_node);

        return static_cast<void*>(pv); 
    }

@q ***** (5)@>

    else 
    {
           cerr_strm << thread_name 
                     << "ERROR!  In `Scan_Parse::polyhedron_get_net_func():'"
                     << endl 
                     << "`type' == " << name_map[type] << " (" << type << ")"
                     << endl 
                     << "Can't handle this case yet."
                     << endl
                     << "Exiting function unsuccessfully with return value 0.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");                

            return 0;

    }   /* |else|  */

@q ***** (5)@>

    if (v.size() <= 0)
       return 0;

    Pointer_Vector<Reg_Polygon>* pv = new Pointer_Vector<Reg_Polygon>;
 

    for (vector<Reg_Polygon*>::iterator iter = v.begin();
         iter != v.end();
         ++iter)
       *pv += *iter;

    v.clear();

    return pv;

}  /* End of |Scan_Parse::polyhedron_get_net_func|
      definition.  */

@q ** (2) Get hyperbola branch.@> 
@*1 Get hyperbola branch.
\initials{LDF 2007.07.09.}

\LOG
\initials{LDF 2007.07.09.}
Added this function.
\ENDLOG

@q ** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::get_hyperbola_branch_func(real r, void* v, void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);


   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4) Error handling:  |void* v| is null.@> 
@ Error handling:  |void* v| is null.
@
@<Define |Scan_Parse| functions@>=

   if (v == static_cast<void*>(0))
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::get_hyperbola_branch_func':"
                 << endl 
                 << "`void* v' is null.  No hyperbola from which to get branch."
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 0;

   }  /* |if (v == 0)|  */


@q **** (4).@>

    Hyperbola* h = static_cast<Hyperbola*>(v);

@q **** (4) Error handling:  |r < 0 || r > 1|.@>

   if (r < 0 || r > 1)
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::get_hyperbola_branch_func':"
                 << endl 
                 << "Invalid branch number:  " << r 
                 << endl
                 << "It must be either 0 or 1."
                 << endl 
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete h;
       h = 0;
   
       return 0;

   }  /* |if (r < 0 || r > 1)|  */


@q **** (4)@> 

   Path* p = h->get_branch(static_cast<unsigned short>(r), scanner_node);

@q **** (4) |Hyperbola::get_branch| failed.@> 
@ |Hyperbola::get_branch| failed.
\initials{LDF 2007.07.09.}

@<Define |Scan_Parse| functions@>=

   if (p == static_cast<Path*>(0))
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::get_hyperbola_branch_func':"
                 << endl 
                 << "`Hyperbola::get_branch' failed, returning 0."
                 << endl
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete h;
       h = 0;
   
       return 0;

   }  /* |if (p == 0)|  */

@q **** (4) |Hyperbola::get_branch| succeeded.@> 
@ |Hyperbola::get_branch| succeeded.
\initials{LDF 2007.07.09.}

@<Define |Scan_Parse| functions@>=

   else  /* |p != 0|  */
   {

       delete h;
       h = 0;

      return static_cast<void*>(p); 
    
   }  /* |else| (|p != 0|)  */
      
@q **** (4)@>    

}  /* End of |Scan_Parse::get_hyperbola_branch_func| definition.  */

@q ** (2) Get conic section lattice.@> 
@*1 Get conic section lattice.
\initials{LDF 2007.08.05.}

\LOG
\initials{LDF 2007.08.05.}
Added this function.
\ENDLOG

@q ** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=
void* 
Scan_Parse::get_conic_section_lattice_func(Pointer_Vector<Point>* pv, 
                                           Scanner_Node scanner_node,
                                           Conic_Section_Lattice_Options* options)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    bool do_cull;
    bool do_rectify;    
    real tolerance;
    bool do_test;
    bool do_transform; 
    Transform* t = 0;        

@q ***** (5)@> 

    if (scanner_node && scanner_node->conic_section_lattice_options)
    {
        do_cull      = scanner_node->conic_section_lattice_options->do_cull;
        do_rectify   = scanner_node->conic_section_lattice_options->do_rectify;     
        tolerance    = scanner_node->conic_section_lattice_options->tolerance;     
        do_test      = scanner_node->conic_section_lattice_options->do_test;
        do_transform = scanner_node->conic_section_lattice_options->do_transform;
        t            = scanner_node->conic_section_lattice_options->transform; 
        scanner_node->conic_section_lattice_options->transform = 0; 
    }

@q ***** (5)@> 

    else
    {
        do_cull      = true;
        do_rectify   = true;    
        tolerance    = -1;   
        do_test      = true;
        do_transform = true;
        t            = 0;     
    }   

@q **** (4)@> 

    if (scanner_node)
    {
       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;
    }

@q **** (4)@> 

    Conic_Section_Lattice* c = pv->get_conic_section_lattice(scanner_node,
                                                             do_cull,
                                                             do_rectify,
                                                             tolerance,
                                                             do_test,
                                                             do_transform,
                                                             t);            


   return static_cast<void*>(c);

}  /* |Scan_Parse::get_conic_section_lattice_func| definition.  */


@q ** (2) Traverse |Conic_Section_Lattice|.@> 
@*1 Traverse {\bf Conic\_Section\_Lattice}.
\initials{LDF 2007.08.08.}

\LOG
\initials{LDF 2007.08.08.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| functions@>=

void* 
Scan_Parse::traverse_conic_section_lattice_func(void* parameter,
                                                void* c,
                                                real start, 
                                                real end)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::traverse_conic_section_lattice_func'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) Error handling:  |c == 0|.@>
@ Error handling:  |c == 0|.
\initials{LDF 2007.08.08.}

@<Define |Scan_Parse| functions@>=

    if (c == static_cast<void*>(0))
    {
        cerr_strm << thread_name << "ERROR!  "
                  << "In `Scan_Parse::traverse_conic_section_lattice_func':"
                  << endl
                  << "`void* c' argument is null.  No `Conic_Section_Lattice' "
                  << "to traverse."
                  << endl 
                  << "Exiting function unsuccessfully with return value 0.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         if (scanner_node)
         {
            delete scanner_node->conic_section_lattice_options;
            scanner_node->conic_section_lattice_options = 0;
         }

         return 0;

    }  /* |if (c == 0)|  */

@q **** (4)@> 
@
@<Define |Scan_Parse| functions@>=

  
    Conic_Section_Lattice* lattice 
       = static_cast<Conic_Section_Lattice*>(c); 

    Pointer_Vector<Point>* pv 
       = lattice->traverse(start, end, scanner_node);


@q **** (4) Error handling:  |Conic_Section_Lattice::traverse| @> 
@q **** (4) returned 0.@> 

@ Error handling:  |Conic_Section_Lattice::traverse| 
returned 0.
\initials{LDF 2007.08.08.}

@<Define |Scan_Parse| functions@>=
 
   if (pv == static_cast<Pointer_Vector<Point>*>(0))
   {
       cerr_strm << thread_name << "ERROR!  "
                 << "In `Scan_Parse::traverse_conic_section_lattice_func':"
                 << endl 
                 << "`Conic_Section_Lattice::traverse' returned 0."
                 << endl  
                 << "Exiting function unsuccessfully with return value 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete lattice;
       lattice = 0;

       if (scanner_node)
       {
          delete scanner_node->conic_section_lattice_options;
          scanner_node->conic_section_lattice_options = 0;
       } 

       return 0;

   }  /* |if (pv == 0)|  */

@q **** (4)@> 
@
@<Define |Scan_Parse| functions@>=


    delete lattice;
    lattice = 0;

    if (scanner_node)
    {
       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;
    }

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name 
                 << "Exiting `Scan_Parse::traverse_conic_section_lattice_func'"
                 << endl 
                 << "successfully with return value `Pointer_Vector<Point>*'"
                 << "(cast to 0)";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    return static_cast<void*>(pv); 
   

}  /* End of |Scan_Parse::traverse_conic_section_lattice_func| 
      definition.  */

@q ** (2) Numeric Primary Rule Function 1.@>
@*1 Numeric Primary Rule Function 1.
\initials{LDF 2007.11.04.}

\LOG
\initials{LDF 2007.11.04.}
Added this function definition.
\ENDLOG

@q *** (3) Definition.@>

@<Define |Scan_Parse| functions@>=

real
Scan_Parse::numeric_primary_rule_func_1(int point_part,
                                        void* v,
                                        void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

/* This assignment is for functions that take a 
   |void* parameter| argument.  */

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::numeric_primary_rule_func_1'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  real r = 0;

  Point* p = static_cast<Point*>(v);
  
@q ****** (6) Determine which coordinate we need.  @>
@ Determine which coordinate we need.  This code depends on the fact that 
|ZPART == YPART + 1 == XPART + 2 == WPART + 3|.

\initials{LDF 2004.05.05.}

@<Define |Scan_Parse| functions@>=

  int i;
  char c;

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name 
                << "In `Scan_Parse::numeric_primary_rule_func_1':"
                << endl
                << "`point_part' == ";

      if (point_part == WPART)
         cerr_strm << "`WPART'.";
      else if (point_part == XPART)
         cerr_strm << "`XPART'.";
      else if (point_part == YPART)
         cerr_strm << "`YPART'.";
      else if (point_part == ZPART)
         cerr_strm << "`ZPART'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
  
@q ******* (7) point_part is valid.  Set value of rule.@>
@ |point_part| is valid.  Set value of rule.
\initials{LDF 2004.10.01.}

\LOG
\initials{LDF 2004.10.01.}
Now setting value of rule in this section.  
Removed the |goto| I used before.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  if (point_part >= WPART && point_part <= ZPART)
    {
      i = point_part - WPART;
      c = i + 'w';
      r = p->get_coord(c);
    }

@q ******* (7) Error handling for the case that point_part has an invalid value.  @>
@ Error handling for the case that |point_part| has an invalid value.
\initials{LDF 2004.05.05.}

@<Define |Scan_Parse| functions@>=

  else  /* |!(point_part >= WPART && point_part <= ZPART)|  */
    {

#if 1       
      cerr_strm << thread_name << "ERROR!  "
                << "In `Scan_Parse::numeric_primary_rule_func_1':"
                << endl 
                << "Rule `numeric_primary --> point_part point_primary':"
                << endl 
                << "`point_part' has invalid value: " << point_part
                << endl 
                << "Setting `numeric_primary' to 0 and will try to continue.";
                
      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
#endif 

      r = 0;

    } /* |else| (|!(point_part >= WPART && point_part <= ZPART)|)  */
  

@q ****** (6)  Delete |p|, and exit function.@>

@ Delete |p|, and exit function. 
\initials{LDF 2004.05.05.}

@<Define |Scan_Parse| functions@>=
 
  delete p;
  p = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "In `Scan_Parse::numeric_primary_rule_func_1':"
                << endl 
                << "`r' == " << r;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  return r;
  
}  /* End of |Scan_Parse::numeric_primary_rule_func_1| definition.  */

@q ** (2) Numeric List Rule Function 0.@>
@*1 Numeric List Rule Function 0.
\initials{LDF 2007.11.04.}

\LOG
\initials{LDF 2007.11.04.}
Added this function definition.

\initials{LDF 2007.11.25.}
Changed |Scanner_Type::token_real_vector| to 
|Scanner_Type->numeric_list_real_vector|.
\ENDLOG

@q *** (3) Definition.@>

@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::numeric_list_rule_func_0(void* v, void* parameter)
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "Entering `Scan_Parse::numeric_list_rule_func_0'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       if (scanner_node)
       {
           cerr_strm << thread_name << "In `Scan_Parse::numeric_list_rule_func_0':"
                     << endl 
                     << "`scanner_node->numeric_list_real_vector.size()' == " 
                     << scanner_node->numeric_list_real_vector.size();
       }
       else
       {
           cerr_strm << thread_name << "In `Scan_Parse::numeric_list_rule_func_0':"
                     << endl 
                     << "`scanner_node' or "
                     << "`scanner_node->numeric_list_real_vector.size()' is null.";
       }
       
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
               
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


  Pointer_Vector<real>* w = new Pointer_Vector<real>;

  for (vector<real>::const_iterator iter =
       scanner_node->numeric_list_real_vector.begin(); 
       iter != scanner_node->numeric_list_real_vector.end();
       ++iter)
    {
      *w += new real(*iter);
    }

    scanner_node->numeric_list_real_vector.clear();
  
#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "In `Scan_Parse::numeric_list_rule_func_0':"
                 << endl 
                 << "`w->ctr' == " << w->ctr
                 << endl 
                 << "`w->v.size()' == " << w->v.size();
         
       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
               
   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    return static_cast<void*>(w); 


}  /* End of |Scan_Parse::numeric_list_rule_func_0| definition.  */


@q ** (2) Point Primary Rule Function 0.@>
@*1 Point Primary Rule Function 0.
\initials{LDF 2007.11.04.}

\LOG
\initials{LDF 2007.11.04.}
Added this function definition.
\ENDLOG

@q *** (3) Definition.@>

@<Define |Scan_Parse| functions@>=

void*
Scan_Parse::point_primary_rule_func_0(void* v, void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

#if DEBUG_COMPILE
   if (DEBUG)
   {  
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::point_primary_rule_func_0'";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  Point* p = create_new<Point>(0);

  real x;
  real y;
  real z;

  Pointer_Vector<real>* w = static_cast<Pointer_Vector<real>*>(v); 
  
  int s = w->v.size();

#if DEBUG_COMPILE
   if (DEBUG)
   {  
      cerr_strm << thread_name 
                << "In `Scan_Parse::point_primary_rule_func_0':"
                << endl 
                << "`s' == " << s;

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling for the case that |w->v.size() <= 0|.  @>
@ Error handling for the case that |w->v.size() <= 0|.
\initials{LDF 2004.05.12.}

@<Define |Scan_Parse| functions@>=

  if (s <= 0)
    {
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::point_primary_rule_func_0':"
                   << endl 
                   << "`w->v.size()' <= 0. "
                   << "No `real' values for setting the coordinates of "
                   << "the `point_primary'." 
                   << endl
                   << "Setting `*p' to `INVALID_POINT' and returning `(void*) p'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
              
         *p = INVALID_POINT;

         delete w;

         return static_cast<void*>(p); 
      
    } /* if (s <= 0)  */@;

@q ***** (5) Warning if |w->v.size() > 3|.  @>
@ Warning if |w->v.size() > 3|.
\initials{LDF 2004.05.12.}

@<Define |Scan_Parse| functions@>=
  if (s > 3)
    {
        cerr_strm << thread_name 
                  << "WARNING!  In `Scan_Parse::point_primary_rule_func_0':"
                  << endl
                  << "w->v.size() > 3. "
                  << "Too many `real' values specified. "
                  << endl
                  << "Ignoring the extra ones and continuing.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, warning_stop_value);
        cerr_strm.str("");
      
    } /* |if (s > 3)|  */@;

@q ***** (5) Success!  @>
@ Success!

If this code is reached, then |w->v.size()| should be |>= 2|.  
If |w->v.size() < 3| (i.e., |w->v.size() == 2|), I set |z| to 0 rather than
|curr_z|.   
I may want change this in the future.
\initials{LDF 2004.05.12.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
Consider setting |z| to |curr_z| if |w->v.size() < 3|.
\initials{LDF 2004.05.12.}
\ENDTODO 

@<Define |Scan_Parse| functions@>=

  x = *(w->v[0]);

  y = (s > 1) ? *(w->v[1]) : 0;
  z = (s > 2) ? *(w->v[2]) : 0;

  p->set(x, y, z);

  for (vector<real*>::iterator iter = w->v.begin();
       iter != w->v.end();
       ++iter)
    {
      delete *iter;
    }

  w->v.clear();
  delete w;

#if DEBUG_COMPILE
   if (DEBUG)
     {
       p->show("p:");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return static_cast<void*>(p);

}  /* End of |Scan_Parse::point_primary_rule_func_0| definition.  */


@q * (1) |Conic_Section_Lattice| functions.@> 
@* {\bf Conic\_Section\_Lattice} functions.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.  The functions defined here are declared 
in \filename{cncsctlt.web}.
\ENDLOG

@q ** (2) Drawing.@> 
@*1 Drawing.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG

@q *** (3) Draw Lattice.@> 
@*2 Draw Lattice.
\initials{LDF 2007.08.16.}


The way this function is programmed is a compromise, because of the
way |Scan_Parse::drawing_command_path| works.  See below.
\initials{LDF 2007.08.20.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.20.}
Change the way |Scan_Parse::drawing_command_path| works.  Also 
put the drawing options on |Scanner_Type| into a structure, 
e.g., |struct Drawing_Options|.
\ENDTODO 

\LOG
\initials{LDF 2007.08.16.}
Added this function definition.  
The declaration is in \filename{cncsctlt.web}.

\initials{LDF 2007.08.19.}
Changed |Point*| argument to |real|.

\initials{LDF 2007.08.19.}
Made this function non-|const| because it must call 
|Conic_Section_Lattice::get_point|, which is a non-|const| function.
\ENDLOG

@q **** (4) Definition.@> 

@
@<Define |Conic_Section_Lattice| functions@>=
int
Conic_Section_Lattice::draw_lattice(real increment, void* parameter) 
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;


@q ***** (5)@>
@
@<Define |Conic_Section_Lattice| functions@>=
  
   Pen* pen_temp = 0;
   Pointer_Vector<Pen>* pen_vector_temp = 0;
   Dash_Pattern* dash_pattern_temp = 0;
   Pointer_Vector<Dash_Pattern>* dash_pattern_vector_temp = 0;
   Color* color_temp = 0;
   Color* draw_color_temp = 0;
   Color* fill_color_temp = 0;

   Pointer_Vector<Color>* color_vector_temp = 0;
   Pointer_Vector<Color>* draw_color_vector_temp = 0;
   Pointer_Vector<Color>* fill_color_vector_temp = 0;

#if 0 
   pen_ptr
   pen_vector_ptr
   dash_pattern_ptr
   dash_pattern_vector_ptr
   color_ptr
   draw_color_ptr
   fill_color_ptr
#endif 


@q ****** (6)@>

   if (scanner_node && scanner_node->pen_ptr)
      pen_temp = create_new<Pen>(static_cast<Pen*>(scanner_node->pen_ptr)); 

   if (scanner_node && scanner_node->pen_vector_ptr)
   {
      pen_vector_temp = new Pointer_Vector<Pen>;
      *pen_vector_temp = *(static_cast<Pointer_Vector<Pen>*>(
                             scanner_node->pen_vector_ptr)); 
   }


@q ****** (6)@>

   if (scanner_node && scanner_node->dash_pattern_ptr)
      dash_pattern_temp 
         = create_new<Dash_Pattern>(
              static_cast<Dash_Pattern*>(scanner_node->dash_pattern_ptr)); 

   if (scanner_node && scanner_node->dash_pattern_vector_ptr)
   {
      dash_pattern_vector_temp = new Pointer_Vector<Dash_Pattern>;
      *dash_pattern_vector_temp = *(static_cast<Pointer_Vector<Dash_Pattern>*>(
                             scanner_node->dash_pattern_vector_ptr)); 
   }

@q ****** (6)@>

   if (scanner_node && scanner_node->color_ptr)
      color_temp 
         = create_new<Color>(
              static_cast<Color*>(scanner_node->color_ptr)); 

   if (scanner_node && scanner_node->color_vector_ptr)
   {
      color_vector_temp 
         = new Pointer_Vector<Color>;
      
      *color_vector_temp 
         = *static_cast<Pointer_Vector<Color>*>(scanner_node->color_vector_ptr); 

   }

@q ****** (6)@>

   if (scanner_node && scanner_node->draw_color_ptr)
      draw_color_temp 
         = create_new<Color>(
              static_cast<Color*>(scanner_node->draw_color_ptr)); 


   if (scanner_node && scanner_node->draw_color_vector_ptr)
   {
      draw_color_vector_temp 
         = new Pointer_Vector<Color>;
      
      *draw_color_vector_temp 
         = *static_cast<Pointer_Vector<Color>*>(scanner_node->draw_color_vector_ptr); 

   }


@q ****** (6)@>

   if (scanner_node && scanner_node->fill_color_ptr)
      fill_color_temp 
         = create_new<Color>(
              static_cast<Color*>(scanner_node->fill_color_ptr)); 


   if (scanner_node && scanner_node->fill_color_vector_ptr)
   {
      fill_color_vector_temp 
         = new Pointer_Vector<Color>;
      
      *fill_color_vector_temp 
         = *static_cast<Pointer_Vector<Color>*>(scanner_node->fill_color_vector_ptr); 

   }


@q ***** (5)@>
@
@<Define |Conic_Section_Lattice| functions@>=

   signed short cycle_value = 0;
   bool do_shift = true;
   bool lattice_point_flag = false;

   if (scanner_node && scanner_node->conic_section_lattice_options)
   {
       cycle_value = scanner_node->conic_section_lattice_options->cycle_value;

       do_shift = scanner_node->conic_section_lattice_options->do_shift;

       lattice_point_flag 
          = scanner_node->conic_section_lattice_options->lattice_point_flag;

       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;

   }  /* |if|  */


@q ***** (5)@>
@
@<Define |Conic_Section_Lattice| functions@>=

   Path* q;

@q ***** (5) The Pascal line.@>
@ The Pascal line.  
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   q = get_pascal_line(increment, scanner_node);

   if (q)
   {
       drawing_command_path(scanner_node, DRAW, q);

       @<Restore pointers in |draw_lattice|@>@;

   }

@q ***** (5)@>
@ 
\LOG
@:BUG FIX@> BUG FIX:  
\initials{LDF 2007.08.20.}
Now resetting |increment| if |do_shift == true| and |increment > 1|.
In this case, |get_pascal_line| shifts the lattice.  If |increment| 
were greater than 0, it would be shifted again by |get_point|, 
below.
\ENDLOG 

\initials{LDF 2007.08.20.}

@<Define |Conic_Section_Lattice| functions@>=

   if (do_shift && increment > 1)
      increment -= floor(increment);

@q ***** (5)@>
@
@<Define |Conic_Section_Lattice| functions@>=

    Point* p = 0;

    if (increment != ZERO_REAL)
    {
        p = get_point(scanner_node, 
                      cycle_value, 
                      new real(increment), 
                      do_shift,
                      lattice_point_flag);
    }




@q ***** (5) Paths containing |F|.@>
@ Paths containing |F|.  These are only drawn if |increment != 0| and
|Conic_Section_Lattice::get_point| returned a valid |Point*|.
\initials{LDF 2007.08.19.}

@q ***** (5) CF@> 
@ $CF$.
@<Define |Conic_Section_Lattice| functions@>=

    if (p != static_cast<Point*>(0))
    {
       q = create_new<Path>(0);

       q->set(*(lattice[2]), *p);

       drawing_command_path(scanner_node, DRAW, q);

       @<Restore pointers in |draw_lattice|@>@;

    }

@q ***** (5) DF@> 
@ $DF$.
@<Define |Conic_Section_Lattice| functions@>=

    if (p != static_cast<Point*>(0))
    {

        q = create_new<Path>(0);

        q->set(*(lattice[3]), *p);

        drawing_command_path(scanner_node, DRAW, q);

        @<Restore pointers in |draw_lattice|@>@;

    }

@q ***** (5) Other |Paths|.@> 
@ Other |Paths|.
\initials{LDF 2007.08.19.}

@q ****** (6) AC@> 
@ $AC$.
@<Define |Conic_Section_Lattice| functions@>=

    q = create_new<Path>(0);

    q->set(*(lattice[0]), *(lattice[2]));

    drawing_command_path(scanner_node, DRAW, q);

    @<Restore pointers in |draw_lattice|@>@;


@q ****** (6) AE@> 
@ $AE$.
@<Define |Conic_Section_Lattice| functions@>=

    q = create_new<Path>(0);

    q->set(*(lattice[0]), *(lattice[4]));

    drawing_command_path(scanner_node, DRAW, q);

    @<Restore pointers in |draw_lattice|@>@;

@q ****** (6) BD@> 
@ $BD$.
@<Define |Conic_Section_Lattice| functions@>=

    q = create_new<Path>(0);

    q->set(*(lattice[1]), *(lattice[3]));

    drawing_command_path(scanner_node, DRAW, q);

    @<Restore pointers in |draw_lattice|@>@;

@q ****** (6) BE@> 
@ $BE$.
@<Define |Conic_Section_Lattice| functions@>=

    q = create_new<Path>(0);

    q->set(*(lattice[1]), *(lattice[4]));

    drawing_command_path(scanner_node, DRAW, q);

    @<Restore pointers in |draw_lattice|@>@;

@q ****** (6) BE@> 
@ $BE$.
@<Define |Conic_Section_Lattice| functions@>=

    q = create_new<Path>(0);

    q->set(*(lattice[1]), *(lattice[4]));

    drawing_command_path(scanner_node, DRAW, q);

@q ****** (6)@>

@q ***** (5)@> 
@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.08.20.}
Find out why deleting these pointers causes a warning at run-time:\hfil\break 
``{\tt \*\*\* glibc detected \*\*\* corrupted 
double-linked list: 0x0860c8e0 \*\*\*}''.
Not deleting them may be causing a memory leak.  However, the best way to fix 
this problem would be to change the way |Scan_Parse::drawing_command_path| works, 
as mentioned above, so I'm not going to try to fix it here.
\ENDTODO

@<Define |Conic_Section_Lattice| functions@>=


@q ***** (5)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

    delete p;

    delete pen_temp;
    delete pen_vector_temp;

    delete dash_pattern_temp;
    delete dash_pattern_vector_temp;

    delete color_temp;
    delete draw_color_temp;
    delete fill_color_temp;

    delete color_vector_temp;
    delete draw_color_vector_temp;
    delete fill_color_vector_temp;

    return 0;

}  /* End of |Conic_Section_Lattice::draw_lattice| definition.  */


@q **** (4) Restore pointers in |draw_lattice|.@> 
@*3 Restore pointers in {\bf draw\_lattice}.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this section.
\ENDLOG

@<Restore pointers in |draw_lattice|@>=

    if (pen_temp)
       scanner_node->pen_ptr = static_cast<void*>(create_new<Pen>(pen_temp)); 


/* !! Porting:  LDF 2008.10.09.  */

    if (pen_vector_temp)
    {

        Pointer_Vector<Pen>* p = new Pointer_Vector<Pen>(*pen_vector_temp); 

        scanner_node->pen_vector_ptr = static_cast<void*>(p);
    }

    if (dash_pattern_temp)
       scanner_node->dash_pattern_ptr
          = static_cast<void*>(create_new<Dash_Pattern>(dash_pattern_temp)); 

    if (dash_pattern_vector_temp)
       scanner_node->dash_pattern_vector_ptr
          = static_cast<void*>(new Pointer_Vector<Dash_Pattern>(
               *dash_pattern_vector_temp)); 

    if (color_temp)
       scanner_node->color_ptr
          = static_cast<void*>(create_new<Color>(color_temp)); 

    if (color_vector_temp)
    {

        Pointer_Vector<Color>* cv = new Pointer_Vector<Color>;

        vector<Color*>::iterator iter = color_vector_temp->v.begin();
       
        if (color_vector_temp->v.size() > 1)
           ++iter;  

        for (;iter != color_vector_temp->v.end();++iter)
           *cv += create_new<Color>(*iter);   

        scanner_node->color_vector_ptr = static_cast<void*>(cv); 

        color_vector_temp->clear();
 
        for (iter = cv->v.begin(); iter != cv->v.end(); ++iter)
           *color_vector_temp += create_new<Color>(*iter);
       
    }  /* |if (color_vector_temp)|  */


    if (draw_color_temp)
       scanner_node->draw_color_ptr
          = static_cast<void*>(create_new<Color>(draw_color_temp)); 


    if (draw_color_vector_temp)
    {

        Pointer_Vector<Color>* cv = new Pointer_Vector<Color>;

        vector<Color*>::iterator iter = draw_color_vector_temp->v.begin();
       
        if (draw_color_vector_temp->v.size() > 1)
           ++iter;  

        for (;iter != draw_color_vector_temp->v.end();++iter)
           *cv += create_new<Color>(*iter);   

        scanner_node->draw_color_vector_ptr = static_cast<void*>(cv); 

        draw_color_vector_temp->clear();
 
        for (iter = cv->v.begin(); iter != cv->v.end(); ++iter)
           *draw_color_vector_temp += create_new<Color>(*iter);
       
    }  /* |if (draw_color_vector_temp)|  */

                  
    if (fill_color_temp)
       scanner_node->fill_color_ptr
          = static_cast<void*>(create_new<Color>(fill_color_temp)); 


    if (fill_color_vector_temp)
    {

        Pointer_Vector<Color>* cv = new Pointer_Vector<Color>;

        vector<Color*>::iterator iter = fill_color_vector_temp->v.begin();
       
        if (fill_color_vector_temp->v.size() > 1)
           ++iter;  

        for (;iter != fill_color_vector_temp->v.end();++iter)
           *cv += create_new<Color>(*iter);   

        scanner_node->fill_color_vector_ptr = static_cast<void*>(cv); 

        fill_color_vector_temp->clear();
 
        for (iter = cv->v.begin(); iter != cv->v.end(); ++iter)
           *fill_color_vector_temp += create_new<Color>(*iter);
       
    }  /* |if (fill_color_vector_temp)|  */



@q **** (4)@> 


@q *** (3)@> 

@q ** (2) Labeling.@> 
@*1 Labeling.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG

@q *** (3) Label Lattice.@> 
@*2 Label Lattice.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this function definition.  
The declaration is in \filename{cncsctlt.web}.

\initials{LDF 2007.08.19.}
Now labelling the ``|X|'', ``|Y|'', and ``|Z|'' points.
In order to do this, it needs to call 
|Conic_Section_Lattice::get_pascal_points|, which isn't a |const| function.
I have therefore made this function non-|const|.

\initials{LDF 2007.08.19.}
Changed |void* ppoint| argument to |real increment|.
Now labelling ``|F|'' |Point|, if |increment != 0|.
\ENDLOG

@q **** (4) Definition.@> 

@
@<Define |Conic_Section_Lattice| functions@>=
int
Conic_Section_Lattice::label_lattice(void* parameter, 
                                     int label_type, 
                                     int label_suffix, 
                                     real increment,
                                     void* ttransform,
                                     void* ttext_color,
                                     void* ddot_color,
                                     void* eentry) 
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;


@q ***** (5)@>

   signed short cycle_value = 0;
   bool do_shift = true;
   bool lattice_point_flag = false;

   if (scanner_node && scanner_node->conic_section_lattice_options)
   {
       cycle_value = scanner_node->conic_section_lattice_options->cycle_value;

       do_shift = scanner_node->conic_section_lattice_options->do_shift;

       lattice_point_flag 
          = scanner_node->conic_section_lattice_options->lattice_point_flag;

       delete scanner_node->conic_section_lattice_options;
       scanner_node->conic_section_lattice_options = 0;

   }  /* |if|  */


@q ***** (5)@>

    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(eentry);   

    Point* p = 0;
    string* s;

    Transform* transform = 0;
    Color* text_color    = 0;
    Color* dot_color     = 0;
  
    if (ttransform)
    {
        transform = static_cast<Transform*>(ttransform); 
        ttransform = 0;
    }


    if (ttext_color)
    {
       text_color = static_cast<Color*>(ttext_color); 
       ttext_color = 0;
    }

    if (ddot_color)
    {
       dot_color = static_cast<Color*>(ddot_color); 
       ddot_color = 0;
    }

    Transform* t;
    Color*     tc;
    Color*     dc;

    label_type = (label_type == DOTLABEL_LATTICE) ? DOTLABEL : LABEL;
    
@q ***** (5)@> 
@
@<Define |Conic_Section_Lattice| functions@>=

    if (increment != ZERO_REAL)
    {

       p = get_point(scanner_node, 
                      cycle_value, 
                      new real(increment), 
                      do_shift,
                      lattice_point_flag);

       s = new string;
       *s = "$F$";

       t  = (transform)  ? create_new<Transform>(transform) : 0;
       tc = (text_color) ? create_new<Color>(text_color)    : 0;
       dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


       Scan_Parse::label_point_command(scanner_node,
                                       label_type,
                                       label_suffix,
                                       s,
                                       p,
                                       t,
                                       tc,
                                       dc,
                                       entry);

@q ****** (6)@>  

       p = 0;

    }  /* |if (increment != 0)|  */


@q ***** (5) Label the lattice points.@> 
@ Label the lattice points.
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

@q ****** (6)@> 

    p = create_new<Point>(lattice[0]);
    s = new string;
    *s = "$A$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);



@q ****** (6)@> 

    p = create_new<Point>(lattice[1]);
    s = new string;
    *s = "$B$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;

    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);





@q ****** (6)@>

    p = create_new<Point>(lattice[2]);
    s = new string;
    *s = "$C$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;

    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);

@q ****** (6)@>

    p = create_new<Point>(lattice[3]);
    s = new string;
    *s = "$D$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;

    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);

@q ****** (6)@>
@  
@<Define |Conic_Section_Lattice| functions@>=

    p = create_new<Point>(lattice[4]);
    s = new string;
    *s = "$E$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);

@q ****** (6)@>
@  
@<Define |Conic_Section_Lattice| functions@>=

    p = create_new<Point>(lattice[4]);
    s = new string;
    *s = "$E$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);

@q ****** (6)@>

@q ***** (5) Get Pascal points.@> 
@ Get Pascal points.
\initials{LDF 2007.08.19.}

\LOG
\initials{LDF 2007.08.19.}
Added this section.
\ENDLOG

@<Define |Conic_Section_Lattice| functions@>=

@q ***** (5)@> 

   Pointer_Vector<Point>* pv = get_pascal_points(increment, scanner_node);

@q ****** (6) Error handling:  |Conic_Section_Lattice::get_pascal_points| @>
@q ****** (6) failed, returning 0.                                        @>
@ Error handling:  |Conic_Section_Lattice::get_pascal_points| 
failed, returning 0.
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   if (pv == static_cast<Pointer_Vector<Point>*>(0))
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::label_lattice':"
                 << endl 
                 << "`Conic_Section_Lattice::get_pascal_points' failed "
                 << "returning `(Pointer_Vector<Point>*) 0'."
                 << endl
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete transform;
       delete text_color;
       delete dot_color;

       return 1;

   }  /* |if (pv == 0)|  */

@q ****** (6) Error handling:  |*pv| contains too few |Points|.@>
@ Error handling:  |*pv| contains too few |Points|.
\initials{LDF 2007.08.19.}

@<Define |Conic_Section_Lattice| functions@>=

   if (pv->ctr < 3)
   {

       cerr_strm << thread_name << "ERROR!  "
                 << "In `Conic_Section_Lattice::label_lattice':"
                 << endl 
                 << "`Pointer_Vector<Point> *pv' contains too few points:  "
                 << "`pv-ctr' == " << pv->ctr
                 << endl      
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete transform;
       delete text_color;
       delete dot_color;

       return 1;

   }  /* |if (pv == 0)|  */


@q ****** (6) |X|.@>
@ |X|.
@<Define |Conic_Section_Lattice| functions@>=

    p = create_new<Point>(pv->v[0]);
    s = new string;
    *s = "$X$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);



@q ****** (6) |Y|.@>
@ |Y|.
@<Define |Conic_Section_Lattice| functions@>=

    p = create_new<Point>(pv->v[1]);
    s = new string;
    *s = "$Y$";

    t  = (transform)  ? create_new<Transform>(transform) : 0;
    tc = (text_color) ? create_new<Color>(text_color)    : 0;
    dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;


    Scan_Parse::label_point_command(scanner_node,
                                    label_type,
                                    label_suffix,
                                    s,
                                    p,
                                    t,
                                    tc,
                                    dc,
                                    entry);

@q ****** (6) @>
@ 
@<Define |Conic_Section_Lattice| functions@>=

    if (increment != ZERO_REAL)
    {
        p = create_new<Point>(pv->v[2]);
        s = new string;
        *s = "$Z$";

        t  = (transform)  ? create_new<Transform>(transform) : 0;
        tc = (text_color) ? create_new<Color>(text_color)    : 0;
        dc = (dot_color)  ? create_new<Color>(dot_color)     : 0;

        Scan_Parse::label_point_command(scanner_node,
                                        label_type,
                                        label_suffix,
                                        s,
                                        p,
                                        t,
                                        tc,
                                        dc,
                                        entry);

    }  /* |if (increment != 0)|  */


@q ****** (6)@>   

@q ***** (5)@> 

    delete transform;
    delete text_color;
    delete dot_color;

    return 0;

}  /* End of |Conic_Section_Lattice::label_lattice| definition.  */


@q ** (2)@> 

@q * (1) Putting additional |Scan_Parse| functions together.@>
@* Putting additional {\bf Scan\_Parse} functions together.

@q ** This is what's compiled.@>
@ This is what's compiled.
@c
@<Include files@>@;
@<Declare |namespace Scan_Parse|@>@;
@<Define |Scan_Parse| functions@>@;
@<Define |Conic_Section_Lattice| functions@>@;

@q **  This is what's written to \filename{scanprsf.h}. @>
@ This is what's written to \filename{scanprsf.h}. 
@(scanprsf.h@>=
@<Declare |namespace Scan_Parse|@>@;




@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>


  
@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
