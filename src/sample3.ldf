%%%% sample3.ldf
%%%% Created by Laurence D. Finston (LDF) Tue 29 Jun 2021 11:31:54 PM CEST

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2021 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.
  

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de

% * (1) Beginning of 3DLDF code.

%% * (1) Plotting stars on sphere development (spherical biangles)

verbatim_metapost "verbatimtex \font\largebf=cmbx12\font\Largebf=cmbx14 etex;";

macro plot_star_on_sphere_development;

picture v[];
focus f;

set f with_position (0, 20, -50) 
  with_direction (0, 20, 10) with_distance 70; 


def plot_star_on_sphere_development {numeric radius, star S} :=
  numeric a[];
  numeric b[];
  numeric diameter;
  numeric m;
  numeric n[];
  numeric bi_ang[];
  numeric middle_angle;   
  numeric min_edge_angle; 
  numeric max_edge_angle; 
  numeric height[];
  sphere s;
  point p[];
  path  q[];
  path edge[];
  circle c[];
  transform t[];
  string u[];
  bool_point_vector bpv;
  string str;
  
  u0 := common_name S;
  message "u0 (common name of S):";
  show u0;
  diameter := 2 * radius;
  message "radius:"; 
  show radius;
  message "S:";
  %show S;
  %pause;

%% Find out why using the 'set' command for 'sphere s' didn't work here.  LDF 2021.7.1.
  
  s := unit_sphere scaled (radius, radius, radius);
  rotate s (0, 22.5);
  %message "s (sphere):"; 
  %show s;
  draw s;  

  a0 := ra_decimal_degrees S;
  message "RA decimal deg. of star S (a0):";
  show a0;
  

  a1 := declination_decimal_degrees S;
  message "Declination decimal deg. S (a1):";
  show a1;

  c0 := unit_circle scaled (radius, 0, radius);
  draw c0 with_color red;

  p5 := plot S with_radius radius;
  dotlabel.rt("$p_5$", p5);        
  
  p12 := (xpart p5, 0, zpart p5);  
  dotlabel.lft("$p_{12}$", p12);  
  bpv := c0 intersection_points (origin -- p12);
  %message "bpv:";
  %show bpv;
  p13 := bpv[0];
  dotlabel.top("$p_{13}$", p13);
  p14 := bpv[1];
  dotlabel.lrt("$p_{14}$", p14);

  a40 := magnitude(p13 - p12);
  a41 := magnitude(p14 - p12);

  message "a40 (magnitude(p13 - p12)):"; 
  show a40;

  message "a41 (magnitude(p14 - p12));"; 
  show a41;

  if a40 < a41:
    p14 := p13;
  fi;

  q0 := origin -- p5 -- p14 -- cycle;

  draw q0 with_color blue;

  p34 := get_normal q0;

  message "p34 (normal of q0):";
  show p34;

  i := 1;
  q3 += p14;
  q3 += ..;
   forever:
     p35 := p14;
     message "p35 before rotating"; 
     show p35;
     p35 := p35 rotated_around (origin, p34) (i * 5);  %% Check this!  rotate_around (the command) didn't work here!  LDF 2021.7.1. 
     show p35;
     message "p35 after rotating"; 
     show p35;
     i := i + 1;
     exit_if (ypart p35) >= (ypart p5);
     q3 += p35;
     exit_if (ypart p35) >= (ypart p5);
   endfor; 

   draw q3 with_color orange;  

   a2 := circumference c0;   %% Circumference of horizontal great circle.
   a3 := arc_length (a1) c0; %% Arc length for declination of star S.

   message "a2 (circumference of red circle (horizontal great circle)):";
   show a2;

   message "a3 (arc length of arc from p14 to p5, Declination of star S (" & u0 & ")):";
   show a3;

   message "a0 (RA of Star S (" & u0 & ")):";
   show a0;


%% Get points for the divisions of the horizontal great circle.

   q2 := origin -- (radius, 0) -- p14 -- cycle;

   draw q2 dashed evenly with_color green;

   p15 := (radius, 0);
   dotlabel.urt("$0^\\circ$", p15);
   dotlabel.lrt("$360^\\circ$", p15);

   p16 := (radius, 0) rotated (0, 22.5);
   dotlabel.urt("$22.5^\\circ$", p16);

   p17 := (radius, 0) rotated (0, 45);
   dotlabel.urt("$45^\\circ$", p17);

   p18 := (radius, 0) rotated (0, 67.5);
   dotlabel.urt("$67.5^\\circ$", p18);

   p19 := (radius, 0) rotated (0, 90);
   dotlabel.urt("$90^\\circ$", p19);

   p20 := (radius, 0) rotated (0, 112.5);
   dotlabel.top("$112.5^\\circ$", p20);

   p21 := (radius, 0) rotated (0, 135.0);
   dotlabel.ulft("$135^\\circ$", p21);

   p22 := (radius, 0) rotated (0, 157.5);
   dotlabel.lft("$157.5^\\circ$", p22);

   p23 := (radius, 0) rotated (0, 180);
   dotlabel.lft("$180^\\circ$", p23);

   p24 := (radius, 0) rotated (0, 202.5);
   dotlabel.lft("$202.5^\\circ$", p24);

   p25 := (radius, 0) rotated (0, 225);
   dotlabel.lft("$225^\\circ$", p25);

   p26 := (radius, 0) rotated (0, 247.5);
   dotlabel.llft("$247.5^\\circ$", p26);

   draw origin -- p26;

   p27 := (radius, 0) rotated (0, 270);
   dotlabel.bot("$270^\\circ$", p27);

   draw origin -- p27;

   p28 := (radius, 0) rotated (0, 292.5);
   dotlabel.lrt("$292.5^\\circ$", p28);

   draw origin -- p28;

   p29 := (radius, 0) rotated (0, 315);
   dotlabel.lrt("$315^\\circ$", p29);

   p30 := (radius, 0) rotated (0, 337.5);
   dotlabel.rt("$337.5^\\circ$", p30);

   p31 := (0, ypart p5, 0);
   dotlabel.lft("$p_{31}$", p31); 

   draw p31 -- p5 with_color red;
   draw origin -- p31;

   a4 := 2 * magnitude (p31 - p5);

   set c1 with_center p31 with_diameter a4;

   draw c1 with_color cyan;

   message "a4 (diameter of c1):";
   show a4;
   
%% Find which spherical biangle or biangles (0--7) the star must be plotted on.
%% It can be 2, if the star is exactly on one of the edges.  This probably only occurs
%% rarely.
   
   if (a0 == 337.5):
     message "a0 (RA) == 337.5";
     bi_ang0 := 0;
     bi_ang1 := 7;
   elseif (a0 > 337.5) or (a0 < 22.5):
     message "a0 (RA) > 337.5 or < 22.5";
     bi_ang0 := 0;
     bi_ang1 := -1;
     middle_angle := 0;       %% This case requires special handling.
     min_edge_angle := 337.5;
     max_edge_angle := 22.5;
   elseif (a0 == 22.5):
     message "a0 (RA) == 22.5";
     bi_ang0 := 0;
     bi_ang1 := 1;
   elseif (a0 > 22.5) and (a0 < 67.5):
     message "a0 (RA) > 22.5 or a0 < 67.5";
     bi_ang0 := 1;
     bi_ang1 := -1;
     middle_angle   := 45;
     min_edge_angle := 22.5;
     max_edge_angle := 67.5;
   elseif (a0 == 67.5):
     message "a0 (RA) == 67.5";
     bi_ang0 := 1;
     bi_ang1 := 2;
   elseif (a0 > 67.5) and (a0 < 112.5):
     message "a0 (RA) > 67.5 and a0 < 112.5";
     bi_ang0 := 2;
     bi_ang1 := -1;
     middle_angle   := 90;
     min_edge_angle := 67.5;
     max_edge_angle := 112.5;
   elseif (a0 == 112.5):
     message "a0 (RA) == 112.5";
     bi_ang0 := 2;
     bi_ang1 := 3;
   elseif (a0 > 112.5) and (a0 < 157.5):
     bi_ang0 := 3;
     bi_ang1 := -1;
     middle_angle   := 135;
     min_edge_angle := 112.5;
     max_edge_angle := 157.5;
   elseif a0 == 157.5:
     message "a0 (RA) == 157.5";
     bi_ang0 := 3;
     bi_ang1 := 4;
   elseif (a0 > 157.5) and (a0 < 202.5):
     message "a0 (RA) > 157.5 and a0 < 202.5";
     bi_ang0 := 4;
     bi_ang1 := -1;
     middle_angle   := 180;
     min_edge_angle := 157.5;
     max_edge_angle := 202.5;
   elseif a0 == 202.5:
     message "a0 (RA) == 202.5";
     bi_ang0 := 4;
     bi_ang1 := 5;
   elseif (a0 > 202.5) and (a0 < 247.5):
     message "a0 (RA) > 202.5 and a0 < 247.5";
     bi_ang0 := 5;
     bi_ang1 := -1;
     middle_angle   := 225;
     min_edge_angle := 202.5;
     max_edge_angle := 247.5;
   elseif a0 == 247.5:
     message "a0 (RA) == 247.5";
     bi_ang0 := 5;
     bi_ang1 := 6;
   elseif (a0 > 247.5) and (a0 < 292.5):
     message "a0 (RA) > 247.5 and a0 < 292.5";
     bi_ang0 := 6;
     bi_ang1 := -1;
     middle_angle   := 270;
     min_edge_angle := 247.5;
     max_edge_angle := 292.5;
   elseif a0 == 292.5:
     message "a0 (RA) == 292.5";
     bi_ang0 := 6;
     bi_ang1 := 7;
   elseif (a0 > 292.5) and (a0 < 337.5):
     message "a0 (RA) > 292.5 and a0 < 337.5";
     bi_ang0 := 7;
     bi_ang1 := -1;
     middle_angle   := 315;
     min_edge_angle := 292.5;
     max_edge_angle := 337.5;
   else
     errmessage "a0 (RA) has invalid value.";
   fi;

   message "bi_ang0:"; 
   show bi_ang0;

   message "bi_ang1:"; 
   show bi_ang1;

   message "middle_angle:";
   show middle_angle;   

   message "min_edge_angle:";
   show min_edge_angle; 

   message "max_edge_angle:";
   show max_edge_angle; 
   
   p32 := (.5a4, ypart p31) rotated (0, middle_angle);
   dotlabel.llft("$p_{32}$", p32);

   p33 := (.5a4, ypart p31) rotated (0, max_edge_angle);
   dotlabel.bot("$p_{33}$", p33);
     
%% a3 (arc length of arc from p14 to p5 (Declination of star S):
%% a7 (arc length from p5 to p32):

     a5 := a0 - middle_angle;

     message "a5 (RA dec. deg. " & u0 & " - " & decimal middle_angle & "):";
     show a5;

     a6 := max_edge_angle - a0; 
     message "a6 (" & decimal max_edge_angle & " - RA dec. deg. " & u0 & "):";
     show a6;

     a7 := arc_length (a5) c1;
     message "a7 (arc length from p5 to p32):";
     show a7;

     a8 := arc_length (a6) c1;
     message "a8 (arc length from p5 to p33):";
     show a8;

   message "circumference of  c1:";
   show circumference c1;

   a10 := circumference c1 / 8;
   message "a10 (circumference c1 / 8):";
   show a10;

   v0 := current_picture;
   clear current_picture;

%% *** (3) Draw circle with declination angles in first quadrant.

   c3 := unit_circle scaled (radius, 0, radius) rotated (90, 0);
   draw c3;
   draw (-radius, 0) -- (radius, 0);
   draw (0, -radius) -- (0, radius);

   j := 10;

   for i = 11.25 step 11.25 until 78.75:
     p36 := (radius, 0);
     rotate p36 (0, 0, i);
     p37 := (0, ypart p36);
     draw p37 -- p36;
     height[j] := ypart p36;
     b[j] := magnitude (p36 - p37);
     message "b[" & decimal j & "], (magnitude (p36 - p37)):";
     show b[j];
     u1 := "$" & decimal i & "^\circ$";
     c[j] := unit_circle scaled (b[j], 0, b[j]) shifted (0, ypart p36);
     a[j] := circumference c[j] / 16;
     message "a[" & decimal j & "] (circumference of c[" & decimal j & "] divided by 16):";
     show a[j];
     message "height[" & decimal j & "] (height of c[" & decimal j & "]):";
     show height[j];
     draw c[j] with_color red;
     dotlabel.rt(u1, p36);
     draw origin -- p36;
     u1 := decimal b[j];
     dotlabel.bot(u1, mediate(p36, p37, .5));
     j += 1;
   endfor;

   v1 := current_picture;
   clear current_picture;

%% *** (3) Draw spherical biangle

   edge0 += ..;
   edge1 += ..;
   edge2 += ..;
   edge3 += ..;
  
   n0 := a2 / 8;
   n1 := a2 / 32;
   draw (-.5n0, 0) -- (.5n0, 0);
   edge0 += (-.5n0, 0);
   edge1 += (.5n0, 0);
   edge2 += (-.5n0, 0);
   edge3 += (.5n0, 0);
   draw (0, -.25a2) -- (0, .25a2);  %% Half of circumference

   if bi_ang1 == -1:

     label.urt("{\Largebf " & decimal bi_ang0 & "}", origin);
     dotlabel.llft("(0, 0)",  origin);
     dotlabel.rt("$0^\circ$", (.5n0, 0));

     label("RA $" & decimal min_edge_angle & "^\circ$", (-(.5n0 + 1), 0));
     label("RA $" & decimal max_edge_angle & "^\circ$", ((.5n0 + 1.5), 0));
     
     j := 0;
     
     for i = 10 upto 16:
       n2 := (i - 9) * n1;
       edge0 += (-a[i], n2);
       edge1 += (a[i], n2);
       edge2 += (-a[i], -n2);
       edge3 += (a[i], -n2);
       draw (-a[i], n2) -- (a[i], n2);
       draw (-a[i], -n2) -- (a[i], -n2);
       j += 11.25;
       str := "$" & decimal j & "^\circ$";
       dotlabel.rt(str, (a[i], n2));
       dotlabel.rt(str, (a[i], -n2));
     endfor;

     edge0 += (0, .25a2);
     edge1 += (0, .25a2);
     edge2 += (0, -.25a2);
     edge3 += (0, -.25a2);  

     label.top("RA $" & decimal middle_angle & "^\circ$", (0, .25a2));
     label.bot("RA $" & decimal middle_angle & "^\circ$", (0, -.25a2));
     
     draw edge0;
     draw edge1;
     draw edge2;
     draw edge3;

     a10 := circumference c1 / 8;
     
     p40 := (0, a3);
     dotlabel.ulft("$p_{40}$", p40);
     p41 := (-.5a10, ypart p40);
     p42 := (.5a10, ypart p40);

     dotlabel.lft("$p_{41}$", p41);
     dotlabel.rt("$p_{42}$", p42);
     
     draw p41 -- p42;

     p43 := ((xpart p40 + a7), ypart p40);
     draw p40 -- p43 with_color red with_pen pencircle scaled (3pt, 3pt, 3pt);
     dotlabel.bot("$p_{43}$", p43);
     label.top(u0, p43);

   else: %% bi_ang1 <> -1  %% This case requires special handling.
     
     drawdot origin with_pen pencircle scaled (3pt, 3pt, 3pt);
   fi;

  v2 := current_picture;   
  
enddef;

plot_star_on_sphere_development {3.5, vega};

beginfig(1);
  currentpicture := v0;
  label("{\\bf Perspective Projection}", (0, -4.5));
endfig with_focus f;

beginfig(2);
  currentpicture := v0;
  label("{\\bf Parallel X-Y} (Viewed from the front)", (0, -4.5));
endfig with_projection parallel_x_y; 

beginfig(3);
  currentpicture := v0;
  label("{\\bf Parallel X-Z} (Viewed from above)", (0, 0, -4.5));
endfig with_projection parallel_x_z; 

beginfig(4);
  currentpicture := v0;
  label("{\\bf Parallel Z-Y} (Viewed from the right side)", (0, -4.5));
endfig with_projection parallel_z_y; 

beginfig(5);
  currentpicture := v1;
endfig with_projection parallel_x_y; 

beginfig(6);
  current_picture := v2;
endfig with_projection parallel_x_y; 

verbatim_metapost "end";
  
end;  



  






end;

%% ** (2) *******************************************

end;

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metafont
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% eval:(setq font-lock-mode nil)
%% End:
