%%%% sample3.ldf
%%%% Created by Laurence D. Finston (LDF) Tue 29 Jun 2021 11:31:54 PM CEST

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2021 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.
  

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de

% * (1) Beginning of 3DLDF code.

%% * (1) Plotting stars on sphere development (spherical biangles)

input "sample3.lmc";

get_spherical_biangles {3.5, false};  %% Second arg. is 'do_black'.  LDF 2021.7.4.

for i = 0 upto 7:
  beginfig(i);
    output bi_ang_pict[i] with_projection parallel_x_y; 
  endfig;
endfor;

%% ** (2)

picture v[];  %% Global
numeric a[];
numeric bi_ang[];
numeric middle_angle;   
numeric min_edge_angle; 
numeric max_edge_angle;
sphere s;
point r[];
path q[];
circle c[];
transform t[];

%get_sphere_for_plotting_stars {3.5};
get_sphere_for_plotting_stars {3.5};



macro plot_star_on_sphere;

picture_vector pv;
pv++;
pv++;
pv++;
pv++;

def plot_star_on_sphere (pv) {numeric radius, star S} =

  path q[];
  string u[];
  point P[];
  
  u0 := common_name S;
  message "star S == " & u0 & ".";

  a0 := ra_decimal_degrees S;
  message "RA decimal deg. of star S (" & u0 & ") (a0):";
  show a0;

  a1 := declination_decimal_degrees S;
  message "Declination decimal deg. of star S (" & u0 & ") (a1):";
  show a1;

  P17 := r16 rotated (0, a0);
  dotlabel.top("$P_{17}$", P17) v8;
  label.lft("$P_{17}$:  RA $" & decimal a0 & "^\circ$", P17 shifted (-.75cm, 0)) v8;
  dotlabel.top("$P_{17}$", P17) v9;
  dotlabel.llft("$P_{17}$", P17) v10;
  dotlabel.top("$P_{17}$", P17) v11;

  P19 := r16 rotated (0, 0, a1);
  dotlabel.rt("$P_{19}$:  Decl.~$" & decimal a1 & "^\circ$", P19) pv0;
  dotlabel.rt("$P_{19}$:  Decl.~$" & decimal a1 & "^\circ$", P19) pv1;

  P22 := P19 rotated (0, a0);  %% a0:  RA of star S.

  q0 := origin -- P17 -- P22 --cycle;

  draw q0 with_color blue on_picture pv0;
  draw q0 with_color blue on_picture pv1;
  draw q0 with_color blue on_picture pv2;
  draw q0 with_color blue on_picture pv3;

  P23 := get_normal q0;
  show P23;

  q1 += ..;

  t0 := identity rotated_around (origin, P23) 3;

  P24 := P17 transformed t0; 

  if (magnitude (P22 - P24)) > (magnitude (P22 - P17)):
    invert t0;
  fi;

  forever:
    P24 *= t0;
    exit_if magnitude(ypart P24) >= magnitude(ypart P22);
    q1 += P24;
  endfor;

  draw q1 on_picture pv0 with_pen pencircle scaled (2pt, 2pt, 2pt) with_color orange;
  draw q1 on_picture pv1 with_pen pencircle scaled (2pt, 2pt, 2pt) with_color orange;
  draw q1 on_picture pv3 with_pen pencircle scaled (2pt, 2pt, 2pt) with_color orange;

  dotlabel.lft("$P_{22}$", P22) pv0;
  dotlabel.lft("$P_{22}$", P22) pv1;
  dotlabel.lft("$P_{22}$", P22) pv2;
  dotlabel.lft("$P_{22}$", P22) pv3;
  
enddef;

plot_star_on_sphere (pv) {3.5, hadar};
plot_star_on_sphere (pv) {3.5, sirius};
  
%% *** (3)

focus f;

set f with_position (0, 20, -50) 
  with_direction (0, 20, 10) with_distance 70; 

beginfig(8);
  %rotate v8 (0, 70);
  current_picture := v8;
  current_picture += pv0;
  %dotlabel.rt("
  label("{\\bf Perspective Projection}", (0, -4.5));
endfig with_focus f;

beginfig(9);
  currentpicture := v9;
  current_picture += pv1;
  label("{\\bf Parallel X-Y} (Viewed from the front)", (0, -4.5));
endfig with_projection parallel_x_y; 

beginfig(10);
  currentpicture := v10;
  current_picture += pv2;
  label("{\\bf Parallel X-Z} (Viewed from above)", (0, 0, -4.5));
endfig with_projection parallel_x_z; 

beginfig(11);
  currentpicture := v11;
  current_picture += pv3;  
  label("{\\bf Parallel Z-Y} (Viewed from the right side)", (0, -4.5));
endfig with_projection parallel_z_y; 

verbatim_metapost "end";
  
end;  

%% *** (3)





%% Find which spherical biangle or biangles (0--7) the star must be plotted on.
%% It can be 2, if the star is exactly on one of the edges.  This probably only occurs
%% rarely.

message "a0 (RA of star S in decimal degrees):";
show a0;

if (a0 == 337.5):
  message "a0 (RA) == 337.5";
  bi_ang0 := 0;
  bi_ang1 := 7;
elseif (a0 > 337.5) or (a0 < 22.5):
  message "a0 (RA) > 337.5 or < 22.5";
  bi_ang0 := 0;
  bi_ang1 := -1;
  middle_angle := 0;       %% This case requires special handling.
  min_edge_angle := 337.5;
  max_edge_angle := 22.5;
elseif (a0 == 22.5):
  message "a0 (RA) == 22.5";
  bi_ang0 := 0;
  bi_ang1 := 1;
elseif (a0 > 22.5) and (a0 < 67.5):
  message "a0 (RA) > 22.5 or a0 < 67.5";
  bi_ang0 := 1;
  bi_ang1 := -1;
  middle_angle   := 45;
  min_edge_angle := 22.5;
  max_edge_angle := 67.5;
elseif (a0 == 67.5):
  message "a0 (RA) == 67.5";
  bi_ang0 := 1;
  bi_ang1 := 2;
elseif (a0 > 67.5) and (a0 < 112.5):
  message "a0 (RA) > 67.5 and a0 < 112.5";
  bi_ang0 := 2;
  bi_ang1 := -1;
  middle_angle   := 90;
  min_edge_angle := 67.5;
  max_edge_angle := 112.5;
elseif (a0 == 112.5):
  message "a0 (RA) == 112.5";
  bi_ang0 := 2;
  bi_ang1 := 3;
elseif (a0 > 112.5) and (a0 < 157.5):
  bi_ang0 := 3;
  bi_ang1 := -1;
  middle_angle   := 135;
  min_edge_angle := 112.5;
  max_edge_angle := 157.5;
elseif a0 == 157.5:
  message "a0 (RA) == 157.5";
  bi_ang0 := 3;
  bi_ang1 := 4;
elseif (a0 > 157.5) and (a0 < 202.5):
  message "a0 (RA) > 157.5 and a0 < 202.5";
  bi_ang0 := 4;
  bi_ang1 := -1;
  middle_angle   := 180;
  min_edge_angle := 157.5;
  max_edge_angle := 202.5;
elseif a0 == 202.5:
  message "a0 (RA) == 202.5";
  bi_ang0 := 4;
  bi_ang1 := 5;
elseif (a0 > 202.5) and (a0 < 247.5):
  message "a0 (RA) > 202.5 and a0 < 247.5";
  bi_ang0 := 5;
  bi_ang1 := -1;
  middle_angle   := 225;
  min_edge_angle := 202.5;
  max_edge_angle := 247.5;
elseif a0 == 247.5:
  message "a0 (RA) == 247.5";
  bi_ang0 := 5;
  bi_ang1 := 6;
elseif (a0 > 247.5) and (a0 < 292.5):
  message "a0 (RA) > 247.5 and a0 < 292.5";
  bi_ang0 := 6;
  bi_ang1 := -1;
  middle_angle   := 270;
  min_edge_angle := 247.5;
  max_edge_angle := 292.5;
elseif a0 == 292.5:
  message "a0 (RA) == 292.5";
  bi_ang0 := 6;
  bi_ang1 := 7;
elseif (a0 > 292.5) and (a0 < 337.5):
  message "a0 (RA) > 292.5 and a0 < 337.5";
  bi_ang0 := 7;
  bi_ang1 := -1;
  middle_angle   := 315;
  min_edge_angle := 292.5;
  max_edge_angle := 337.5;
else
  errmessage "a0 (RA) has invalid value.";
fi;

message "bi_ang0:"; 
show bi_ang0;

message "bi_ang1:"; 
show bi_ang1;

message "middle_angle:";
show middle_angle;   

message "min_edge_angle:";
show min_edge_angle; 

message "max_edge_angle:";
show max_edge_angle; 

%% !! START HERE:  LDF 2021.7.3.  Get radius.
%% Then get arc length from P17 to P22 and from P22 to the nearest "major" RA angle.
%%
%% Try the code thus far on a star with negative declination.

P25 := (0, ypart P22);  %% Point on y-axis with height equal to declination of star S.
dotlabel.rt("$P_{25}$", P25) v8;
dotlabel.rt("$P_{25}$", P25) v9;
dotlabel.rt("$P_{25}$", P25) v11;

message "a1 (declination_decimal_degrees S)";
show a1;

a2 := magnitude(P22 - P25);
message "a2 (radius of circle through P22):";
show a2;

a3 := arc_length (magnitude(a1)) c0;

message "a3 (arc length corresponding to declination of star S):";
show a3;

a4 := middle_angle - a0;

message "a0 (RA of star S in decimal degrees):";
show a0;

message "a4 (difference between middle_angle == " & decimal middle_angle & " and RA of  of star S):";
show a4;

  %rotate s (0, 22.5);
  %message "s (sphere):"; 
  %show s;
draw s;  

%% *** (3)

focus f;

set f with_position (0, 20, -50) 
  with_direction (0, 20, 10) with_distance 70; 

beginfig(8);
  %rotate v8 (0, 70);
  current_picture := v8;
  %dotlabel.rt("
  label("{\\bf Perspective Projection}", (0, -4.5));
endfig with_focus f;

beginfig(9);
  currentpicture := v9;
  label("{\\bf Parallel X-Y} (Viewed from the front)", (0, -4.5));
endfig with_projection parallel_x_y; 

beginfig(10);
  currentpicture := v10;
  label("{\\bf Parallel X-Z} (Viewed from above)", (0, 0, -4.5));
endfig with_projection parallel_x_z; 

beginfig(11);
  currentpicture := v11;
  label("{\\bf Parallel Z-Y} (Viewed from the right side)", (0, -4.5));
endfig with_projection parallel_z_y; 


%% ** (2)

verbatim_metapost "end";
  
end;  

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    


%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metapost
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% abbrev-mode:t
%% outline-regexp:"%% [*\f]+"
%% End:


