%%%% sample3.ldf
%%%% Created by Laurence D. Finston (LDF) Tue 29 Jun 2021 11:31:54 PM CEST

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2021 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.
  

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de

% * (1) Beginning of 3DLDF code.

%% * (1) Plotting stars on sphere development (spherical biangles)

verbatim_metapost "verbatimtex \font\largebf=cmbx12\font\Largebf=cmbx14 etex;";

macro plot_star;

picture v[];
focus f;

set f with_position (0, 20, -50) 
  with_direction (0, 20, 10) with_distance 70; 


def plot_star_on_sphere_development {numeric radius, star S} :=
  numeric a[];
  numeric b[];
  numeric diameter;
  numeric m;
  numeric bi_ang[];
  sphere s;
  point p[];
  path  q[];
  circle c[];


  transform t[];
  string u[];
  bool_point_vector bpv;
  
  u0 := common_name S;
  message "u0 (common name of S):";
  show u0;
  diameter := 2 * radius;
  message "radius:"; 
  show radius;
  message "S:";
  %show S;
  %pause;

%% Find out why using the 'set' command for 'sphere s' didn't work here.  LDF 2021.7.1.
  
  s := unit_sphere scaled (radius, radius, radius);
  rotate s (0, 22.5);
  %message "s (sphere):"; 
  %show s;
  draw s;  

  a0 := ra_decimal_degrees S;
  message "RA decimal deg. of star S (a0):";
  show a0;
  

  a1 := declination_decimal_degrees S;
  message "Declination decimal deg. S (a1):";
  show a1;

  c0 := unit_circle scaled (radius, 0, radius);
  draw c0 with_color red;

  p5 := plot S with_radius radius;
  dotlabel.rt("$p_5$", p5);        
  
  p12 := (xpart p5, 0, zpart p5);  
  dotlabel.lft("$p_{12}$", p12);  
  bpv := c0 intersection_points (origin -- p12);
  %message "bpv:";
  %show bpv;
  p13 := bpv[0];
  dotlabel.top("$p_{13}$", p13);
  p14 := bpv[1];
  dotlabel.lrt("$p_{14}$", p14);

  a40 := magnitude(p13 - p12);
  a41 := magnitude(p14 - p12);

  message "a40 (magnitude(p13 - p12)):"; 
  show a40;

  message "a41 (magnitude(p14 - p12));"; 
  show a41;

  if a40 < a41:
    p14 := p13;
  fi;

  q0 := origin -- p5 -- p14 -- cycle;

  draw q0 with_color blue;

  p34 := get_normal q0;

  message "p34 (normal of q0):";
  show p34;

  i := 1;
  q3 += p14;
  q3 += ..;
   forever:
     p35 := p14;
     message "p35 before rotating"; 
     show p35;
     p35 := p35 rotated_around (origin, p34) (i * 5);  %% Check this!  rotate_around (the command) didn't work here!  LDF 2021.7.1. 
     show p35;
     message "p35 after rotating"; 
     show p35;
     i := i + 1;
     exit_if (ypart p35) >= (ypart p5);
     q3 += p35;
     exit_if (ypart p35) >= (ypart p5);
   endfor; 

   draw q3 with_color orange;  

   a2 := circumference c0;   %% Circumference of horizontal great circle.
   a3 := arc_length (a1) c0; %% Arc length for declination of star S.

   message "a2 (circumference of red circle (horizontal great circle)):";
   show a2;

   message "a3 (arc length of arc from p14 to p5, Declination of star S (" & u0 & ")):";
   show a3;

   message "a0 (RA of Star S (" & u0 & ")):";
   show a0;

%% Find which spherical biangle or biangles (0--7) the star must be plotted on.
%% It can be 2, if the star is exactly on one of the edges.  This probably only occurs
%% rarely.
   
   if (a0 == 337.5):
     message "a0 (RA) == 337.5";
     bi_ang0 := 0;
     bi_ang1 := 7;
   elseif (a0 > 337.5) or (a0 < 22.5):
     message "a0 (RA) > 337.5 or < 22.5";
     bi_ang0 := 0;
     bi_ang1 := -1;
   elseif (a0 == 22.5):
     message "a0 (RA) == 22.5";
     bi_ang0 := 0;
     bi_ang1 := 1;
   elseif (a0 > 22.5) and (a0 < 67.5):
     message "a0 (RA) > 22.5 or a0 < 67.5";
     bi_ang0 := 1;
     bi_ang1 := -1;
   elseif (a0 == 67.5):
     message "a0 (RA) == 67.5";
     bi_ang0 := 1;
     bi_ang1 := 2;
   elseif (a0 > 67.5) and (a0 < 112.5):
     message "a0 (RA) > 67.5 and a0 < 112.5";
     bi_ang0 := 2;
     bi_ang1 := -1;
   elseif (a0 == 112.5):
     message "a0 (RA) == 112.5";
     bi_ang0 := 2;
     bi_ang1 := 3;
   elseif (a0 > 112.5) and (a0 < 157.5):
     bi_ang0 := 3;
     bi_ang1 := -1;
   elseif a0 == 157.5:
     message "a0 (RA) == 157.5";
     bi_ang0 := 3;
     bi_ang1 := 4;
   elseif (a0 > 157.5) and (a0 < 202.5):
     message "a0 (RA) > 157.5 and a0 < 202.5";
     bi_ang0 := 4;
     bi_ang1 := -1;
   elseif a0 == 202.5:
     message "a0 (RA) == 202.5";
     bi_ang0 := 4;
     bi_ang1 := 5;
   elseif (a0 > 202.5) and (a0 < 247.5):
     message "a0 (RA) > 202.5 and a0 < 247.5";
     bi_ang0 := 5;
     bi_ang1 := -1;
   elseif a0 == 247.5:
     message "a0 (RA) == 247.5";
     bi_ang0 := 5;
     bi_ang1 := 6;
   elseif (a0 > 247.5) and (a0 < 292.5):
     message "a0 (RA) > 247.5 and a0 < 292.5";
     bi_ang0 := 6;
     bi_ang1 := -1;
   elseif a0 == 292.5:
     message "a0 (RA) == 292.5";
     bi_ang0 := 6;
     bi_ang1 := 7;
   elseif (a0 > 292.5) and (a0 < 337.5):
     message "a0 (RA) > 292.5 and a0 < 337.5";
     bi_ang0 := 7;
     bi_ang1 := -1;
   else
     errmessage "a0 (RA) has invalid value.";
   fi;

   message "bi_ang0:"; 
   show bi_ang0;

   message "bi_ang1:"; 
   show bi_ang1;

%% Get points for the divisions of the horizontal great circle.

   q2 := origin -- (radius, 0) -- p14 -- cycle;

   draw q2 dashed evenly with_color green;

   p15 := (radius, 0);
   dotlabel.urt("$0^\\circ$", p15);
   dotlabel.lrt("$360^\\circ$", p15);

   p16 := (radius, 0) rotated (0, 22.5);
   dotlabel.urt("$22.5^\\circ$", p16);

   p17 := (radius, 0) rotated (0, 45);
   dotlabel.urt("$45^\\circ$", p17);

   p18 := (radius, 0) rotated (0, 67.5);
   dotlabel.urt("$67.5^\\circ$", p18);

   p19 := (radius, 0) rotated (0, 90);
   dotlabel.urt("$90^\\circ$", p19);

   p20 := (radius, 0) rotated (0, 112.5);
   dotlabel.top("$112.5^\\circ$", p20);

   p21 := (radius, 0) rotated (0, 135.0);
   dotlabel.ulft("$135^\\circ$", p21);

   p22 := (radius, 0) rotated (0, 157.5);
   dotlabel.lft("$157.5^\\circ$", p22);

   p23 := (radius, 0) rotated (0, 180);
   dotlabel.lft("$180^\\circ$", p23);

   p24 := (radius, 0) rotated (0, 202.5);
   dotlabel.lft("$202.5^\\circ$", p24);

   p25 := (radius, 0) rotated (0, 225);
   dotlabel.lft("$225^\\circ$", p25);

   p26 := (radius, 0) rotated (0, 247.5);
   dotlabel.llft("$247.5^\\circ$", p26);

   draw origin -- p26;

   p27 := (radius, 0) rotated (0, 270);
   dotlabel.bot("$270^\\circ$", p27);

   draw origin -- p27;

   p28 := (radius, 0) rotated (0, 292.5);
   dotlabel.lrt("$292.5^\\circ$", p28);

   draw origin -- p28;

   p29 := (radius, 0) rotated (0, 315);
   dotlabel.lrt("$315^\\circ$", p29);

   p30 := (radius, 0) rotated (0, 337.5);
   dotlabel.rt("$337.5^\\circ$", p30);

   p31 := (0, ypart p5, 0);
   dotlabel.lft("$p_{31}$", p31); 

   draw p31 -- p5 with_color red;
   draw origin -- p31;

   a4 := 2 * magnitude (p31 - p5);

   set c1 with_center p31 with_diameter a4;

   draw c1 with_color cyan;

   message "a4 (diameter of c1):";
   show a4;


   p32 := (.5a4, ypart p31) rotated (0, 270);
   dotlabel.llft("$p_{32}$", p32);

   p33 := (.5a4, ypart p31) rotated (0, 292.5);
   dotlabel.bot("$p_{33}$", p33);
   
   v0 := current_picture;
   clear current_picture;
  
enddef;

plot_star_on_sphere_development {3.5, vega};

beginfig(1);
  currentpicture := v0;
  label("{\\bf Perspective Projection}", (0, -4.5));
endfig with_focus f;

beginfig(2);
  currentpicture := v0;
  label("{\\bf Parallel X-Y} (Viewed from the front)", (0, -4.5));
endfig with_projection parallel_x_y; 

beginfig(3);
  currentpicture := v0;
  label("{\\bf Parallel X-Z} (Viewed from above)", (0, 0, -4.5));
endfig with_projection parallel_x_z; 

beginfig(4);
  currentpicture := v0;
  label("{\\bf Parallel Z-Y} (Viewed from the right side)", (0, -4.5));
endfig with_projection parallel_z_y; 

verbatim_metapost "end";
  
end;  

% a3 (arc length of arc from p14 to p5 (Declination of star S):
% a7 (arc length from p5 to p32):




a5 := a0 - 270;

message "a5 (RA dec. deg. Vega - 270):";
show a5;

a6 := 292.5 - a0; 
message "a6 (292.5 - RA dec. deg. Vega):";
show a6;

a7 := arc_length (a5) c1;
message "a7 (arc length from p5 to p32):";
show a7;

a8 := arc_length (a6) c1;
message "a8 (arc length from p5 to p33):";
show a8;

message "circumference of  c1:";
show circumference c1;

a10 := circumference c1 / 8;
message "a10 (circumference c1 / 8):";
show a10;

%pause;

;% Declination

% p23 := (radius, 0) rotated (0, 0, 22.5);
% dotlabel.rt("$22.5^\\circ$", p23) with_text_color blue;
% dotlabel.rt("$22.5^\\circ$", p23 rotated (180, 0)) with_text_color blue;
% dotlabel.lft("$22.5^\\circ$", p23 rotated (0, 180)) with_text_color blue;
% dotlabel.lft("$22.5^\\circ$", p23 rotated (0, 0, 180)) with_text_color blue;


% p24 := (radius, 0) rotated (0, 0, 45);
% dotlabel.rt("$45^\\circ$", p24) with_text_color blue;
% dotlabel.rt("$45^\\circ$", p24 rotated (180, 0)) with_text_color blue;
% dotlabel.ulft("$45^\\circ$", p24 rotated (0, 180)) with_text_color blue;
% dotlabel.ulft("$45^\\circ$", p24 rotated (0, 0, 180)) with_text_color blue;

% p25 := (radius, 0) rotated (0, 0, 67.5);
% dotlabel.rt("$67.5^\\circ$", p25) with_text_color blue;
% dotlabel.rt("$67.5^\\circ$", p25 rotated (180, 0)) with_text_color blue;
% dotlabel.ulft("$67.5^\\circ$", p25 rotated (0, 180)) with_text_color blue;
% dotlabel.ulft("$67.5^\\circ$", p25 rotated (0, 0, 180)) with_text_color blue;

% p23 := (0, radius, 0);
% dotlabel.top("$90^\\circ$", p23) with_text_color blue;
% dotlabel.bot("$90^\\circ$", p23 rotated (180, 0)) with_text_color blue;

v0 := currentpicture;

%% ** (2)

currentpicture := nullpicture;

drawdot origin;

v1 := currentpicture;

% +--------------------------------+-------------+
% | approx_rank_apparent_magnitude | common_name |
% +--------------------------------+-------------+
% |                              1 | Sirius      |
% |                              2 | Canopus     |
% |                              4 | Arcturus    |
% |                              5 | Vega        |
% |                              6 | Capella     |
% |                              7 | Rigel       |
% |                              8 | Procyon     |
% |                              9 | Achernar    |
% |                             10 | Betelgeuse  |
% |                             11 | Hadar       |
% |                             12 | Altair      |
% |                             14 | Aldebaran   |
% |                             15 | Antares     |
% |                             16 | Spica       |
% |                             17 | Pollux      |
% |                             18 | Fomalhaut   |
% |                             19 | Deneb       |
% |                             20 | Mimosa      |
% |                             21 | Regulus     |
% |                             22 | Adhara      |
% |                             24 | Shaula      |
% |                             25 | Gacrux      |
% |                             26 | Bellatrix   |
% |                             27 | Elnath      |
% |                             28 | Miaplacidus |
% |                             29 | Alnilam     |
% |                             30 | Alnair      |
% |                             31 | Alnitak     |
% |                             32 | Alioth      |
% |                             33 | Mirfak      |
% +--------------------------------+-------------+

%% !! START HERE:  LDF 2021.6.28.  Get star with rank 3!

beginfig(7);
  plot_star {3.5, vega};
endfig with_projection parallel_x_y; 

beginfig(5);
  c3 := unit_circle scaled (radius, 0, radius) rotated (90, 0);
  draw c3;
  draw (-radius, 0) -- (radius, 0);
  draw (0, -radius) -- (0, radius);

  j := 10;

  numeric height[];

  for i = 11.25 step 11.25 until 78.75:
     p36 := (radius, 0);
     rotate p36 (0, 0, i);
     p37 := (0, ypart p36);
     draw p37 -- p36;
     height[j] := ypart p36;
     b[j] := magnitude (p36 - p37);
     message "b[" & decimal j & "], (magnitude (p36 - p37)):";
     show b[j];
     u1 := "$" & decimal i & "^\circ$";
     c[j] := unit_circle scaled (b[j], 0, b[j]) shifted (0, ypart p36);
     a[j] := circumference c[j] / 16;
     message "a[" & decimal j & "] (circumference of c[" & decimal j & "] divided by 16):";
     show a[j];
     message "height[" & decimal j & "] (height of c[" & decimal j & "]):";
     show height[j];
     draw c[j] with_color red;
     dotlabel.rt(u1, p36);
     draw origin -- p36;
     u1 := decimal b[j];
     dotlabel.bot(u1, mediate(p36, p37, .5));
     j += 1;
  endfor;

%pause;

  % p36 := (3, 0);
  % rotate p36 (0, 0, 22.5);
  % dotlabel.rt("$22.5^\circ$", p36);
  % p37 := (0, ypart p36);
  % draw p37 -- p36;
  % a9 := magnitude (p36 - p37);
  % message "a9, (magnitude (p36 - p37)):";
  % show a9;
  % u1 := decimal a9;
  % message "u1:"; 
  % show u1;
  % draw origin -- p36;
  % dotlabel.bot(u1, mediate(p36, p37, .5));

endfig with_projection parallel_x_y; 

beginfig(6);
  numeric n[];
  path edge[];
  string str;

  edge0 += ..;
  edge1 += ..;
  edge2 += ..;
  edge3 += ..;
  
  n0 := a2 / 8;
  n1 := a2 / 32;
  draw (-.5n0, 0) -- (.5n0, 0);
  edge0 += (-.5n0, 0);
  edge1 += (.5n0, 0);
  edge2 += (-.5n0, 0);
  edge3 += (.5n0, 0);
  draw (0, -.25a2) -- (0, .25a2);  %% Half of circumference

  label.urt("{\Largebf 6}", origin);
  dotlabel.llft("(0, 0)",  origin);
  dotlabel.rt("$0^\circ$", (.5n0, 0));

  label("RA $247.5^\circ$", (-(.5n0 + 1), 0));
  label("RA $292.5^\circ$", ((.5n0 + 1.5), 0));

  j := 0;
  
  for i = 10 upto 16:
    n2 := (i - 9) * n1;
    edge0 += (-a[i], n2);
    edge1 += (a[i], n2);
    edge2 += (-a[i], -n2);
    edge3 += (a[i], -n2);
    draw (-a[i], n2) -- (a[i], n2);
    draw (-a[i], -n2) -- (a[i], -n2);
    j += 11.25;
    str := "$" & decimal
      j & "^\circ$";
    dotlabel.rt(str, (a[i], n2));
    dotlabel.rt(str, (a[i], -n2));
  endfor;

  edge0 += (0, .25a2);
  edge1 += (0, .25a2);
  edge2 += (0, -.25a2);
  edge3 += (0, -.25a2);  

  label.top("RA $270^\circ$", (0, .25a2));
  label.bot("RA $270^\circ$", (0, -.25a2));
  
  draw edge0;
  draw edge1;
  draw edge2;
  draw edge3;

  a10 := circumference c1 / 8;
  
  p40 := (0, a3);
  dotlabel.ulft("$p_{40}$", p40);
  p41 := (-.5a10, ypart p40);
  p42 := (.5a10, ypart p40);

  dotlabel.lft("$p_{41}$", p41);
  dotlabel.rt("$p_{42}$", p42);
 
  draw p41 -- p42;

  p43 := ((xpart p40 + a7), ypart p40);
  draw p40 -- p43 with_color red with_pen pencircle scaled (3pt, 3pt, 3pt);
  dotlabel.bot("$p_{43}$", p43);
  label.top("Vega", p43);
  
endfig with_projection parallel_x_y; 





end;

%% ** (2) *******************************************

end;

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metafont
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% eval:(setq font-lock-mode nil)
%% End:
