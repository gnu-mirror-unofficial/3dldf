@q pspglb.web @>

@q * Copyright and License.@>

@q This file is part of 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,        @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation, Inc.  @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>
  
@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Global items (pspglb).@>
@** Global items\quad ({\tt pspglb\PERIOD web}).\hfil
Typedefs, global variables and constants, and some non-class functions. 
(\filename{pspglb.web}.)  

\LOG
\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  
Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

\immediate\write\functexifile{File:  pspglb.web^^J}

@q * Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.07.21.}  No longer including \filename{bitset}.  
It's included in \filename{loader.web} instead.
\ENDLOG 

@<Include files@>=
#include "loader.h++"

@q * (1) Type definitions.@>
@* Type definitions.
\initials{LDF Undated.}

Currently, all floating point variables are declared
as |reals|.  I've defined |real| in order to make it easy to switch
between using |floats| and |doubles| simply by changing the value of
the |@[#if@]| expression.
\initials{LDF 2002.10.15.}  

I try to avoid using preprocessor commands (see
Introduction), but this is one of the cases where there's no
better alternative to using the preprocessor (I don't consider
commenting out the unwanted version preferable to using the preprocessor).

\LOG
\initials{LDF 2002.04.10.}  
Added formatting commands.

\initials{LDF 2002.04.10.}  
Added declaration of |Bool_Real|. 

\initials{LDF 2002.12.11.}  Added the macros |LDF_REAL_FLOAT| and
|LDF_REAL_DOUBLE|.  They're needed below, where |MAX_REAL| and
|INVALID_REAL| are declared in the GNU/Linux version (using GCC).

\initials{LDF 2003.06.03.}  
Added |Real_Short|.  It's the return type of
|Plane::get_distance|. 

\initials{LDF 2003.12.30.}  
Now using |#define| instead of |@@d| for
the definitions of |LDF_REAL_FLOAT| and |LDF_REAL_DOUBLE|.  If |@@d|
is used, the definitions are only written to \filename{pspglb.c}.
Using |#define|, and writing |@<Type definitions@>| to
\filename{pspglb.h} makes the definitions available to the files that
include \filename{pspglb.h}.  

\initials{LDF 2004.04.25.}  
Added |typedef| for |String_Bool|.  It's
used for |vector <String_Bool> token_string_bool_vector| in
\filename{io.web}. 

\initials{LDF 2004.05.13.}  
Added |typedef| for |Bool_Void_Pointer|.  It's
used as the return value for |Scanner_Type::handle_numeric_list|.

\initials{LDF 2004.12.21.}
Added the declaration |typedef pair<int, string> Int_String|.

\initials{LDF 2005.04.01.}
Added the type definitions
|typedef unsigned char Unsigned_Byte|,
|typedef signed char Signed_Byte|,
and
|typedef Signed_Byte Byte|.

\initials{LDF 2005.12.06.}
Added |typedef| for |ulong_long|. 
It will be a synonym for |unsigned long long|, if this type exists.  
Otherwise, it will be a synonym for |unsigned long|, if this type exists.  
Otherwise, it will be a synonym for |unsigned int|, if this type exists.  
If |unsigned int| doesn't exist, we're in trouble.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.05.13.}  Add more formatting commands.  Add them to
\filename{3DLDFprg.web}, too.
\ENDTODO 

@f real float
@f Real_Pair real
@f Bool_Pair Real_Pair
@f Real_Pair Real_Short
@f Transform_Matrix int
@f Transform_Matrices Transform_Matrix 

@f Signed_Byte int
@f Byte Signed_Byte
@f UnSigned_Byte Signed_Byte

@f ulong_long unsigned long long

@f Bool_Void_Pointer int

@<Type definitions@>=

#define LDF_REAL_FLOAT  1 
#define LDF_REAL_DOUBLE 0

#if LDF_REAL_FLOAT
typedef float real;
#elif LDF_REAL_DOUBLE
typedef double real;
#else /* Default.  \initials{LDF 2003.12.17.}  */
typedef float real;
#endif

typedef unsigned char Unsigned_Byte;
typedef signed char Signed_Byte;
typedef Signed_Byte Byte;

#if HAVE_UNSIGNED_LONG_LONG
   typedef unsigned long long ulong_long; 
#elif HAVE_UNSIGNED_LONG
   typedef unsigned long ulong_long; 
#elif HAVE_UNSIGNED_INT
   typedef unsigned int ulong_long; 
#endif

typedef real Transform_Matrix[4][4];

typedef pair<real, real> Real_Pair;
typedef pair<real, signed short> Real_Short;
typedef pair<bool, bool> Bool_Pair;
typedef pair<bool, real> Bool_Real;  
typedef pair<bool, void*> Bool_Void_Pointer;

typedef pair<string, bool> String_Bool;  

typedef pair<int, string> Int_String;  

@q * (1) Utility classes and structs@>
@* Utility classes and structs.
\initials{LDF Undated.}

@q ** (2) Real_Triple.  @>
@*1 {\bf Real\_Triple}.  
\initials{LDF Undated.}

@f Real_Triple real

@<Utility classes@>=

struct 
Real_Triple
{
    real first;
    real second;
    real third;
    Real_Triple() : first(0), second(0), third(0) {}
    Real_Triple(real a, real b, real c) : first(a), second(b), third(c) {}

    @<Declare |Real_Triple| functions@>@;
};

@q *** (3) |Real_Triple| functions.@> 
@ {\bf Real\_Triple} functions.
\initials{LDF 2005.11.27.}

\LOG
\initials{LDF 2005.11.27.}
Added this section.
\ENDLOG

@q **** (4) Equality operator.@> 
@ Equality operator.
\initials{LDF 2005.11.27.}
@^\cofunc{Real\_Triple}{==}@>
\cofunctexi{Real_Triple}{==}

\LOG
\initials{LDF 2005.11.27.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Real_Triple| functions@>=
bool
operator==(const Real_Triple& r) const;

@q ***** (5) Definition.@> 
@
@<Define |Real_Triple| functions@>=
bool
Real_Triple::operator==(const Real_Triple& r) const
{
    return r.first && second == r.second && third == r.third;
}

@q **** (4) |is_equal|.@> 
@ {\bf is\_equal}.
\initials{LDF 2005.11.27.}
@^\cfunc{Real\_Triple}{is\_equal}@>
\cfunctexi{Real\_Triple}{is_equal}

\LOG
\initials{LDF 2005.11.27.}
Added this function.
\ENDLOG

@q ***** (5) Declaration.@> 

@<Declare |Real_Triple| functions@>=
bool
is_equal(const Real_Triple& r, real tolerance = 0) const;

@q ***** (5) Definition.@> 
@
@<Define |Real_Triple| functions@>=
bool
Real_Triple::is_equal(const Real_Triple& r, real tolerance) const
{
    if (tolerance <= 0)
       return operator==(r);

    else

       return    fabs(fabs(first) - fabs(r.first))   <= tolerance
              && fabs(fabs(second) - fabs(r.second)) <= tolerance
              && fabs(fabs(third) - fabs(r.third)) <= tolerance;

}  /* End of |Real_Triple::is_equal| definition.  */

@q ** (2) Int_Void_Ptr.  @>
@*1 {\bf Int\_Void\_Ptr}.  

|Int_Void_Ptr| is used in |Scan_Parse::assign_simple| and 
|Scan_Parse::assign_chained|.
\initials{LDF 2004.07.26.}

\LOG
\initials{LDF 2004.07.26.}
Added this declaration.  
\ENDLOG 

@f Int_Void_Ptr int
@<Utility classes@>=
struct 
Int_Void_Ptr
{
   int i;
   void* v;
   Int_Void_Ptr(int ii, void* vv) : i(ii), v(vv) {}
   Int_Void_Ptr(void) : i(0), v(static_cast<void*>(0)) {}
   @<Declare |Int_Void_Ptr| functions@>@;
};

@q *** (3) Int_Void_Ptr Functions.@>
@ |Int_Void_Ptr| Functions.

@q **** (4) Set.@>
@ Set.
@^\cfunc{Int\_Void\_Ptr}{set}@>
\cfunctexi{Int_Void_Ptr}{set}

@
@<Declare |Int_Void_Ptr| functions@>=
void
set(int ii, void* vv);

@
@<Define |Int_Void_Ptr| functions@>=
void
Int_Void_Ptr::set(int ii, void* vv)
{
   i = ii;
   v = vv;
 
   return;

}

@q ** (2) Int_Void_Ptr_Bool.  @>
@*1 {\bf Int\_Void\_Ptr\_Bool}.  

|Int_Void_Ptr_Bool| is used in |Scanner_Type|, |yyparse|, and
|yylex|. 
\initials{LDF 2004.05.03.}

\LOG
\initials{LDF 2004.05.03.}  
Added this declaration.  

\initials{LDF 2004.07.24.}
Added default constructor.
\ENDLOG 

@f Int_Void_Ptr_Bool int
@<Utility classes@>=
struct Int_Void_Ptr_Bool
{
   int i;
   void* v;
   bool b;
   Int_Void_Ptr_Bool(int ii, void* vv, bool bb) : i(ii), v(vv), b(bb) {}
   Int_Void_Ptr_Bool(void) : i(0), v(static_cast<void*>(0)), b(false) {}

   @<Declare |Int_Void_Ptr_Bool| functions@>@;
};

@q *** (3) Int_Void_Ptr_Bool Functions.@>
@ |Int_Void_Ptr_Bool| Functions.

@q **** (4) Set.@>
@ Set.
@^\cfunc{Int\_Void\_Ptr\_Bool}{set}@>
\cfunctexi{Int_Void_Ptr_Bool}{set}

@<Declare |Int_Void_Ptr_Bool| functions@>=
void
set(int ii, void* vv, bool bb);

@
@<Define |Int_Void_Ptr_Bool| functions@>=
void
Int_Void_Ptr_Bool::set(int ii, void* vv, bool bb)
{
   i = ii;
   v = vv;
   b = bb;
  
   return;
}

@q ** (2) |struct Mutex_Type|.@>
@*1 {\bf struct Mutex\_Type}.

\LOG
\initials{LDF 2004.06.29.}
Added this declaration.

\initials{LDF 2004.07.03.}
Changed name of this |struct| from |mutex_struct| to |Mutex_Struct|.

\initials{LDF 2004.07.15.}
Changed name of this |struct| from |Mutex_Struct| to |Mutex_Type|.
Changed it everywhere without comment.

\initials{LDF 2004.07.15.}  
Changed |pthread_mutex_t mutex| to |inner_mutex|.  
Changed it everywhere without comment.
\ENDLOG 

@<Declare |struct Mutex_Type|@>=

#ifdef HAVE_PTHREAD_H  
struct Mutex_Type
{

pthread_mutex_t inner_mutex;

@<Declare |Mutex_Type| functions@>;

};
#endif /* |HAVE_PTHREAD_H|  */@; 

@q *** (3) |Mutex_Type| functions.  @>
@ {\bf Mutex\_Type} functions.

\LOG
\initials{LDF 2004.06.22.}
Added this section.
\ENDLOG 

@q **** (4)  Default constructor.  @>
@ Default constructor.

@q ***** (5) Declaration.@> 

@<Declare |Mutex_Type| functions@>=
Mutex_Type(void);

@q ***** (5)  Definition.@> 

@
@<Define |Mutex_Type| functions@>=

#ifdef HAVE_PTHREAD_H 
Mutex_Type::Mutex_Type(void)
{

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
      {
          cerr << "Entering `Mutex_Type' default constructor."
               << endl;
      }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

   status = pthread_mutex_init(&inner_mutex, 0);

    if (status != 0)
       {
          cerr << "ERROR! In `Io_Struct::Io_Struct(void)':"
               << endl << "`pthread_mutex_init' failed.";
       }   
   else
      {
#if DEBUG_COMPILE
         if (DEBUG)
             {
                 cerr << "In `Io_Struct::Io_Struct(void)':"
                      << endl << "`pthread_mutex_init' succeeded!"
                      << endl;
             }
#endif /* |DEBUG_COMPILE|  */@; 
      }     

#if DEBUG_COMPILE
   if (DEBUG)
       {
           cerr << "Exiting `Mutex_Type' default constructor."
                << endl;
       }      
#endif /* |DEBUG_COMPILE|  */@; 

   return;

}
#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4)  Destructor.  @>
@ Destructor.

\LOG
\initials{LDF 2004.06.29.} 
Added this function.

\initials{LDF 2004.07.16.}
Now trying to lock the mutex before destroying it.  

\initials{LDF 2004.10.12.}
Now writing to |cerr| directly when destroying |cerr_mutex| 
instead of calling |cerr_message|, which tries to lock
|cerr_mutex|.  Nonetheless, this destructor still fails when 
trying to destroy |cerr_mutex| (see following log entry).

\initials{LDF 2004.10.12.}
@:KLUDGE@> KLUDGE:  Added code for suppressing error output when
trying to destroy |cerr_mutex|.  This fails since the system
administrator performed an update.  I'm not sure what exactly he
updated;  it could have been the operating system, the compiler,
and/or the \CPLUSPLUS/ standard library.  It doesn't really matter,
since |cerr_mutex| is only destroyed when the program exits anyway,
but I would like to know why it fails.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Mutex_Type| functions@>=
~Mutex_Type(void);

@q ***** (5)  Definition.@> 

@
@<Define |Mutex_Type| functions@>=
#ifdef HAVE_PTHREAD_H 
Mutex_Type::~Mutex_Type(void)
{

   stringstream cerr_strm;

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
      {
          cerr_strm << "Entering `Mutex_Type::~Mutex_Type(void)'."
                    << endl;

   if (this != &cerr_mutex)
   {
      cerr_mutex.unlock();
      cerr_message(cerr_strm);
   }
   else
      cerr << cerr_strm.str() << endl;

   cerr_strm.str("");
}
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q ****** (6) Try to lock |inner_mutex|.@> 
@ Try to lock |inner_mutex|.
\initials{LDF 2004.07.17.}

|inner_mutex| shouldn't be locked when this function is called.  
However, it may still be possible to recover, because we can 
unlock it, if it was locked by the same thread that calls 
this function. 
\initials{LDF 2004.07.17.}

\LOG
\initials{LDF 2004.11.06.}
Commented-out the warning output.
\ENDLOG 

@<Define |Mutex_Type| functions@>=

   status = pthread_mutex_trylock(&inner_mutex);

   if (status == EBUSY)
       {

       /* !! START HERE.  Try to find out what |Mutex_Type| this is.  
          LDF 2004.10.20.*/@; 
#if 0 

        cerr_strm << "WARNING! In `Mutex_Type::~Mutex_Type(void)':"
                  << endl << "`pthread_mutex_trylock' returned `EBUSY'."
                  << endl << "This mutex is still being held. "
                  << "Will try to continue anyway.";

if (this != &cerr_mutex)
           {
                cerr_strm << endl << "`this' != `&cerr_mutex'.";
                cerr_message(cerr_strm, true); 
           }
        else         

           cerr << cerr_strm.str() 
                << endl << "`this' == `&cerr_mutex'." << endl;

        cerr_strm.str("");
#endif 

      return;

    } /* |if (status == EBUSY)|  */

  else if (status != 0)
   {
     cerr_strm << "ERROR! In `Mutex_Type::~Mutex_Type(void)':"
               << endl << "`pthread_mutex_trylock' failed. Returning." 
               << endl;

     cerr << cerr_strm.str() << endl;   

     cerr_strm.str("");
   
     return;

   } /* |else if (status != 0)|  */

 else /* (|status == 0|)  */
   {
#if DEBUG_COMPILE
      if (DEBUG)
          {

              cerr_strm << "In `Mutex_Type::~Mutex_Type(void)':"
                        << endl << "`pthread_mutex_lock' succeeded!"
                        << endl;

              cerr << cerr_strm.str() << endl;
              cerr_strm.str("");

          }
#endif /* |DEBUG_COMPILE|  */@; 

@q ******* (7) Now try to unlock |inner_mutex|.@> 
@ Now try to unlock |inner_mutex|.
@<Define |Mutex_Type| functions@>=

  status = pthread_mutex_unlock(&inner_mutex);

  if (status != 0)
   {
      cerr_strm << "ERROR! In `Mutex_Type::~Mutex_Type(void)':"
                << endl << "`pthread_mutex_unlock' failed. Returning." 
                << endl;

      cerr << cerr_strm.str() << endl;

      cerr_strm.str("");

      return;

   } /* |if (status != 0)|  */

 else /* |status == 0|  */
   {
#if DEBUG_COMPILE
      if (DEBUG)
          {
             cerr_strm << "In `Mutex_Type::~Mutex_Type(void)':"
                       << endl << "`pthread_mutex_unlock' succeeded!"
                       << endl;
   
             cerr << cerr_strm.str() << endl;

             cerr_strm.str("");
          }
#endif /* |DEBUG_COMPILE|  */@; 

   }  /* |else| (|status == 0|)  */

 }   /* |else| (|status == 0|---|pthread_mutex_trylock| succeeded.)  */

@q ****** (6) Try to destroy |inner_mutex|.@> 
@ Try to destroy |inner_mutex|.

\LOG
\initials{LDF 2004.11.21.}
Commented-out the error messages.
\ENDLOG 

@:URGENT}{{\bf URGENT}@>
!! URGENT: 
Find out why |pthread_mutex_destroy(&inner_mutex)| fails!
\initials{LDF 2004.11.21.}

@<Define |Mutex_Type| functions@>=

  status = pthread_mutex_destroy(&inner_mutex);

#if 0 
  if (status != 0 && this != &cerr_mutex)
   {

      cerr_strm << "ERROR! In `Mutex_Type::~Mutex_Type(void)':"
                << endl << "`pthread_mutex_destroy' failed." << endl;

      if (status == EBUSY)
         
          cerr_strm << "`status' == `EBUSY' (mutex is in use).";

else if (status == EINVAL)
         cerr_strm << "`status' == `EINVAL' (mutex is invalid).";

else 
        cerr_strm << "`status' == " << status 
                  << " (Don't know what error this is).";

       cerr_strm << endl << "Returning and will try to continue.";

       if (this != &cerr_mutex)
          cerr_message(cerr_strm, true); 
       else
          cerr << cerr_strm.str() << endl;

       cerr_strm.str("");

      return;
 
  } /* |if (status != 0 && this != &cerr_mutex)|  */
#endif 

@q ******* (7). @> 
@ 
@:URGENT}{{\bf URGENT}@>
!! URGENT:  Find out why destroying |cerr_mutex| fails.
It started to after a system update.
\initials{LDF 2004.10.12.}

@q ****** (6)  Success! Exit function.@> 
@ Success! Exit function.
@<Define |Mutex_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << "Exiting `Mutex_Type::~Mutex_Type(void)'."
                << endl;

      cerr << cerr_strm.str() << endl;

      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  return;

} /* End of |~Mutex_Type| definition.  */

#endif /* |HAVE_PTHREAD_H|  */@;

@q **** (4) Lock |inner_mutex|.@>
@ Lock {\bf inner\_mutex}.
@^\cfunc{Mutex\_Type}{lock}@>
\cfunctexi{Mutex_Type}{lock}

\LOG
\initials{LDF 2004.06.29.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Mutex_Type| functions@>=
inline
int 
lock(void)
{
  return pthread_mutex_lock(&inner_mutex);
}

@q **** (4) Unlock |inner_mutex|.@>
@ Unlock {\bf inner\_mutex}.
@^\cfunc{Mutex\_Type}{unlock}@>
\cfunctexi{Mutex_Type}{unlock}

\LOG
\initials{LDF 2004.06.29.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Mutex_Type| functions@>=
inline
int 
unlock(void)
{
  return pthread_mutex_unlock(&inner_mutex);
}

@q **** (4) Trylock |inner_mutex|.@>
@ Trylock {\bf inner\_mutex}.
@^\cfunc{Mutex\_Type}{trylock}@>
\cfunctexi{Mutex_Type}{trylock}

\LOG
\initials{LDF 2004.06.29.}
Added this function.
\ENDLOG 

@q ***** (5) Declaration.@> 

@<Declare |Mutex_Type| functions@>=

inline
int 
trylock(void)
{
  return pthread_mutex_trylock(&inner_mutex);
}

@q *** Global |Mutex_Type| variables.@> 
@ Global {\bf Mutex\_Type} variables.

\LOG
\initials{LDF 2004.07.05.}
Added this section, with |cerr_mutex_struct|.

\initials{LDF 2004.07.15.} 
Changed |Mutex_Type cerr_mutex_struct| to |cerr_mutex|.
\ENDLOG 

@<Global variables@>=
Mutex_Type cerr_mutex;

bool database_enabled = false;
bool astronomy_enabled = false;

@
@<|extern| declarations for global |Mutex_Type| variables@>=

extern
Mutex_Type cerr_mutex;

extern 
bool database_enabled;

extern 
bool astronomy_enabled;

@q ** (2) |struct Cond_Var_Type|.@>
@*1 {\bf struct Cond\_Var\_Type}.

@q ***  |struct Cond_Var_Type| declaration.@>
@ {\bf struct Cond\_Var\_Type} declaration.

\LOG
\initials{LDF 2004.07.15.}
Added this declaration.

\initials{LDF 2004.07.16.}
Added |class D| to template declaration.
\ENDLOG

@<Declare |struct Cond_Var_Type|@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> 
struct
Cond_Var_Type : public Mutex_Type
{
  pthread_cond_t   inner_cond_var;
  C value_0;
  D value_1;

  @<Declare |Cond_Var_Type| functions@>@;

};

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ***  |Cond_Var_Type| functions.@>
@ {\bf Cond\_Var\_Type} functions.

\LOG
\initials{LDF 2004.07.15.}
Added this section.
\ENDLOG

@q ****  (4) Default constructor.@>
@ Default constructor.

\LOG
\initials{LDF 2004.07.15.}
Added this function.
\ENDLOG

@q *****  (5) Declaration.@>

@<Declare |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

Cond_Var_Type(void);

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *****  (5) Definition.@>

@
@<Define |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> Cond_Var_Type<C, D>::Cond_Var_Type(void)
{

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
   
   string thread_name = Thread_Info_Type::get_thread_name(thread_info);

   stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {

      cerr_strm << thread_name << "Entering "
                << "`Cond_Var_Type' constructor.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q ******  (6) Initialize |inner_cond_var|.  Exit on error.@>

@ Initialize |inner_cond_var|.  Exit on error.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_cond_init(&inner_cond_var, 0);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type' constructor:"
                    << endl << "Failed to initialize `inner_cond_var'. "
                    << "Exiting and will try to continue.";
          cerr_message(cerr_strm, true); /* Don't delete this!  */
          cerr_strm.str("");

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type' constructor:"
                    << endl << "Initialized `inner_cond_var'.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Initialize |inner_mutex|.  Exit on error.@>
@ Initialize |inner_mutex|.  Exit on error.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_mutex_init(&inner_mutex, 0);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type' constructor:"
                    << endl << "Failed to initialize `inner_mutex'. "
                    << "Exiting and will try to continue.";
          cerr_message(cerr_strm, true); /* Don't delete this!  */
          cerr_strm.str("");

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type' constructor:"
                    << endl << "Initialized `inner_mutex'.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Exit constructor successfully.@>
@ Exit constructor successfully.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << "Exiting "
                << "`Cond_Var_Type' constructor.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   return;
}

#endif /* |HAVE_PTHREAD_H|  */@; 

@q **** (4) Destructor.@>
@ Destructor.

\LOG
\initials{LDF 2004.07.15.}
Added this function.
\ENDLOG

@q *****  (5) Declaration.@>

@<Declare |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

~Cond_Var_Type(void);

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *****  (5) Definition.@>

@
@<Define |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> Cond_Var_Type<C, D>::~Cond_Var_Type(void)
{

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
   
   string thread_name = Thread_Info_Type::get_thread_name(thread_info);

   stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {

      cerr_strm << thread_name << "Entering "
                << "`Cond_Var_Type' destructor.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q *****  (6) Destroy |inner_cond_var|.  Exit on error.@>

@ Destroy |inner_cond_var|.  Exit on error.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_cond_destroy(&inner_cond_var);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type' destructor:"
                    << endl << "Failed to destroy `inner_cond_var'. "
                    << "Exiting and will try to continue.";
          cerr_message(cerr_strm, true); /* Don't delete this!  */
          cerr_strm.str("");

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type' destructor:"
                    << endl << "Destroyed `inner_cond_var'.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Exit destructor successfully.@>
@ Exit destructor successfully.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << "Exiting "
                << "`Cond_Var_Type' destructor.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   return;
}

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****  (4) Wait.@>
@ Wait.

\LOG
\initials{LDF 2004.07.15.}
Added this function.
\ENDLOG

@q *****  (5) Declaration.@>

@<Declare |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

int
wait(void);

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *****  (5) Definition.@>

@
@<Define |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> 
int
Cond_Var_Type<C, D>::wait(void)
{

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
   
   string thread_name = Thread_Info_Type::get_thread_name(thread_info);
   
   stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {

      cerr_strm << thread_name << "Entering "
                << "`Cond_Var_Type::wait'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q ******  (6) Call |pthread_cond_wait|.  Exit on error.@>
@ Call |pthread_cond_wait|.  Exit on error.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_cond_wait(&inner_cond_var, &inner_mutex);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type::wait':"
                    << endl << "`pthread_cond_wait' failed."
                    << "Exiting function with return value 1.";
          cerr_message(cerr_strm, true); /* Don't delete this!  */
          cerr_strm.str("");

          return 1;

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type::wait':"
                    << "`pthread_cond_wait' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Exit function successfully.@>
@ Exit constructor successfully.
\initials{LDF 2004.07.15.}

@<Define |Cond_Var_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << endl << "Exiting "
                << "`Cond_Var_Type::wait' successfully "
                << "and returning 0.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;
}

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****  (4) Timed wait.@>
@ Timed wait.

\LOG
\initials{LDF 2004.07.16.}
Added this function.
\ENDLOG

@q *****  (5) Declaration.@>

@<Declare |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

int
timedwait(const struct timespec* abstime);

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *****  (5) Definition.@>

@
@<Define |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> 
int
Cond_Var_Type<C, D>::timedwait(const struct timespec* abstime)
{

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
   
   string thread_name = Thread_Info_Type::get_thread_name(thread_info);

   stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {

      cerr_strm << thread_name << "Entering "
                << "`Cond_Var_Type::timedwait'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q ******  (6) Call |pthread_cond_timedwait|.  Exit on error.@>
@ Call |pthread_cond_timedwait|.  Exit on error.
\initials{LDF 2004.07.16.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_cond_timedwait(&inner_cond_var, &inner_mutex, abstime);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type::timedwait':"
                    << endl << "`pthread_cond_timedwait' failed."
                    << "Exiting function with return value 1.";
          cerr_message(cerr_strm, true); /* Don't delete this!  */
          cerr_strm.str("");

          return 1;

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type::timedwait':"
                    << "`pthread_cond_timedwait' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Exit function successfully.@>
@ Exit constructor successfully.
\initials{LDF 2004.07.16.}

@<Define |Cond_Var_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << endl << "Exiting "
                << "`Cond_Var_Type::timedwait' successfully "
                << "and returning 0.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;
}

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****  (4) Signal condition.@>
@ Signal condition.

\LOG
\initials{LDF 2004.07.16.}
Added this function.
\ENDLOG

@q *****  (5) Declaration.@>

@<Declare |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

int
signal(void);

#endif /* |HAVE_PTHREAD_H|  */@; 

@q *****  (5) Definition.@>

@
@<Define |Cond_Var_Type| functions@>=

#ifdef HAVE_PTHREAD_H  

template <class C, class D> 
int
Cond_Var_Type<C, D>::signal(void)
{

   Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
   
   string thread_name = Thread_Info_Type::get_thread_name(thread_info);

   stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {

      cerr_strm << thread_name << "Entering "
                << "`Cond_Var_Type::signal'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;

@q ******  (6) Call |pthread_cond_signal|.  Exit on error.@>
@ Call |pthread_cond_signal|.  Exit on error.
\initials{LDF 2004.07.16.}

@<Define |Cond_Var_Type| functions@>=

   status = pthread_cond_signal(&inner_cond_var);

   if (status != 0)
     {
        
          cerr_strm << thread_name << "ERROR! "
                    << "In `Cond_Var_Type::signal':"
                    << endl << "`pthread_cond_signal' failed."
                    << "Exiting function with return value 1.";
          cerr_message(cerr_strm, true);  /* Don't delete this!  */
          cerr_strm.str("");

          return 1;

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

          cerr_strm << thread_name 
                    << "In `Cond_Var_Type::signal':"
                    << "`pthread_cond_signal' succeeded.";
          cerr_message(cerr_strm);
          cerr_strm.str("");

     }     /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ******  (6) Exit function successfully.@>
@ Exit constructor successfully.
\initials{LDF 2004.07.16.}

@<Define |Cond_Var_Type| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << endl << "Exiting "
                << "`Cond_Var_Type::signal' successfully "
                << "and returning 0.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;
}

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ** (2)  |struct Thread_Info_Type|.@>
@*1 {\bf struct Thread\_Info\_Type}.

\LOG
\initials{LDF 2004.07.02.}
Added this declaration.

\initials{LDF 2004.07.03.}
Changed name of this |struct| from |thread_info_type| to 
|Thread_Info_Type|.  
No longer deriving it from |Mutex_Type|.
Added |name|, |mutex|, and |identity_key|.
Now including the section |@<Declare |Thread_Info_Type| functions@>|.

\initials{LDF 2004.07.03.}
Changed |char* name| to |string name|.

\initials{LDF 2004.07.05.}
Made |int thread_ctr static|.

\initials{LDF 2004.07.12.}
Changed |pthread_t id| to |int it|.  Added |int ctr|.

\initials{LDF 2004.07.15.}
Changed |static Mutex_Type mutex_struct| to |mutex|.
Changed it everywhere without comment.

\initials{LDF 2004.07.18.}
Removed |int id|.

\initials{LDF 2004.07.21.}
Added |ofstream log_stream|.

\initials{LDF 2004.11.08.}
Added |Scanner_Node scanner_node|.
\ENDLOG 

@q *** Declaration.@>

@<Declare |struct Thread_Info_Type|@>=

#ifdef HAVE_PTHREAD_H  
struct Thread_Info_Type 
{
  string name;
  int ctr;
  Scanner_Node scanner_node;

  static Mutex_Type mutex;
  static pthread_key_t identity_key;
  static int thread_ctr;

  ofstream log_stream;

  @<Declare |Thread_Info_Type| functions@>@;
};
#endif /* |HAVE_PTHREAD_H|  */@; 

@q *** Declare |static Thread_Info_Type| member variables.@>
@ Declare |static Thread_Info_Type| member variables.

\LOG
\initials{LDF 2004.07.03.}
Added this section.

\initials{LDF 2004.07.05.}
Now declaring |int Thread_Info_Type::thread_ctr|.  Formerly, 
it was non-static. 
\ENDLOG 

@<Declare |static Thread_Info_Type| member variables@>=

pthread_key_t Thread_Info_Type::identity_key;

Mutex_Type Thread_Info_Type::mutex;

int Thread_Info_Type::thread_ctr;

@q *** |Thread_Info_Type| functions.@>
@ |Thread_Info_Type| functions.

\LOG
\initials{LDF 2004.07.03.}
Added this section.
\ENDLOG 

@q *** Destructor.@>
@ Destructor.

\LOG
\initials{LDF 2004.07.03.}
Added this function.
\ENDLOG 

@<Declare |Thread_Info_Type| functions@>=
~Thread_Info_Type(void);

@
@<Define |Thread_Info_Type| functions@>=
Thread_Info_Type::~Thread_Info_Type(void)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     cerr << "Entering `Thread_Info_Type' destructor."
          << endl; 
#endif /* |DEBUG_COMPILE|  */@; 

  log_stream << endl << endl << flush;

  log_stream.close();

#if DEBUG_COMPILE
   if (DEBUG)
     cerr << "Exiting `Thread_Info_Type' destructor."
          << endl; 
#endif /* |DEBUG_COMPILE|  */@; 

  return;

}

@q *** Destroy key value.@>
@ Destroy key value.

\LOG
\initials{LDF 2004.07.03.}
Added this function.
\ENDLOG 

@<Declare |Thread_Info_Type| functions@>=
static
void
destroy_key_value(void* arg);

@
@<Define |Thread_Info_Type| functions@>=
void
Thread_Info_Type::destroy_key_value(void* arg)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     cerr << "Entering `Thread_Info_Type::destroy_key_value'."
          << endl; 
#endif /* |DEBUG_COMPILE|  */@; 

  Thread_Info_Type* t = static_cast<Thread_Info_Type*>(arg);

  if (t != static_cast<Thread_Info_Type*>(0))
    delete t;
  t = 0;

#if DEBUG_COMPILE
   if (DEBUG)
     cerr << "Exiting `Thread_Info_Type::destroy_key_value'."
          << endl; 
#endif /* |DEBUG_COMPILE|  */@; 

  return;

}

@q *** Get thread info.@>
@ Get thread info.

\LOG
\initials{LDF 2004.07.18.}
Added this function.

\initials{LDF 2004.07.21.}
@:BUG FIX@> BUG FIX:  
Now calling |pthread_setspecific| if |pthread_getspecific| returns 0 and
|create_if_none| is |true|.  

\initials{LDF 2004.07.22.}
Now testing whether |pthread_setspecific| succeeds.  
Exiting on error.

\initials{LDF 2004.11.08.}
Added |Scanner_Node sscanner_node| argument with default 0.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Thread_Info_Type| functions@>=
static
Thread_Info_Type*
get_thread_info(bool create_if_none = false, 
                Scanner_Node sscanner_node = 0);

@q **** (4) Definition.@>

@
@<Define |Thread_Info_Type| functions@>=
Thread_Info_Type*
Thread_Info_Type::get_thread_info(bool create_if_none,
                                  Scanner_Node sscanner_node)
{

   stringstream cerr_strm;

   int status;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
       cerr_strm << "Entering `Thread_Info_Type::get_thread_info'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  Thread_Info_Type* thread_info;

  void* v = pthread_getspecific(identity_key);

@q ***** (5) No thread-specific information and |!create_if_none|.@>   
@ No thread-specific information and |!create_if_none|.
\initials{LDF 2004.07.22.}

@<Define |Thread_Info_Type| functions@>=

  if (v == static_cast<void*>(0) && !create_if_none)
    {

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << "In `Thread_Info_Type::get_thread_info':" << endl
                   << "No `Thread_Info_Type' and `create_if_none' == `false'."
                   << endl << "Returning 0.";
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

       return 0;

    } /* |if (v == 0 && !create_if_none)|  */

@q ***** (5) Thread-specific information exists.@>   
@ Thread-specific information exists.
\initials{LDF 2004.07.22.}

@<Define |Thread_Info_Type| functions@>=

  if (v != static_cast<void*>(0))
   {
#if DEBUG_COMPILE
   if (DEBUG)
     {

      cerr_strm << "In `Thread_Info_Type::get_thread_info':" << endl
                << "`Thread_Info_Type' exists for this thread. "
                << "Returning `Thread_Info_Type*'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

      return static_cast<Thread_Info_Type*>(v);

   } /* |if (v != 0)|  */

@q ***** (5) No thread-specific information and |create_if_none == true|.@>   
@ No thread-specific information and |!create_if_none == true|.
\initials{LDF 2004.07.22.}

@<Define |Thread_Info_Type| functions@>=

   thread_info =  new Thread_Info_Type;

@q ****** (6) Try to lock |mutex|.  @>   

@ Try to lock |mutex|. 
\initials{LDF 2004.07.22.}
@<Define |Thread_Info_Type| functions@>=

   status = mutex.lock();

   if (status != 0)
     {
         cerr_strm << "ERROR! In `Thread_Info_Type::get_thread_info':" << endl
                   << "`mutex.lock' failed. Deleting `thread_info' "
                   << "and returning 0.";
         cerr_message(cerr_strm);
         cerr_strm.str("");

         delete thread_info;
         return 0;
     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {
         cerr_strm << "In `Thread_Info_Type::get_thread_info':" << endl
                   << "`mutex.lock' succeeded.";
         cerr_message(cerr_strm);
         cerr_strm.str("");

     } /* |else if (DEBUG)|  (|status == 0|)  */  
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) Set |thread_info| values.  @>   

@ Set |thread_info| values.
\initials{LDF 2004.07.22.}
@<Define |Thread_Info_Type| functions@>=

   thread_info->ctr  = thread_ctr;
   thread_info->scanner_node = sscanner_node;

   stringstream s;

   s << "[Thread " << thread_ctr << "] ";

   thread_info->name = s.str();

   s.str("");

   s << "ldf_" << thread_ctr << ".log";

   thread_info->log_stream.open(s.str().c_str());

   time_t tt;
   tm *lt;
   tt = time(0);
   lt =localtime(&tt);

   string datestamp(asctime(lt));
   datestamp.erase(datestamp.size() - 1); /*  Remove terminal line-feed.  */

   thread_info->log_stream << "%%%% " << s.str() << endl
                           << "%%%% Generated on " 
                           << datestamp << " from GNU 3DLDF " 
                           << VERSION_3DLDF << "." 
                           << endl << endl << flush;
   thread_ctr++;

@q ******* (7) Call |pthread_setspecific|.  Exit on error.  @>   

@ Call |pthread_setspecific|.  Exit on error.
\initials{LDF 2004.07.22.}
@<Define |Thread_Info_Type| functions@>=

   status = pthread_setspecific(identity_key, thread_info);

   if (status != 0)
     {

       cerr_strm << "ERROR! In `Thread_Info_Type::get_thread_info':" << endl
                 << "   `pthread_setspecific' failed. Deleting `thread_info',"
                 << endl 
                 << "   trying to unlock |mutex|, and returning 0.";
       cerr_message(cerr_strm);
       cerr_strm.str("");

       delete thread_info;
       mutex.unlock();
       return 0;

     } /* |if (status != 0)|  */

#if DEBUG_COMPILE

   else if (DEBUG) /* (|status == 0|)  */
     {
       cerr_strm << "In `Thread_Info_Type::get_thread_info':" << endl
                 << "`pthread_setspecific' succeeded.";
       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else| (|DEBUG && status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@;    

@q ****** (6) Try to unlock |mutex|.  @>   

@ Try to unlock |mutex|. 
\initials{LDF 2004.07.22.}
@<Define |Thread_Info_Type| functions@>=

   status = mutex.unlock();

   if (status != 0)
     {
         cerr_strm << "ERROR! In `Thread_Info_Type::get_thread_info':" << endl
                   << "`mutex.unlock' failed. Deleting `thread_info' "
                   << "and returning 0.";
         cerr_message(cerr_strm);
         cerr_strm.str("");

         delete thread_info;
         return 0;
     } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {
         cerr_strm << "In `Thread_Info_Type::get_thread_info':" << endl
                   << "`mutex.unlock' succeeded.";
         cerr_message(cerr_strm);
         cerr_strm.str("");

     } /* |else if (DEBUG)|  (|status == 0|)  */  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Exit function successfully, returning |thread_info|.@>   

@ Exit function successfully, returning |thread_info|.
\initials{LDF 2004.07.22.}
@<Define |Thread_Info_Type| functions@>=

   return thread_info;

}  /* End of |Thread_Info_Type::get_thread_info| definition.  */

@q *** (3) Get thread name.@>
@ Get thread name.

\LOG
\initials{LDF 2004.07.18.}
Added this function.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Thread_Info_Type| functions@>=
static
string
get_thread_name(Thread_Info_Type* thread_info);

@q **** (4) Definition.@>

@
@<Define |Thread_Info_Type| functions@>=
string
Thread_Info_Type::get_thread_name(Thread_Info_Type* thread_info)
{

   stringstream cerr_strm;

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
       cerr_strm << "Entering `Thread_Info_Type::get_thread_name'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   if (thread_info == static_cast<Thread_Info_Type*>(0))
     {
       string s = "";
       return s;
     }
   else
      return thread_info->name;

}  /* End of |Thread_Info_Type::get_thread_name| definition.  */

@q *** (3) Get |scanner_node|.@>
@ Get {\bf scanner\_node}.

\LOG
\initials{LDF 2004.11.07.}
Added this function.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Thread_Info_Type| functions@>=
static
Scanner_Node 
get_scanner_node(Thread_Info_Type* thread_info);

@q **** (4) Definition.@>

@
@<Define |Thread_Info_Type| functions@>=
Scanner_Node 
Thread_Info_Type::get_scanner_node(Thread_Info_Type* thread_info)
{

   stringstream cerr_strm;

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
       cerr_strm << "Entering `Thread_Info_Type::get_scanner_node'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

   if (thread_info == static_cast<Thread_Info_Type*>(0))
     {
       return 0;
     }
   else
      return thread_info->scanner_node;

}  /* End of |Thread_Info_Type::get_scanner_node| definition.  */

@q ** (2) |struct Bad_Assignment_Type|.@>
@*1 {\bf struct Bad\_Assignment\_Type}.

\LOG
\initials{LDF 2004.09.15.}
Added this declaration.

\initials{LDF 2004.09.16.}
Changed the name of this |struct| from |Ldf_Error_Type| to
|Bad_Assignment_Type|. 
\ENDLOG 

@<Declare |struct Bad_Assignment_Type|@>=

struct
Bad_Assignment_Type
{};

@q ** (2) |struct Parser_Error_Type|.@>
@*1 {\bf struct Parser\_Error\_Type}.

\LOG
\initials{LDF 2005.04.15.}
Added this declaration.
\ENDLOG 

@<Declare |struct Parser_Error_Type|@>=

struct
Parser_Error_Type
{
   Unsigned_Byte code;
   string rule_name;
};

@q * Global variables.@>
@* Global variables.

@q ** For compilation.@>
@ For compilation.
\initials{LDF 2003.08.25.}  GCC 2.95 doesn't have the |numeric_limits| 
template,  and GCC 3.3 doesn't seem to
have it either.

\LOG
\initials{LDF 2002.12.11.}  
@: BUG FIX@> BUG FIX: 
Discovered that the way this was before, 
|MAX_REAL = INVALID_REAL - real_limits.epsilon| caused |MAX_REAL|
and |INVALID_REAL| to be equal!  I didn't notice the problem until I
started to port 3DLDF to GNU/Linux.  It also doesn't work to use 
|MAX_REAL = INVALID_REAL - real_limits.min|.  
\ENDLOG 
@<Global variables@>=
valarray<real> null_coordinates(4);

@ |MAX_REAL| is the second largest |real| value.
|MAX_REAL_SQRT| is convenient to have for testing when computing
distances. 

@:!! KLUDGE@> !! KLUDGE:  Using the macros |FLT_MAX| or |DBL_MAX|
because the |numeric_limits| template doesn't seem to be available
under GNU/Linux using GCC, at least not on the computer I'm using.
\initials{LDF 2002.12.11.}  

\LOG
\initials{LDF 2003.12.08.}
Changed the definition of |MAX_REAL|.  Previously, it
was calculated using 
|.00000003 * FLT_MAX|, which was a kludge.  

\initials{LDF 2003.12.29.}  Changed the way |MAX_REAL| and
|MAX_REAL_SQRT| are declared.  They can no longer be |const|, because
the value of |MAX_REAL| is set at the beginning of |main| using 
|get_second_largest<Real>|. 
The value of |MAX_REAL_SQRT| is set
after this.  Their values should never change after this!

|MAX_REAL_SQRT| must be initialized here,
because it's used in |Point::magnitude|.  
\initials{LDF 2003.12.29.}  
\ENDLOG 

@<Global variables@>=
#ifdef __DECCXX
numeric_limits<real> real_limits;
extern const real INVALID_REAL= real_limits.max();
#else
#if LDF_REAL_DOUBLE
extern const real INVALID_REAL= DBL_MAX;
#else /* |LDF_REAL_FLOAT|, or not specified.  LDF 2003.12.08.  */
extern const real INVALID_REAL = FLT_MAX;
#endif
#endif 

real MAX_REAL = 0;
real MAX_REAL_SQRT = 0;

@ |VERBOSE_GLOBAL| is |false| by default.  
It is set to |true| by the command line option ``{\tt --verbose}''.  
If |VERBOSE_GLOBAL| is |true|, the local
|verbose| variables in functions are set to |true|.
\initials{LDF 2003.08.14.}  

\LOG  
\initials{LDF 2003.08.14.}  
Added |VERBOSE_GLOBAL| and |SILENT_GLOBAL|.

\initials{LDF 2004.09.30.}
Added |bool QUIET_GLOBAL|.
\ENDLOG 

@<Global variables@>=
bool QUIET_GLOBAL   = false;
bool VERBOSE_GLOBAL = false;
bool SILENT_GLOBAL  = false;

@
@<Declarations for the header file@>=
extern bool QUIET_GLOBAL;
extern bool VERBOSE_GLOBAL;
extern bool SILENT_GLOBAL;
extern const bool ldf_real_float;
extern const bool ldf_real_double;
extern real MAX_REAL;
extern real MAX_REAL_SQRT;

@
\LOG
\initials{LDF 2003.08.14.}  
Added |VERSION_3DLDF| and |COPYRIGHT_3DLDF|.

\initials{LDF 2004.09.16.}
Updated the |strings| |COPYRIGHT_3DLDF| and |DISCLAIMER_3DLDF|.

\initials{LDF 2005.10.24.}
Updated the |string| |DISCLAIMER_3DLDF|.

\initials{LDF 2006.01.25.}
Added ``2006'' to the |string| |COPYRIGHT_3DLDF|.

\initials{LDF 2007.07.03.}
Removed years previous to ``2007'' from the |string| |COPYRIGHT_3DLDF|.

\initials{LDF 2013.12.12.}
Added |extern const float ZERO_REAL| it is initialized to |0.0F| or |0.0D|, depending
on the values of |LDF_REAL_FLOAT| and |LDF_REAL_DOUBLE|.
\ENDLOG 

@<Global constants@>=

#if LDF_REAL_FLOAT
  extern const bool ldf_real_float  = 1;
  extern const bool ldf_real_double = 0;
  extern const float ZERO_REAL = 0.0F;
#elif LDF_REAL_DOUBLE
  extern const bool ldf_real_float  = 0;
  extern const bool ldf_real_double = 1;
  extern const double ZERO_REAL = 0.0D;
#else /* Defaults.  LDF 2003.12.17.  */
  extern const bool ldf_real_float  = 1;
  extern const bool ldf_real_double = 0;
  extern const float ZERO_REAL = 0.0F;
#endif

extern const string VERSION_3DLDF = "3.0";
extern const string COPYRIGHT_3DLDF 
   = "Copyright (C) 2021 The Free Software Foundation, Inc.";
extern const string DISCLAIMER_3DLDF
   = "GNU 3DLDF comes with ABSOLUTELY NO WARRANTY;\n\
for details see the file COPYING,\n\
which you should have received \
in the distribution of GNU 3DLDF 3.0\n\
This is Free Software, and you are welcome \
to redistribute it under certain conditions;\n\
for details, again, see the file COPYING.\n\n\
Please send bug reports to Laurence.Finston@@gmx.de\n\
Web site:  http://www.gnu.org/software/3dldf/LDF.html";

@
\LOG
\initials{LDF 2003.11.28.}  Changed |VERSION_3DLDF| from a |real| to a
|string|.  This is necessary, because I now have versions with three
digits separated by periods.
\ENDLOG 
@<Declarations for the header file@>=
extern const string VERSION_3DLDF;
extern const string COPYRIGHT_3DLDF;
extern const string DISCLAIMER_3DLDF;
extern const bool ldf_real_float;
extern const bool ldf_real_double;
extern const float ZERO_REAL;

@ @:!! TO DO@> TO DO:  Find out why the library
version of |trunc| can't be found in the version for 
GCC 2.95 under Linux! \initials{LDF 2002.12.10.}  

The problem doesn't exist for
GCC 3.3 under Linux.  \initials{LDF 2003.08.14.}

\LOG
\initials{LDF 2003.08.14.}  Put this function declaration in 
|@<Declare utility functions@>|.  Formerly, it was in 
|@<Declarations for the header file@>|.

Changed the conditional from |@[#ifdef@]| |__GNUC__| to
|@[#ifdef@]| |LDF_GCC_2_95|, because the library version of |trunc| is
found when compiling with GCC 3.3 under Linux.
\ENDLOG 
@<Declare utility functions@>=
#ifndef HAVE_TRUNC
double
trunc(double d);
#endif 

@
\LOG
\initials{LDF 2003.08.14.}  Put this function definition into 
|@<Define utility functions@>|.  Formerly, it was  in 
|@<Global variables@>|.
\ENDLOG 
@<Define utility functions@>=
#ifndef HAVE_TRUNC
double
trunc(double d)
{
  int i;
  i = static_cast<int>(d);
  return static_cast<double>(i);
}
#endif

@q ** For the header file.@>
@ For the header file.
@<Declarations for the header file@>=
extern valarray<real> null_coordinates;
#ifdef __DECCXX
extern numeric_limits<real> real_limits;
#endif

@q * (1) Global constants.@>
@* Global constants.
|INVALID_REAL| is the largest possible |real| value, where |real| is
either a synonym for |float| or for |double|, depending on how it's
defined.  Values are set to |INVALID_REAL| or functions return it when
something has gone wrong.  |INVALID_REAL| is also used for the |real|
values in |INVALID_TRANSFORM| and  |INVALID_POINT|.  Another
possibility would be to use exception handling, but so far I've found
it convenient to use |INVALID_REAL| instead.  Since the largest
|float| is so large, and |epsilon| for |floats| is so small, the
loss of the largest possible  valid value is insignificant.  Using
exception handling has its advantages, and if it turns out to be
useful, I'll put in exception handling code, but using an otherwise
valid value to signal exceptional conditions or errors does have the
advantage of simplifying the path of execution through the program
code. 
\initials{LDF 2002.10.16.}
Modified \initials{LDF 2002.10.20.}  

\LOG
\initials{LDF 2002.09.25.}  Added this section.  Previously, I declared and
initialized my global
constants in the header file.  This meant that each compilation unit
that loaded \filename{pspglb.h} had its own version of |PI|,
|INVALID_REAL|, etc.  I didn't know that |consts| had internal linkage
by default and that I could make their linkage external by using
|extern| in the declaration with the initialization, and put a second
declaration, also with |extern|, in the header file.  This is what
I've done now.

\initials{LDF 2003.06.03.}  
Added |INVALID_REAL_SHORT|.

\initials{LDF 2005.11.17.}
Added |INVALID_REAL_TRIPLE|.
\ENDLOG

@q ** (2) For compilation.@>
@ For compilation.
\initials{LDF Undated.}

@<Global constants@>=

extern const real PI = 4.0 * atan(1.0);
extern const Real_Pair INVALID_REAL_PAIR(INVALID_REAL, INVALID_REAL);
extern const Real_Triple INVALID_REAL_TRIPLE(INVALID_REAL, INVALID_REAL, INVALID_REAL);
extern const Real_Short INVALID_REAL_SHORT(INVALID_REAL, 0);

@q ** (2) For the header file.@>
@ For the header file.
\initials{LDF Undated.}

@<Declarations for the header file@>=

extern const real PI;

extern const real        INVALID_REAL;
extern const Real_Pair   INVALID_REAL_PAIR;
extern const Real_Triple INVALID_REAL_TRIPLE;
extern const Real_Short  INVALID_REAL_SHORT;

@q * Utility functions.@>
@* Utility functions.

@q **  Write to |cerr| safely.@>
@ Write to {\bf cerr} safely.

If |HAVE_PTHREAD_H| is defined, 
|cerr_message| locks |cerr_mutex| and disables
thread cancellation before writing output to |cerr|.  It then unlocks
|cerr_mutex| and restores the old cancel state before returning.
\initials{LDF 2004.07.05.}

\LOG
\initials{LDF 2004.07.05.}
Added this function.

\initials{LDF 2004.07.09.}  
Changed the argument |bool do_endl_flush| to |do_endl|.  
Output sent to |cerr| is unbuffered. 
\ENDLOG 

@<Declare utility functions@>=
int
cerr_message(stringstream& s,
             bool get_char = false,
             bool do_endl = true);

@
@<Define utility functions@>=
int
cerr_message(stringstream& s, 
             bool get_char, 
             bool do_endl)
{
#ifdef HAVE_PTHREAD_H  

  int old_cancel_state;

  pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancel_state);

  int status;

  status = cerr_mutex.lock();

  if (status !=0)
    {
      cerr << "ERROR! In `cerr_message': "
           << "`cerr_mutex.lock' failed."
           << endl << "Exiting with return value " << status
           << "." << endl;
      return status;
    }

#endif /* |HAVE_PTHREAD_H|  */@; 

  cerr << s.str();

  if (do_endl)
     cerr << endl;

  if(get_char)
    {
      cerr << "Type <RETURN> to continue.\n"; 
      getchar(); /* Don't delete this!  */ 
    }

#ifdef HAVE_PTHREAD_H  
  status = cerr_mutex.unlock();

  if (status !=0)
    {
      cerr << "ERROR! In `cerr_message': "
           << "`cerr_mutex.unlock' failed."
           << endl << "Exiting with return value " 
           << status << "." << endl;
      return status;
    }

pthread_setcancelstate(old_cancel_state, 0);
#endif /* |HAVE_PTHREAD_H|  */@;   

  return 0;

} /* End of |cerr_message| definition.  */

@q ** (2) Solve quadratic equation.@>
@ Solve quadratic equation.
@:!! TO DO@> 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:@>  
\initials{LDF 2002.09.03.}  
Maybe add functions for solving cubic and quartic
equations, if this is practicable.
\ENDTODO 

\LOG
\initials{LDF 2003.06.1.}  
Changed return type from |pair<real, real>| to |Real_Pair|, 
which is equivalent.

\initials{LDF 2005.11.30.}
Rewrote this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare utility functions@>=

Real_Pair
solve_quadratic(real a, real b, real c);

@q *** (3) Definition.@> 

@
@<Define utility functions@>=

Real_Pair
solve_quadratic(real a, real b, real c)
{

    Real_Pair p;

    Signed_Byte sign_b = (b >= 0) ? 1 : -1;

    real q;
 
    try
       {
           q = -(b +  sign_b * sqrt((b * b) - (4 * a * c))) / 2;
       }
    catch (...)
       {
           return Real_Pair(INVALID_REAL, INVALID_REAL);
       }

    if (!finite(q))
       return Real_Pair(INVALID_REAL, INVALID_REAL);

    p.first  = (a == ZERO_REAL) ? INVALID_REAL : q/a;
    p.second = (q == ZERO_REAL) ? INVALID_REAL : c/q;

    return p;

}  /* End of |solve_quadratic| definition.  */

@q * System information.@>
@* System information.

\LOG
\initials{LDF 2003.12.29.}  
Added this section.
\ENDLOG 

@q ** Declare |namespace System|. @>
@*1 Declare {\bf namespace System}. @>
\LOG
\initials{LDF 2003.12.29.}  Added this section.
\ENDLOG 
@<Declare |namespace System|@>=
namespace 
System
{
  @<Declare |System| functions@>@;
}

@q * (1) Run state.@>
@* Run state.
\LOG
\initials{LDF 2004.03.26.}  
Added this section.
\ENDLOG 

@q ** (2) Declare |struct Run_State|. @>
@ Declare {\bf struct Run\_State}.

\LOG
\initials{LDF 2004.03.26.}  Added this section.

\initials{LDF 2004.04.27.}
Added the |unsigned short| |message_mode| and
the |static const unsigned shorts|
|SILENT|, |NORMAL|, |VERBOSE| for setting it.

\initials{LDF 2004.04.27.}
Added |unsigned short stop_mode| and the 
|static const unsigned shorts| |ERRORSTOP| and 
|NON_STOP| for setting it.

\initials{LDF 2004.06.23.}
Removed the |bools| |multiprocess_input| 
and |multiprocess_output|.

\initials{LDF 2004.07.02.}
Added |bool multithread_include|.  It's for using multiple threads for input
files included in other input files using the ``{\bf include}'' command.

\initials{LDF 2004.09.30.}
Added |static const unsigned short QUIET|.

\initials{LDF 2004.10.05.}
Changed the name of |unsigned short stop_mode| to |error_stop_mode|.
Changed the name of |static const unsigned short ERRORSTOP| to 
|STOPPING|.  Added |unsigned short warning_stop_mode|.

\initials{LDF 2004.10.06.}
Changed the name of |static const unsigned short NORMAL| 
to |STANDARD|.  It interfered with the Bison token declaration that
I've added today.
\ENDLOG 

@<Declare |struct Run_State|@>=
struct
Run_State
{

  bool multithread_input;
  bool multithread_output;
  bool multithread_include;

  static const unsigned short MAX_OUTPUT_FORMATS;
  static const unsigned short METAPOST;
  static const unsigned short PNG;
  static const unsigned short LIBPLOT;

  static const unsigned short QUIET; 
  static const unsigned short SILENT; 
  static const unsigned short STANDARD; 
  static const unsigned short VERBOSE;
                                     
  static const unsigned short STOPPING;   
  static const unsigned short NON_STOP;

  bool do_output[3];
  bool single_output_file;

  unsigned short message_mode;
  unsigned short error_stop_mode;
  unsigned short warning_stop_mode;

  @<Declare |Run_State| functions@>@;
};

@q ** (2) Static data members. @>
@ Static data members.

\LOG
\initials{LDF 2004.09.30.}
Added code for setting |QUIET|.

\initials{LDF 2004.10.05.}
Changed the name of |static const unsigned short ERRORSTOP| to 
|STOPPING|.

\initials{LDF 2004.10.06.}
Changed the name of |static const unsigned short NORMAL| 
to |STANDARD|.  It interfered with the Bison token declaration that
I've added today.
\ENDLOG 

@<Define |static| |Run_State| member variables@>=

const unsigned short Run_State::METAPOST = 0;
const unsigned short Run_State::PNG      = 1;
const unsigned short Run_State::LIBPLOT  = 2;

const unsigned short Run_State::MAX_OUTPUT_FORMATS = 3;

const unsigned short Run_State::QUIET   = 0;
const unsigned short Run_State::SILENT  = 1;
const unsigned short Run_State::STANDARD  = 2;
const unsigned short Run_State::VERBOSE = 3;

const unsigned short Run_State::STOPPING  = 0;
const unsigned short Run_State::NON_STOP  = 1;

@q ** Global |Run_State| variables. @>
@ Global {\bf Run\_State} variables.
\LOG
\initials{LDF 2004.04.16.}  Moved the declaration of
|run_state_initial| to here from \filename{scanprse.web}.  This is so
that I can move the declarations of |id_map_entry_node|,
|id_map_type|, |id_map_entry_node|, |Id_Map_Node|, and |Scanner_Node|
to \filename{io.web}.  These types are ``under construction'' and some
may be renamed or eliminated.
\ENDLOG 

@<Declare global |Run_State| variables@>=
Run_State run_state_initial;

@
@<|extern| declarations for global |Run_State| variables@>=
extern Run_State run_state_initial;

@q ** (2) |Run_State| functions. @>
@ {\bf Run\_State} functions. @>
@f Run_State int

@q *** (3) Constructor. @>
@ Constructor. @>

\LOG
\initials{LDF 2004.03.26.}  
Added this function.

\initials{LDF 2004.04.27.}  
Now setting |message_mode| to |NORMAL| and
|stop_mode| to |ERRORSTOP|.

\initials{LDF 2004.06.23.}
No longer setting |multiprocess_input| and |multiprocess_output|, because I've
removed them from the |struct| declaration.

\initials{LDF 2004.07.02.}
Now setting |multithread_include|, which I've added today.

\initials{LDF 2004.10.05.}
Now setting |error_stop_mode| to |STOPPING| rather than |ERRORSTOP|.
Now setting |warning_stop_mode| to |STOPPING|.

\initials{LDF 2004.10.06.}
Now setting |message_mode| to |STANDARD| rather than |NORMAL|.
\ENDLOG 

@q **** (4) Declaration.@> 

@<Declare |Run_State| functions@>=
Run_State(void);

@q **** (4) Definition.@> 

@
@<Define |Run_State| functions@>=
Run_State::Run_State(void)
{
  multithread_input   = false;
  multithread_output  = false;
  multithread_include = false;
  do_output[METAPOST] = true;
  do_output[PNG]      = false;
  do_output[LIBPLOT]  = false;
  single_output_file  = false;

  message_mode      = STANDARD;
  error_stop_mode   = STOPPING;
  warning_stop_mode = STOPPING;

}  

@q *** Assignment. @>
@ Assignment. @>

\LOG
\initials{LDF 2004.04.16.}  Added this function.

\initials{LDF 2004.06.23.}
No longer setting |multiprocess_input| and |multiprocess_output|, 
because I've removed them from the |struct| declaration.

\initials{LDF 2004.07.02.}
Now setting |multithread_include| to |r.multithread_include|.
Added |multithread_include| today.
\ENDLOG 

@<Declare |Run_State| functions@>=
const
Run_State& 
operator=(const Run_State& r);

@
@<Define |Run_State| functions@>=
const
Run_State& 
Run_State::operator=(const Run_State& r)
{
  multithread_input   = r.multithread_input;   
  multithread_output  = r.multithread_output;  
  multithread_include = r.multithread_include;  

  for (int i = 0; i < MAX_OUTPUT_FORMATS; ++i)
     do_output[i] = r.do_output[i]; 

  single_output_file =  r.single_output_file;
  return r;
}  

@q *** Showing. @>
@ Showing. @>

\LOG
\initials{LDF 2004.03.26.}  Added this function.

\initials{LDF 2004.06.23.}
No longer showing the values of |multiprocess_input| and |multiprocess_output|, 
because I've removed them from the |struct| declaration.

\initials{LDF 2004.07.02.}
Added code for showing |multithread_include|.
\ENDLOG 

@<Declare |Run_State| functions@>=
void
show(void);

@
@<Define |Run_State| functions@>=
void
Run_State::show(void)
{
  cout << "multithread_input == " << multithread_input << endl;
  cout << "multithread_output == " << multithread_output << endl;
  cout << "multithread_include == " << multithread_include << endl;
  return;
}

@q * namespace Projections@>
@* {\bf namespace Projections}.
\LOG
\initials{LDF 2003.05.11.}  Added |AXON|.

\initials{LDF 2004.03.14.}  Added |SUPPRESS|. 

\initials{LDF 2004.03.14.}  Moved this section from
\filename{pictures.web} to \filename{pspglb.web}.

\initials{LDF 2004.06.08.}  Made the names of the constants 
|persp|, |parallel_x_y|, |parallel_x_z|, |parallel_z_y|, |axon|, |iso|, 
and |suppress| lowercase.  They were formerly uppercase.  This was necessary
because I've now declared tokens with these names (in uppercase) in
\filename{pbsndecl.w} for the parser, and they interfered with these constants
before I made these changes.  
\ENDLOG 

@<Declare namespace |Projections|@>=
namespace 
Projections
{
    extern const unsigned short persp        = 0;
    extern const unsigned short parallel_x_y = 1;
    extern const unsigned short parallel_x_z = 2;
    extern const unsigned short parallel_z_y = 3;
    extern const unsigned short axon         = 4;
    extern const unsigned short iso          = 5;
    extern const unsigned short suppress     = 6;
};

@ External.
@<|extern| declaration of namespace |Projections|@>=
namespace Projections
{
    extern const unsigned short persp;
    extern const unsigned short parallel_x_y;
    extern const unsigned short parallel_x_z;
    extern const unsigned short parallel_z_y;
    extern const unsigned short axon;
    extern const unsigned short iso;
    extern const unsigned short suppress;
};

@q * (1) namespace Sorting@>
@* {\bf namespace Sorting}.
This namespace contains constants that are
passed to |Picture::output| for determining how the |Shapes| on the
|Picture| are sorted in order to determine the order in which
they are output.
\LOG
\initials{LDF 2003.05.16.}  Added this namespace.  

\initials{LDF 2004.03.14.}  Moved this section from
\filename{pictures.web} to \filename{pspglb.web}.

\initials{LDF 2004.06.29.}
Changed |SORTING::NO_SORT| to |SORTING::SUPPRESS_SORT| because 
|NO_SORT| is now a macro defined by means of a token declaration in 
\filename{pbsndecl.w}.

\initials{LDF 2007.07.22.}
Added the declarations of the |const unsigned shorts| |SORTING_NULL_VALUE|,
|SORTING_EQUAL|, |SORTING_NOT_EQUAL|, |SORTING_LESS|,
|SORTING_LESS_EQUAL|, |SORTING_GREATER|, and |SORTING_GREATER_EQUAL|.
\ENDLOG 

@<Declare namespace |Sorting|@>=
namespace Sorting
{

    extern const unsigned short SORTING_NULL_VALUE    = 0;

    extern const unsigned short SUPPRESS_SORT = 1;
    extern const unsigned short MAX_Z         = 2;
    extern const unsigned short MIN_Z         = 3;
    extern const unsigned short MEAN_Z        = 4;

    extern const unsigned short SORTING_EQUAL         =  5;
    extern const unsigned short SORTING_NOT_EQUAL     =  6;
    extern const unsigned short SORTING_LESS          =  7;
    extern const unsigned short SORTING_LESS_EQUAL    =  8;
    extern const unsigned short SORTING_GREATER       =  9;
    extern const unsigned short SORTING_GREATER_EQUAL = 10;

};

@ External.
@<|extern| declaration of namespace |Sorting|@>=
namespace Sorting
{
    extern const unsigned short SUPPRESS_SORT;
    extern const unsigned short MAX_Z;
    extern const unsigned short MIN_Z;
    extern const unsigned short MEAN_Z;

    extern const unsigned short SORTING_NULL_VALUE;
    extern const unsigned short SORTING_EQUAL;
    extern const unsigned short SORTING_NOT_EQUAL;
    extern const unsigned short SORTING_LESS;
    extern const unsigned short SORTING_LESS_EQUAL;
    extern const unsigned short SORTING_GREATER;
    extern const unsigned short SORTING_GREATER_EQUAL;
};

@q ** (2) Endianness.@>
@*1 Endianness.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this section.
\ENDLOG 

@q *** (3) Get endianness.@>
@ Get endianness.
\initials{LDF 2003.12.29.}  

|get_endianness| returns the following values:
\item{0}  if the processor is little-endian.
\item{1}  if the processor is big-endian.
\item{-1} if the endianness cannot be determined.

It is called by |is_little_endian| and |is_big_endian|.
\initials{LDF 2003.12.21.}
 
This function has been adapted from 
Harbison, Samuel~P., and Guy~L. Steele Jr.
{\it C, A Reference Manual}, pp.~163--164.
\initials{LDF 2003.12.29.}

\LOG
\initials{LDF 2003.12.29.}  
Added this function.
\ENDLOG 

@q **** (4) Declaration.@>   

@<Declare |System| functions@>=
signed short
get_endianness(const bool verbose = false);

@q **** (4) Definition.@>   

@
@<Define |System| functions@>=
signed short
System::get_endianness(const bool verbose)
{
  union {
    long Long;
    char Char[sizeof(long)];
  } u;
  u.Long = 1;
  if (u.Char[0] == 1)
    {
      if (verbose)
        cout << "Processor is little-endian." << endl << endl;

      return 0;
    }
  else if (u.Char[sizeof(long) - 1] == 1)
    {
      if (verbose)
        cout << "Processor is big-endian." << endl << endl;

      return 1;
    }
  else
    {
      cerr << "ERROR! In System::get_endianness:\n"
           << "Can't determine endianness. Returning -1"
           << endl << endl;
      return -1;
    }

} /* End of |System::get_endianness| definition.  */

@q *** (3) Is big endian. @>
@ Is big endian.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this function.
\ENDLOG 

@<Declare |System| functions@>=
bool
is_big_endian(const bool verbose = false);

@
@<Define |System| functions@>=
bool
System::is_big_endian(const bool verbose)
{
  return (get_endianness(verbose) == 1);
}

@q *** (3) Is little endian. @>
@ Is little endian.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this function.
\ENDLOG 

@<Declare |System| functions@>=
bool
is_little_endian(const bool verbose = false);

@
@<Define |System| functions@>=
bool
System::is_little_endian(const bool verbose)
{
  return (get_endianness(verbose) == 0);
}

@q ** (2) Register width. @>
@ Register width.

\LOG
\initials{LDF 2003.12.29.}  
Added this section.
\ENDLOG 

@q *** (3) Get register width. @>
@ Get register width.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this function.

\initials{LDF 2004.1.2.}  
Changed the name of this function from
|get_processor_size| to |get_register_width|.
\ENDLOG 

@<Declare |System| functions@>=
unsigned short
get_register_width();

@
@<Define |System| functions@>=
unsigned short
System::get_register_width()
{
  return (sizeof(void*) * CHAR_BIT);
}

@q *** (3) Is 32 bit. @>
@ Is 32 bit.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this function.
\ENDLOG 

@<Declare |System| functions@>=
bool 
is_32_bit();

@
@<Define |System| functions@>=
bool 
System::is_32_bit()
{
  return (get_register_width() == 32);
}

@q *** (3) Is 64 bit. @>
@ Is 64 bit.
\initials{LDF 2003.12.29.}  

\LOG
\initials{LDF 2003.12.29.}  
Added this function.
\ENDLOG 

@<Declare |System| functions@>=
bool 
is_64_bit();

@
@<Define |System| functions@>=
bool 
System::is_64_bit()
{
  return (get_register_width() == 64);
}

@q * (1) Forward declarations.@>
@* Forward declarations.
In the files that are compiled first, some classes
refer to other classes that haven't been defined yet.  Forward
declarations make it possible to do this.  
\initials{LDF 2002.10.16.}  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.10.16.}  
Get citation from Stroustrup.   
\ENDTODO 

\LOG
\initials{LDF 2002.04.10.}  
Added the forward declaration of |Bool_Real_Point|.
It's needed because it's used as the return value of
|Point::intersection_point|, which is, of course, declared within
the declaration of |class Point|.  However, |Bool_Real_Point| can only
be defined {\it after\/} |Point| is defined.  This forward declaration
solves the problem.

\initials{LDF 2003.07.16.}  
Added forward declaration of |Ellipse|.  It's needed,
because I've declared |Ellipse| to be a |friend| of |Path|.  Formerly,
|Circle| was a |friend| of |Path|, but now it must be |Ellipse|,
because I've made the ``segment'' functions |segment|, |half|, and
|quarter| members of |Ellipse| instead of |Circle|.

\initials{LDF 2004.04.20.}  
Added forward declarations of |struct Id_Map_Entry_Type|, 
|struct Id_Map_Type|, and |struct Scanner_Type|.
Forward declarations are needed so that I can declare
|Id_Map_Entry_Node|, |Id_Map_Node|, and |Scanner_Node| before the
complete declaration of the corresponding `Type' type.
The `Node' types are pointer types pointing to the `Type' types and
are declared using |typedef|.
They must be declared before the complete declaration of the `Type'
types because the latter 
include one or more data members of the corresponding `Node' type.

\initials{LDF 2004.05.25.}  
Added forward declaration of |class Shape|.

\initials{LDF 2004.07.21.}
Added |typedef Scanner_Type* Scanner_Node|.

\initials{LDF 2004.07.21.}
Added declaration of |struct Thread_Info_Type|.

\initials{LDF 2004.08.12.}
Added |typedef Id_Map_Entry_Type* Id_Map_Entry_Node|.

\initials{LDF 2004.08.29.}
Added forward declarations of |Id_Map_Type| and  |Id_Map_Node|.

\initials{LDF Undated.}
Added forward declarations of the classes |Solid|, |Solid_Faced|,
|Cuboid|, |Polyhedron|, |Tetrahedron|, |Octahedron|, |Dodecahedron|,
|Icosaahedron|, and |Trunc_Octahedron|.

\initials{LDF 2004.09.13.}
Added forward declarations of |Loop_Info_Type| and 
|Loop_Info_Node|.

\initials{LDF 2004.09.17.}
Added forward declaration for |class Color|.  It's needed for the
declarations for the template function instantiations of
|Id_Map_Entry_Type::set_subordinate_array| in \filename{io.web}.

\initials{LDF 2004.09.29.}
Added forward declaration for |class Transform|.  
It's needed for the declarations of |Scan_Parse::rotate_around_func|
in this file (\filename{pspglb.web}) and \filename{io.web}.

\initials{LDF 2004.10.01.}
Added forward declaration for |class Polygon|.  
It's needed for the declarations of 
|Scan_Parse::intersection_points_polygon_like|
in this file (\filename{pspglb.web}) and \filename{io.web}.

\initials{LDF 2004.11.12.}
Added forward declarations for |class Pen| and 
|class Dash_Pattern|.  

\initials{LDF 2004.12.21.}
Added forward declarations of |Definition_Info_Type| and 
|Definition_Info_Node|.

\initials{LDF 2005.01.26.}
Added forward declaration of |class Nurb|.

\initials{LDF 2005.02.03.}
Added forward declarations of the classes |Origami_Figure|
and |Origami_Subfigure|.

\initials{LDF 2005.05.19.}
Added the forward declaration for 
|struct Helix_Set_Option_Struct|.

\initials{LDF 2005.05.25.}
Added the forward declarations for 
|struct Cone_Set_Option_Struct| and |struct Cylinder_Set_Option_Struct|.

\initials{LDF 2005.05.26.}
Added the forward declaration for 
|struct Ellipsoid_Set_Option_Struct|.

\initials{LDF 2005.06.06.}
Added the forward declaration for 
|struct Sphere_Set_Option_Struct|.

\initials{LDF 2005.10.27.}
Added the forward declaration for 
|struct Bool_Point_Quadruple|

\initials{LDF 2005.10.28.}
Added the forward declaration for |class Sphere|.

\initials{LDF 2005.11.01.}
Added the forward declaration for |class Ellipsoid| and |class Triangle|.

\initials{LDF 2005.11.01.}
Added the forward declaration for |class Conic_Section|.

\initials{LDF 2005.11.01.}
Added the forward declaration for |class Rectangle|.

\initials{LDF 2005.11.07.}
Added forward declarations for 
|class  Parabola|, |class  Paraboloid|, 
|class  Hyperbola|, |class  Hyperboloid|, 
|struct Parabola_Set_Option_Struct|, 
|struct Paraboloid_Set_Option_Struct|, |struct Hyperbola_Set_Option_Struct|,
and |struct Hyperboloid_Set_Option_Struct|.

\initials{LDF 2007.07.29.}
Added forward declarations for 
|class  Conic_Section_Lattice| and |struct Conic_Section_Lattice_Options|.

\initials{LDF 2007.08.16.}
Added forward declarations for the following types:\hfil\break 
|class Parabola_Slice|\hfil\break 
|class Hyperbola_Slice|\hfil\break 
|class Paraboloid_Slice|\hfil\break 
|class Hyperboloid_Slice|\hfil\break 
|class Helix_Slice|\hfil\break 
|class Cone_Slice|\hfil\break 
|class Cylinder_Slice|\hfil\break 
|class Ellipsoid_Slice|\hfil\break 
|class Sphere_Slice|\hfil\break 
|class Glyph_Slice|\hfil\break 

\initials{LDF 2007.09.19.}
Added the forward declaration for |struct Focus_Options|.

\initials{LDF 2007.10.12.}
Added the forward declaration for |struct Polyhedron_Options|.

\initials{LDF 2007.10.13.}
Added the forward declaration for |class Arc|.

\initials{LDF 2007.11.25.}
Added the forward declaration for |struct Arc_Options|.

\initials{LDF 2007.11.28.}
Added the forward declarations for |class Matrix| and
|struct Matrix_Options|.

\initials{LDF 2009.11.04.}
Added the forward declaration for |class Sphere_Development|.

\initials{LDF 2009.11.17.}
Added the forward declaration for 
|struct Sphere_Development_Set_Option_Struct|.
\ENDLOG 

@q ** (2) Declarations.@>

@<Forward declarations@>=

class  Arc;
struct Arc_Options;
struct Bool_Point; 
struct Bool_Point_Quadruple; 
struct Bool_Real_Point; 
class  Conic_Section;
class  Conic_Section_Lattice;
struct Conic_Section_Lattice_Options;
class  Dodecahedron;
struct Polyhedron_Options;
class  Color;
class  Circle; 
class  Cuboid;
class  Dash_Pattern;
class  Ellipse; 
class  Ellipsoid; 
struct Focus;
class  Hyperbola;
class  Hyperboloid; 
class  Icosaahedron;
struct Line;
class Matrix;
struct Matrix_Options;
class  Nurb;
class  Pen;
class  Octahedron;
class  Origami_Figure;
class  Origami_Subfigure;
class  Parabola;   
class  Paraboloid; 
class  Path;
class  Picture;
struct Plane;
class  Point;
class  Parabola_Slice;
class  Hyperbola_Slice;
class  Paraboloid_Slice;
class  Hyperboloid_Slice;
class  Helix_Slice;
class  Cone_Slice;
class  Cylinder_Slice;
class  Ellipsoid_Slice;
class  Sphere_Slice;
class  Glyph_Slice;
class  Star;

template<class C, class D = C>
struct
Pointer_Vector;

class  Polygon;
class  Polyhedron;
class  Rectangle;
class  Shape;
class  Solid;
class  Solid_Faced;

class  Sphere;
class  Sphere_Development;

class  Tetrahedron;
class  Transform;
class  Triangle;
class  Trunc_Octahedron;

struct Focus_Options;

struct Cone_Set_Option_Struct;
struct Cylinder_Set_Option_Struct;
struct Ellipsoid_Set_Option_Struct;
struct Helix_Set_Option_Struct;
struct Hyperbola_Set_Option_Struct;
struct Hyperboloid_Set_Option_Struct;
struct Parabola_Set_Option_Struct;
struct Paraboloid_Set_Option_Struct;
struct Sphere_Set_Option_Struct;
struct Sphere_Development_Set_Option_Struct;
struct Stars_Get_Option_Struct;

struct Id_Map_Entry_Type;
typedef Id_Map_Entry_Type* Id_Map_Entry_Node;
struct Id_Map_Type; 

class Loop_Info_Type; 
typedef Loop_Info_Type* Loop_Info_Node;

class Definition_Info_Type; 
typedef Definition_Info_Type* Definition_Info_Node;

class Scanner_Type; 
typedef Scanner_Type* Scanner_Node;

struct Thread_Info_Type;

class Id_Map_Type;
typedef Id_Map_Type* Id_Map_Node;

@q ** (2) |namespace Scan_Parse|.@>
@*1 {\bf namespace Scan\_Parse}.

\LOG
\initials{LDF 2004.07.03.}
Added this declaration.  It's needed in order to declare 
|Scan_Parse::parse_func| to be a |friend| of |class Scanner_Type|.

\initials{LDF 2004.07.09.}
Added declarations of |endfig_func|, |output_func|, 
and |output_command_func|.  They also need to be |friends| of 
|class Scanner_Type|.

\initials{LDF 2004.07.16.}
Removed declaration of |endfig_func|, which no longer exists.
Added declaration of |beginfig_func|.

\initials{LDF 2004.07.21.}
Added additional |int| argument to |Scan_Parse::variable_func|
in the |friend| declarations.  It's needed in order to pass
|YYEMPTY| to the function.

\initials{LDF 2004.07.21.}
Added declaration of |non_shape_decl_func|.

\initials{LDF 2004.07.21.}
Added declaration of |log_message|.

\initials{LDF 2004.07.22.} 
Added declaration of |Scan_Parse::shape_decl_func|.

\initials{LDF 2004.07.23.}
Added default of 0 for the dummy |C*| argument for
|template <class C> shape_decl_func|.

\initials{LDF 2004.07.24.}
Added |assign_0_func| declaration.

\initials{LDF 2004.07.26.}
Changed |assign_0_func| to |assign_simple|.  Changed its return type
from |int_void_ptr_bool| to |Int_Void_Ptr| and its third argument from 
|C&| to |const C*|.

\initials{LDF 2004.07.26.}
Added declaration of the template function |assign_chained|.

\initials{LDF 2004.07.27.}
Added default of 0 for the argument |C* dummy| in the template function 
|assign_chained|.

\initials{LDF 2004.07.27.}
Added declaration of the template function 
|assign_simple_1|.

\initials{LDF 2004.07.28.}
Removed declaration of 
|assign_simple_1| and changed arguments for 
|assign_simple|.

\initials{LDF 2004.07.29.}
In |assign_simple|:
Changed |string type_name| and |C* expr| arguments to |const|.

\initials{LDF 2004.08.08.}
In the declaration of |assign_chained|:
Changed the |void* expr| argument to |const C* expr| and removed the 
|const C* dummy| argument. 

\initials{LDF 2004.08.12.}
Added declaration of |assign_picture_simple|.

\initials{LDF 2004.08.13.}
Added declaration of |assign_picture_chained|.

\initials{LDF 2004.08.13.}
Added declaration of |assign_point_numeric|.

\initials{LDF 2004.08.14.}
Added declaration of |set_color|.

\initials{LDF 2004.08.14.}
Added declaration of |set_focus|.

\initials{LDF 2004.08.14.}
In |set_focus| declaration:
Changed the type of the arguments |position| and |direction| 
from |void*| to |Point*|. 

\initials{LDF 2004.08.14.}
Added the |int| arguments |x_axis|, |y_axis|, and |z_axis| 
to the declaration of |set_focus|.  This makes it possible to leave the
definition in \filename{scanprse.web}.  The values passed are 
|X_AXIS|, |Y_AXIS|, and |Z_AXIS|, which are
terminal symbols declared in the parser file and therefore unknown when 
\filename{scanprse.web} is compiled.

\initials{LDF 2004.08.14.}
In the |set_focus| declaration:
Made the |int| arguments |x_axis|, |y_axis|, and |z_axis| 
|const|.

\initials{LDF 2004.08.16.}
Added declaration of |label_command|.

\initials{LDF 2004.08.17.}
Added declaration of |on_picture_optional_0|.

\initials{LDF 2004.08.17.}
Added declaration of |drawing_command|.

\initials{LDF 2004.08.17.}
Added declaration of |drawdot_command|.

\initials{LDF 2004.08.18.}
Added declaration of |variable_type|.

\initials{LDF 2004.08.20.}
Added default for the |bool| argument to |log_message|.

\initials{LDF 2004.08.24.}
Added declaration of the template function 
|vector_type_decl|.

\initials{LDF 2004.08.24.}
Made |vector_type_decl| a non-template function 
and changed its arguments.

\initials{LDF 2004.08.25.}
Made |vector_type_decl| a template function again
and added the argument |C* dummy| with default 0.

\initials{LDF 2004.08.30.}
Changed name of |drawing_command| to |drawing_command_path|. 

\initials{LDF 2004.08.30.}
Added declaration of |drawing_command_solid|.

\initials{LDF 2004.09.01.}
Added declaration of the |template| function
|vector_type_plus_assign|, which is defined in
\filename{scanprse.web}.    

\initials{LDF 2004.09.01.}
Added |Id_Map_Entry_Node entry| argument to
|vector_type_plus_assign|. 

\initials{LDF 2004.09.06.}
Added declaration of |intersection_point_command|.

\initials{LDF 2004.09.06.}
Changed the |Id_Map_Entry_Node path_entry_0| and 
|Id_Map_Entry_Node path_entry_1| arguments of 
|intersection_point_command|  to |Path* path_0| 
and |Path* path_1|.

\initials{LDF 2004.09.07.}
In |intersection_point_command|:
Changed name of |Id_Map_Entry_Node point_entry| argument to |entry|
and added |int type| argument. 

\initials{LDF 2004.09.07.}
Added declaration of |intersection_points_path_ellipse|.

\initials{LDF 2004.09.08.}
Added declaration of the template function
|intersection_points_ellipse_like|.

\initials{LDF 2004.09.10.}
Added declaration of |conditional|.

\initials{LDF 2004.09.10.}
In |conditional| declaration:  Changed |bool bool_value| argument to 
|int arg|.

\initials{LDF 2004.09.14.}
Added declaration of |input_command|.

\initials{LDF 2004.09.24.}
Added declaration of |transformation_command_func|.

\initials{LDF 2004.09.25.}
In |transformation_command_func|:  
Changed |Pointer_Vector<real>* pvr| argument to |void* v|.

\initials{LDF 2004.09.29.}
Added declaration of |rotate_around_func|.

\initials{LDF 2004.10.01.}
Added declaration of 
|transformation_assignment_command_func|.

\initials{LDF 2004.10.01.}
Added declaration of |intersection_points_polygon_like|.

\initials{LDF 2004.10.04.}
Added declaration of the template function |reflect_func|.

\initials{LDF 2004.10.08.}
Added declaration of |label_path_command|.

\initials{LDF 2004.10.12.}
Changed the name of |reflect_func| to |reflect_in_func|.

\initials{LDF 2004.10.25.}
Made |C* expr| argument of |assign_simple| non-|const|.

\initials{LDF 2004.10.26.}
Added declaration of the specialization of 
|Scan_Parse::assign_simple| for |real|.

\initials{LDF 2004.10.26.}
Removed the declaration of the specialization of
|Scan_Parse::assign_simple| for |real|, which didn't work.
Added the declaration of |assign_real|, which
replaces the former function.

\initials{LDF 2004.10.27.}
Added the argument |bool use_or_delete| to the template function
|assign_simple| with default |true|.  Removed the declaration of
|assign_real|.

\initials{LDF 2004.10.28.}
Added the declaration of |for_loop_func|.

\initials{LDF 2004.11.08.}
Added the declaration for the template function
|vector_type_assign|.

\initials{LDF 2004.11.10.}
Removed the declarations of |intersection_point_command|,
|intersection_points_path_ellipse|,
|intersection_points_ellipse_like|, 
and |intersection_points_polygon_like|.  These functions are no longer used.

\initials{LDF 2004.11.11.}
Added a second type parameter to the template function
|vector_type_assign| and removed the |int|
arguments |vector_type_num| and |array_type_num|, which
weren't used.

\initials{LDF 2004.11.13.}
Added declaration of the template function 
|pickup_command|.

\initials{LDF 2004.11.14.}
Added the declaration for the template function
|drop_command|.

\initials{LDF 2004.12.02.}
In the declaration of |Scan_Parse::assign_picture_simple|:
Changed |Id_Map_Entry_Node entry_0| argument to
|Picture* p|.

\initials{LDF 2004.12.03.}
In the declaration of |Scan_Parse::assign_picture_simple|:
Changed |Picture* p| argument back to |Id_Map_Entry_Node entry_0|.

\initials{LDF 2004.12.04.}
Added the declaration for the template function
|reflect_off_func|.

\initials{LDF 2004.12.09.}
In the declaration for the template function
|reflect_off_func|:
Changed the |C* reflection| argument to |Point_Vector<C>* pv|.
It's passed to |C::reflect_off|.  

\initials{LDF 2004.12.13.}
Added the declaration for |verbatim_metapost_func|.

\initials{LDF 2004.12.29.}
Added the declaration for |macro_definition_func|.

\initials{LDF 2005.01.02.}
Added the declaration for |is_symbolic_token|.

\initials{LDF 2005.01.02.}
Added the declaration for |macro_call_func|.

\initials{LDF 2005.01.03.}
Added |bool left_brace_predicate| argument to 
|macro_call_func| with default |false|.

\initials{LDF 2005.01.03.}
Added the declaration for |macro_vector_definition_func|.

\initials{LDF 2005.01.03.}
In the |vector_type_plus_assign| declaration:
Added |bool copy_object| argument with the default |true|.

\initials{LDF 2005.01.03.}
Added the declaration for |clear_vector_func|.

\initials{LDF 2005.01.05.}
Added the declarations for |push_back_func| and
|pop_back_func|.

\initials{LDF 2005.01.18.}
Added the declaration of |for_suffixes_loop_func|.

\initials{LDF 2005.01.19.}
Added the declaration of |for_suffixes_internal_func|.

\initials{LDF 2005.01.19.}
Added |unsigned short ctr| argument to 
|for_suffixes_internal_func|.

\initials{LDF 2005.01.26.}
Added the declaration of |let_func|.

\initials{LDF 2005.01.26.}
In the declaration of |let_func|:
Removed the second |string| argument.

\initials{LDF 2005.01.29.}
In |label_point_command| declaration:
Added |Color* text_color| and |Color* dot_color| 
arguments.

\initials{LDF 2005.01.31.}
In |label_path_command| declaration:
Added |Color* text_color| and |Color* dot_color| 
arguments.

\initials{LDF 2005.02.23.}
Added the declaration of |decompose_func|.

\initials{LDF 2005.02.24.}
Added the arguments |void* object_2| and |int type_2| to 
|decompose_func|.

\initials{LDF 2005.03.10.}
Added the declaration of |drawing_command_path_vector|.

\initials{LDF 2005.08.14.}
Added |Transform* transform| argument to |label_point_command|.

\initials{LDF 2005.11.03.}
Added |const unsigned short DEFAULT_PRECISION|.

\initials{LDF 2007.08.14.}
Added the declaration of |reverse_func|.

\initials{LDF 2007.08.16.}
Made |reverse_func| a template function.
\ENDLOG 

@q *** (3) Declaration.@>

@<Declare |namespace Scan_Parse|@>=

namespace 
Scan_Parse
{

   const unsigned short DEFAULT_PRECISION = 6;

   struct Picture_Output_Arg_Type;

@q **** (4) Functions for groups.@>   
@*3 Functions for groups.
\initials{LDF 2007.10.09.}

\LOG
\initials{LDF 2007.10.09.}
Added this section with the declaration of |end_group_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void
end_group_func(void* parameter);

@q **** (4) Functions for numerics.@>   
@*3 Functions for numerics.
\initials{LDF 2005.08.29.}

\LOG
\initials{LDF 2005.08.29.}
Added this section with the declaration of |measure_text_func|.

\initials{LDF 2005.08.30.}
In |measure_text_func|:
Replaced the argument |real* r| with |Pointer_Vector<real>* pv|.

\initials{LDF 2005.08.30.}
Added the declaration of |numeric_vector_assignment_func|.

\initials{LDF 2007.02.06.}
Added the declaration of |numeric_primary_rule_func_0|.

\initials{LDF 2007.11.04.}
Added the declaration of |numeric_primary_rule_func_1|.

\initials{LDF 2007.11.04.}
Added the declaration of |numeric_list_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
measure_text_func(Scanner_Node scanner_node, 
                  void* v,
                  Pointer_Vector<real>* pv);

void*
numeric_vector_assignment_func(Scanner_Node scanner_node,
                               void* v,
                               void* w);

int
numeric_primary_rule_func_0(int          operator_value,
                            real         operand,
                            real*        result,
                            Scanner_Node scanner_node);

real
numeric_primary_rule_func_1(int point_part,
                            void* v,
                            void* parameter);

void*
numeric_list_rule_func_0(void* v, void* parameter);

@q **** (4) Functions for complex numbers.@>   
@*3 Functions for complex numbers.
\initials{LDF 2007.12.11.}

\LOG
\initials{LDF 2007.12.11.}
Added this section with the declarations of 
|complex_arith_op_rule_func| and |complex_primary_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
complex_arith_op_rule_func(void* v,
                           void* w,
                           int op,
                           void* parameter = 0);

void*
complex_primary_rule_func_0(void* v,
                            int op,
                            void* parameter = 0);

@q **** (4) Functions for matrices.@>   
@*3 Functions for matrices.
\initials{LDF 2007.12.20.}

\LOG
\initials{LDF 2007.12.20.}
Added this section with the declaration of 
|matrix_secondary_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
matrix_secondary_rule_func_0(void* v, void* w, void* parameter = 0);

@q **** (4) @>   
@
@<Declare |namespace Scan_Parse|@>=

void*
parse_func(void*);

void*
output_func(void*);

int
output_command_func(Scanner_Node);

int
beginfig_func(Scanner_Node, int);

String_Bool variable_func(Scanner_Node,
                          char*,
                          char*,
                          int,
                          int);

int non_shape_decl_func(Scanner_Node, int);

template <class C> int shape_decl_func(Scanner_Node,
                                       int,
                                       C* dummy = 0);

int log_message(stringstream&, bool do_endl = true);

template <class C> 
  Int_Void_Ptr
    assign_simple(Scanner_Node scanner_node,
                  const string type_name,
                  void* var,
                  C* expr,
                  bool use_or_delete_expr = true);

template <class C>
  Int_Void_Ptr
    assign_chained(Scanner_Node scanner_node,
                   void* var,
                   const C* expr);

Int_Void_Ptr
  assign_picture_simple(Scanner_Node scanner_node,
                        Id_Map_Entry_Node entry,
                        Id_Map_Entry_Node entry_0);

Int_Void_Ptr
  assign_picture_chained(Scanner_Node scanner_node,
                         Id_Map_Entry_Node entry,
                         Id_Map_Entry_Node entry_0);

Int_Void_Ptr
  assign_point_numeric(Scanner_Node scanner_node,
                       Id_Map_Entry_Node entry,
                       real x);

Int_Void_Ptr
  set_color(Scanner_Node scanner_node,
            Id_Map_Entry_Node entry,
            real red_part,
            real green_part,
            real blue_part);

Int_Void_Ptr
  set_focus(Scanner_Node scanner_node,
            Id_Map_Entry_Node entry,
            Point* position,
            Point* direction,
            real distance,
            real angle,
            int axis,
            const int x_axis,
            const int y_axis,
            const int z_axis);

@q **** (4) Functions for labels.@> 
@ Functions for labels.

\LOG
\initials{LDF 2005.12.01.}
Added the declaration of |label_bool_point_func|.
\ENDLOG 

@<Declare |namespace Scan_Parse|@>=

   int
     label_point_command(Scanner_Node scanner_node,
                         int label_or_dotlabel,
                         int label_suffix,
                         string* text_str,
                         Point* position,
                         Transform* transform,
                         Color* text_color,
                         Color* dot_color,
                         Id_Map_Entry_Node entry);

   int
   label_bool_point_func(void* parameter,
                         int label_type, 
                         int suffix, 
                         void* str, 
                         real num, 
                         void* bp, 
                         void* col, 
                         void* dot_col,
                         void* pict);

     int
     label_path_command(Scanner_Node scanner_node,
                        int label_or_dotlabel,
                        int label_suffix,
                        string* text_str,
                        Color* text_color,
                        Color* dot_color,
                        int start_ctr,
                        Path* position,
                        Id_Map_Entry_Node entry);
 
@q **** (4) Functions for |Points|.@> 
@*3 Functions for {\bf Points}.
\initials{LDF 2005.12.09.}

\LOG
\initials{LDF 2005.12.09.}
Added this section with the declaration of |Scan_Parse::normal_func|.

\initials{LDF 2009.11.16.}
Added declaration of |Scan_Parse::drawing_command_sphere_development|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

template <class C>
void*
normal_func(C* c, Scanner_Node scanner_node = 0);

@q **** (4)@>   
@
@<Declare |namespace Scan_Parse|@>=
   
void*
on_picture_optional_0(Scanner_Node scanner_node);

int
drawing_command_path(Scanner_Node scanner_node,
                     int basic_drawing_command,
                     Path* ppath);
int
drawing_command_path_vector(Scanner_Node scanner_node,
                            int basic_drawing_command,
                            Pointer_Vector<Path>* pv);

int
drawing_command_solid(Scanner_Node scanner_node,
                      int basic_drawing_command,
                      Solid* solid);

int
drawing_command_sphere_development(Scanner_Node scanner_node,
                                   int basic_drawing_command,
                                   Sphere_Development* sd);

int
drawdot_command(Scanner_Node scanner_node,
                int drawdot_or_undrawdot,
                Point* ppoint);
   
Int_Void_Ptr
variable_type(Scanner_Node scanner_node,
              Id_Map_Entry_Node entry,
              string curr_name,
              int curr_type);

template <class C>
int 
vector_type_decl(Scanner_Node scanner_node,
                     int vector_type_num,
                     int array_type_num,
                     C* dummy = 0);

template <class C>
int 
vector_type_plus_assign(Scanner_Node scanner_node,
                        Id_Map_Entry_Node entry,
                        int vector_type_num,
                        int array_type_num,
                        C* object,
                        bool copy_object = true);

template <class C, class D>
int 
vector_type_assign(Scanner_Node scanner_node,
                   Id_Map_Entry_Node entry,
                   const Pointer_Vector<D>* object_vector,
                   C* dummy = 0);

int 
conditional(Scanner_Node scanner_node,
              int arg);

int
input_command(Scanner_Node scanner_node, string* filename);

int
transformation_command_func(Scanner_Node scanner_node,
                              int transformation_type,
                              Id_Map_Entry_Node entry,
                              void* v);
Transform* 
rotate_around_func(Scanner_Node scanner_node,
                     Point* p,
                     Point* q,
                     real r);

Transform*
transformation_assignment_command_func(Scanner_Node scanner_node,
                                       Id_Map_Entry_Node entry,
                                       Transform* t);
template <class C>
C*
reflect_in_func(Scanner_Node scanner_node,
                 C* object,
                 Path* plane_path);

int
for_loop_func(Scanner_Node scanner_node,
              const unsigned short loop_type,
              string curr_symbol = "",
              real start_value = 0,
              real step_value = 0,
              real limit_value = 0);

int 
for_suffixes_loop_func(Scanner_Node scanner_node,
                       string curr_symbol);

int
for_suffixes_internal_func(Scanner_Node scanner_node,
                           unsigned int ctr);

template<class C>
int
pickup_command(Scanner_Node scanner_node,
               C* expression,
               C* pointer);

template<class C>
int
drop_command(Scanner_Node scanner_node,
             C** pointer,
             string pointer_name);

template <class C, class D>
int
reflect_off_func(Scanner_Node scanner_node,
                 C* object,
                 Path* plane_path,
                 Point* direction,
                 Pointer_Vector<C, D>* pv);

int
verbatim_metapost_func(Scanner_Node scanner_node, 
                       const string* s);

int
macro_definition_func(Scanner_Node scanner_node,
                      Id_Map_Entry_Node entry);

int
macro_vector_definition_func(Scanner_Node scanner_node,
                             Id_Map_Entry_Node entry);

int
macro_call_func(Scanner_Node scanner_node,
                Id_Map_Entry_Node entry,
                bool left_brace_predicate = false);

bool
is_symbolic_token(int curr_token);

int
clear_vector_func(Scanner_Node scanner_node, 
                  Id_Map_Entry_Node entry);

int
push_back_func(Scanner_Node scanner_node, 
               Id_Map_Entry_Node entry);
int
pop_back_func(Scanner_Node scanner_node, 
              Id_Map_Entry_Node entry);

template<class C>
int
reverse_func(void* v, void* parameter = 0, C* c = 0);

int
let_func(Scanner_Node scanner_node,
         string s);

int
decompose_func(Scanner_Node scanner_node,
               void* object_0, 
               int type_0, 
               void* object_1, 
               int type_1,
               void* object_2, 
               int type_2,
               void* vector_object,
               int vector_type);

@q **** (4) Parser rule functions.@>   
@*3 Parser rule functions.
\initials{LDF 2005.04.15.}

\LOG
\initials{LDF 2005.04.15.}
Added this section.
\ENDLOG

@q ***** (5) Functions for assignments.@> 
@ Functions for assignments.
\initials{LDF 2005.11.30.}

\LOG
\initials{LDF 2005.11.30.}
Added this section with the declaration of |bool_point_vector_assignment_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
bool_point_vector_assignment_func(void* v, void* w, void* parameter);

@q ***** (5) |string| expressions.@>  
@ {\bf string} expressions.
\initials{LDF 2005.11.03.}

\LOG
\initials{LDF 2005.11.03.}
Added this section with the declaration of |string_primary_rule_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
string_primary_rule_func(void* v, void* parameter = 0);

@q ***** (5) |transform| expressions.@>  
@ {\bf transform} expressions.

\LOG
\initials{LDF 2005.04.15.}
Added this section with the declaration of |transform_primary_rule_0|.

\initials{LDF 2005.04.16.}
Added the declaration of |transform_primary_rule_1|.

\initials{LDF 2005.11.18.}
Added the declaration of |standardize_func|.

\initials{LDF 2007.10.02.}
Added the declaration of |align_path_func|.

\initials{LDF 2007.10.14.}
Added the |int command| argument to |transform_primary_rule_func_1|.
Changed the |void* ttransform| argument to |Transform* transform|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
transform_primary_rule_func_0(void* ffocus,
                              Scanner_Node scanner_node = 0);

void*
transform_primary_rule_func_1(Transform* transform,
                              int command,
                              Scanner_Node scanner_node = 0);

template<class C>
void*
standardize_func(C* c, void* v = 0);
   
void*
align_path_func(void* v, int ax, void* parameter = 0);

@q ***** (5) |point| expressions.@>  
@ {\bf point} expressions.

\LOG
\initials{LDF 2005.04.15.}
Added this section with the declaration of |point_primary_rule_0|.

\initials{LDF 2005.04.15.}
Changed the name of |point_primary_rule_0| to 
|point_primary_rule_func_0| and added the argument 
|void* ffocus|.

\initials{LDF 2005.04.15.}
In the declaration of |point_primary_rule_0|:
Added optional |Scanner_Node scanner_node| argument with default 0.

\initials{LDF 2005.04.19.}
Changed the name of |point_primary_rule_func_0| 
to |point_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z| to |point_secondary_rule_0|.

\initials{LDF 2007.11.04.}
Added the declaration of |point_primary_rule_func_0| (a new version).
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
point_primary_rule_func_0(void* v, void* parameter);

void*
point_secondary_rule_func_0(void* ppoint, 
                            void* ffocus,
                            int with_z,
                            Scanner_Node scanner_node = 0);

@q ***** (5) |path| expressions.@>  
@ {\bf path} expressions.

\LOG
\initials{LDF 2005.04.15.}
Added this section with the declaration of |path_primary_rule_0|.

\initials{LDF 2005.04.19.}
Changed the name of |path_primary_rule_func_0| 
to |path_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z| to |path_secondary_rule_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
path_secondary_rule_func_0(void* ppath, 
                              void* ffocus,
                              int with_z,
                              Scanner_Node scanner_node = 0);

@q ***** (5) |polygon| expressions.@>  
@ {\bf polygon} expressions.

\LOG
\initials{LDF 2005.04.15.}
Added this section with the declaration of |polygon_primary_rule_0|.

\initials{LDF 2005.04.19.}
Changed the name of |polygon_primary_rule_func_0| 
to |polygon_secondary_rule_func_0|.

\initials{LDF 2005.04.19.}
Added the argument |int with_z| to |polygon_secondary_rule_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
polygon_secondary_rule_func_0(void* ppolygon, 
                                 void* ffocus,
                                 int with_z,
                                 Scanner_Node scanner_node = 0);

@q ***** (5) Functions for conic sections and |Conic_Section_Lattices|.@>  
@ Functions for conic sections and {\bf Conic\_Section\_Lattices}.
\initials{LDF Undated.}

\LOG
\initials{LDF 2007.07.03.}
Added this section with the declaration of |get_conic_section_func|.

\initials{LDF 2007.07.03.}
Added |const unsigned short conic_section_type| argument
to |Scan_Parse::get_conic_section_func|.

\initials{LDF 2007.07.09.}
Added the declaration of |Scan_Parse::get_hyperbola_branch_func|.

\initials{LDF 2007.07.15.}
Added |real tolerance| and |bool ignore_extra_points| arguments 
to |Scan_Parse::get_conic_section_func|.

\initials{LDF 2007.07.20.}
Added optional |bool test_points| argument with the default |true|.

\initials{LDF 2007.07.20.}
Added optional |bool rectify_points| argument with the default |true|.

\initials{LDF 2007.07.20.}
In the declaration of |Scan_Parse::get_conic_section|:
Changed the default value of |real tolerance| argument from |INVALID_REAL|
to -1.

\initials{LDF 2007.08.05.}
Added declaration of |get_conic_section_lattice_func|.

\initials{LDF 2007.08.08.}
Added declaration of |traverse_conic_section_lattice_func|.

\initials{LDF 2007.08.16.}
Added declaration of |conic_section_lattice_intersection_func|.

\initials{LDF 2007.08.21.}
Added the |real| arguments |tolerance| and |increment| to the declaration of 
|conic_section_lattice_intersection_func|.
\ENDLOG

@q ****** (6) Code.@>

@<Declare |namespace Scan_Parse|@>=

void*
get_hyperbola_branch_func(real r, 
                          void* v, 
                          void* parameter = 0);

template<class C>
void*
get_conic_section_func(Pointer_Vector<Point>* pv,
                       int increment_value,
                       const unsigned short conic_section_type,
                       C* c, 
                       void* parameter = 0,
                       bool test_points = true,
                       bool rectify_points = true,
                       real tolerance = -1,
                       bool ignore_extra_points = true);

void* 
get_conic_section_lattice_func(Pointer_Vector<Point>* pv, 
                               Scanner_Node scanner_node = 0,
                               Conic_Section_Lattice_Options* options = 0);

void* 
traverse_conic_section_lattice_func(void* parameter,
                                    void* c,
                                    real start, 
                                    real end);

template<class C>
void*
conic_section_lattice_intersection_func(Scanner_Node scanner_node,
                                        Conic_Section_Lattice* conic_section_lattice,
                                        C* c,
                                        real tolerance,
                                        real increment);

@q ***** (5) |cuboid| expressions.@>  
@ {\bf cuboid} expressions.

\LOG
\initials{LDF 2005.12.07.}
Added this section with the declarations of |in_cuboid_func|
and |out_cuboid_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

template<class C>
void*
in_cuboid_func(C* c, void* parameter = 0);

template<class C>
void*
out_cuboid_func(C* c, void* parameter = 0);

@q ***** (5) Functions for |Pointer_Vectors|.@> 
@ Functions for {\bf Pointer\_Vectors}.
\initials{LDF 2007.07.23.}

\LOG
\initials{LDF 2007.07.23.}
Added this section with the declaration of |cull_func|.

\initials{LDF 2007.07.23.}
Added optional |const unsigned short comparison| argument
to |cull_func|.  The default is 0.

\initials{LDF 2007.07.27.}
Added optional |real tolerance| argument to |cull_func|.  
The default is -1.

\initials{LDF 2007.07.27.}
Added the declaration of |rectify_func|.

\initials{LDF 2007.08.05.}
Changed types of arguments of |Scan_Parse::rectify_func|.

\initials{LDF 2007.08.06.}
Added optional |Transform* transform| argument to 
|Scan_Parse::rectify_func|.  The default is 0.

\initials{LDF 2007.08.06.}
Added optional |bool do_transform| argument to 
|Scan_Parse::rectify_func|.  The default is |true|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

template<class C>
int
cull_func(void* v, 
          const unsigned short comparison = 0,
          Scanner_Node scanner_node  = 0, 
          real tolerance = -1,
          C* c = 0);

template<class C>
int 
rectify_func(void* v,
             Scanner_Node scanner_node = 0,
             bool do_test = true,
             bool do_cull = true,
             bool do_transform = true,
             real tolerance = -1,
             Transform* t = 0,
             C* c = 0);

@q ***** (5) Functions for Quadric Surfaces.@> 
@ Functions for Quadric Surfaces.
\initials{LDF 2006.11.09.}

\LOG
\initials{LDF 2006.11.09.}
Added this section with the declaration of
|quad_surf_get_element_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
quad_surf_get_element_func(void* parameter      = 0, 
                           unsigned int command = 0,
                           unsigned int type    = 0,
                           void* object         = 0,
                           int arg_0            = 0,
                           int arg_1            = 0);

@q ***** (5) Operation assignments.@>  
@ Operation assignments.

\LOG
\initials{LDF 2005.05.12.}
Added this section.
\ENDLOG

@q ****** (6) Operation assignments for |pictures|.@>  
@ Operation assignments for {\bf pictures}.

\LOG
\initials{LDF 2005.05.12.}
Added this section with the declaration of 
|operation_assignment_picture_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
operation_assignment_picture_rule_func_0(void* to_picture_entry,
                                            void* from_picture_entry,
                                            Scanner_Node scanner_node = 0);

@q ***** (5) Set commands.@>  
@ Set commands.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this section.
\ENDLOG

@q ****** (6) Set commands for |Parabolae|.@>  
@ Set commands for |Parabolae|.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2007.11.28.}
Added this section with the declaration of 
|set_matrix_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_matrix_rule_func_0(void* curr_var,
                       real rrows,
                       real ccolumns,
                       void* parameter);

@q ****** (6) Set commands for |Parabolae|.@>  
@ Set commands for |Parabolae|.
\initials{LDF 2005.11.07.}

\LOG
\initials{LDF 2005.11.07.}
Added this section with the declaration of 
|set_parabola_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_parabola_rule_func_0(void* curr_var,
                         void* parameter);

@q ****** (6) Set commands for |Hyperbolae|.@>  
@ Set commands for |Hyperbolae|.
\initials{LDF 2005.11.14.}

\LOG
\initials{LDF 2005.11.14.}
Added this section with the declaration of 
|set_hyperbola_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_hyperbola_rule_func_0(void* curr_var,
                          void* parameter);

@q ****** (6) Set commands for |arcs|.@>  
@ Set commands for |arcs|.
\initials{LDF 2007.11.25.}

\LOG
\initials{LDF 2007.11.25.}
Added this section with the declaration of 
|set_arc_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_arc_rule_func_0(void* curr_var,
                    void* parameter);

@q ****** (6) Set commands for |Helices|.@>  
@ Set commands for |Helices|.
\initials{LDF 2005.05.19.}

\LOG
\initials{LDF 2005.05.19.}
Added this section with the declaration of 
|set_helix_rule_func_0|.

\initials{LDF 2005.05.21.}
Removed the |void* option_list| argument from |set_helix_rule_func_0|.
The |void* parameter| argument is now required.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_helix_rule_func_0(void* curr_var,
                      void* parameter);

@q ****** (6) Set commands for |Cones|.@>  
@ Set commands for |Cones|.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this section with the declaration of 
|set_cone_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_cone_rule_func_0(void* curr_var,
                     void* parameter);

@q ****** (6) Set commands for |Cylinders|.@>  
@ Set commands for |Cylinders|.
\initials{LDF 2005.05.25.}

\LOG
\initials{LDF 2005.05.25.}
Added this section with the declaration of 
|set_cylinder_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_cylinder_rule_func_0(void* curr_var,
                     void* parameter);

@q ****** (6) Set commands for |Ellipsoids|.@>  
@ Set commands for |Ellipsoids|.
\initials{LDF 2005.05.26.}

\LOG
\initials{LDF 2005.05.26.}
Added this section with the declaration of 
|set_ellipsoid_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_ellipsoid_rule_func_0(void* curr_var,
                          void* parameter);

@q ****** (6) Set commands for |Spheres|.@>  
@ Set commands for |Spheres|.
\initials{LDF 2005.06.06.}

\LOG
\initials{LDF 2005.06.06.}
Added this section with the declaration of 
|set_sphere_rule_func_0|.

\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_sphere_rule_func_0(void* curr_var,
                       void* parameter);

@q ****** (6) Set commands for |Sphere_Developments|.@>  
@ Set commands for |Spheres_Developments|.
\initials{LDF 2009.11.17.}

\LOG
\initials{LDF 2009.11.17.}
Added this section with the declaration of 
|set_sphere_development_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_sphere_development_rule_func_0(void* curr_var,
                                   void* parameter);

@q ****** (6) Set commands for |Paraboloids|.@>  
@ Set commands for |Paraboloids|.
\initials{LDF 2006.01.25.}

\LOG
\initials{LDF 2006.01.25.}
Added this section with the declaration of 
|set_paraboloid_rule_func_0|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
set_paraboloid_rule_func_0(void* curr_var,
                           void* parameter);

@q ***** (5) Variable declarations.@>  
@ Variable declarations.
\initials{LDF 2005.06.06.}

\LOG
\initials{LDF 2005.06.08.}
Added this section with the declaration of 
|glyph_vector_variable_rule_func_0|.

\initials{LDF 2005.06.08.}
Changed the type of |arg1| from |void*| to |char*|.

\initials{LDF 2005.06.08.}
Removed the declaration of |glyph_vector_variable_func|
and replaced it with the declaration of 
|vector_variable_decl_func|.

\initials{LDF 2005.06.09.}
Removed the declaration of |simple_variable_decl_func|.
Changed |vector_variable_decl_func| to |variable_decl_func|.
There's no need for separate versions for simple and vector-type
variables.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
variable_decl_func(char* arg1,
                   void* arg2,
                   unsigned int type,
                   void* parameter);

@q ***** (5) Functions for |Points|.@>   
@ Functions for {\bf Points}.
\initials{LDF 2005.10.25.}

\LOG
\initials{LDF 2005.10.25.}
Added this section with the declaration of the template function
|get_center_func|.

\initials{LDF 2005.11.09.}
Added the declarations of the template functions
|get_focus0_func| and |get_vertex_func|.

\initials{LDF 2005.11.09.}
Added the declaration of the template function |get_point|.

\initials{LDF 2005.11.14.}
Changed the names of |get_focus0_func| and |get_vertex_func|
to |get_focus_0_func| and |get_vertex_0_func|, respectively.
Added the declarations of |get_focus_1_func| and |get_vertex_1_func|.

\initials{LDF 2005.11.17.}
Changed the name of |get_focus_0_func| to |get_focus_func|
and the name of |get_vertex_0_func| to |get_vertex_func|.
Added optional |const unsigned short s| arguments with the default 0.
Removed |get_focus_1_func| and |get_vertex_1_func|.

\initials{LDF 2007.08.03.}
Added declaration of the specialization of |get_point_func| where the 
template type argument is |Conic_Section_Lattice|.
\ENDLOG

@q ****** (6) Code.@> 

@<Declare |namespace Scan_Parse|@>=

template <class C>
void*
get_point_func(real r, C* c, void* parameter = 0);

template <>
void*
get_point_func(real r, 
               Conic_Section_Lattice* c, 
               void* parameter);

template <class C>
void*
get_center_func(C* c, void* parameter = 0);

template <class C>
void*
get_focus_func(C* c, const unsigned short s = 0, void* parameter = 0);

template <class C>
void*
get_vertex_func(C* c, const unsigned short s = 0, void* parameter = 0);

@q ***** (5) Functions for |Focuses|.@>   
@ Functions for {\bf Focuses}.
\initials{LDF 2007.09.19.}

\LOG
\initials{LDF 2007.09.19.}
Added this section with the declaration of the function
|rotate_focus_func|.

\initials{LDF 2007.09.19.}
Removed the |real tolerance| argument from |rotate_focus_func|.
\ENDLOG

@q ****** (6) Code.@> 

@<Declare |namespace Scan_Parse|@>=

int
rotate_focus_func(void* id, 
                  void* num, 
                  int axes, 
                  void* parameter = 0);

@q ***** (5) Functions for |Planes|.@>   
@ Functions for {\bf Planes}.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this section with the declarations of 
|plane_cast_func| and |plane_assignment_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

template<class C>
void*
plane_cast_func(C* c, void* parameter = 0);

template <class C>
void*
plane_assignment_func(void* entry, C* c, void* parameter = 0);

@q ***** (5) Functions for |strings|.@>   
@ Functions for {\bf strings}.
\initials{LDF 2005.09.09.}

\LOG
\initials{LDF 2005.09.09.}
Added this section with the declarations of 
|binary_number_string_func| and 
|sub_binary_number_string_func|.

\initials{LDF 2005.09.10.}
In the declaration of |sub_binary_number_string_func|:
Added optional |bool oversize_switch| argument with 
the default |false|.  This required making 
|Scanner_Node scanner_node| optional, too.  The default is 0.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

string*
binary_number_string_func(real r, Scanner_Node scanner_node);

template<class C>
string*
sub_binary_number_string_func(C c, 
                              bool oversize_switch = false,
                              Scanner_Node scanner_node = 0);

@q ***** (5) Functions for |Polyhedra|.@>   
@ Functions for {\bf Polyhedra}.
\initials{LDF 2005.12.20.}

\LOG
\initials{LDF 2005.12.20.}
Added this section with the declaration of |polyhedron_get_net_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
polyhedron_get_net_func(int type, real diameter, int do_half, void* parameter);

@q ***** (5) Functions for extracting information.@> 
@* Functions for extracting information.
\initials{LDF 2009.09.09.}

\LOG
\initials{LDF 2009.09.09.}
Added this section with the declaration of |sphere_size_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=
int
sphere_size_func(void* v, void* parameter = 0);

@q ***** (5) Functions for terminal output.@>   
@ Functions for terminal output.
\initials{LDF 2005.10.27.}

\LOG
\initials{LDF 2005.10.31.}
Added this section with the declaration of |show_func|.

\initials{LDF 2005.11.03.}
Added declaration of |message_command_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

int
message_command_func(int message_type, void* v, void* parameter = 0);

template <class C>
int
show_func(C* c, string text = "", void* parameter = 0);

@q ***** (5) Functions for intersections.@>   
@ Functions for intersections.
\initials{LDF 2005.10.27.}

\LOG
\initials{LDF 2005.10.27.}
Added this section with the declaration of 
|intersection_points_func|.

\initials{LDF 2005.10.27.}
Added the declaration of |convert|.

\initials{LDF 2005.10.28.}
Added the declaration of |ellipse_intersection_func|.

\initials{LDF 2005.10.28.}
Replaced the declaration of |ellipse_intersection_func| with
the declaration of the template function
|ellipse_like_intersection_func|.

\initials{LDF 2005.10.28.}
Added the declaration of |polygon_like_intersection_func|.

\initials{LDF 2005.10.28.}
Added the declaration of |sphere_plane_intersection_func|.

\initials{LDF 2005.10.28.}
Added the declaration of |sphere_line_intersection_func|

\initials{LDF 2005.10.30.}
In the declaration of |sphere_plane_intersection_func|:
Changed the |Path*| argument to a |Plane*|.

\initials{LDF 2005.10.31.}
Replaced |sphere_plane_intersection_func| with the 
template function |ellipsoid_like_plane_intersection_func|.

\initials{LDF 2005.11.04.}
Added declaration of the template function
|ellipse_like_plane_intersection_func|.

\initials{LDF 2005.11.17.}
Added declaration of the template function
|conic_section_line_intersection_func|.

\initials{LDF 2005.11.21.}
Changed the name of |conic_section_line_intersection_func|
to |conic_section_intersection_func| and added a second 
template parameter.  Changed the |Path*| argument to 
a pointer to the type of the new template parameter.

\initials{LDF 2006.01.20.}
Added declaration of |polyhedron_path_intersection_func|.

\initials{LDF 2007.10.06.}
Added the declaration of |plane_intersection_func|.
\ENDLOG

@q ****** (6) Code.@> 

@<Declare |namespace Scan_Parse|@>=

template <class C, class D, class E>
void*
intersection_points_func(C* c, 
                         D* d, 
                         void* parameter = 0, 
                         E* e = 0);

Pointer_Vector<Bool_Point>*
convert(Bool_Point_Quadruple* bpq, void* parameter = 0, bool delete_bpq = true);

template<class C, class D>
void*
ellipse_like_intersection_func(C* c, D* d, void* parameter = 0);

template<class C>
void*
ellipse_like_plane_intersection_func(C* c, void* w, void* parameter = 0);

template<class C, class D>
void*
conic_section_intersection_func(C* c, D* d, void* parameter = 0);

template<class C, class D>
void*
polygon_like_intersection_func(C* c, D* d, void* parameter = 0);

template<class C>
void*
ellipsoid_like_plane_intersection_func(C* c,
                                       Plane* p,
                                       void* parameter = 0);
void*
sphere_line_intersection_func(Sphere* s,
                              Path* p,           
                              void* parameter = 0);  

void*
polyhedron_path_intersection_func(Polyhedron* p,
                                  Path* q,
                                  void* parameter = 0);  

int
save_to_database_func(Scanner_Node scanner_node, string prefix, bool debug = false);

int
restore_from_database_func(Scanner_Node scanner_node, 
                           string prefix, 
                           int overwrite_option, 
                           bool debug = false);

int 
get_stars_func(Scanner_Node, vector<Star*>&);

int 
plot_stars_func(Scanner_Node);

int
show_stars_func(Scanner_Node);

int
plot_stars_func(Sphere *, Scanner_Node);

template <class C>
int
show_func(C* c, string text, void* parameter);

void*
plane_intersection_func(void* v, void* w, void* parameter = 0);

@q ***** (5) Clipping |Pictures|.@>   
@ Clipping {\bf Pictures}.
\initials{LDF 2005.08.16.}

\LOG
\initials{LDF 2005.08.16.}
Added this section with the declaration of |clip_to_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
clip_to_func(void* arg1,
             void* parameter);

@q ***** (5) Predicates.@>   
@ Predicates.

\LOG
\initials{LDF 2005.10.24.}
Added this section with the declaration of |is_cycle_func|.

\initials{LDF 2005.10.26.}
Added the declaration of the template function |is_whatever_func|.

\initials{LDF 2005.10.26.}
Added the declaration of |is_on_sphere_func|.
\ENDLOG

@<Declare |namespace Scan_Parse|@>=

void*
is_cycle_func(void* arg1,
              void* parameter);

template<class C>
void*
is_whatever_func(C* c, void* parameter = 0);

void*
is_on_sphere_func(void* ppoint, 
                  void* ssphere, 
                  void* parameter = 0,
                  real tolerance = -1);

@q **** (4) @>   

 };

@q ** (2) Dummy function.  @>
@*1 Dummy function.  This function is useful with GDB, when the latter
can't recognize the name of a function.
\initials{2008.12.19.}

\LOG
\initials{2008.12.19.}
Added this function.
\ENDLOG

@q ** (2) Declaration  @>

@<Declare |dummy_func|@>=
int 
dummy_func(void);

@q *** (3) Definition @>
@
@<Define |dummy_func|@>=
int 
dummy_func(void)
{
   return 0;
}

@q * (1) Putting pspglb together.@>
@ Putting {\tt pspglb} together.

\immediate\write\functexifile{^^JEnd of file:  pspglb.web^^J}

@q ** (2) This is what's compiled.@>
@ This is what's compiled.
@c
@<Include files@>@;
@<Type definitions@>@;
@<Forward declarations@>@;
@<Utility classes@>@;
@<Declare utility functions@>@;
@<Declare |namespace Scan_Parse|@>@;
@<Declare |struct Mutex_Type|@>@;
@<Declare |struct Cond_Var_Type|@>@;
@<Declare |struct Thread_Info_Type|@>@;
@<Declare |static Thread_Info_Type| member variables@>@;
@<Declare |struct Bad_Assignment_Type|@>@;
@<Declare |struct Parser_Error_Type|@>@;
@<Global variables@>@; 
@<Global constants@>@; 
@<Define |Real_Triple| functions@>@;
@<Define utility functions@>@;
@<Declare |namespace System|@>@;
@<Declare |struct Run_State|@>@;
@<Define |static| |Run_State| member variables@>@;
@<Declare global |Run_State| variables@>@;
@<Declare namespace |Projections|@>@;
@<Declare namespace |Sorting|@>@;
@<Define |System| functions@>@;
@<Define |Run_State| functions@>@;
@<Define |Int_Void_Ptr| functions@>@;
@<Define |Int_Void_Ptr_Bool| functions@>@;
@<Define |Mutex_Type| functions@>@;
@<Define |Cond_Var_Type| functions@>@;
@<Define |Thread_Info_Type| functions@>@;
@<Define |dummy_func|@>@;

@q ** (2) This is what's written to \filename{pspglb.h}.@>
@ This is what's written to the \filename{pspglb.h}.
@(pspglb.h@>=
#ifndef LDF_PSPGLB_H_KNOWN
#define LDF_PSPGLB_H_KNOWN
@<Type definitions@>@;
typedef void* yyscan_t;
@<Forward declarations@>@;
@<Utility classes@>@;
@<Declare |namespace Scan_Parse|@>@;
@<Declare |struct Mutex_Type|@>@;
@<Declare |struct Cond_Var_Type|@>@;
@<|extern| declarations for global |Mutex_Type| variables@>@;
@<Declare |struct Thread_Info_Type|@>@;
@<Declare |struct Bad_Assignment_Type|@>@;
@<Declare |struct Parser_Error_Type|@>@;
@<Declarations for the header file@>@;
@<Declare |namespace System|@>@;
@<Declare |struct Run_State|@>@;
@<|extern| declaration of namespace |Projections|@>@;
@<|extern| declaration of namespace |Sorting|@>@;
@<|extern| declarations for global |Run_State| variables@>@;
@<Declare |dummy_func|@>@;
#endif 

/* This doesn't work, apparently because it's incompatible with the
use of \filename{sstream}. */
#if 0 
#ifdef __DECCXX /* Using the DEC \CPLUSPLUS/ Compiler.  */
  const real PI = __CXXL_PI;   
#endif
#endif 

@<Declare utility functions@>@;

@<Define |Cond_Var_Type| functions@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 70))    @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweb-on-file:"3DLDF.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>

