macro draw_extra_label_on_spherical_biangle;

def draw_extra_label_on_spherical_biangle {star S, point star_point, numeric bi_ang_one, numeric bi_ang_two,
                                           boolean left_or_right, boolean bottom_or_top, numeric label_pos,
                                           numeric shift_x, numeric shift_y, boolean do_labels} =
  point P[];

  numeric RA;
  numeric Decl;

  RA := right_ascension_decimal_degrees S;

  Decl := declination_decimal_degrees S;

  message "RA:";
  show RA;

  message "Decl:";
  show Decl;

  path curr_edge[];
  

  draw edge1 with_pen pencircle scaled (3pt, 3pt) with_color green on_picture qv[bi_ang_one];
  draw edge2 with_pen pencircle scaled (3pt, 3pt) with_color blue on_picture qv[bi_ang_one];
  draw edge3 with_pen pencircle scaled (3pt, 3pt) with_color red on_picture qv[bi_ang_one];
  
  if bottom_or_top and left_or_right:         %% top right
    message "top right.";
    curr_edge0 := edge1;
  elseif bottom_or_top and not left_or_right: %% top left
    curr_edge0 := edge0;
  elseif not bottom_or_top and left_or_right: %% bottom right
    curr_edge0 := edge3;
  else:                                       %% bottom left
    curr_edge0 := edge2;
  fi;

  for i = 0 upto (length Q - 1):
    P[i] := get_point (i) Q;
  endfor;

  dotlabel.rt("$P_{0}$", P0) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{1}$", P1) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{2}$", P2) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{3}$", P3) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{4}$", P4) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{5}$", P5) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{6}$", P6) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{7}$", P7) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{8}$", P8) on_picture qv[bi_ang_one];
  dotlabel.rt("$P_{9}$", P9) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{10}$", P10) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{11}$", P11) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{12}$", P12) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{13}$", P13) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{14}$", P14) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{15}$", P15) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{16}$", P16) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{17}$", P17) on_picture qv[bi_ang_one];
  dotlabel.rt("$P_{18}$", P18) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{19}$", P19) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{20}$", P20) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{21}$", P21) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{22}$", P22) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{23}$", P23) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{24}$", P24) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{25}$", P25) on_picture qv[bi_ang_one];
  dotlabel.rt("$P_{26}$", P26) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{27}$", P27) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{28}$", P28) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{29}$", P29) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{30}$", P30) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{31}$", P31) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{32}$", P32) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{33}$", P33) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{34}$", P34) on_picture qv[bi_ang_one];
  dotlabel.lft("$P_{35}$", P35) on_picture qv[bi_ang_one];
  
  P36 :=star_point shifted (-1cm, 0);
  P37 := star_point shifted (1cm, 0);

  draw P36 -- P37 with_color red on_picture qv[bi_ang_one];

  P38 := (P36 -- P37) intersection_point (P27 -- P8);

  dotlabel.urt("$P_{38}$", P38) on_picture qv[bi_ang_one];

  numeric mag;

  mag := magnitude(xpart star_point - xpart P38);

  message "mag:";
  show mag;
  
  P39 := star_point rotated_around (P8, P27) 180;
  label.rt("{\medium " & common_name S & "}", P39 shifted (shift_x, shift_y)) on_picture qv[bi_ang_two];

%% !! START HERE: LDF 2021.08.04.  Get a circle with the radius corresponding to the declination
%% of star_point.  That will get me the intersection point I need to place the new point correctly.
%% Add code for the other cases (top left, bottom right, etc.).
  
  P40 := P5 shifted (0, 1cm);
  P41 := (star_point rotated_around (P5, P40) 180) shifted by (P12 - P5);

  drawdot P41 with_pen pencircle scaled (5pt, 5pt)on_picture qv[bi_ang_one];  
  
  draw edge0 with_pen pencircle scaled (3pt, 3pt) with_color cyan on_picture qv[bi_ang_one];  

enddef;
 
