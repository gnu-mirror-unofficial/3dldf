%%%% sample1.ldf
%%%% Created by Laurence D. Finston (LDF) Mon Sep 20 14:50:43 CEST 2004

%% * (1) Copyright and License.

%%%% This file is part of GNU 3DLDF, a package for three-dimensional drawing.  
%%%% Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 
%%%% 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 The Free Software Foundation  

%%%% GNU 3DLDF is free software; you can redistribute it and/or modify 
%%%% it under the terms of the GNU General Public License as published by 
%%%% the Free Software Foundation; either version 3 of the License, or 
%%%% (at your option) any later version.  

%%%% GNU 3DLDF is distributed in the hope that it will be useful, 
%%%% but WITHOUT ANY WARRANTY; without even the implied warranty of 
%%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
%%%% GNU General Public License for more details.  

%%%% You should have received a copy of the GNU General Public License 
%%%% along with GNU 3DLDF; if not, write to the Free Software 
%%%% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

%%%% GNU 3DLDF is a GNU package.  
%%%% It is part of the GNU Project of the  
%%%% Free Software Foundation 
%%%% and is published under the GNU General Public License. 
%%%% See the website http://www.gnu.org 
%%%% for more information.   
%%%% GNU 3DLDF is available for downloading from 
%%%% http://www.gnu.org/software/3dldf/LDF.html.
  

%%%% Please send bug reports to Laurence.Finston@gmx.de
%%%% The mailing list help-3dldf@gnu.org is available for people to 
%%%% ask other users for help.  
%%%% The mailing list info-3dldf@gnu.org is for sending 
%%%% announcements to users. To subscribe to these mailing lists, send an 
%%%% email with ``subscribe <email-address>'' as the subject.  

%%%% The author can be contacted at: 

%%%% Laurence D. Finston 
%%%% c/o Free Software Foundation, Inc. 
%%%% 51 Franklin St, Fifth Floor 
%%%% Boston, MA  02110-1301  
%%%% USA

%%%% Laurence.Finston@gmx.de


% * (1) Beginning of 3DLDF code.

%% * (1) New sample code.

point p;

p := (1, 2, 3);

show p;

show database points paths;

show database all;

show database all paths;

end;

%% * (1) "Old" sample code.

% point p[];
% path q;
% p0 := (1, 2, 3);
% p1 := (1, 4, 5);

% q := p0 .. p1;

% show p0;
% show p1;
% show q;

% end;


%% *** (3) Declarations

point p[];
path q[];

transform t[];

circle c[];

picture crosshair_picture;
picture help_picture;
picture main_picture;

path frame;

numeric frame_wd;
numeric frame_ht;

%% *** (3) Frame path

frame_wd := 19cm;
frame_ht := 26cm;

frame := origin -- (frame_wd, 0) -- (frame_wd, 0, frame_ht) -- (0, 0, frame_ht) -- cycle;

transform frame_transform;

frame_transform := identity shifted (-.5frame_wd, 0, -.5frame_ht);

frame *= frame_transform;

%% *** (3)

pickup pencircle scaled (.5mm, .5mm, .5mm);

%% *** (3) Assigments

%% Outer circle

set c0 with_diameter 16 with_point_count 64;

%% *** (3) Figure 0 --- Crosshairs

beginfig(0); 

p0 := (1cm, 0, 1cm);

q0 := p0 shifted (-.5, 0) -- p0 shifted (.5, 0);

p1 := p0 shifted (0, 1);

q1 := q0 rotated_around (p0, p1) 90;

draw q0 transformed frame_transform on_picture crosshair_picture; 
draw q1 transformed frame_transform on_picture crosshair_picture; 


draw q0 rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht)) 
     transformed frame_transform on_picture crosshair_picture; 

draw q1 rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht)) 
     transformed frame_transform on_picture crosshair_picture; 


draw q0 rotated_around ((.5frame_wd, 0, 0), (.5frame_wd, 0, .5frame_ht)) 
     transformed frame_transform on_picture crosshair_picture; 

draw q1 rotated_around ((.5frame_wd, 0, 0), (.5frame_wd, 0, .5frame_ht)) 
     transformed frame_transform on_picture crosshair_picture; 

draw q0 rotated_around ((.5frame_wd, 0, 0), (.5frame_wd, 0, .5frame_ht))
     rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht))
     transformed frame_transform  on_picture crosshair_picture; 

draw q1 rotated_around ((.5frame_wd, 0, 0), (.5frame_wd, 0, .5frame_ht))
     rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht))
     transformed frame_transform  on_picture crosshair_picture; 

draw q0 shifted by ((.5frame_wd, 0, 1cm) - p0) transformed frame_transform  
on_picture crosshair_picture; 

draw q1 shifted by ((.5frame_wd, 0, 1cm) - p0) transformed frame_transform  
on_picture crosshair_picture; 

draw (q0 shifted by ((.5frame_wd, 0, 1cm) - p0)) 
     rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht))
     transformed frame_transform  
     on_picture crosshair_picture; 

draw (q1 shifted by ((.5frame_wd, 0, 1cm) - p0)) 
     rotated_around ((0, 0, .5frame_ht), (frame_wd, 0, .5frame_ht))
     transformed frame_transform  
     on_picture crosshair_picture; 


endfig; 

%% *** (3) macro polygon_circle

macro polygon_circle;

def polygon_circle {circle main_circle, 
                    numeric polygon_sides, 
                    transform label_transform, 
                    string label_string} =

%% **** (4)

message "Entering polygon_circle";

circle outer_circle;  %% Not drawn!  Used for extended help lines.

numeric a, b;

point p[];

transform t[];

reg_polygon r[];

numeric main_circ_diam;

main_circ_diam := get_diameter main_circle;

clear help_picture;
clear main_picture;

set r0 with_sides polygon_sides with_diameter main_circ_diam;

set r1 with_sides (2 * polygon_sides) with_diameter main_circ_diam;

set outer_circle with_diameter main_circ_diam + 3 with_point_count 64;

a := 360;
a /= 4polygon_sides;

rotate r1 (0, a);

%% Crosshair at origin

draw (-.25, 0) -- (.25, 0) on_picture help_picture;
draw (0, 0, -.25) -- (0, 0, .25) on_picture help_picture;

set c1 with_diameter 1.5 with_point_count 64;

draw c1 with_color dark_grey dashed evenly on_picture help_picture;

set c2 with_diameter .75 with_point_count 64;

p2 := get_point 48 c2;
p3 := get_point 48 main_circle;
p4 := get_point 48 outer_circle;

a := 360;

a /= 2 * polygon_sides;

t0 := identity rotated (0, a);

b := 2 * polygon_sides - 1;

for i = 0 upto b:
   if is_even i:
      draw p2 -- p3 on_picture main_picture;
      draw p3 -- p4 with_color dark_grey dashed evenly on_picture help_picture;
   else:
      draw p2 -- p4 with_color dark_grey dashed evenly on_picture help_picture;
   fi;
   p2 *= p3 *= p4 *= t0;
endfor;

draw main_circle on_picture main_picture;

draw r0 with_color dark_grey dashed evenly on_picture help_picture;


for i := 0 upto polygon_sides - 1:

   a := i + 1;

   if a == polygon_sides:
      a := 0;
   fi;

   p6 := unit_vector(get_point (i) r0 - get_point (a) r0) * 1.5
      shifted by get_point (i) r0;


   p7 := unit_vector(get_point (a) r0 - get_point (i) r0) * 1.5
      shifted by get_point (a) r0;

   draw get_point (i) r0 -- p6 with_color dark_grey dashed evenly on_picture help_picture;

   draw get_point (a) r0 -- p7 with_color dark_grey dashed evenly on_picture help_picture;

endfor;

%% These help lines will probably not be needed.
%% LDF 2011.01.01.

if false:
for i := 0 upto 2 * polygon_sides - 1:

   a := i + 1;

   if a == 2 * polygon_sides:
      a := 0;
   fi;

   p6 := unit_vector(get_point (i) r1 - get_point (a) r1) * 1.5
      shifted by get_point (i) r1;


   p7 := unit_vector(get_point (a) r1 - get_point (i) r1) * 1.5
      shifted by get_point (a) r1;

   draw get_point (i) r1 -- p6 with_color dark_grey dashed evenly on_picture help_picture;

   draw get_point (a) r1 -- p7 with_color dark_grey dashed evenly on_picture help_picture;

endfor;
fi;

%pause;

draw r1 with_color dark_grey dashed evenly on_picture help_picture;

%% *** (3)

p5 := (.5, 0, 3) transformed label_transform;

label.rt(label_string, p5);

%% *** (3)

enddef;

%% *** (3) Figure 1

beginfig(1); 

string s;

s := "\vbox{\hbox{Octagon/16-gon}\vskip1pt\hbox{Radius $= 9\rm{cm}$}}";

polygon_circle {c0, 8, frame_transform, s};

%% **** (4)

draw frame with_color dark_grey dashed evenly on_picture help_picture;

current_picture += help_picture;
current_picture += crosshair_picture;
current_picture += main_picture;

%% **** (4) End of figure 1

endfig with_projection parallel_x_z; 



%% *** (3) Figure 2

beginfig(2); 

string s;

s := "\vbox{\hbox{Nonagon/Octadecagon}\vskip1pt\hbox{Radius $= 9\rm{cm}$}}";

polygon_circle {c0, 9, frame_transform, s};

%% **** (4)

draw frame with_color dark_grey dashed evenly on_picture help_picture;

current_picture += help_picture;
current_picture += crosshair_picture;
current_picture += main_picture;

%% **** (4) End of figure 2

endfig with_projection parallel_x_z; 

%% *** (3)


verbatim_metapost "end";

end;

%% ** (2) Stellation pattern 3  (Revised version)

input "stlltns.lmc";

%% ** (2) Declarations

numeric inner_t_len, inner_t_wid, seg, betw_t_len, betw_t_wid, 
        outer_len_scale_val, outer_wid_scale_val,
        betw_len_scale_val, betw_wid_scale_val;

picture main_pict;
picture aux_pict;

boolean do_betw_quads;

%% ** (2) Figure 1

beginfig(1); 

inner_t_len 	    := 0.5;    %% inner_triangle_length
inner_t_wid 	    := 0.25;   %% inner_triangle_width
seg         	    := 8;     %% The number of segments
outer_len_scale_val := 4;
outer_wid_scale_val := 3;
betw_len_scale_val  := 3;
betw_wid_scale_val  := 1.5;
betw_distance_val   := 0.675;

do_betw_quads := false;  % true

generate_pattern (main_pict, aux_pict) 
                 {inner_t_len, inner_t_wid, seg, 
                  outer_len_scale_val, outer_wid_scale_val,
                  betw_len_scale_val, betw_wid_scale_val, 
                  betw_distance_val, do_betw_quads};

current_picture += aux_pict;
current_picture += main_pict;

endfig with_projection parallel_x_z no_sort;

%% ** (2) Figure 2

beginfig(2); 

clear aux_pict;
clear main_pict;

inner_t_len 	    := 0.5;    %% inner_triangle_length
inner_t_wid 	    := 0.25;   %% inner_triangle_width
seg         	    := 8;     %% The number of segments
outer_len_scale_val := 4;
outer_wid_scale_val := 3;
betw_len_scale_val  := 3;
betw_wid_scale_val  := 1.5;
betw_distance_val   := 0.675;

do_betw_quads := true;  % false

generate_pattern (main_pict, aux_pict) 
                 {inner_t_len, inner_t_wid, seg, 
                  outer_len_scale_val, outer_wid_scale_val,
                  betw_len_scale_val, betw_wid_scale_val, 
                  betw_distance_val, do_betw_quads};

current_picture += aux_pict;
current_picture += main_pict;

endfig with_projection parallel_x_z no_sort;

%% ** (2) Figure 3

beginfig(3); 

clear aux_pict;
clear main_pict;

inner_t_len 	    := 0.5;    %% inner_triangle_length
inner_t_wid 	    := 0.25;   %% inner_triangle_width
seg         	    := 10;     %% The number of segments
outer_len_scale_val := 4;
outer_wid_scale_val := 2;
betw_len_scale_val  := 3;
betw_wid_scale_val  := 1.5;
betw_distance_val   := 0.675;

do_betw_quads := false;  % true

generate_pattern (main_pict, aux_pict) 
                 {inner_t_len, inner_t_wid, seg, 
                  outer_len_scale_val, outer_wid_scale_val,
                  betw_len_scale_val, betw_wid_scale_val, 
                  betw_distance_val, do_betw_quads};

current_picture += aux_pict;
current_picture += main_pict;

endfig with_projection parallel_x_z no_sort;

%% ** (2) Figure 4

beginfig(4); 

clear aux_pict;
clear main_pict;

inner_t_len 	    := 0.5;    %% inner_triangle_length
inner_t_wid 	    := 0.25;   %% inner_triangle_width
seg         	    := 10;     %% The number of segments
outer_len_scale_val := 4;
outer_wid_scale_val := 2;
betw_len_scale_val  := 3;
betw_wid_scale_val  := 1.5;
betw_distance_val   := 0.675;

do_betw_quads := true;  % false

generate_pattern (main_pict, aux_pict) 
                 {inner_t_len, inner_t_wid, seg, 
                  outer_len_scale_val, outer_wid_scale_val,
                  betw_len_scale_val, betw_wid_scale_val, 
                  betw_distance_val, do_betw_quads};

current_picture += aux_pict;
current_picture += main_pict;

endfig with_projection parallel_x_z no_sort;

%% ** (2) Testing triangle.is_equal()
%% This doesn't work yet.  See below.
%% LDF 2010.12.06.

focus f[];

set f0 with_position (0, 30, -50) 
       with_direction (0, 30, 10) with_distance 40; 


triangle t[];

set t0 with_points ((0, 1, 2), (2, 3, 7), (5, 4, 1));

t1 := t0 sheared (1.2, 2, 3, 4, 5, 3);

beginfig(1); 

boolean b;

message "t0:"; 
show t0;

message "t1:"; 
show t1;

%pause;

% !! START HERE:  This won't work for |Triangles| that have been transformed, because 
% |a|, |b|, |c|, |alpha|, |beta| and |gamma| are not recalculated when this happens!  
% This is because |Path::operator*=| is used for multiplying a |Triangle| with a 
% |Transform|.  !! TODO:  Define this operator for |Triangle|!

if t0 == t1:
message "Equal"; 
else:
message "Unequal"; 
fi;

%pause;

draw t0;
draw t1;

endfig with_focus f0;

end;



%% ** (2) Testing outputting and clearing pictures

% LDF 2010.10.08.
% See `00TODO'

pickup pencircle scaled (1mm, 1mm, 1mm);

path q;
q := (0, 0) -- (5, 0) -- (5, 5) -- (0, 5) -- cycle;

color c;
set c (0, 1, 0);

for i = 1 upto 3:

   beginfig(i); 

      draw (-5, 2.5) -- (10, 2.5) with_color c;
      draw (0, 0) -- (5, 0) -- (5, 5) -- (0, 5) -- cycle;
      output current_picture with_projection parallel_x_y;
      %clip_to q;
      %clear current_picture;
      draw (-5, 3) -- (10, 3) with_color blue;
      endfig;

endfor;

end;

%% ** (2) Stellation Pattern 3 (Must change number!  Using "3" for another drawing. LDF 2010.12.17.)

%% LDF 2010.06.09.

%% *** (3) Declarations

reg_polygon r[];
circle c[];

point p[];

string s;

triangle w[];

focus f[];

picture v[];

%% *** (3) Figure 1

pickup pencircle scaled (.5mm, .5mm, .5mm);

beginfig(1);

%% **** (4)
  
r0 := unit_octagon scaled (1.5cm, 0, 1.5cm) rotated (0, 180);
r1 := unit_octagon scaled (4cm, 0, 4cm) rotated (0, 180);

rotate r1 (0, 22.5);

set c0 with_diameter 15 with_point_count 64;
rotate c0 (0, 0, 180);


draw r0;
draw r1;
draw c0;


for i = 0 upto 7:
   p[i]     := get_point (i) r0;
   p[i + 8] := get_point (i) r1;
endfor;   

dotlabel.lrt("$p_{0}$",  p0);
dotlabel.rt("$p_{1}$",  p1);
dotlabel.rt("$p_{2}$",  p2);
dotlabel.urt("$p_{3}$",  p3);
dotlabel.ulft("$p_{4}$",  p4);
dotlabel.ulft("$p_{5}$",  p5);
dotlabel.llft("$p_{6}$",  p6);
dotlabel.llft("$p_{7}$",  p7);

dotlabel.rt("$p_{8}$",  p8);
dotlabel.rt("$p_{9}$",  p9);
dotlabel.urt("$p_{10}$", p10);
dotlabel.ulft("$p_{11}$", p11);
dotlabel.lft("$p_{12}$", p12);
dotlabel.llft("$p_{13}$", p13);
dotlabel.llft("$p_{14}$", p14);
dotlabel.bot("$p_{15}$", p15);

%% **** (4)

set w0 with_points (origin, p0, p7);

p16 := mediate(p0, p7) shifted (0, magnitude(p7 - p0));

draw w0;

set w1 with_points (p0, p16, p7);

%% **** (4) End of Figure 1

endfig with_projection parallel_x_z;

%% *** (3) Figure 2

beginfig(2); 

draw w0;

draw w1;

dotlabel.bot("$p_{0}$", p0);
dotlabel.bot("$p_{7}$", p7);
dotlabel.top("$p_{16}$", p16);


%% **** (4) End of Figure 2

endfig with_projection parallel_x_y;

%% *** (3) Figure 3

beginfig(3); 

draw w0;

draw w1;

dotlabel.bot("$o$", origin);
dotlabel.bot("$p_{0}$/$p_{7}$", p0);
dotlabel.lft("$p_{16}$", p16);

%% **** (4) End of Figure 3

endfig with_projection parallel_z_y;

%% *** (3) Figure 4

set f0 with_position (0, 20, -50) 
       with_direction (0, 20, 10) with_distance 70; 

beginfig(4); 

draw r0;
draw r1;

draw w0;
draw w1;

dotlabel.bot("$p_{0}$", p0);
dotlabel.bot("$p_{7}$", p7);
dotlabel.top("$p_{16}$", p16);
dotlabel.rt("$o$", origin);

v0 := current_picture;

rotate v0 (0, 90);

%% **** (4) End of Figure 4

endfig with_focus f0;

%% *** (3) Figure 5

beginfig(5); 

current_picture := v0;

%% **** (4) End of Figure 5

endfig with_focus f0;

%% *** (3)

end;

%% ** (2)

%% ** (2) Plans for a paper or cardboard model of an ellipsoid (Ellipsoid Model 1)

%% ** (2) Declarations

picture v[];

focus f[];

set f0 with_position (0, 30, -50) 
       with_direction (0, 30, 10) with_distance 40; 

ellipsoid E;

ellipse e[];

point p[];

transform t[];

triangle w[];

pickup pencircle scaled (.5mm, .5mm, .5mm);

color_vector cv;

cv += red;      %  0
cv += black;    %  1
cv += blue;     %  2
cv += black;    %  3
cv += black;    %  4
cv += black;    %  5
cv += black;    %  6
cv += black;    %  7
cv += yellow;   %  8
cv += black;    %  9
cv += black;    % 10
cv += cyan;     % 11
cv += magenta;  % 12
cv += green;    % 13

bool_point_vector bpv;

%% ** (2) Figure 1

beginfig(1); 

%% *** (3) Ellipsoid E

Ew := 20;
Eh := 16;
Ed := 8;

set E with_center origin with_axis_x Ew with_axis_y Eh with_axis_z Ed
       with_divisions_x 8 with_divisions_y 8 with_divisions_z 2
       with_point_count 64;

draw E;

%% *** (3) Get the individual ellipses from E

for i = 0 upto 13:
   e[i] := get_ellipse (i) E;
endfor;

draw e0  with_color  red;
draw e2  with_color  blue;
draw e8  with_color  yellow;
draw e13 with_color green;

%% *** (3) Trapezoid 0

bpv := e0 intersection_points e2;

p0 := bpv1;

% message "bpv:"; 
% show bpv;

dotlabel.urt("$p_{0}$", p0);

bpv := e2 intersection_points e13;

p1 := bpv1;

% message "bpv:"; 
% show bpv;

dotlabel.urt("$p_{1}$", p1);

bpv := e13 intersection_points e8;

% message "bpv:"; 
% show bpv;

p2 := bpv[1];

dotlabel.urt("$p_{2}$", p2);

bpv := e0 intersection_points e8;

p3 := bpv[1];

dotlabel.urt("$p_{3}$", p3);

p4 := mediate(p0, p2);
p5 := mediate(p1, p3);

p6 := mediate(p4, p5);

bpv := (origin -- p6) intersection_points E;

% message "bpv:"; 
% show bpv;

p7 := bpv0;

dotlabel.top("$p_{7}$", p7);

%% **** (4) Triangle 0

set w0 with_points (p0, p1, p7);

draw w0 with_color gray;

p8 := get_center w0;
%dotlabel.top("$p_{8}$", p8);

p9 := (get_normal w0) shifted p8;

%dotlabel.top("$p_{9}$", p9);

%% **** (4)  Triangle 1

set w1 with_points (p1, p7, p2);

draw w1 with_color gray;

p10 := get_center w1;
dotlabel.top("$p_{10}$", p10);

p11 := (-1 * (get_normal w1)) shifted p10;

dotlabel.top("$p_{11}$", p11);


%% **** (4)  Triangle 2

set w2 with_points (p0, p7, p3);

draw w2;  %  with_color gray;

%% w1 and w2 are nearly similar, but not quite.

% message "w1:"; 
% show w1;

% message "w2:"; 
% show w2;

% message "w1 == w2:"; 
% show w1 == w2;
% pause;


%% **** (4)

%% *** (3)

v0 := current_picture;

%% *** (3) End of Figure 1

endfig with_projection parallel_x_y no_sort;

%% ** (2) Figure 2

beginfig(2); 
current_picture := v0;
endfig with_projection parallel_x_z no_sort;

%% ** (2) Figure 3

beginfig(3); 
current_picture := v0;
endfig with_projection parallel_z_y no_sort;

%% ** (2) Figure 4

beginfig(4); 
current_picture := v0;
endfig with_focus f0 no_sort;

%% ** (2) Figure 5

%% Notes:

%% The p[] points aren't transformed.  In this figure, r[] points are used 
%% instead.
%% The w[] triangles are transformed, _not_ copied!
%% transform t0 -- t2 can be reused.
%%
%% LDF 2010.08.27.

point r[];
point s[];


beginfig(5); 

%% *** (3) Trapezoid 0

%% **** (4) Triangle 0

t0 := align (p8 -- p9) with_axis y_axis;

r0 := p0 * t0;
r1 := p1 * t0;
r7 := p7 * t0;

w0 *= t0;

t1 := identity shifted by (-1 * r0);

w0 *= r0 *= r1 *= r7 *= t1;

ang_0 := r1 angle (1, 0);

message "ang_0:"; 
show ang_0;

t2 := (identity rotated (0, -ang_0)) rotated (0, 90);

w0 *= r0 *= r1 *= r7 *= t2;

% message "r0:"; 
% show r0;

dotlabel.rt("$r_{0}$", r0);
dotlabel.rt("$r_{1}$", r1);
dotlabel.ulft("$r_{7}$", r7);

label("$w_{0}$", get_center w0);

%draw w0 with_color dark_gray;

draw r0 -- r1 dashed evenly;
draw r1 -- r7 dashed evenly;
draw r7 -- r0 dashed evenly;

% message "w0:"; 
% show w0;

% pause;

%% **** (4) Triangle 1

s1 := p1;
s2 := p2;
s7 := p7;

t0 := ((align (p10 -- p11) with_axis y_axis) rotated (0, -90));
s1 *= s2 *= s7 *= w1 *= t0;

t1 := identity  shifted by (r1 - s1);

s1 *= s2 *= s7 *= w1 *= t1;

s8 := s1 shifted (0, 1);

ang_0 := (s1 - s7) angle (s1 - r7);

t2 := identity rotated_around (s1, s8) -ang_0;

s1 *= s2 *= s7 *= w1 *= t2;

% message "(s1 - s7) angle (s1 - r7):"; 
% show (s1 - s7) angle (s1 - r7);

% message "w1:"; 
% show w1;

% message "r7:"; 
% show r7;

% message "s7:"; 
% show s7;

% message "s1 == r1:"; 
% show s1 == r1;

r2 := s2;
dotlabel.top("$s_{2}$", s2);

label("$w_{1}$", get_center w1);

draw r1 -- r2 dashed evenly;
draw r2 -- r7;


%% *** (3) Trapezoid 1

%% *** (3) End of Figure 5

endfig with_projection parallel_x_z no_sort;

%% ** (2)

%% *** (3) End of 3DLDF code

verbatim_metapost "end;";

end;



%% ** (2) Circle Pattern 1.

%% LDF 2010.05.03.

%% *** (3) Declarations


sphere s;

circle c[];

%% *** (3) Figure 1

beginfig(1);

%% **** (4)

sphere s;
set s with_center (0, -2.75, 0) with_radius 5 with_point_count 64 with_divisions 8;

draw s;

for i = 4 upto 8:
   c[i] := get_circle (i) s;
   draw c[i] with_color red;
endfor;
  
endfig with_projection parallel_x_y;

%% *** (3) Figure 2

beginfig(2);

draw s;

for i = 4 upto 8:
   c[i] := get_circle (i) s;
   draw c[i] with_color red;
endfor;

endfig with_projection parallel_x_z;

%% ** (2) Church Tower 1
%% ** (2) Square cross-section.

%% This vevrion is far along, but incomplete.  I'm continuing work 
%% in `clktwr_0.ldf'.  
%% LDF 2010.05.14.

%% *** (3) Declarations

point p[];
path q[];
circle c[];

picture v[];

string s[];

transform t[];

side_width  := 5cm;
side_height := 4cm;

spire_height := 8cm;

clock_height := 5cm;

%% *** (3) Figure 1

beginfig(1);

%% **** (4) Arcade

pickup pencircle scaled (.5mm, .5mm, .5mm);

p0 := origin;

p1 := p0 shifted (side_width, 0);

p2 := p1 shifted (0, side_height);

p3 := p0 shifted (0, side_height);

draw p0 -- p1 -- p2 -- p3 -- cycle;

%% **** (4) Spire

p4 := (.5side_width, side_height + spire_height);

dotlabel.lft("$p_0$", p0);
dotlabel.rt("$p_1$", p1);
dotlabel.rt("$p_2$", p2);
dotlabel.lft("$p_3$", p3);
dotlabel.lft("$p_4$", p4);

draw p2 -- p4 -- p3;

p6 := p0 shifted (0, 1cm);
p7 := p1 shifted (0, 1cm);

p8 := p6 shifted (.5cm, 0);
p9 := p8 shifted (1cm , 0);

draw p8 -- p9;

dotlabel.lft("$p_8$", p8);
dotlabel.rt("$p_9$", p9);

p10 := p8 shifted (0, 2cm);

p11 := p10 shifted (1cm, 0);

dotlabel.lft("$p_{10}$", p10);
dotlabel.rt("$p_{11}$", p11);

p12 := mediate(p10, p11);

set c0 with_center p12 with_diameter 1cm with_point_count 64 with_normal (0, 0, -1);

%shift c0 p12;

q0 := p9 -- p11 .. half c0 .. p10 -- p8 -- p9 -- cycle;

draw q0;

draw q0 shifted (1.5cm , 0);

draw q0 shifted (3cm , 0);


%% ***** (5) Cutaway at base of spire

p31 := unit_vector(p4 - p3) scaled .3 shifted p3;

%dotlabel.ulft("$p_{31}$", p31);

p32 := (xpart p31, ypart p3);

p33 := p3 rotated_around (p31, p32) 180;

draw p31 -- p33;

draw mediate(p31, p33, 6) -- mediate(p33, p31, 6) dashed evenly with_color gray;

dotlabel.urt("$p_{33}$", p33);

p36 := mediate(p2, p3);

dotlabel.bot("$p_{36}$", p36);

p34 := p31 rotated_around (p4, p36) 180;
p35 := p33 rotated_around (p4, p36) 180;

dotlabel.rt("$p_{34}$", p34);
dotlabel.rt("$p_{35}$", p35);

draw p34 -- p35;

draw mediate(p35, p34, 6) -- mediate(p34, p35, 6) dashed evenly with_color gray;

%% ***** (5) Tabs for spire

%% ****** (6) Outer tabs

p37 := mediate(p3, p4);

dotlabel.rt("$p_{37}$", p37);

p38 := p37 shifted (0, 0, 1);

p39 := unit_vector(p4 - p3) scaled .75 shifted p37 rotated_around (p37, p38) 90;
dotlabel.lft("$p_{39}$", p39);


p40 := unit_vector(p4 - p3) scaled .75 shifted p3;

dotlabel.rt("$p_{40}$", p40);

p41 := unit_vector(p3 - p4) scaled .75 shifted p4;
dotlabel.rt("$p_{41}$", p41);

p42 := p40 shifted (0, 0, 1);

p43 := mediate(p40, p37, .5) rotated_around (p40, p42) 45;

dotlabel.lft("$p_{43}$", p43);

p44 := (p39 - p37) shifted p40;

dotlabel.rt("$p_{44}$", p44);

p45 := (p40 -- p43) intersection_point (p39 -- p44);

dotlabel.lft("$p_{45}$", p45);

p46 := p45 rotated_around (p37, p39) 180;

dotlabel.lft("$p_{46}$", p46);

draw p40 -- p45 --p46 -- p41;

% message "angle (p46 - p41) angle (p4 - p3):"; 
% show (p46 - p41) angle (p4 - p3);

% message "angle (p45 - p40) angle (p4 - p3):"; 
% show (p45 - p40) angle (p4 - p3);

p47 := mediate(p37, p39);

dotlabel.urt("$p_{47}$", p47);

p48 := (p47 - p39) shifted p45;

dotlabel.lrt("$p_{48}$", p48);

p49 := (p40 -- p45) intersection_point (p47 -- p48);

dotlabel.llft("$p_{49}$", p49);

p50 := (p41 -- p46) intersection_point (p47 -- p48);

dotlabel.ulft("$p_{50}$", p50);

draw p37 -- p39 with_color gray;

draw p49 -- p50 with_color gray;

for i = 0 upto 16:
   drawdot mediate(p49, p50, (i / 16)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;

%% ***** (5)

%% ****** (6)  Inner tabs

p51 := p37;
p52 := p39;
p53 := p40;
p54 := p41;
p55 := p45;
p56 := p46;
p57 := p49;
p58 := p50;

t0 := (identity rotated_around (p4, p36) 180) rotated_around (p4, p2) 180;

p51 *= p52 *= p53 *= p54 *= p55 *= p56 *= p57 *= p58 *= t0;


dotlabel.top("$p_{51}$", p51);
dotlabel.top("$p_{52}$", p52);
dotlabel.top("$p_{53}$", p53);
dotlabel.top("$p_{54}$", p54);
dotlabel.top("$p_{55}$", p55);
dotlabel.top("$p_{56}$", p56);
dotlabel.top("$p_{57}$", p57);
dotlabel.top("$p_{58}$", p58);

draw p54 -- p56 -- p55 -- p53 dashed evenly;

draw p58 -- p57 dashed evenly with_color gray;

for i = 0 upto 16:
   drawdot mediate(p57, p58, (i / 16)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;


%% **** (4) Clock

p13 := p0 shifted (0, -clock_height);

p14 := p1 shifted (0, -clock_height);

draw p13 -- p14 -- p1 -- p0 -- cycle;


dotlabel.lft("$p_{13}$", p13);
dotlabel.rt("$p_{14}$", p14);

p15 := mediate(p1, p13);

dotlabel.top("$p_{15}$", p15);

set c1 with_center p15 with_diameter (side_width - 1cm) with_point_count 64 with_normal (0, 0, -1);

draw c1;

set c2 with_center p15 with_diameter (side_width - 1.75cm) with_point_count 64 with_normal (0, 0, -1);

draw c2 dashed evenly with_color gray with_pen pencircle scaled (.3mm, .3mm, .3mm);

p18 := p15 shifted (0, 0, -1);

p19 := get_point 0 c2 rotated_around (p15, p18) -90;

label("\uppercase\expandafter{\romannumeral 12}", p19);

%dotlabel.top("$p_{19}$", p19);

for i = 1 upto 11:
   s0 := "\uppercase\expandafter{\romannumeral " & decimal i & "}";
   p[19 + i]  := p19 rotated_around (p15, p18) (30 * i);
    label(s0, p[19 + i]);
%   s0 := "$p_{" & decimal (19 + i) & "}$";
%   dotlabel.top(s0, p[19 + i]);
endfor;

v0 := current_picture;

clear current_picture;

%% **** (4) Tabs for arcade

%% ***** (5) Outer

p60 := mediate(p0, p3);

p61 := p60 shifted (-.375, 0);

dotlabel.rt("$p_{60}$", p60);
dotlabel.lft("$p_{61}$", p61);

p62 := p61 shifted (0, -1cm);

%dotlabel.lft("$p_{62}$", p62);

p63 := p0 shifted (0, .5cm);

p64 := p3 shifted (0, -.5cm);

dotlabel.rt("$p_{63}$", p63);
dotlabel.rt("$p_{64}$", p64);

p66 := p63 shifted (0, 0, 1);

p65 := mediate(p63, p64, .25) rotated_around (p63, p66) 45;

%dotlabel.rt("$p_{65}$", p65);

p67 := (p63 -- p65) intersection_point (p61 --  p62);

dotlabel.lft("$p_{67}$", p67);

p68 := p67 rotated_around (p60, p61) 180;

dotlabel.lft("$p_{68}$", p68);

draw p63 -- p67 -- p68 -- p64;

p69 := mediate(p60, p61);

p70 := p69 shifted (0, 1cm);

p71 := (p69 -- p70) intersection_point (p63 -- p67);

dotlabel.llft("$p_{71}$", p71);

p72 := p71 rotated_around (p60, p61) 180;

dotlabel.ulft("$p_{72}$", p72);

draw p60 -- p61 with_color gray;

draw p71 -- p72 with_color gray;

for i = 0 upto 8:
   drawdot mediate(p71, p72, (i / 8)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;


%% ***** (5) Inner

p73 := p60;
p74 := p61;
p75 := p63;
p76 := p64;
p77 := p67;
p78 := p68;
p79 := p71;
p80 := p72;

t1 := identity shifted (4 * side_width, 0);

p73 *= p74 *= p75 *= p76 *= p77 *= p78 *= p79 *= p80 *= t1;

dotlabel.rt("$p_{73}$", p73);
dotlabel.lft("$p_{74}$", p74);
dotlabel.lrt("$p_{75}$", p75);
dotlabel.rt("$p_{76}$", p76);
dotlabel.lft("$p_{77}$", p77);
dotlabel.lft("$p_{78}$", p78);
dotlabel.llft("$p_{79}$", p79);
dotlabel.ulft("$p_{80}$", p80);


draw p75 -- p77 -- p78 -- p76 dashed evenly;

draw p73 -- p74 with_color gray;

draw p79 -- p80 with_color gray;

for i = 0 upto 8:
   drawdot mediate(p79, p80, (i / 8)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;

v1 := current_picture;

clear current_picture;

%% **** (4) Tabs for Clock

p81 := (p63 - p0) shifted p13;

dotlabel.llft("$p_{81}$", p81);

p82 := (p64 - p3) shifted p0;

dotlabel.rt("$p_{82}$", p82);

p83 := (p68 - p64) shifted p82;

%dotlabel.lft("$p_{83}$", p83);

p84 := (p67 - p63) shifted p81;

%dotlabel.lft("$p_{84}$", p84);

p85 := mediate(p0, p13);

dotlabel.lrt("$p_{85}$", p85);

p86 := p85 shifted (-.5cm, 0);

dotlabel.lft("$p_{86}$", p86);

p87 := p86 shifted (0, 1cm);

p88 := (p86 -- p87) intersection_point (p82 -- p83);

dotlabel.lft("$p_{88}$", p88);

p89 := p88 rotated_around (p85, p86) 180;

dotlabel.lft("$p_{89}$", p89);

draw p81 -- p89 -- p88 -- p82;

p90 := mediate(p85, p86);

p91 := p90 shifted (0, 1);

p92 := (p90 -- p91) intersection_point (p82 --- p88);

dotlabel.ulft("$p_{92}$", p92);

p93 := p92 rotated_around (p85, p86) 180;

dotlabel.lft("$p_{93}$", p93);

draw p92 -- p93 with_color gray;
draw p85 -- p86 with_color gray;

for i = 0 upto 8:
   drawdot mediate(p92, p93, (i / 8)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;


v2 := current_picture;
clear current_picture;

%% ***** (5) Inner

p94  := p81;
p95  := p82;
p96  := p85;
p97  := p86;
p98  := p88;
p99  := p89;
p100 := p92;
p101 := p93;

p94 *= p95 *= p96 *= p97 *= p98 *= p99 *= p100 *= p101 *= t1;

dotlabel.rt("$p_{94}$", p94);
dotlabel.rt("$p_{95}$", p95);
dotlabel.rt("$p_{96}$", p96);
dotlabel.llft("$p_{97}$", p97);
dotlabel.ulft("$p_{98}$", p98);
dotlabel.lft("$p_{99}$", p99);
dotlabel.ulft("$p_{100}$", p100);
dotlabel.llft("$p_{101}$", p101);

draw p95 -- p98 -- p99 -- p94 dashed evenly;

draw p96 -- p97 with_color gray;
draw p100 -- p101 with_color gray;

for i = 0 upto 8:
   drawdot mediate(p100, p101, (i / 8)) with_pen pencircle scaled (.75mm, .75mm, .75mm);
endfor;


v3 := current_picture;
clear current_picture;

%% **** (4) Copy and shift picture v0

current_picture += v0;
current_picture += v1;
current_picture += v2;
current_picture += v3;


for i = 0 upto 2:
   shift v0 (side_width, 0);
   current_picture += v0;
endfor;


%% **** (4) Bottom flap

p16 := p13 shifted (0, -side_width);
p17 := p14 shifted (0, -side_width);

draw p13 -- p16 -- p17 -- p14 -- cycle;

%% **** (4) Undraw and redraw lines for scoring tabs

undraw p63 -- p64;

draw p63 -- p64 dashed evenly;

undraw p40 -- p41;

draw p40 -- p41 dashed evenly;

undraw p81 -- p82;

draw p81 -- p82 dashed evenly;

undraw p94 -- p95;

draw p94 -- p95 dashed evenly;


%% **** (4)

endfig with_projection parallel_x_y no_sort;

%% *** (3)

end;

%% ** (2) Windrose 1

%% LDF 2010.04.09.


%% *** (3) Declarations

circle c[];
       
point p[];
path q[];

transform t[];

diam := 5;

length_0 := .75diam; %% Length of long triangle
rotation_0 := 12.5;

length_1 := .375diam;  %% Length of short triangle
rotation_1 :=  20;

divisions := 10;

%% *** (3) Figure 1

beginfig(1);

%% **** (4)
  
set c0 with_diameter diam with_point_count 64;

draw c0;

%% **** (4) 

p0 := (2.5, 0, 0);

%dotlabel.rt("$p_{0}$", p[0]);

%% **** (4) First long triangle

p1 := p0 shifted length_0;

p2 := p1 shifted (0, 1);

p3 := p0 rotated_around (p1, p2) rotation_0;

bool_point_vector bpv;

bpv := c0 intersection_points (p1 --  p3);

p4 := bpv[0];
p5 := bpv[1];

if is_invalid p4 and is_invalid p5:
   message "p4 and p5 are invalid.  Quitting";
   endfig;
   end;
elseif is_invalid p4:
   p4 := p5;
elseif is_invalid p5:
   ;
else: 
   message "p4 and p5 are both valid.";
   if xpart p5 >= xpart p4:
      p4 := p5;
   fi;
fi;


p5 := p4 rotated_around (p1, p0) 180;

% dotlabel.rt("$p_{1}$", p[1]); 
% dotlabel.rt("$p_{3}$", p[3]);
% dotlabel.lft("$p_{4}$", p[4]);  
% dotlabel.lft("$p_{5}$", p[5]);

q0 := p4 -- p1 -- p5;
draw q0;

q1 := p0 -- p1;

draw q1;
%dotlabel.rt("$p_{3}$", p[3]);

p20 := unit_vector(p4) / 4;
p21 := unit_vector(p5) / 4;
p22 := unit_vector(p0) / 4;

draw p4 -- p20;
draw p5 -- p21;

draw p0 -- p22;

%% **** (4) First short triangle

p6 := p0 shifted (length_1, 0);

p7 := p6 shifted (0, 1);

p8 := p0 rotated_around (p6, p7) rotation_1;

bpv := c0 intersection_points (p6 --  p8);

p9 := bpv[0];
p10 := bpv[1];

if is_invalid p9 and is_invalid p10:
   message "p9 and p10 are invalid.  Quitting";
   endfig;
   end;
elseif is_invalid p9:
   p9 := p10;
elseif is_invalid p10:
   ;
else: 
   message "p9 and p10 are both valid.";
   if xpart p10 >= xpart p9:
      p9 := p10;
   fi;
fi;

p10 := p9 rotated_around (p0, p6) 180;

q2 := p9 -- p6 -- p10;

t0 := identity rotated (0, (360 / divisions));

p11 := p0;

q2 *= p6 *= p9 *= p10 *= p11 *= t0;

draw q2;

q3 := p11 -- p6; 

draw q3;

% dotlabel.rt("$p_{6}$", p[6]);
% dotlabel.rt("$p_{8}$", p[8]);
% dotlabel.rt("$p_{9}$", p[9]);  
% dotlabel.rt("$p_{10}$", p[10]);  
% dotlabel.rt("$p_{11}$", p[11]);  

p23 := unit_vector(p11) / 4;

draw p11 -- p23;

%% **** (4) Additional triangles

t1 := identity rotated (0, ((2 * 360) / divisions));

q4 := q0;
q5 := q1;
q6 := q2;
q7 := q3;

p12 := p0;
p13 := p4;
p14 := p5;
p15 := p11;

p16 := unit_vector(p12) / 4;
p17 := unit_vector(p13) / 4;
p18 := unit_vector(p14) / 4;
p19 := unit_vector(p15) / 4;


% dotlabel.lft("$p_{16}$", p16);
% dotlabel.lft("$p_{17}$", p17);
% dotlabel.lft("$p_{18}$", p18);
% dotlabel.lft("$p_{19}$", p19);

draw origin -- p17;

for i := 0 upto 3:
   p19 *= p18 *= p17 *= p16 *= p12 *= p13 *= p14 *= p15 *= q4 *= q5 *= q6 *= q7 *= t1;
   draw origin -- p17;
   draw q4; 
   draw q5;
   draw q6; 
   draw q7; 
   draw p16 -- p12;
   draw p17 -- p13;
   draw p18 -- p14;
   draw p19 -- p15;
endfor;


%% *= q6 *= q7 
%draw q6; 
%draw q7;


rotate current_picture (0, (180 / divisions));



%% **** (4) End of figure 1

endfig with_projection parallel_x_z;

%% *** (3)

end;

%% ** (2)  Sphere Development 1 --- Preview for DeviantArt

verbatim_metapost "prologues := 3;";
verbatim_metapost "verbatimtex \font\large=cmr12 scaled \magstep2 etex;";
verbatim_metapost "verbatimtex \font\Large=cmr17 scaled \magstep2 etex;";

%% *** (3) Declarations and initializations

PI := 3.141592653589793;

focus f[];

set f0 with_position (0, 30, -50) 
       with_direction (0, 30, 10) with_distance 20; 

circle c[];       

point p[];
path q[];

transform t[];

picture v[];

string s;

%% *** (3) Figure 1

beginfig(1); 
  
k := 5;

r := 10;

set c0 with_diameter 10 with_point_count 128;

rotate c0 (90, 11.25);

for i = 1 upto 7:
   rotate c0 (0, 22.5);
   draw c0;
endfor;

draw c0;


a := 10.5;
d := 8.5;

draw ((-a, -d) -- (a, -d) -- (a, d) -- (-a, d) -- cycle) with_pen pensquare;

label("{\Large Plans for a Model of a Sphere 1 (Sphere Development)}", (0, d) shifted (0, -1));

label("{\large Copyright (C) 2021 The Free Software Foundation}", 
   (0, -d) shifted (0, 1.50));

label("{\large Author:  Laurence D. Finston}",  (0, -d) shifted (0, .75));


endfig with_projection parallel_x_y;

end;


%% ** (2) Preview for Facetted Cone 1 (needed for posting at DeviantArt).

verbatim_metapost "prologues := 3;";
verbatim_metapost "verbatimtex \font\large=cmr12 scaled \magstep2 etex;";
verbatim_metapost "verbatimtex \font\Large=cmr17 scaled \magstep2 etex;";

%% ** (2) Facetted Cone 1 --- Image for DeviantArt Gallery

%% *** (3) Declarations and initializations

picture v[];

transform t[];

focus f[];
set f0 with_position (0, 35, -100) 
       with_direction (0, 35, 10) with_distance 50; 

circle c[];

point p[];

path q[];

bool do_labels;

do_labels := false;

bool b;
bool_point_vector bpv;



h := 10;  % 30

point n[]; %% Normals
              
pen dot_pen;

dot_pen := pencircle scaled (.75mm, .75mm, .75mm);

transform t[];

string s;


%% *** (3) Figure 1
       
beginfig(1);
  
%% **** (4)

outer_diam := 10;  %% 20
inner_diam :=  8;  %% 15;

c0 := unit_circle scaled (outer_diam, 0, outer_diam);
c1 := unit_circle scaled (inner_diam, 0, inner_diam);

draw c0;  
draw c1;  

%% **** (4)

j := 2;

for i := 0 step 4 until 28:
   p[j] := get_point (i) c0;
   %drawdot p[j] with_pen pencircle scaled (1.5mm, 1.5mm, 1.5mm);
   j += 1;
endfor;

if do_labels:
   dotlabel.lft(7, p7);
   dotlabel.lft(8, p8);
fi;

p0 := get_center c0;
p1 := p0 shifted (0, h);

if do_labels:
   dotlabel.bot(0, p0);   
   dotlabel.top(1, p1);   
fi;

p10 := mediate(p7, p8);

if do_labels:
   dotlabel.top(10, p10);   
fi;

bpv := (p0 -- p10) intersection_points c0;

%show bpv;

p11 := bpv[0];

if do_labels:
   dotlabel.lft(11, p11);
fi;

bpv := (p0 -- p10) intersection_points c1;

p12 := bpv[0];

if do_labels:
   dotlabel.rt(12, p12);
fi;

%draw p0 -- p1 -- p7 -- p12 -- p1 -- p8 -- p12;

%% **** (4) Paths.

q0 :=  p12 -- p7 -- p1 -- cycle;

triangle w[];

set w0 with_points (p12, p7, p1);

set w1 with_points (p12, p8, p1);

rotate w0 (0, 180 + 22.5);
rotate w1 (0, 180 + 22.5);

filldraw w0;
filldraw w1;

p13 := get_center w0;

n0 := (get_normal w0) shifted p13;

if do_labels:
   dotlabel.rt(13, p13);
fi;

%message "n0:"; 
%show n0;

%label.top("$n_0$", n0);
%drawarrow p13 -- n0;

t0 := identity rotated (0, 22.5);

for i = 1 upto 4:
   w[10 + i] := w0 rotated (0, (i * 45));
   filldraw w[10 + i];
   w[20 + i] := w1 rotated (0, (i * 45));
   filldraw w[20 + i];
endfor;

for i = 1 upto 3:
   w[20 + i] := w1 rotated (0, -(i * 45));
   filldraw w[20 + i];
   w[10 + i] := w0 rotated (0, -(i * 45));
   filldraw w[10 + i];
endfor;

v0 := current_picture;

%% **** (4) End of figure 1

output v0 with_focus f0 no_sort;

current_picture := null_picture;

a := 9.5;
d := 7;
e := 15.5;


draw ((-a, -d) -- (a, -d) -- (a, d) -- (-a, d) -- cycle) shifted (0, -e) 
   with_pen pensquare;

label("{\Large Plans for a Model of a Facetted Cone 1}", (0, d) shifted (0, -(e + .75)));

label("{\large Copyright (C) 2021 The Free Software Foundation}", 
   (0, -d) shifted (0, -(e - 1.50)));

label("{\large Author:  Laurence D. Finston}",  (0, -d) shifted (0, -(e - .75)));



%\quad 

endfig with_projection parallel_x_y;

%% *** (3)


%% ** (2) Facetted Cone 1

%% *** (3) Declarations and initializations

picture v[];

focus f[];
set f0 with_position (0, 30, -100) 
       with_direction (0, 30, 10) with_distance 50; 

circle c[];

point p[];

path q[];

bool b;
bool_point_vector bpv;

h := 10;  % 30

point n[]; %% Normals
              
pen dot_pen;

dot_pen := pencircle scaled (.75mm, .75mm, .75mm);

transform t[];

string s;


%% *** (3) Figure 0
       
beginfig(0);
  
%% **** (4)

outer_diam := 10;  %% 20
inner_diam :=  8;  %% 15;

c0 := unit_circle scaled (outer_diam, 0, outer_diam);
c1 := unit_circle scaled (inner_diam, 0, inner_diam);

draw c0;  
draw c1;  

%% **** (4)

j := 2;

for i := 0 step 4 until 28:
   p[j] := get_point (i) c0;
   drawdot p[j] with_pen pencircle scaled (1.5mm, 1.5mm, 1.5mm);
   j += 1;
endfor;

%dotlabel.lft(7, p7);
%dotlabel.lft(8, p8);

p0 := get_center c0;
p1 := p0 shifted (0, h);

%dotlabel.bot(0, p0);   
%dotlabel.top(1, p1);   

p10 := mediate(p7, p8);

%dotlabel.top(10, p10);   



bpv := (p0 -- p10) intersection_points c0;

%show bpv;

p11 := bpv[0];

%dotlabel.lft(11, p11);

bpv := (p0 -- p10) intersection_points c1;

p12 := bpv[0];

%dotlabel.rt(12, p12);

draw p0 -- p1 -- p7 -- p12 -- p1 -- p8 -- p12;

%% **** (4) Paths.

q0 :=  p12 -- p7 -- p1 -- cycle;

triangle w[];

set w0 with_points (p12, p7, p1);

p13 := get_center w0;

n0 := (get_normal w0) shifted p13;

%dotlabel.rt(13, p13);

%message "n0:"; 
%show n0;

label.top("$n_0$", n0);
drawarrow p13 -- n0;

v0 := current_picture;


%% **** (4) End of figure 0
  
endfig with_focus f0;

%% *** (3) Figure 1 --- Base circles

beginfig(1);

draw c0;
draw c1 dashed evenly;

c3 := unit_circle scaled (.25, 0, .25);

draw c3 with_color red;

drawdot origin with_pen dot_pen;

j := 2;

for i = 0 step 4 until 28:
   a := 40 + j;
   p[a] := p[j] rotated (0, 22.5);
   draw origin -- p[40 + j] dashed evenly;
   draw origin -- p[j] dashed evenly;
   s := "$p_{" & decimal j & "}$";
   %dotlabel.top(s, p[j]);
   s := "$p_{" & decimal a & "}$";
   %dotlabel.top(s, p[a]);
   j += 1;
%  message "a:"; 
%  show a;
%  message "j:"; 
%  show j;
endfor; 

unfilldraw c3;

draw (-.25, 0) -- (.25, 0);
draw (0, 0, -.25) -- (0, 0, .25);


p60 := get_point 0 c1;
%dotlabel.top("$p_{60}$", p60);

for i = 1 upto 15:
   a := 60 + i;
   p[a] := p60 rotated (0, i * 22.5);
   s := "$p_{" & decimal a & "}$";
   %dotlabel.top(s, p[a]);
endfor;


%% **** (4)

q3 :=    p2 -- p61 -- p3 -- p63 -- p4 -- p65 -- p5 -- p67 -- p6 -- p69
      -- p7 -- p71 -- p8 -- p73 -- p9 -- p75 -- p2;

draw q3;

%% **** (4) Tabs 

%% ***** (5) First tab

p80 := mediate(p5, p65, .2);
p81 := mediate(p65, p5, .2);

%dotlabel.top("$p_{80}$", p80);
%dotlabel.top("$p_{81}$", p81);

p82 := p80 shifted (0, 1);

p83 := (unit_vector(p81 - p80) scaled .5 shifted p80) rotated_around (p80, p82) -60;

%dotlabel.top("$p_{83}$", p83);

p84 := p81 shifted (0, 1);

p85 := (unit_vector(p80 - p81) scaled .5 shifted p81) rotated_around (p81, p84) 60;

%dotlabel.top("$p_{85}$", p85);

q4 := p80 -- p83 -- p85 -- p81;

draw q4;

p86 := mediate(p80, p83);
p87 := mediate(p81, p85);

%dotlabel.lft("$p_{86}$", p86);
%dotlabel.rt("$p_{87}$", p87);

draw p86 -- p87 dashed evenly;

for i = 1 upto 4:
   drawdot mediate(p86, p87, i/5) with_pen dot_pen;
endfor;


%% ***** (5)

t2 := identity rotated_around (origin, p5) 180;

q5 := q4;
p88 := p86;
p89 := p87;

q5 *= p88 *= p89 *= t2;

draw q5;
for i = 1 upto 4:
   drawdot mediate(p88, p89, i/5) with_pen dot_pen;
endfor;


t3 := identity rotated (0, 45);

for i := 1 upto 7:
   q4 *= q5 *= p86 *= p87 *= p88 *= p89 *= t3;
   draw q4;
   draw q5;
   draw p86 -- p87 dashed evenly;
   draw p88 -- p89 dashed evenly;
   for j = 1 upto 4:
      drawdot mediate(p86, p87, j/5) with_pen dot_pen;
      drawdot mediate(p88, p89, j/5) with_pen dot_pen;
   endfor;
endfor;

%% **** (4) End of figure 1

endfig with_projection parallel_x_z with_factor .5 no_sort;

%% *** (3)

%% *** (3) Figure 2

beginfig(2); 

p14 := p13;
n1 := n0;  
  
t0 := align (p13 -- n0) with_axis y_axis;

rotate t0 (180, 0);

w1 :=  w0;

w1 *= p14 *= n1 *= t0;

%draw w1 dashed evenly;

%dotlabel.lft($p_{14}$, p14);
%dotlabel.rt("$n_1$", n1);

%message "n1:"; 
%show n1;

%message "p14:"; 
%show p14;

for i = 0 upto 2:
   p[15 + i] := get_point (i) w1;
   a := 15 + i;
   s := "$p_{" & decimal a & "}$";
endfor;


%dotlabel.rt("$p_{15}$", p15);
%dotlabel.lft("$p_{16}$", p16);

%label.rt("$p_{17}$", p17);


% message "magnitude (p1 - p7):"; 
% show magnitude (p1 - p7);

% message "magnitude (p1 - p12):"; 
% show magnitude (p1 - p12);

% message "magnitude (p7 - p12):"; 
% show magnitude (p7 - p12);

% message "magnitude (p17 - p15):"; 
% show magnitude (p17 - p15);

% message "magnitude (p17 - p16):"; 
% show magnitude (p17 - p16);

% message "magnitude (p15 - p16):"; 
% show magnitude (p15 - p16);

% magnitude (p1 - p7):
% >> 36.0555
% magnitude (p17 - p16):
% >> 36.0555

% magnitude (p17 - p15):
% >> 33.541
% magnitude (p1 - p12):
% >> 33.541

% magnitude (p7 - p12):
% >> 8.40668
% magnitude (p15 - p16):
% >> 8.40668

%% **** (4) Second triangle

p20 := p16;

t1 := identity rotated_around (p15, p17) 180;

%show t1;

w1 *= p20 *= t1;

%draw w1 dashed evenly;

%dotlabel.top("$p_{20}$", p20);

%% **** (4) Third triangle

p21 := p15;
t1 := identity rotated_around (p20, p17) 180;

w1 *= p21 *= t1;

%draw w1 dashed evenly;
%dotlabel.top("$p_{21}$", p21);

%% **** (4) The remaining 13 triangles


for i = 22 upto 34:
   s := "$p_{" & decimal i & "}$";
   p[i] := p[i-2];
   t1 := identity rotated_around (p[i-1], p17) 180;
   w1 *= p[i] *= t1;
 %  draw w1 dashed evenly;
   %dotlabel.top(s, p[i]);
endfor;

%% **** (4) Clear out the the lines surrounding p17

c2 := unit_circle scaled (.375, 0, .375) shifted p17;
draw c2 dashed evenly;

a := 35;

for_suffixes i := 16, 15:

   bpv := (p[i] -- p17) intersection_points c2;

   b := bpv0;
    
   if b:
      p[a] := bpv0;
   else:
      p[a] := bpv1;
   fi;

   %s := "$p_{" & decimal a & "}$";
   %dotlabel.top(s, p[a]);

   %drawdot p[a] with_pen dot_pen;

   a += 1;

endfor;

draw p36 -- p15 dashed evenly;

for i := 20 upto 34:

   bpv := (p[i] -- p17) intersection_points c2;

   b := bpv0;
    
   if b:
      p[a] := bpv0;
   else:
      p[a] := bpv1;
   fi;

   %s := "$p_{" & decimal a & "}$";
   %dotlabel.top(s, p35);
 
   %drawdot p[a] with_pen dot_pen;

   draw p[a] -- p[i] dashed evenly;

%    message "i:"; 
%    show i;
%    message "a:"; 
%    show a;

   a += 1;

endfor;



draw p17 -- p38;
draw p17 -- p40;
draw p17 -- p43;
draw p17 -- p48;


q1 += --;

q1 += p17;
q1 += p16;
q1 += p15;

for i := 20 upto 34:
   q1 += p[i];
endfor;

q1 += p17;

draw q1;

%% **** (4) Tabs on short sides

%% ***** (5) First tab on short side

p90 := mediate(p15, p16, .2);
p91 := mediate(p16, p15, .2);

%dotlabel.top("$p_{90}$", p90);
%dotlabel.top("$p_{91}$", p91);

p92 := p90 shifted (0, 1);
p93 := (unit_vector(p91 - p90) scaled .5 shifted p90) rotated_around (p90, p92) 60;

%dotlabel.lrt("$p_{93}$", p93);

p94 := p91 shifted (0, 1);

p95 := (unit_vector(p90 - p91) scaled .5 shifted p91) rotated_around (p91, p94) -60;

%dotlabel.llft("$p_{95}$", p95);

q6 := p90 -- p93 -- p95 -- p91;

draw q6;

p96 := mediate(p90, p93);
p97 := mediate(p91, p95);

%dotlabel.rt("$p_{96}$", p96);
%dotlabel.lft("$p_{97}$", p97);

draw p96 -- p97 dashed evenly;

for i = 1 upto 4:
   drawdot mediate(p96, p97, i/5) with_pen dot_pen;
endfor;

%% ***** (5) Second tab on short side

t4 := identity rotated_around (p15, p17) 180;

p90 *= p91 *= p93 *= p95 *= p96 *= p97 *= q6 *= t4;

draw q6;
draw p96 -- p97 dashed evenly;

for i = 1 upto 4:
   drawdot mediate(p96, p97, i/5) with_pen dot_pen;
endfor;

%% ***** (5)  Remaining tabs on short sides

for j := 20 upto 33:
   t4 := identity rotated_around (p[j], p17) 180;

   p90 *= p91 *= p93 *= p95 *= p96 *= p97 *= q6 *= t4;

   draw q6;
   draw p96 -- p97 dashed evenly;

   for i = 1 upto 4:
      drawdot mediate(p96, p97, i/5) with_pen dot_pen;
   endfor;
endfor;

%% **** (4) Tabs on long sides

%% ***** (5) Inner tab on p16 -- p17

p100 := unit_vector (p17 - p16) shifted p16;
p101 := (unit_vector (p16 - p17) scaled 2.5) shifted p17;

% dotlabel.lft("$p_{100}$", p100);
% dotlabel.lft("$p_{101}$", p101);

p102 := p101 shifted (0, 1);

p103 := ((unit_vector (p16 - p17) scaled .5) shifted p101) rotated_around (p101, p102) 60;
%dotlabel.rt("$p_{103}$", p103);

p104 := p100 shifted  (0, 1);

p105 := ((unit_vector (p17 - p16) scaled .5) shifted p100) rotated_around (p100, p104) -60;
%dotlabel.rt("$p_{105}$", p105);

draw p100 -- p105 -- p103 -- p101;

p106 := mediate(p100, p105);
%dotlabel.bot("$p_{106}$", p106);

p107 := mediate(p101, p103);
%dotlabel.urt("$p_{107}$", p107);

draw p106 -- p107 dashed evenly;

for i := 1 upto 15:
   drawdot mediate(p106, p107, i/16) with_pen dot_pen;
endfor;

%% ***** (5) Outer tab on p34 -- p17

a := (p34 - p17) angle (p16 - p17);


p108 := p17 shifted (0, 1);

t5 := identity rotated_around (p17, p108) -a;

p100 *= p101 *= p103 *= p105 *= p106 *= p107 *= t5;

draw p100 -- p105 -- p103 -- p101;
draw p106 -- p107 dashed evenly;


for i := 1 upto 15:
   drawdot mediate(p106, p107, i/16) with_pen dot_pen;
endfor;

%% **** (4) End of figure 2

rotate current_picture (0, -90);

endfig with_projection parallel_x_z with_factor .5 no_sort;

%% *** (3)

end;

%% ** (2) Sphere Development 1

%% This sample has been put into `sphrmd01.ldf' and added to the webpages.
%% LDF 2009.10.26.


verbatim_metapost "verbatimtex \font\large=cmr17 etex;";

%% *** (3) Declarations and initializations


PI := 3.141592653589793;

focus f[];

set f0 with_position (0, 10, -30) 
       with_direction (0, 10, 10) with_distance 20; 

circle c[];       

point p[];
path q[];

transform t[];

pen thin_pen;
pen line_pen;
pen dot_pen;

thin_pen := pencircle scaled (.25mm, .25mm, .25mm);

line_pen := pencircle scaled (.333mm, .333mm, .333mm);

dot_pen := pencircle scaled (1mm, 1mm, 1mm);

pickup line_pen;

color_vector cv;

cv += blue;
cv += red;
cv += green;
cv += cyan;
cv += magenta;
cv += yellow;
cv += violet;
cv += orange;
cv += black;

picture v[];

bool_point_vector bpv;

string s;

numeric r[];  %% Radii

numeric d[][];  %% Lengths of the horizontals.

string s;

%% *** (3) Figure 0

beginfig(0); 
  
k := 5;

m[0] := 45;  %% Main curves

m[1] := 30; %% Inner curve for stitches

m[2] := 60; %% Outer curve for stitches

m[3] := 70; %% Even further out curve for offset beyond the stitches

r0 := 5;

set c0 with_diameter 2*r0 with_point_count 64;

d[0][0] := 2 * PI * r0 * m[0] / 360;

d[1][0] := 2 * PI * r0 * m[1] / 360;

d[2][0] := 2 * PI * r0 * m[2] / 360;

d[3][0] := 2 * PI * r0 * m[3] / 360;


for i = 0 upto 2:
   s := "d[" & decimal i & "][0]:";
   message s;
   show d[i][0];
endfor;

p0 := get_center c0;

dotlabel.rt("$p_0$", p0);

rotate c0 (90, 0);

draw c0;

p1 := p0 shifted (0, -r0);
dotlabel.lrt("$p_1$", p1);

%draw p0 -- p1;  %% Not really necessary.

j := 2;

for i := k step k until (180 - k):

   message "i:"; 
   show i;

   p[j] := p1 rotated (0, 0, i);

   s := "$p_{" & decimal j & "}$";
   dotlabel.lrt(s, p[j]);

   draw p0 -- p[j];  %% Not really necessary.

   j += 1;

   p[j] := (0, ypart p[j - 1]);

   r[i] := magnitude (p[j] - p[j - 1]);

   s := "r[" & decimal i & "]:";

   message s;
   show r[i];

   s := "$p_{" & decimal j & "}$";

   dotlabel.ulft(s, p[j]);

   draw p[j - 1] -- p[j];  %% Not really necessary.

   j += 1;


   d[0][i] := (2 * PI * r[i] *  m[0]) / 360;
   d[1][i] := (2 * PI * r[i] *  m[1]) / 360;
   d[2][i] := (2 * PI * r[i] *  m[2]) / 360;
   d[3][i] := (2 * PI * r[i] *  m[3]) / 360;

%   s := "d[0][" & decimal i & "]:";
%
%   message s;
%   show d[0][i];


endfor;

endfig with_projection parallel_x_y no_sort;

%% *** (3) Figure 1

e := PI * r0;
f := e * k / 180;

beginfig(1); 

p2 := (0, e);

draw origin -- p2 with_pen thin_pen;

j := 1;

q0 += origin;
q1 += origin;
q2 += origin;
q3 += origin;
q4 += origin;
q5 += origin;
q6 += origin;

q0 += ..;
q1 += ..;
q2 += ..;
q3 += ..;
q4 += ..;
q5 += ..;
q6 += ..;

for i := k step k until (180 - k):

   message "i:"; 
   show i;

   p3 := (-d[0][i]/2, j * f);  %% Points on main curves
   p4 := (d[0][i]/2, j * f);

   p5 := (-d[1][i]/2, j * f);  %% Points on inner curves
   p6 := (d[1][i]/2, j * f);

   p7 := (-d[2][i]/2, j * f);  %% Points on outer curves
   p8 := (d[2][i]/2, j * f);


   p9 := (d[3][i]/2, j * f);  %% Point on even further out curve

   draw p3 -- p9 with_color gray;  %% Horizontals

   q0 += p3;                   %% Main curves
   q1 += p4;

   q2 += p5;                   %% Inner curves
   q3 += p6;

   drawdot p5 with_pen dot_pen;

   q4 += p7;                   %% Outer curves
   q5 += p8;

   q6 += p9;                   %% Even futher out curve

   drawdot p8 with_pen dot_pen;

   j += 1;

endfor;

q0 += p2;
q1 += p2;

q2 += p2;
q3 += p2;
q4 += p2;
q5 += p2;
q6 += p2;


draw q0;
draw q1 dashed evenly;

draw q2 dashed evenly withpen thin_pen;
%draw q3;

%draw q4;
draw q5 dashed evenly withpen thin_pen;

draw q6;

v0 := currentpicture;
v1 := v0;

p30 := (0, .5e);
p31 := p30;

a := 6.5;
t0 := identity shifted (a, 0);

for i = 1 upto 4:
   s := "{\large " & decimal i & "}";
   label.rt(s, p31);
   currentpicture += v1;
   v1 *= t0;
   p31 *= t0;
endfor;

%% Second row

v1 := v0;
p31 := p30;

t1 := identity shifted (0, -17);

v1 *= t1;
p31 *= t1;

for i = 5 upto 8:
   s := "{\large " & decimal i & "}";
   label.rt(s, p31);
   currentpicture += v1;
   v1 *= t0;
   p31 *= t0;
endfor;

endfig with_projection parallel_x_y no_sort;

end;



%% ** (2) Great Dodecahedron --- Plans for a Cardboard Model

point p[];
point q[][];

transform t[];

pen dot_pen;
pen tiny_pen;

dot_pen := pencircle scaled (.375mm, .375mm, .375mm);
tiny_pen := pencircle scaled (.25mm, .25mm, .25mm);

pickup pencircle scaled (.5mm, .5mm, .5mm);

%% *** (3) Figure 1

beginfig(1); 

%% **** (4) Parallelogram 1

p0 := origin;
p1 := (3, 0);

p2 := p1 rotated (0, 72);

p3 := p0 rotated_around (p1, p2) 180;

t0 := identity rotated (0, -36);

p0 *= p1 *= p2 *= p3 *= t0;

p4 := mediate(p1, p2);
p5 := p4 shifted (0, 0, .5);

label(1, p5);

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 

draw p0 -- p1 -- p3 -- p2 -- cycle dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

%% This sets p[6] -- p[32].

for i := 1 upto 9:

   p[5 + i]  := mediate(p0, p3, i/10);
   p[14 + i] := mediate(p0, p3, i/10) shifted (0, 0, .125);
   p[23 + i] := mediate(p0, p3, i/10) shifted (0, 0, -.125);

   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;

endfor;

for i := 0 upto 32:
   q[1][i] := p[i];
endfor;

%% **** (4) Parallelogram 2

t0 := identity rotated_around (p0, p2) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[2][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(2, p5);

draw p1 -- p0 dashed evenly;;
draw p2 -- p3 -- p1;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;


%% **** (4) Parallelogram 3

t0 := identity rotated_around (p0, p1) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[3][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(3, p5);

draw p1 -- p3 -- p2 -- p0 dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 4

t0 := identity rotated_around (p0, p2) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[4][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(4, p5);

draw p1 -- p3 -- p2 -- p0 -- cycle dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 5

t0 := identity rotated_around (p0, p1) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[5][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(5, p5);

draw p1 -- p3 -- p2;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;


%% **** (4) Parallelogram 6

t0 := identity rotated_around (p0, p1) 180;

rotate_around t0 (q[4][3], q[4][1]) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[6][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(6, p5);

draw p1 -- p0 -- p2;
draw p1 -- p3 -- p2 dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;


%% **** (4) Parallelogram 7

t0 := identity rotated_around (p3, p2) 180;

for i := 0 upto 32:
   p[i] *= t0;
   q[7][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(7, p5);

draw p3 -- p1 -- p0 -- p2;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;


%% **** (4) Parallelogram 8

t0 := identity shifted by (q[3][4] - q[6][4]);

for i := 0 upto 32:
   p[i] *= t0;
   q[8][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(8, p5);

draw p0 -- p2;
draw p0 -- p1 -- p3 dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 9


t0 := identity shifted by (q[8][5] - q[2][5]);

for i = 0 upto 32:
   p[i] := q[3][i];
   p[i] *= t0;
   q[9][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(9, p5);

draw p0 -- p2;
draw p1 -- p3;

draw p2 -- p3 dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 10


t0 := identity rotated_around (p[2], p[3]) 180;

for i = 0 upto 32:
   p[i] *= t0;
   q[10][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(10, p5);

draw p2 -- p0 -- p1 -- p3;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 11


t0 := identity rotated_around (q[8][1], q[8][3]) 180;

for i = 0 upto 32:
   q[11][i] := p[i] := q[8][i] * t0;
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(11, p5);

draw p2 -- p0 -- p1;

draw p2 -- p3 dashed evenly;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 12

t0 := identity rotated_around (q[11][2], q[11][3]) 180;

for i = 0 upto 32:
   p[i] *= t0;
   q[12][i] := p[i];
endfor;

if true: 
%if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(12, p5);

draw p0 -- p1 dashed evenly;
draw p0 -- p2 dashed evenly;
draw p1 -- p3 dashed evenly;


draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 13


t0 := identity rotated_around (q[12][1], q[12][3]) 180;

for i = 0 upto 32:
   p[i] *= t0;
   q[13][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(13, p5);

draw p0 -- p1;
draw p0 -- p2;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 14

t0 := identity rotated_around (q[12][0], q[12][1]) 180;

for i = 0 upto 32:
   p[i] := q[12][i];
   p[i] *= t0;	
   q[14][i] := p[i];
endfor;

%if true: 
if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(14, p5);

draw p0 -- p2;
draw p1 -- p3;
draw p2 -- p3;

draw p0 -- p3 with_pen tiny_pen;

for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;

%% **** (4) Parallelogram 15

t0 := identity rotated_around (q[12][0], q[12][3]) 180;

for i = 0 upto 32:
   p[i] := q[14][i];
   p[i] *= t0;
endfor;

t0 := identity rotated_around (p0, p2) 180;

for i = 0 upto 32:
   p[i] *= t0;
   q[15][i] := p[i];
endfor;

if true: 
%if false: 
   dotlabel.top("$p_0$", p0);
   dotlabel.top("$p_1$", p1);
   dotlabel.top("$p_2$", p2);
   dotlabel.top("$p_3$", p3);
fi; 
   
label(15, p5);

draw p0 -- p1;
draw p0 -- p2 dashed evenly;
draw p1 -- p3;
draw p2 -- p3;

draw p0 -- p3 with_pen tiny_pen;


for i := 1 upto 9:
   drawdot p[5 + i] with_pen dot_pen;
   draw p[14 + i] -- p[23 + i] with_pen tiny_pen;
endfor;


%% **** (4) End of Figure 1

%rotate current_picture (0, 180);

endfig with_projection parallel_x_z no_sort; 

%% *** (3)

end;

%% ** (2) Plans for a cardboard model of the Great Rhombicosidodecahedron

%% This code is not completely correct.  The finished version is in
%% `/home/lfinsto2/3DLDF/www/3dldf/SRC_CODE/grrhm_06.ldf'.
%%
%% LDF 2009.01.23.

%% *** (3) Declarations.

point c[];  %% centers

point p[][];

point q[];

path w[];

pen dot_pen;
pen tiny_pen;

dot_pen := pencircle scaled (.5mm, .5mm, .5mm);
tiny_pen := pencircle scaled (.25mm, .25mm, .25mm);

reg_polygon_vector rpv;

transform t[];

pickup pencircle scaled (.5mm, .5mm, .5mm);

rpv := get_net great_rhombicosidodecahedron with_diameter 5;  %% 62 polyhedra

for i := 0 upto size rpv - 1:
   rotate rpv[i] (0, -90);
   c[i] := get_center rpv[i];
endfor;

for i := 0 upto 61:
   for j := 0 upto ((size rpv[i]) - 1):
      p[i][j] := get_point (j) rpv[i];
   endfor;
endfor;

%% *** (3) Comment figures 1 and 2 out (or in)

if true:     
%if false: 

%% *** (3) Figure 1

beginfig(1); 

%% **** (4) The net without tabs

for i := 0 upto size rpv - 1:
   label(i, c[i]);
endfor;


draw rpv with_color red;

% dotlabel.rt(0, p[0][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[0][i]);
% endfor;

%% **** (4) First tab on rpv0

q0 := ((p[0][1] - p[0][0]) / 5) shifted p[0][0];

q1 := mediate(p[0][0], p[0][1]);

%dotlabel.lft("$q_{0}$", q0);
%dotlabel.lft("$q_{1}$", q1);

q2 := q0 rotated_around (c0, q1) 180;

%dotlabel.lft("$q_{2}$", q2);

draw p[0][0] -- q0;
draw q0 -- q2 dashed evenly;
draw q2 -- p[0][1];


q3 := q0 shifted (0, 1);

q4 := p[0][0] rotated_around (q0, q3) 114;

%dotlabel.rt("$q_{4}$", q4);

q5 := (unit_vector(q4 - q0) / 2) shifted q0;

%dotlabel.rt("$q_{5}$", q5);

a := (q5 - q0) angle (q2 - q0);

% message "a:"; 
% show a;

% message "magnitude (q4 - q0):"; 
% show magnitude (q4 - q0);

% message "magnitude (q5 - q0):"; 
% show magnitude (q5 - q0);

q6 := q5 rotated_around (c0, q1) 180;

%dotlabel.rt("$q_{6}$", q6);

q7 := mediate(q0, q5, 1/3);
q8 := mediate(q2, q6, 1/3);

% dotlabel.bot("$q_{7}$", q7);
% dotlabel.ulft("$q_{8}$", q8);

q9 := mediate(q0, q5, 2/3);
q10 := mediate(q2, q6, 2/3);

% dotlabel.lrt("$q_{9}$", q9);
% dotlabel.urt("$q_{10}$", q10);

draw q0 -- q5 -- q6 -- q2;

draw q7 -- q8 with_pen tiny_pen;
draw q9 -- q10 with_pen tiny_pen;

%% Dots for stitches (q[11] -- q[20])

for i = 1 upto 5:
   q[10 + i] := mediate(q7, q8, i/6);
   q[15 + i] := mediate(q9, q10, i/6);
   q[20 + i] := (q[10 + i] -- q[15 + i]) intersection_point (q0 -- q2);
   q[25 + i] := (q[10 + i] -- q[15 + i]) intersection_point (q5 -- q6);
   q[30 + i] := q[20 + i];
   q[35 + i] := q[25 + i];
   drawdot q[10 + i] with_pen dot_pen;
   drawdot q[15 + i] with_pen dot_pen;
   draw q[20 + i] -- q[25 + i] with_pen tiny_pen;
endfor;


w0 := q0 -- q5 -- q6 -- q2;
w1 := q7 -- q11 -- q12 -- q13 -- q14 -- q15 -- q8;
w2 := q9 -- q16 -- q17 -- q18 -- q19 -- q20 -- q10;



%% **** (4) Additional outer tabs on rpv[0]

c70 := c0 shifted (0, 1);

t0 := identity rotated_around (c0, c70) 36;

for i := 1 upto 6:

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30
      *= t0;

   draw p[0][i] -- q0;
   draw q0 -- q2 dashed evenly;

   draw q2 -- p[0][i + 1];

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
  
endfor;

%% **** (4) Outer tabs on rpv7;

% dotlabel.rt(0, p[7][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[7][i]);
% endfor;

c77 := c7 shifted (0, 1);

t0 := identity shifted by (c7 - c0);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c7, c77) 36;

for i := 7 upto 11:
 
   k := i;
   m := k + 1;

   if k > 9:
      k -= 10;
   fi;

   if m > 9:
      m -= 10;
   fi;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   % draw p[7][i] -- q0;
   % draw q0 -- q2 dashed evenly;

   %draw q2 -- p[0][i + 1];

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[7][k] -- q0;
   draw p[7][m] -- q2;
      
   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
endfor;

%% **** (4) Outer tabs on rpv12;

%dotlabel.rt(0, p[12][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[12][i]);
% endfor;

c82 := c12 shifted (0, 1);

t0 := identity shifted by (c12 - c7);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c12, c82) 36;

for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[12][i] -- q0;
    draw p[12][i + 1] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;
endfor;


%% **** (4) Outer tabs on rpv17;

%dotlabel.rt(0, p[17][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[17][i]);
% endfor;

c87 := c17 shifted (0, 1);

t0 := identity shifted by (c17 - c12);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

% draw q0 -- q5 -- q6 -- q2;

% draw q7 -- q8 with_pen tiny_pen;
% draw q9 -- q10 with_pen tiny_pen;

% draw q0 -- q2 dashed evenly;

% for j = 1 upto 5:
%    drawdot q[10 + j] with_pen dot_pen;
%    drawdot q[15 + j] with_pen dot_pen;
%    draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
% endfor;

t1 := identity rotated_around (c17, c87) 36;

for i := 6 upto 13:

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[17][k] -- q0;
    draw p[17][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

endfor;

%% **** (4) Outer tabs on rpv19;

%dotlabel.rt(0, p[19][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[19][i]);
% endfor;

c89 := c19 shifted (0, 1);

t0 := identity shifted by (c19 - c17);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

% draw q0 -- q5 -- q6 -- q2;

% draw q7 -- q8 with_pen tiny_pen;
% draw q9 -- q10 with_pen tiny_pen;

% draw q0 -- q2 dashed evenly;

% for j = 1 upto 5:
%    drawdot q[10 + j] with_pen dot_pen;
%    drawdot q[15 + j] with_pen dot_pen;
%    draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
% endfor;

t1 := identity rotated_around (c19, c89) 36;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

if true: 
%if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[19][k] -- q0;
    draw p[19][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% **** (4) Outer tabs on rpv24;

%dotlabel.rt(0, p[24][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[24][i]);
% endfor;

c94 := c24 shifted (0, 1);

t0 := identity shifted by (c24 - c19);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c24, c94) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;



if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[24][k] -- q0;
    draw p[24][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% **** (4)

%% **** (4) Outer tabs on rpv31;

%dotlabel.rt(0, p[31][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[31][i]);
% endfor;

c101 := c31 shifted (0, 1);

t0 := identity shifted by (c31 - c24);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c31, c101) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

if true: 
%if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[31][k] -- q0;
    draw p[31][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% ***** (5) End of outer tabs on rpv31


%% **** (4) Outer tabs on rpv37;

%dotlabel.rt(0, p[37][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[37][i]);
% endfor;

c107 := c37 shifted (0, 1);

t0 := identity shifted by (c37 - c31);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c37, c107) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[37][k] -- q0;
    draw p[37][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% ***** (5) End of outer tabs on rpv37

%% **** (4) Outer tabs on rpv43;

%dotlabel.rt(0, p[43][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[43][i]);
% endfor;

c113 := c43 shifted (0, 1);

t0 := identity shifted by (c43 - c37);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c43, c113) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

if true: 
%if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[43][k] -- q0;
    draw p[43][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% ***** (5) End of outer tabs on rpv43

%% **** (4) Outer tabs on rpv49;

%dotlabel.rt(0, p[49][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[49][i]);
% endfor;

c119 := c49 shifted (0, 1);

t0 := identity shifted by (c49 - c43);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c49, c119) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;


%% ***** (5)

if true: 
%if false: 
for i := 1 upto 8:

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[49][k] -- q0;
    draw p[49][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

endfor;
fi;

%% ***** (5) End of outer tabs on rpv49


%% **** (4) Outer tabs on rpv50;

%dotlabel.rt(0, p[50][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[50][i]);
% endfor;

c120 := c50 shifted (0, 1);

t0 := identity shifted by (c50 - c49);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c50, c120) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%% ***** (5)

if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[50][k] -- q0;
    draw p[50][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;



endfor;
fi;

%% ***** (5) End of outer tabs on rpv50

%% **** (4) Outer tabs on rpv56;

%dotlabel.rt(0, p[56][0]);

% for i := 0 upto 9:
%    dotlabel.top(i, p[56][i]);
% endfor;

c126 := c56 shifted (0, 1);

t0 := identity shifted by (c56 - c50);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c56, c126) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

if true: 
%if false: 
for i := 6 upto 11:

    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[56][k] -- q0;
    draw p[56][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;



endfor;
fi;

%% ***** (5) End of outer tabs on rpv56

%% **** (4) Inner tabs on rpv0

% for i := 0 upto 9:
%    dotlabel.lft(i, p[0][i]);
% endfor;

t0 := identity shifted by (c0 - c56);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c0, c70) 36;

t2 := t1;

t2 *= t1;
t2 *= t1;
t2 *= t1;
t2 *= t1;

rotate_around t2 (p[0][7], p[0][8]) 180;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t2;

if true:
%if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)


t1 := identity rotated_around (c0, c70) 36;

if true: 
%if false: 
for i := 8 upto 8:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;



    k := i;
    m := i + 1;

    if k > 9:
       k -= 10;
    fi;

    if m > 9:
       m -= 10;
    fi;

    draw q0 -- q5 -- q6 -- q2;

    draw q7 -- q8 with_pen tiny_pen;
    draw q9 -- q10 with_pen tiny_pen;

    draw q0 -- q2 dashed evenly;

    draw p[0][k] -- q0;
    draw p[0][m] -- q2;
     
    for j = 1 upto 5:
       drawdot q[10 + j] with_pen dot_pen;
       drawdot q[15 + j] with_pen dot_pen;
       draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
    endfor;


endfor;
fi;

%% **** (4) Inner tabs on rpv7

% for i := 0 upto 9:
%    dotlabel.lft(i, p[7][i]);
% endfor;

t0 := identity shifted by (c7 - c0);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c7, c77) 36;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

t2 := t1;
t2 *= t1;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t2;


%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 4:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[7][k] -- q0;
       draw p[7][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% **** (4) Inner tabs on rpv12

% for i := 0 upto 9:
%    dotlabel.lft(i, p[12][i]);
% endfor;

t0 := identity shifted by (c12 - c7);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


t1 := identity rotated_around (c12, c82) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)


%t1 := identity rotated_around (c12, c82) 36;

if true: 
%if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 9:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[12][k] -- q0;
       draw p[12][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% **** (4)

%% **** (4) Inner tabs on rpv17

% for i := 0 upto 9:
%    dotlabel.lft(i, p[17][i]);
% endfor;

t0 := identity shifted by (c17 - c12);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


t1 := identity rotated_around (c17, c87) 144;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


if true:
%if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

%% **** (4) Inner tabs on rpv19

% for i := 0 upto 9:
%    dotlabel.lft(i, p[19][i]);
% endfor;

t0 := identity shifted by (c19 - c17);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


t1 := identity rotated_around (c19, c89) -144;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)


t1 := identity rotated_around (c19, c89) 36;

if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 4:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[19][k] -- q0;
       draw p[19][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% **** (4) Inner tabs on rpv24

% for i := 0 upto 9:
%    dotlabel.lft(i, p[24][i]);
% endfor;

t0 := identity shifted by (c24 - c19);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


if false: 
%t1 := identity rotated_around (c24, c94) 36;

% q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
%    *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
%    *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
%       *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)


t1 := identity rotated_around (c24, c94) 36;

if true: 
%if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 9:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[24][k] -- q0;
       draw p[24][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% **** (4) Inner tabs on rpv31

% for i := 0 upto 9:
%    dotlabel.lft(i, p[31][i]);
% endfor;

t0 := identity shifted by (c31 - c24);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


t1 := identity rotated_around (c31, c101) 36;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

if true: 
%if false: 
for i := 2 upto 6:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
       *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 4:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[31][k] -- q0;
       draw p[31][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5)

%% **** (4) Inner tabs on rpv37

% for i := 0 upto 9:
%    dotlabel.lft(i, p[37][i]);
% endfor;

t0 := identity shifted by (c37 - c31);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c37, c107) 36;

if false: 
% q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
%    *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
%    *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
%       *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
  *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

if true: 
%if false: 
for i := 7 upto 11:

    if i <> 9:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[37][k] -- q0;
       draw p[37][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


endfor;
fi;

%% **** (4) Inner tabs on rpv43

% for i := 0 upto 9:
%    dotlabel.lft(i, p[43][i]);
% endfor;

t0 := identity shifted by (c43 - c37);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;


t1 := identity rotated_around (c43, c113) 36;

if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

if true: 
%if false: 
for i := 2 upto 6:

    if i <> 4:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[43][k] -- q0;
       draw p[43][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


endfor;
fi;

%% **** (4) Inner tabs on rpv49

% for i := 0 upto 9:
%    dotlabel.lft(i, p[49][i]);
% endfor;

t0 := identity shifted by (c49 - c43);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c49, c119) 36;

t2 := t1;
t2 *= t1;
t2 *= t1;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t2;

if true:
%if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

%if true: 
if false: 
for i := 7 upto 11:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 9:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[49][k] -- q0;
       draw p[49][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% **** (4) Inner tabs on rpv50

% for i := 0 upto 9:
%    dotlabel.lft(i, p[50][i]);
% endfor;

t0 := identity shifted by (c50 - c49);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c50, c120) -108;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;



%% ***** (5)

t1 := identity rotated_around (c50, c120) 36;

if true: 
%if false: 
for i := 7 upto 11:

    if i <> 9:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[50][k] -- q0;
       draw p[50][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


endfor;
fi;

%% **** (4) Inner tabs on rpv56

% for i := 0 upto 9:
%    dotlabel.lft(i, p[56][i]);
% endfor;

t0 := identity shifted by (c56 - c50);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c56, c126) 36;

if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ***** (5)

if true: 
%if false: 
for i := 2 upto 5:

    if i <> 4:
       k := i;
       m := i + 1;

       if k > 9:
          k -= 10;
       fi;

       if m > 9:
          m -= 10;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[56][k] -- q0;
       draw p[56][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

endfor;
fi;

%% **** (4) The remaining edges on the dodecagons

forsuffixes i = 7, 17, 19, 31, 43, 56:
   draw p[i][4] -- p[i][5] dashed evenly;
endfor;

forsuffixes i = 0, 12, 24, 37, 49, 50:
   draw p[i][0] -- p[i][9] dashed evenly;
endfor;

%% **** (4) Inner tabs on the hexagons
%%
%%          I believe there are no outer tabs on the hexagons or squares,
%%          but I may have to correct this later.
%%          LDF 2009.01.19.


forsuffixes i :=  1,  3,  6,  9, 13, 15, 20, 22, 26, 28, 
                 32, 34, 38, 40, 44, 46, 51, 53, 57, 59:
   c[70 + i] := c[i] shifted (0, 1);
if false: 
   for j := 0 upto 5:
      dotlabel.lft(j, p[i][j]);
   endfor;
fi; 
endfor;

%% ***** (5) Inner tabs on rpv1

%w0 := q0 -- q5 -- q6 -- q2;
%w1 := q7 -- q11 -- q12 -- q13 -- q14 -- q15 -- q8;
%w2 := q9 -- q16 -- q17 -- q18 -- q19 -- q20 -- q10;

q0 := get_point 0 w0;
q5 := get_point 1 w0;
q6 := get_point 2 w0;
q2 := get_point 3 w0;

q7  := get_point 0 w1;
q11 := get_point 1 w1;
q12 := get_point 2 w1;
q13 := get_point 3 w1;
q14 := get_point 4 w1;
q15 := get_point 5 w1;
q8  := get_point 6 w1;

q9  :=  get_point 0 w2; 
q16 :=  get_point 1 w2;
q17 :=  get_point 2 w2;
q18 :=  get_point 3 w2;
q19 :=  get_point 4 w2;
q20 :=  get_point 5 w2;
q10 :=  get_point 6 w2;

for i := 1 upto 5:
   q[20 + i] := q[30 + i];
   q[25 + i] := q[35 + i];
endfor;

t1 := identity rotated_around (c0, c70) -36;

c71 := c1 shifted (0, 1);

rotate_around t1 (c1, c71) -120;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

t1 := identity rotated_around (c1, c71) 60;

%% ****** (6)

if true: 
%if false: 
for i := 0 upto 4:

    if (i <= 1) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[1][k] -- q2;  
       draw p[1][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;



endfor;
fi;

%% ***** (5) Inner tabs on rpv3



t0 := identity shifted by (c[3] - c[1]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[3], c73) 60;

if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

if true: 
%if false: 
for i := 0 upto 5:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if (i <> 2) and (i <> 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[3][k] -- q2;
       draw p[3][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[6]



t0 := identity shifted by (c[6] - c[3]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[6], c[76]) 60;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

if true: 
%if false: 
for i := 1 upto 5:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if (i == 1) or (i == 3):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[6][k] -- q0;
       draw p[6][m] -- q2;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[9]



t0 := identity shifted by (c[9] - c[6]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[9], c[79]) 60;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

if true: 
%if false: 
for i := 0 upto 4:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 1:
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[9][k] -- q2;
       draw p[9][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

endfor;
fi;

%% ***** (5) Inner tabs on rpv[13]



t0 := identity shifted by (c[13] - c[9]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[13], c[83]) 60;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

if true: 
%if false: 
for i := 0 upto 4:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if (i == 0) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[13][k] -- q2;
       draw p[13][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[15]



t0 := identity shifted by (c[15] - c[13]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[15], c[85]) 60;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)


if true: 
%if false: 
for i := 0 upto 3:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 2:
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[15][k] -- q2;
       draw p[15][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[20]



t0 := identity shifted by (c[20] - c[15]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[20], c[90]) 180;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[20], c[90]) 60;

if true: 
%if false: 
for i := 1 upto 3:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if i <> 2:
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[20][k] -- q2;
       draw p[20][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[22]



t0 := identity shifted by (c[22] - c[20]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[22], c[92]) 180;


q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[22], c[92]) 60;

if true: 
%if false: 
for i := 0 upto 5:

    if (i <> 1) and (i <> 5):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[22][k] -- q2;
       draw p[22][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;



endfor;
fi;

%% ***** (5) Inner tabs on rpv[26]



t0 := identity shifted by (c[26] - c[22]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[26], c[96]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[26], c[96]) 60;

if true: 
%if false: 
for i := 0 upto 5:

    if (i == 0) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[26][k] -- q2;
       draw p[26][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

endfor;
fi;

%% ***** (5) Inner tabs on rpv[28]



t0 := identity shifted by (c[28] - c[26]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[28], c[98]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[28], c[98]) 60;

if true: 
%if false: 
for i := 0 upto 5:


    if (i <> 2) and (i <> 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[28][k] -- q2;
       draw p[28][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


endfor;
fi;

%% ***** (5) Inner tabs on rpv[32]



t0 := identity shifted by (c[32] - c[28]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[32], c[102]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[32], c[102]) 60;

if true: 
%if false: 
for i := 1 upto 3:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 2):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[32][k] -- q2;
       draw p[32][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;


%% ***** (5) Inner tabs on rpv[34]



t0 := identity shifted by (c[34] - c[32]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[34], c[104]) 120;

if true: 
%if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[34], c[104]) 60;

if true: 
%if false: 
for i := 0 upto 4:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 1):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[34][k] -- q2;
       draw p[34][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[38]



t0 := identity shifted by (c[38] - c[34]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[38], c[108]) 60;

if true: 
%if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[38], c[108]) 60;

if true: 
%if false: 
for i := 0 upto 5:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i == 0) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[38][k] -- q2;
       draw p[38][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[40]



t0 := identity shifted by (c[40] - c[38]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[40], c[110]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[40], c[110]) 60;

if true: 
%if false: 
for i := 0 upto 5:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 2) and (i <> 4):  % (i == 0) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[40][k] -- q2;
       draw p[40][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

endfor;
fi;

%% ***** (5) Inner tabs on rpv[44]



t0 := identity shifted by (c[44] - c[40]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[44], c[114]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[44], c[114]) 60;

if true: 
%if false: 
for i := 0 upto 5:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i == 1) or (i == 3):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[44][k] -- q2;
       draw p[44][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[46]



t0 := identity shifted by (c[46] - c[44]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[46], c[116]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[46], c[116]) 60;

if true: 
%if false: 
for i := 0 upto 4:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 1) and (i <> 2):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[46][k] -- q2;
       draw p[46][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[51]



t0 := identity shifted by (c[51] - c[46]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[51], c[121]) 60;

if true: 
%if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

if true: 
%if false: 
for i := 0 upto 5:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i == 0) or (i == 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[51][k] -- q2;
       draw p[51][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[53]



t0 := identity shifted by (c[53] - c[51]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[53], c[123]) 60;

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[53], c[123]) 60;

if true: 
%if false: 
for i := 0 upto 5:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 2) and (i <> 4):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[53][k] -- q2;
       draw p[53][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[57]



t0 := identity shifted by (c[57] - c[53]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[57], c[127]) 60;

%if true: 
if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[57], c[127]) 60;

if true: 
%if false: 
for i := 0 upto 3:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i == 1) or (i == 3):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[57][k] -- q2;
       draw p[57][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5) Inner tabs on rpv[59]

t0 := identity shifted by (c[59] - c[57]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

t1 := identity rotated_around (c[59], c[129]) 120;

if true: 
%if false: 
q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

%if true:
if false: 
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;
fi;

%% ****** (6)

t1 := identity rotated_around (c[59], c[129]) 60;

if true: 
%if false: 
for i := 0 upto 4:

if true: 
%if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 

    if (i <> 1):
       k := i;
       m := i + 1;

       if k > 5:
          k -= 6;
       fi;

       if m > 5:
          m -= 6;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[59][k] -- q2;
       draw p[59][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

%if true: 
if false: 
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
fi; 


endfor;
fi;

%% ***** (5)

%% **** (4) The remaining edges on the hexagons

forsuffixes i :=  1, 13, 26, 38, 51:
   if i > 1:
      draw p[i][1] -- p[i][2] dashed evenly;
   fi;
   draw p[i][3] -- p[i][4] dashed evenly;
   draw p[i][5] -- p[i][0] dashed evenly;
endfor;

forsuffixes i = 3, 15, 28, 40, 53:
   draw p[i][2] -- p[i][3] dashed evenly;
   draw p[i][4] -- p[i][5] dashed evenly;
endfor;

forsuffixes i = 6, 20, 32, 44, 57:
   draw p[i][0] -- p[i][1] dashed evenly;
   draw p[i][2] -- p[i][3] dashed evenly;
   draw p[i][4] -- p[i][5] dashed evenly;
endfor;

forsuffixes i = 9, 22, 34, 46, 59:
   draw p[i][1] -- p[i][2] dashed evenly;
   draw p[i][5] -- p[i][0] dashed evenly;
endfor;

%% **** (4) Inner tabs on the squares

forsuffixes i := 2, 4, 5, 8, 10, 11, 14, 16, 18, 21, 23, 25, 27, 29, 30, 33, 35,
                 36, 39, 41, 42, 45, 47, 48, 52, 54, 55, 58, 60, 61: 
              
   c[70 + i] := c[i] shifted (0, 1);
if false: 
   for j := 0 upto 3:
      dotlabel.lft(j, p[i][j]);
   endfor;
fi;
endfor;

%% ***** (5) Inner tabs on rpv[2]

t1 := identity rotated_around (c59, c129) 60;
shift t1 by (p[2][0] - p[59][0]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

%% ***** (5) Inner tabs on rpv[2]

t1 := identity rotated_around (c[2], c[72]) 90;

if true: 
%if false: 
for i := 0 upto 3:

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

    if (i == 0) or (i == 2):
       k := i;
       m := i + 1;

       if k > 3:
          k -= 4;
       fi;

       if m > 3:
          m -= 4;
       fi;

       draw q0 -- q5 -- q6 -- q2;

       draw q7 -- q8 with_pen tiny_pen;
       draw q9 -- q10 with_pen tiny_pen;

       draw q0 -- q2 dashed evenly;

       draw p[2][k] -- q2;
       draw p[2][m] -- q0;
        
       for j = 1 upto 5:
          drawdot q[10 + j] with_pen dot_pen;
          drawdot q[15 + j] with_pen dot_pen;
          draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
       endfor;
    fi;

endfor;
fi;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
  *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;



%% ***** (5) Inner tabs on the horizontally- and vertically-orientated squares

j := 2;

forsuffixes i := 8, 14, 21, 27, 33, 39, 45, 52, 58:

    t0 := identity shifted by (c[i] - c[j]);
    
    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

      draw q0 -- q5 -- q6 -- q2;

      draw q7 -- q8 with_pen tiny_pen;
      draw q9 -- q10 with_pen tiny_pen;

      draw q0 -- q2 dashed evenly;

      draw p[i][0] -- q2;
      draw p[i][1] -- q0;
       
      for j = 1 upto 5:
         drawdot q[10 + j] with_pen dot_pen;
         drawdot q[15 + j] with_pen dot_pen;
         draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
      endfor;


    t1 := identity rotated_around (c[i], c[70 + i]) 180;

    q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
       *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
       *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

      draw q0 -- q5 -- q6 -- q2;

      draw q7 -- q8 with_pen tiny_pen;
      draw q9 -- q10 with_pen tiny_pen;

      draw q0 -- q2 dashed evenly;

      draw p[i][2] -- q2;
      draw p[i][3] -- q0;
       
      for j = 1 upto 5:
         drawdot q[10 + j] with_pen dot_pen;
         drawdot q[15 + j] with_pen dot_pen;
         draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
      endfor;

      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;
 
   j := i;

endfor;

%% ***** (5) Inner tabs on rpv[4] and the diagonally-orientated squares below it

t0 := identity shifted by (p[4][0] - p[58][0]);

p[4][10] := p[4][0] shifted (0, 1);

rotate_around t0 (p[4][0], p[4][10]) -60;

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;
 


forsuffixes i := 4, 16, 29, 41, 54:

   if i > 4:
      t0 := identity shifted by (c[i] - c[j]);
      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;
   fi;

   t1 := identity rotated_around (c[i], c[i + 70]) 90;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][0] -- q2;
   draw p[i][1] -- q0;
 
   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][2] -- q2;
   draw p[i][3] -- q0;
 
   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][3] -- q2;
   draw p[i][0] -- q0;
 
   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   j := i;

endfor;


%% ***** (5) Inner tabs on rpv[5] and the similarly
%% ***** (5) diagonally-orientated squares below it

t0 := identity shifted by (p[5][0] - p[54][0]);

p[5][10] := p[5][0] shifted (0, 1);

rotate_around t0 (p[5][0], p[5][10]) 30;

rotate_around t0 (c[5], c[75]) 90; 

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;
 

forsuffixes i := 5, 18, 30, 42, 55:

   if i > 5:
      t0 := identity shifted by (c[i] - c[k]);
      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;
   fi;

   t1 := identity rotated_around (c[i], c[i + 70]) 180;
     
   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][1] -- q2;
   draw p[i][2] -- q0;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][3] -- q2;
   draw p[i][0] -- q0;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   k := i;

endfor;

%% ***** (5) Inner tabs on rpv[11] and the similarly
%% ***** (5) diagonally-orientated squares below it

t0 := identity rotated_around (c[57], c[127]) -120;

shift t0 by (c[11] - c[61]);



q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

 
forsuffixes i := 11, 25, 36, 48, 61:

   if i > 11:
      t0 := identity shifted by (c[i] - c[k]);

      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

   fi;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][3] -- q2; % with_color blue;
   draw p[i][0] -- q0; % with_color blue;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   t1 := identity rotated_around (c[i], c[i + 70]) 180;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][1] -- q2; % with_color blue;
   draw p[i][2] -- q0; % with_color blue;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;

   k := i;

endfor;

%% ***** (5) Inner tabs on rpv[10] and the diagonally-orientated squares below it

t0 := identity rotated_around (p[55][3], p[58][3]) 180;

shift t0 by (c[59] - c[57]);
shift t0 by (c[10] - c[60]);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

 
forsuffixes i := 10, 23, 35, 47, 60:

   if i > 10:
      t0 := identity shifted by (c[i] - c[k]);

      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

   fi;

   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][0] -- q2;
   draw p[i][3] -- q0;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   t1 := identity rotated_around (c[i], c[i + 70]) 180;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


   draw q0 -- q5 -- q6 -- q2;

   draw q7 -- q8 with_pen tiny_pen;
   draw q9 -- q10 with_pen tiny_pen;

   draw q0 -- q2 dashed evenly;

   draw p[i][2] -- q2;
   draw p[i][1] -- q0;

   for j = 1 upto 5:
      drawdot q[10 + j] with_pen dot_pen;
      drawdot q[15 + j] with_pen dot_pen;
      draw q[20 + j] -- q[25 + j] with_pen tiny_pen;
   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t1;


   k := i;

endfor;

%% ***** (5)

%% **** (4) End of Figure 1

%rotate current_picture (0, 180);

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Figure 2 -- Double tabs

beginfig(2); 

%% **** (4) Set up first double tab

if false: 
   for i := 0 upto 3:
      dotlabel.top(i, p[60][i]);
   endfor;
fi; 

t0 := identity rotated_around (c[59], c[129]) -120;

shift t0 (-10, 0, 35);

q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
   *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
   *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
   *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 *= t0;

if false: 
   dotlabel.ulft("$q_{0}$", q0);
   dotlabel.urt("$q_{2}$", q2);
   dotlabel.top("$q_{5}$", q5);
   dotlabel.top("$q_{6}$", q6);
fi; 


q140 := q0 shifted -.5;
%dotlabel.lft("$q_{140}$",  q140);

q141 := q2 shifted .5;
%dotlabel.lft("$q_{141}$",  q141);

for i := 0 upto 30:
   q[i + 100] := q[i] rotated_around (q0, q2) 180;
endfor;

q140 := q0 shifted -.5;
q141 := q2 shifted .5;

%% **** (4) Draw double tabs

t0 := identity shifted by (q141 - q0);

t1 := identity shifted (0, 0, -1.25);
shift t1 by 4*(q0 - q141);

boolean b;

for i := 0 upto 31:

   for k := 0 upto 3:

      q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
         *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
         *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
         *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 
         *= q100 *= q102 *= q105 *= q106 *= q107 *= q108 *= q109 
         *= q110 *= q111 
         *= q112 *= q113 *= q114 *= q115 *= q116 *= q117
         *= q118 *= q119 *= q120 *= q121 *= q122 *= q123
         *= q124 *= q125 *= q126 *= q127 *= q128 *= q129 *= q130 
         *= q140 *= q141 *= t0;

      if (i >= 20) and (i < 26):
         b := false;
      else:
         b := true;
      fi;

      if b:
      	 draw q0 -- q140 dashed evenly;
      	 draw q0 -- q5 -- q6 -- q2;
      	 draw q100 -- q105 -- q106 -- q102;

      	 draw q2 -- q141 dashed evenly;

      	 draw q7 -- q8 with_pen tiny_pen;
      	 draw q9 -- q10 with_pen tiny_pen;
      	 draw q107 -- q108 with_pen tiny_pen;
      	 draw q109 -- q110 with_pen tiny_pen;

      	 draw q0 -- q2;

      	 for j = 1 upto 5:
      	    drawdot q[10 + j] with_pen dot_pen;
      	    drawdot q[15 + j] with_pen dot_pen;
      	    draw q[20 + j] -- q[25 + j] with_pen tiny_pen;

      	    drawdot q[100 + 10 + j] with_pen dot_pen;
      	    drawdot q[100 + 15 + j] with_pen dot_pen;
      	    draw q[100 + 20 + j] -- q[100 + 25 + j] with_pen tiny_pen;
      	 endfor;
       fi;

   endfor;

   q0 *= q2 *= q5 *= q6 *= q7 *= q8 *= q9 *= q10 *= q11 
      *= q12 *= q13 *= q14 *= q15 *= q16 *= q17
      *= q18 *= q19 *= q20 *= q21 *= q22 *= q23
      *= q24 *= q25 *= q26 *= q27 *= q28 *= q29 *= q30 
      *= q100 *= q102 *= q105 *= q106 *= q107 *= q108 *= q109 
      *= q110 *= q111 
      *= q112 *= q113 *= q114 *= q115 *= q116 *= q117
      *= q118 *= q119 *= q120 *= q121 *= q122 *= q123
      *= q124 *= q125 *= q126 *= q127 *= q128 *= q129 *= q130 
      *= q140 *= q141 *= t1;

endfor;

%% ***** (5)

%% **** (4) End of Figure 2

endfig with_projection parallel_x_z no_sort; 

fi;  %% Figures 1 and 2 commented-out (or in)

%% *** (3) Figure 3 --- Polygons for watercolor paper cut-outs --- Decagons and Hexagons

beginfig(3); 

%% **** (4) Decagons

t0 := identity shifted 7;
t1 := identity shifted (-28, 0, -7);

n := 1;

for k := 0 upto 2:

   for i := 1 upto 4:

      draw rpv0;

      label(n, c0);
   
      if n > 12:
         label("(Extra)", c0 shifted (0, 0, -.5));
      fi;

      n += 1;

      if false: 
      	 dotlabel.rt(0, p[0][0]);
      	 dotlabel.top(1, p[0][1]);
      	 dotlabel.top(2, p[0][2]);
      	 dotlabel.top(3, p[0][3]);
      	 dotlabel.lft(4, p[0][4]);
      	 dotlabel.lft(5, p[0][5]);
      	 dotlabel.lft(6, p[0][6]);
      	 dotlabel.bot(7, p[0][7]);
      	 dotlabel.rt(8, p[0][8]);
      	 dotlabel.rt(9, p[0][9]);
      fi; 
      
      for j := 0 upto 9:
         m := j + 1;

         if m > 9:
            m -= 10;
         fi;

         draw mediate(p[0][j], p[0][m], 2) -- mediate(p[0][m], p[0][j], 2) dashed evenly;

      endfor;

      for j := 0 upto 9:
         p[0][j] *= t0;        
      endfor;

      rpv0 *= c0 *= t0;
        
   endfor;

   for j := 0 upto 9:
      p[0][j] *= t1;        
   endfor;

   rpv0 *= c0 *= t1;

endfor;

%% **** (4) Hexagons (20)

t0 := identity shifted (-5cm, 0, -19.5cm);

rpv1 *= c1 *= t0;
for j := 0 upto 5:
   p[1][j] *= t0;
endfor;


t0 := identity shifted 4.5;

t1 := identity shifted ((-4.5 * 6), 0, -4.5);

n := 1;

for k := 0 upto 3:

   for i := 1 upto 6:

      draw rpv1;
      label(n, c1);

      if n > 20:
         label("(Extra)", c1 shifted (0, 0, -.5)); 
      fi;

      n += 1;

      for j := 0 upto 5:
         m := j + 1; 
         if m > 5:
            m -= 6;
         fi;

         draw mediate(p[1][j], p[1][m], 1.5) -- mediate(p[1][m], p[1][j], 1.5) dashed evenly;

      endfor;

      rpv1 *= c1 *= t0;
      for j := 0 upto 5:
         p[1][j] *= t0;
      endfor;

   endfor;

   rpv1 *= c1 *= t1;
   for j := 0 upto 5:
      p[1][j] *= t1;
   endfor;

endfor;


%% **** (4) End of Figure 3

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Figure 4 --- Polygons for watercolor paper cut-outs --- Squares

beginfig(4); 

if false: 
   dotlabel.top(0, p[2][0]);
   dotlabel.top(1, p[2][1]);
   dotlabel.bot(2, p[2][2]);
   dotlabel.bot(3, p[2][3]);
fi;

q0 := p[2][1] shifted -.5;
q1 := p[2][0] shifted .5;
q2 := p[2][2] shifted -.5;
q3 := p[2][3] shifted .5;
  
q4 := p[2][1] shifted (0, 0, .5);
q5 := p[2][0] shifted (0, 0, .5);
q6 := p[2][2] shifted (0, 0, -.5);
q7 := p[2][3] shifted (0, 0, -.5);

t0 := identity shifted by (q1 - p[2][1]);

t1 := identity shifted by -13 * (q1 - p[2][1]);
shift t1 (0, 0, -2);

n := 1;

for k := 0 upto 2:

   for i := 1 upto 13:

      draw rpv2;
      label(n, c2);

      if n > 30:
         label("(Extra)", c2 shifted (0, 0, -.5));
      fi;

      n += 1;

      if i == 0:   
         draw q0 -- p[2][1] dashed evenly;
         draw q2 -- p[2][2] dashed evenly;
      fi; 

      draw q1 -- p[2][0] dashed evenly;
      draw q3 -- p[2][3] dashed evenly;

      draw q4 -- p[2][1] dashed evenly;
      draw q5 -- p[2][0] dashed evenly;
      draw q6 -- p[2][2] dashed evenly;
      draw q7 -- p[2][3] dashed evenly;

      rpv2 *= c2 *= q0 *= q1 *= q2 *= q3 *= q4 *= q5 *= q6 *= q7 *= t0;

      for j := 0 upto 3:
         p[2][j] *= t0;
      endfor;

   endfor;   

   rpv2 *= c2 *= q0 *= q1 *= q2 *= q3 *= q4 *= q5 *= q6 *= q7 *= t1;

   for j := 0 upto 3:
      p[2][j] *= t1;
   endfor;

endfor;

%% **** (4) End of Figure 4

endfig with_projection parallel_x_z no_sort; 

%% *** (3)

%% ** (2) Archimedean Spiral.  
%%        This is easy.
%%        LDF 2009.01.15.

pickup pencircle scaled (.5mm, .5mm, .5mm);

beginfig(1);

% r = a * phi, 
% a = ny / omega > 0

point p[];
path q;

ny := 1;
omega := 200;

a := ny / omega;

message "a:"; 
show a;

q += origin;
q += ..;

phi := 0;

string s;

for i := 0 upto 840:
   phi += 2.5;
   message "phi:"; 
   show phi;
   r := a * phi;
   message "r:"; 
   show r;
   p[i] := (r, 0) rotated (0, phi);
   shift p[i] (0, i/200);
%   s := "$p_{" & decimal i & "}$";
%   dotlabel.bot(s, p[i]);
   message "point:";
   show p[i];
   q += p[i];
   q += ..;
endfor;

draw q;


endfig with_projection parallel_x_z;

beginfig(2);
draw q; 
endfig with_projection parallel_x_y;

end; 




%% ** (2) Create a filled box within a frame.
%%        I used this for testing changes to the `conveps'
%%        utility.
%%        LDF 2009.01.14.

path q[];

beginfig(1);

q0 := origin -- (1cm, 0) -- (1cm, 0, 2cm) -- (0, 0, 2cm) -- cycle;

shift q0 (-.5cm, 0, -.5cm);

fill q0 with_color blue;

q1 := origin -- (2cm, 0) -- (2cm, 0, 3cm) -- (0, 0, 3cm) -- cycle;

shift q1 (-1cm, 0, -1cm);

draw q1;

endfig with_projection parallel_x_z; 

end;


%% ** (2)  Trochoid Pattern 1

m := 10;
n := 10;

w := 6.4cm;
h := 4.8cm;

w *= 4;
h *= 4;

w /= 1.1375;
h /= 1.1375;

pen_width := .5mm; 

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% *** (3)

circle c[];                                                   
rectangle r[];                                                        
point p[];
transform t[];
path q[][];

pen dot_pen;

dot_pen := pencircle scaled (1mm, 1mm, 1mm);

string s;

boolean inner;
boolean outer;
boolean perimeter;

perimeter := false;  % true
inner     := true; % false
outer     := false; % true

pickup pencircle scaled (.5mm, .5mm, .5mm);

r0 := unit_rectangle scaled (12, 0, 12) shifted origin;

%% *** (3) The circle.

radius := 2.5;

set c0 with_diameter 2*radius with_point_count 32;

%% *** (3) Get points

for i := 0 upto 3:
   p[i] := get_point (i) r0;
endfor;

p5 := get_center c0;

for i := 6 upto 9:
   p[i] := get_point ((i - 6) * 8) c0;
endfor;

p10 := (p5 - p8) shifted by p0;

t0 := identity shifted by (p10 - p9);

c0 *= p5 *= p6 *= p7 *= p8 *= p9 *= t0;

p15 := mediate(p5, p9, .75);

for j = 6 upto 9:
   q[iter_ctr][j] += ..;
   q[iter_ctr][j] += p[j];
endfor;

q[iter_ctr]15 += ..;
q[iter_ctr]15 += p15;

numeric ang[];

PI := 3.141592653589793;

p11 := p5 shifted (0, 1);

p12 := (p0 - p8) shifted by p3;
p13 := (p5 - p8) shifted by p12;
p14 := p13 - p5;

%message "p14:"; 
%show p14;

distance := zpart p14;
message "distance:"; 
show distance;

circumference := 2 * PI * radius;
message "circumference:"; 
show circumference;

ang0 := (360 * distance) / circumference;

message "ang0:"; 
show ang0;

step_value := 256;  %% The number of iterations for each side

total_iterations := 4 * 256;  %% Total iterations per cycle

figure_divisor := 256;  %% Set to 16 for 512 images

numeric curr_value;
numeric curr_figure;

iter_ctr := 0;

color_vector cv;

boolean do_colors;

do_colors := true; % false

if do_colors:
   cv += blue;
   cv += red;
   cv += green;
   cv += cyan;
   cv += magenta;
   cv += yellow;
   cv += violet;
   cv += orange;
else:
   cv += black;
   cv += black;
   cv += black;
   cv += black;
   cv += black;
   cv += black;
   cv += black;
   cv += black;
fi;

%% *** (3) Figure 0

beginfig(0); 

   draw frame;

%% **** (4)  The rectangle

   draw r0;

%    dotlabel.llft("$p_0$", p0);   
%    dotlabel.lrt("$p_1$", p1);   
%    dotlabel.urt("$p_2$", p2);   
%    dotlabel.ulft("$p_3$", p3);   

   %dotlabel.lrt("$p_{10}$", p10);   

   drawdot p5 with_pen dot_pen;

   %label("$p_5$", p5);

   draw c0;

   if perimeter:
      draw p5 -- p9;
      drawdot p9 with_pen dot_pen with_color cv[n];
%      dotlabel.rt("$p_{9}$", p9);   
   fi;

   if inner:
      draw p5 -- p15;
      drawdot p15 with_pen dot_pen with_color cv[n];
%      dotlabel.rt("$p_{15}$", p15);   
   fi;

   %if outer:
   %   draw p5 -- p;
   %fi;

   % dotlabel.top("$p_7$", p7);   
   % dotlabel.lft("$p_8$", p8);   
   % dotlabel.llft("$p_9$", p9);   


endfig with_projection parallel_x_z; 

%% *** (3)  Roll the circle.

curr_value := 1;
curr_figure := 1;

%% *** (3) Outer loop.  One iteration per complete cycle around the square.

for iter_ctr := 0 upto 7:

%% **** (4) Inner loop.  One iteration for each step in paths.
%%          The number of iterations is `total_iterations'.

   for i = ((iter_ctr * 4 * step_value) + 1) 
           upto ((iter_ctr * 4 * step_value) + (4 * step_value)):

      t1 := (identity rotated_around (p5, p11) ang0/step_value);

      if i <= ((iter_ctr * 4 * step_value) + step_value):            %% left side
         shift t1 (0, 0, distance/step_value);
      elseif i <= ((iter_ctr * 4 * step_value) + (2 * step_value)):  %% top
         shift t1 (distance/step_value, 0, 0);
      elseif i <= ((iter_ctr * 4 * step_value) + (3 * step_value)):  %% right side
         shift t1 (0, 0, -distance/step_value);
      elseif i <= ((iter_ctr * 4 * step_value) + (4 * step_value)):  %% bottom
         shift t1 (-distance/step_value, 0, 0);
      fi;

      c0 *= p5 *= p6 *= p7 *= p8 *= p9 *= p11 *= p15 *= t1;

%    message "ang0/step_value:"; 
%    show ang0/step_value;

%% ***** (5) Add point to the paths.

     for j = 6 upto 9:
        q[iter_ctr][j] += ..;
        q[iter_ctr][j] += p[j];
%        draw q[iter_ctr][j];
     endfor;

     q[iter_ctr]15 += ..;
     q[iter_ctr]15 += p15;

     q[iter_ctr]15 += ..;
     q[iter_ctr]15 += p15;

%% ***** (5)  Test whether to output a figure

     k := curr_value / figure_divisor;

     if k == floor k:

        s := "Figure " & decimal curr_figure;

        message s;

%% ***** (5) Output a figure

         beginfig(curr_figure); 

            draw frame;
            draw r0;

            draw c0;

            drawdot p5 with_pen dot_pen;

            %label("$p_5$", p5);

%             dotlabel.rt("$p_6$", p6);   
%             dotlabel.top("$p_7$", p7);   
%             dotlabel.lft("$p_8$", p8);   
%             dotlabel.llft("$p_9$", p9);   
%             dotlabel.lft("$p_{12}$", p12);
%             dotlabel.lft("$p_{13}$", p13);

             if perimeter:
                %dotlabel.rt("$p_{9}$", p9);   
                draw p5 -- p9;

                for n = 0 upto iter_ctr:
                   draw q[n]9 with_color cv[n];
                   drawdot p9 with_pen dot_pen with_color cv[n];
                endfor;
             fi;

            if inner:
               %dotlabel.rt("$p_{15}$", p15);   
               draw p5 -- p15;
               for n = 0 upto iter_ctr:
                  draw q[n]15 with_color cv[n];
                  drawdot p15 with_pen dot_pen with_color cv[n];
               endfor;
            fi;

%             if outer:
%             fi
            
         endfig with_projection parallel_x_z; 

         curr_figure += 1;

%% ***** (5)

      fi;  %% Output a figure

%% ***** (5)

      curr_value += 1;

   endfor;  %% End of inner loop

%% **** (4)

endfor;  %% End of outer loop

%% *** (3)

message "next curr_figure:"; 
show curr_figure;

message "next curr_value:"; 
show curr_value;

% pause;   
 end;

%% ** (2) Great Stellated Dodecahedron

%% The Great Stellated Dodecahedron can be constructed using
%% triangular pyramids attached to an icosahedron.

point c[];  %% centers
point p[][];
reg_polygon_vector rpv[];

transform t[];

verbatim_metapost "verbatimtex \font\largebf=cmbx12 etex;";

pen dot_pen;

dot_pen := pencircle scaled (1mm, 1mm);

%% ** (2) Figure 1

beginfig(1);

%% Diameter == 4 --> Edge length == 6.

%% *** (3) The net

rpv := get_net icosahedron with_diameter 4;  

for i = 0 upto 19:

   rotate rpv[i] (0, 90);
  
   c[i] := get_center rpv[i];

   p[i]0 := get_point 0 rpv[i];
   p[i]1 := get_point 1 rpv[i];
   p[i]2 := get_point 2 rpv[i];

   label(i, c[i]);
 
endfor;

% draw rpv with_color red dashed evenly 
%    with_pen pencircle scaled (.375mm, .375mm, .375mm);

pickup pencircle scaled (.5mm, .5mm, .5mm);

for i = 0 step 4 until 16:
%    draw p[i][0] -- p[i][1];
    draw p[i][0] -- p[i][2];
    draw p[i][1] -- p[i][2] dashed evenly;
endfor;

for i = 3 step 4 until 19:
%    draw p[i][0] -- p[i][1];
    draw p[i][0] -- p[i][2];
    draw p[i][1] -- p[i][2] dashed evenly;
endfor;


%draw p[1][0] -- p[1][1];
draw p[18][0] -- p[18][1];

for i = 1 step 4 until 18:
   draw p[i][0] -- p[i][2] dashed evenly;
endfor;

for i = 2 step 4 until 17:
   draw p[i][0] -- p[i][1] dashed evenly;
endfor;

%% *** (3) The tabs

point tab[];

%% **** (4)

tab0 := mediate(p[0][0], p[0][1], .2);
tab1 := mediate(p[0][0], p[0][1], .8);

% dotlabel.llft("$t_0$", tab0);
% dotlabel.llft("$t_1$", tab1);

tab3 := unit_vector(tab0 - tab1);

tab3 /= 2;

shift tab3 by tab0;

tab4 := tab0 shifted (0, 1);

rotate_around tab3 (tab0, tab4) 110;

%dotlabel.top("$t_3$", tab3);

tab5 := tab3 rotated_around (c[0], p[0][2]) 180;

%dotlabel.top("$t_5$", tab5);

draw  tab0 -- tab3 -- tab5 -- tab1;
draw tab0 -- tab1 dashed evenly;
draw p[0][0] -- tab0;
draw p[0][1] -- tab1;

tab6 := p[4][0] - p[0][0];

tab7 := mediate(tab0, tab1);
tab8 := mediate(tab3, tab5);

%draw tab7 -- tab8;

%dotlabel.llft("$t_7$", tab7);
%dotlabel.urt("$t_8$", tab8);

tab9 := mediate(tab7, tab8);

%dotlabel.rt("$t_9$", tab9);

tab10 := tab9 shifted (0, 1);

tab11 := tab7 rotated_around(tab9, tab10) 90;

%dotlabel.rt("$t_{11}$", tab11);

bool_point bp;

bp := (tab9 -- tab11) intersection_point (tab1 -- tab5);

message "bp:"; 
show bp;

tab12 := bp;

%dotlabel.ulft("$t_{12}$", tab12);

tab13 := tab12 rotated_around (tab9, tab10) 180;

%dotlabel.rt("$t_{13}$", tab13);


draw tab12 -- tab13 dashed evenly;

for j := 1 upto 5:
   tab[j + 13] := mediate(tab12, tab13, j/6);
   drawdot tab[j + 13] with_pen dot_pen;
endfor;%% *** (3)

%% *** (3) Tab traces on triangles

tab20 := tab0;
tab21 := tab1;
tab23 := tab3;
tab25 := tab5;
tab32 := tab12;
tab33 := tab13;

t4 := identity rotated_around (c0, p[0][0]) 180;

rotate_around t4 (p[0][0], p[0][2]) 180;

tab20 *= tab21 *= tab23 *= tab25 *= tab32 *= tab33 *= t4;

% dotlabel.bot("$t_{20}$", tab20);
% dotlabel.bot("$t_{21}$", tab21);
% dotlabel.lft("$t_{23}$", tab23);
% dotlabel.ulft("$t_{25}$", tab25);
% dotlabel.lft("$t_{32}$", tab32);
% dotlabel.rt("$t_{33}$", tab33);

draw tab21 -- tab25 -- tab23 -- tab20 dashed evenly;
draw tab32 -- tab33 dashed evenly;

for j = 1 upto 5:
   tab[33 + j] := mediate(tab32, tab33, j/6);
   drawdot tab[33 + j] with_pen dot_pen;
endfor;

%% *** (3)


t0 := identity shifted by tab6;


for i = 4 step 4 until 16:
   tab0 *= tab1 *= tab3 *= tab5 *= tab12 *= tab13 *= t0;
   tab20 *= tab21 *= tab23 *= tab25 *= tab32 *= tab33 *= t0;
   draw  tab0 -- tab3 -- tab5 -- tab1;
   draw tab0 -- tab1 dashed evenly;
   draw p[i][0] -- tab0;
   draw p[i][1] -- tab1;

   draw tab12 -- tab13 dashed evenly;

   for j := 1 upto 5:
      tab[j + 13] := mediate(tab12, tab13, j/6);
      drawdot tab[j + 13] with_pen dot_pen;
   endfor;

   draw tab21 -- tab25 -- tab23 -- tab20 dashed evenly;
   draw tab32 -- tab33 dashed evenly;

   for j = 1 upto 5:
      tab[33 + j] := mediate(tab32, tab33, j/6);
      drawdot tab[33 + j] with_pen dot_pen;
   endfor;

endfor;

t1 := identity shifted by (p[19][1] - p[16][0]);
rotate_around t1 (p[19][0], p[19][1]) 180;

tab0 *= tab1 *= tab3 *= tab5 *= tab12 *= tab13 *= t1;
draw  tab0 -- tab3 -- tab5 -- tab1;
draw tab0 -- tab1 dashed evenly;

draw tab12 -- tab13 dashed evenly;

for j := 1 upto 5:
   tab[j + 13] := mediate(tab12, tab13, j/6);
   drawdot tab[j + 13] with_pen dot_pen;
endfor;

% dotlabel.top("$t_0$", tab0);
% dotlabel.top("$t_1$", tab1);
% dotlabel.top("$t_3$", tab3);
% dotlabel.top("$t_5$", tab5);

draw p[19][0] -- tab1;
draw p[19][1] -- tab0;

i := 3;

% label.lft(0, p[i]0) with_text_color red;
% label.bot(1, p[i]1) with_text_color red;
% label.lft(2, p[i]2) with_text_color red;

i := 1;

% label.lft(0, p[i]0);
% label.bot(1, p[i]1);
% label.lft(2, p[i]2);


tab20 *= tab21 *= tab23 *= tab25 *= tab32 *= tab33 *= t1;

c190 := c19 shifted (0, 1);

t5 := identity rotated_around (c19, c190) 120;

tab20 *= tab21 *= tab23 *= tab25 *= tab32 *= tab33 *= t5;




draw tab21 -- tab25 -- tab23 -- tab20 dashed evenly;
draw tab32 -- tab33 dashed evenly;

for j = 1 upto 5:
   tab[33 + j] := mediate(tab32, tab33, j/6);
   drawdot tab[33 + j] with_pen dot_pen;
endfor;

%% *** (3)

t2 := identity shifted by (p[15][0] - p[19][0]);

for i = 15 step -4 until 3:
    tab0 *= tab1 *= tab3 *= tab5 *= tab12 *= tab13 *= t2;
    tab20 *= tab21 *= tab23 *= tab25 *= tab32 *= tab33 *= t2;

    draw  tab0 -- tab3 -- tab5 -- tab1;
    draw tab0 -- tab1 dashed evenly;
    draw p[i][1] -- tab0;
    draw p[i][0] -- tab1;

    draw tab12 -- tab13 dashed evenly;

    for j := 1 upto 5:
       tab[j + 13] := mediate(tab12, tab13, j/6);
       drawdot tab[j + 13] with_pen dot_pen;
    endfor;

   draw tab21 -- tab25 -- tab23 -- tab20 dashed evenly;
   draw tab32 -- tab33 dashed evenly;

   for j = 1 upto 5:
      tab[33 + j] := mediate(tab32, tab33, j/6);
      drawdot tab[33 + j] with_pen dot_pen;
   endfor;


endfor;


%% **** (4)

t3 := identity shifted by (p[1][1] - p[3][1]);
tab0 *= tab1 *= tab3 *= tab5 *= tab12 *= tab13 *= t3;
draw  tab0 -- tab3 -- tab5 -- tab1;
draw tab0 -- tab1 dashed evenly;

draw tab12 -- tab13 dashed evenly;

for j := 1 upto 5:
   tab[j + 13] := mediate(tab12, tab13, j/6);
   drawdot tab[j + 13] with_pen dot_pen;
endfor;

%draw p[i][1] -- tab0;
%draw p[i][0] -- tab1;

% dotlabel.top("$t_0$", tab0);
% dotlabel.top("$t_1$", tab1);
% dotlabel.top("$t_3$", tab3);
% dotlabel.top("$t_5$", tab5);

draw p[1][0] -- tab1;
draw p[1][1] -- tab0;


%% *** (3) The last tab trace

% dotlabel.top("$t_0$", tab0);
% dotlabel.top("$t_1$", tab1);
% dotlabel.llft("$t_3$", tab3);
% dotlabel.llft("$t_5$", tab5);
% dotlabel.ulft("$t_{12}$", tab12);
% dotlabel.rt("$t_{13}$", tab13);

t6 := identity shifted by (p[18][0] - p[1][1]);

tab0 *= tab1 *= tab3 *= tab5 *= tab12 *= tab13 *= t6;

% dotlabel.top("$t_0$", tab0);
% dotlabel.top("$t_1$", tab1);
% dotlabel.llft("$t_3$", tab3);
% dotlabel.llft("$t_5$", tab5);
% dotlabel.ulft("$t_{12}$", tab12);
% dotlabel.rt("$t_{13}$", tab13);

% label.rt(0, p[1][0]);
% label.llft(1, p[1][1]);
% label.bot(2, p[1][2]);

% label.lft(0, p[18]0);
% label.bot(1, p[18]1);
% label.lft(2, p[18]2);

draw tab1 -- tab5 -- tab3 -- tab0 dashed evenly;
draw tab12 -- tab13 dashed evenly;

for j = 1 upto 5:
   tab[13 + j] := mediate(tab12, tab13, j/6);
   drawdot tab[13 + j] with_pen dot_pen;
endfor;


%% *** (3)

%label("{\largebf Icosahedron}", p[1][1] shifted (-2, 0, -2));


endfig with_projection parallel_x_z; 


%% ** (2) Figure 2 --- Pyramids

point q[];

beginfig(2);

edge := magnitude (p[0][0] - p[0][2]); 

message "edge:"; 
show edge;

q0 := origin;

q1 := (edge, 0);

%dotlabel.lft("$q_0$", q0);
%dotlabel.rt("$q_1$", q1);

phi := (1 + sqrt 5) / 2;

message "phi:"; 
show phi;

side := phi * edge;

message "side:"; 
show side;

a := arccosd (.5edge / side);

message "a"; 
show a;

q2 := (side, 0) rotated (0, a);

%dotlabel.top("$q_2$", q2);

draw q0 -- q1;
draw q0 -- q2 dashed evenly;
draw q1 -- q2 dashed evenly;

message "q1"; 
show q1;

message "q2"; 
show q2;

q3 := q0 rotated_around (q1, q2) 180;

%dotlabel.top("$q_3$", q3);

draw q1 -- q3 -- q2;

q4 := q1 rotated_around (q0, q2) 180;

%dotlabel.top("$q_4$", q4);

draw q0 -- q4 -- q2;

q5 := q1 rotated (0, -60);

%dotlabel.bot("$q_5$", q5);

draw q0 -- q5 -- q1;

%% *** (3)

%% START HERE:  Working on tabs and tab traces.  LDF 2008.12.30.  

triangle w[];

set w0 with_points (q0, q4, q2);
set w1 with_points (q0, q1, q2);
set w2 with_points (q1, q3, q2);
set w3 with_points (q0, q5, q1);

q6  := get_center w0;
q7  := get_center w1;
q8  := get_center w2;
q9 := get_center w3;

% label(0, q6);
% label(1, q7);
% label(2, q8);
% label(3, q9);

%% *** (3)

q10 := mediate(q0, q5, 1/9);

%dotlabel.lft("$q_{10}$", q10);

q11 := mediate(q5, q0, 1/9);

%dotlabel.rt("$q_{11}$", q11);

q12 := (unit_vector (q5 - q11) * .5) shifted q11;

q13 := q11 shifted (0, 1);

rotate_around q12 (q11, q13) -120;

%dotlabel.lft("$q_{12}$", q12);

q14 := q12 shifted by (q10 - q11);

q15 := q10 shifted (0, 1);

rotate_around q14 (q10, q15) 60;

%dotlabel.lft("$q_{14}$", q14);

draw q11 -- q12 -- q14 -- q10;

%% *** (3)

q16 := mediate(q10, q11);

%dotlabel.rt("$q_{16}$", q16);

q17 := mediate(q14, q12);

%dotlabel.lft("$q_{17}$", q17);

q18 := mediate(q16, q17);

%dotlabel.lrt("$q_{18}$", q18);

q19 := q18 shifted (0, 1);

q20 := q16 rotated_around (q18, q19) 90;

%dotlabel.urt("$q_{20}$", q20);

bp := (q18 -- q20) intersection_point (q10 -- q14);

q21 := bp;

%dotlabel.lft("$q_{21}$", q21);

bp := (q18 -- q20) intersection_point (q11 -- q12);

q22 := bp;

%dotlabel.bot("$q_{22}$", q22);

draw q21 -- q22 dashed evenly;

%% *** (3)

for i = 1 upto 5:
   q[22 + i] := mediate(q22, q21, i/6);
   drawdot q[22 + i]  with_pen dot_pen;
endfor;

q28 := mediate(q0, q1);

%dotlabel.top("$q_{28}$", q28);

t0 := identity rotated_around (q28, q5) 180;

q10 *= q11 *= q12 *= q14 *= q21 *= q22 *= q23 *= q24 *= q25 *= q26 *= q27 *= t0;

% dotlabel.top("$q_{10}$", q10);
% dotlabel.top("$q_{11}$", q11);
% dotlabel.top("$q_{12}$", q12);
% dotlabel.top("$q_{14}$", q14);

draw q11 -- q12 -- q14 -- q10;
draw q21 -- q22 dashed evenly;

for i = 1 upto 5:
   drawdot q[22 + i]  with_pen dot_pen;
endfor;

%% *** (3)

ang := (q4 - q0) angle (q0 - q5);

% message "ang:"; 
% show ang;

q29 := q1 shifted (0, 1);

t1 := (identity shifted by (q1 - q10)) rotated_around (q1, q29) 180 - ang;

q10 *= q11 *= q12 *= q14 *= q21 *= q22 *= q23 *= q24 *= q25 *= q26 *= q27 *= t1;

q30 := (q3 - q11) * .5;

t2 := identity shifted by q30;

q10 *= q11 *= q12 *= q14 *= q21 *= q22 *= q23 *= q24 *= q25 *= q26 *= q27 *= t2;

% dotlabel.top("$q_{10}$", q10);
% dotlabel.top("$q_{11}$", q11);
% dotlabel.top("$q_{12}$", q12);
% dotlabel.top("$q_{14}$", q14);

draw q11 -- q12 -- q14 -- q10 dashed evenly;
draw q21 -- q22 dashed evenly;

for i = 1 upto 5:
   drawdot q[22 + i]  with_pen dot_pen;
endfor;

%% *** (3)

t3 := identity rotated_around (q2, q28) 180;


q10 *= q11 *= q12 *= q14 *= q21 *= q22 *= q23 *= q24 *= q25 *= q26 *= q27 *= t3;

% dotlabel.top("$q_{10}$", q10);
% dotlabel.top("$q_{11}$", q11);
% dotlabel.top("$q_{12}$", q12);
% dotlabel.top("$q_{14}$", q14);

draw q11 -- q12 -- q14 -- q10 dashed evenly;
draw q21 -- q22 dashed evenly;

for i = 1 upto 5:
   drawdot q[22 + i]  with_pen dot_pen;
endfor;

%% *** (3)

q40 := mediate(q3, q2, 1/8);
%dotlabel.lft("$q_{40}$", q40);
q41 := q40 shifted (0, 1);
q42 := unit_vector (q3 - q2);
q42 *= .5;
shift q42 by q40;
rotate_around q42 (q40, q41) 120;
%dotlabel.top("$q_{42}$", q42);
q43 := mediate(q3, q2);
%dotlabel.llft("$q_{43}$", q43);
q44 := unit_vector(q3 - q43);
q44 *= .5;
shift q44 by q43;
q45 := q43 shifted (0, 1);
rotate_around q44 (q43, q45) 90;
%dotlabel.top("$q_{44}$", q44);
q46 := q42 rotated_around (q43, q44) 180;
q47 := q40 rotated_around (q43, q44) 180;
% dotlabel.top("$q_{46}$", q46);
% dotlabel.lft("$q_{47}$", q47);

q48 := mediate(q43, q44);
%dotlabel.rt("$q_{48}$", q48);

q49 := (q3 - q40) shifted q48;
%dotlabel.rt("$q_{49}$", q49);

bp := (q46 -- q47) intersection_point (q48 -- q49);

q50 := bp;
%dotlabel.ulft("$q_{50}$", q50);

bp := (q40 -- q42) intersection_point (q48 -- q49);

q51 := bp;
%dotlabel.rt("$q_{51}$", q51);

%% *** (3)

draw q40 -- q42 -- q46 -- q47;
draw q50 -- q51 dashed evenly;

for i = 1 upto 9:
    q[51 + i] := mediate(q51, q50, i/10);
    drawdot q[51 + i] with_pen dot_pen;
endfor;

%% *** (3)

t7 := (identity rotated_around (q2, q28) 180) rotated_around (q2, q4) 180;

q40 *= q42 *= q46 *= q47 *= q50 *= q51 *= q52 *= q53 *= q54 *= q55 *= q56
    *= q57 *= q58 *= q59 *= q60 *= t7;


draw q40 -- q42 -- q46 -- q47 dashed evenly;
draw q50 -- q51 dashed evenly;

for i = 1 upto 9:
    q[51 + i] := mediate(q51, q50, i/10);
    drawdot q[51 + i] with_pen dot_pen;
endfor;

%% *** (3)

picture save_picture;
save_picture := current_picture;

endfig with_projection parallel_x_z; 

beginfig(3);
current_picture := save_picture;
rotate current_picture (0, 180);
endfig with_projection parallel_x_z; 

%% ** (2)  Surface hiding.

%% Haven't gotten very far with this.
%% I'm going to take a break from it and work on polyhedron models 
%% again.
%% LDF 2008.12.30.

%%%% Having problems with `output <picture>' and the 
%%%% `:=' for `pictures'.  I'm going to have to look at how 
%%%% this works.
%%%% LDF 2008.12.29.

pickup pencircle scaled (0.5mm, 0.5mm, 0.5mm);

%% ** (2) Frame

pen_width := .5mm; 

w := 12cm;
h := 12cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;

frame := origin -- (frame_w, 0) -- (frame_w, frame_h) 
                -- (0, frame_h) -- cycle;

shift frame (-.5frame_w, -.5frame_h);

picture frame_picture;

%% *** (3) Dummy figure for `frame_picture'.

beginfig(0); 
draw frame;
frame_picture := current_picture;
endfig;

%% ** (2) Variables 

point p[];
rectangle r[];
plane n[];

picture temp_picture;

transform t[];

distance := 10;

%% *** (3) Focuses

%%%% `f0' is the "ordinary" focus.  `f1' is the focus that's shown
%%%% in figure 1 (and possibly others).
%%%%
%%%% LDF 2008.12.29.

focus f[];
set f0 with_position (0, 0, -10) 
       with_direction (0, 0, 10) with_distance 10; 


set f1 with_position p0 with_direction p1 with_distance 10; 

beginfig(1);

p0 := origin;
p1 := (0, 0, 20);
p2 := unit_vector(p1 - p0);
p2 *= distance;
p2 := p2 shifted p0;

r0 := unit_rectangle rotated 90 scaled (6, 6) shifted p2;

t0 := identity rotated (0, 30);

p1 *= p2 *= r0 *= t0;

message "p0:";
show p0;

message "p1:";
show p1;

message "p2:";
show p2;

drawarrow p0 -- p1;

message "r0:";
show r0;



p3 := get_up f1;

message "p3:";
show p3;

dotlabel.lrt("$p_0$", p0);
label.bot("$p_1$", p1);
label.top("$p_3$", p3);

drawarrow p0 -- p3;
draw r0;

p4 := get_center r0;

dotlabel.top("$c_{r_0}$", p4);

%% *** (3) 

p5 := (-10, 2, 30);

p6 := p5 projected f1;

message "p5:";
show p5;

message "p6:";
show p6;


dotlabel.top("$p_5$", p5);
dotlabel.top("$p_6$", p6);

bool b;

n0 := get_plane r0;

b := p6 is_on_plane n0;

message "p6 is_on_plane n0:";
show b;

%% *** (3) 

temp_picture := current_picture;

output frame_picture with_projection parallel_x_y;

endfig with_focus f0 no_sort;

%% ** (2) Figure 2 

beginfig(2); 

current_picture := frame_picture;
output current_picture with_projection parallel_x_y;

current_picture := null_picture;

%message "frame_picture:";
%show frame_picture;

draw r0;
dotlabel.top("$c_{r_0}$", p4);


label.bot("Perspective projection, focus $f_1$", p4 shifted (0, -5));


endfig with_focus f1 no_sort;

%% ** (2) Figure 3 

beginfig(3); 

current_picture := temp_picture;
label.bot("Parallel projection, X-Y plane", (-5cm, -5cm));

draw frame shifted (-5, 0);


endfig with_projection parallel_x_y;

%% ** (2)

%% ** (2) Matrices.

%%     Working on complex numbers and matrices.
%%     LDF 2007.12.18.

%%     Unlike the transformation matrices contained in `transforms',
%%     the number of rows and columns of `matrices' can be set by the user.
%%     
%%     They use data types and functions defined in the GNU Scientific Library
%%     (GSL).  The code from that library is conditionally compiled, depending
%%     on whether it's available on the system on which GNU 3DLDF is installed.
%%
%%     If the GSL is unavailable, the `matrix' type is non-functional
%%     and the functions of `class Matrix' will return "unsuccessfully", 
%%     but no parser errors should occur.
%%     LDF 2007.11.29.

%%     !! TODO:  Add optional `with_precision' argument to `show' commands.
%%     This will require changing the `show' function for _every_ type.
%%     LDF 2007.12.18.

%% *** (3) Global declarations and initializations

%% Code for matrices currently doesn't work and is therefore
%% commented-out.  I'm working on it.  
%% LDF 2007.12.21.

focus f;
set f with_position (7, 8, -20) 
      with_direction (7, 8, 10) with_distance 20; 

matrix m[];

set m0 (2, 3);  %% Set parameters of matrix (rows, columns) 

set m1 (3, 2);

m0 (0, 0) := 1;
m0 (0, 1) := 3;
m0 (1, 0) := 2;
m0 (1, 1) := 4;

m1 (0, 0) := 2;
m1 (0, 1) := 3;
m1 (1, 0) := 0;
m1 (1, 1) := 4;

message "m0:";    
show m0;

message "m1:";    
show m1;

message "m0 is_multipliable m1:"; %% true
show m0 is_multipliable m1;

%% **** (4) Multiplying matrices.  This works.  LDF 2008.12.18.

m2 := m0 * m1;

%% ** (2) Matrices.

%%     Working on complex numbers and matrices.
%%     LDF 2007.12.18.

%%     Unlike the transformation matrices contained in `transforms',
%%     the number of rows and columns of `matrices' can be set by the user.
%%     
%%     They use data types and functions defined in the GNU Scientific Library
%%     (GSL).  The code from that library is conditionally compiled, depending
%%     on whether it's available on the system on which GNU 3DLDF is installed.
%%
%%     If the GSL is unavailable, the `matrix' type is non-functional
%%     and the functions of `class Matrix' will return "unsuccessfully", 
%%     but no parser errors should occur.
%%     LDF 2007.11.29.

%%     !! TODO:  Add optional `with_precision' argument to `show' commands.
%%     This will require changing the `show' function for _every_ type.
%%     LDF 2007.12.18.

%% *** (3) Global declarations and initializations

%% Code for matrices currently doesn't work and is therefore
%% commented-out.  I'm working on it.  
%% LDF 2007.12.21.

focus f;
set f with_position (7, 8, -20) 
      with_direction (7, 8, 10) with_distance 20; 

matrix m[];

set m0 (2, 2);  %% Set parameters of matrix (rows, columns) 

set m1 (2, 2);

m0 (0, 0) := 1;
m0 (0, 1) := 3;
m0 (1, 0) := 2;
m0 (1, 1) := 4;

m1 (0, 0) := 2;
m1 (0, 1) := 3;
m1 (1, 0) := 0;
m1 (1, 1) := 5;

message "m0:";    
show m0;

message "m1:";    
show m1;

message "m0 is_multipliable m1:"; %% true
show m0 is_multipliable m1;

message "m2:";

%% LDF 2008.10.10.
%%
%% GSL version 1.9.
%% The preprocessor variable ` __GSL_VERSION_H__'
%% is defined in '/usr/include/gsl/gsl_version.h'.

show m2;


m0 := identity_matrix;  %% Set matrix to identity matrix 
                        %% (1 in the main diagonal, 0 in every other element)

message "m0:"; 
show m0;

m0 := zero_matrix;  %% Set every element to 0

message "m0:"; 
show m0;

m0 := one_matrix;  %% Set every element to 1

message "m0:"; 
show m0;

m0 := 23.7;  %% Set every element to the same value.

message "m0:"; 
show m0;

%% **** (4) Multiplying matrices.  Testing.  LDF 2007.12.21.
%%                                           LDF 2008.10.10.

%% START HERE:  LDF 2008.10.10.

%% "START HERE" in `matrices.web'.  LDF 2008.10.10.
%% Use |gsl_matrix_mul_elements|.
%% Copy changed files.  Download snapshot and use my own CVS here
%% or figure out how to upload to Savannah from here.
%% LDF 2008.10.10.

message "m0 is_multipliable m1:"; %% true
show m0 is_multipliable m1;

m2 := m0 * m1;  %% START HERE:  LDF 2008.10.10.

%% **** (4) Commented-out code.

%% **** (4) Non-multipliable matrices.  Causes error messages to be issued.
%%          LDF 2007.12.21.

if false: 
message "m0 is_multipliable m2:"; %% false
show m0 is_multipliable m2;

%m4 := m0 * m2;  %% This now fails, as it should, but no 
                 %% longer causes a segmentation fault.	 
                 %% LDF 2007.12.21.                      

message "m4:"; 
show m4;

fi; 

%% **** (4) 

if false: 

   m0 (1, 2) := 3.5;  %% Set a single element of the matrix.

   message "m0:"; 
   show m0;

   set m1 (3, 3) with_type complex_type;  

   complex c[];

   c0 := (5, 7);

   m1 (1, 2) := c0;  %% Set a single element of the matrix.

   message "m1:"; 
   show m1;

   m0 := identity_matrix;  %% Set matrix to identity matrix 
                           %% (1 in the main diagonal, 0 in every other element)

   message "m0 (identity matrix with `real' values):"; 
   show m0;


   m1 := identity_matrix;  %% Set matrix to identity matrix (complex)
                           %% (1 in the main diagonal, 0 in every other element)

   message "m1 (identity matrix with `complex' values):"; 
   show m1;
fi; 

%% **** (4) Dummy figure.

beginfig(1); 

  pickup pencircle scaled (.75mm, .75mm, .75mm);
  
  circle c;

  c := unit_circle scaled (5cm, 0, 5cm);

  draw c;
  
endfig with_projection parallel_x_z; 

end;

%% **** (4) 

%% *** (3) 



%% ** (2) Interference Pattern 5

focus f;

set f with_position (0, 0,  -10) 
      with_direction (0, 0, 10) with_distance 7; 

circle c[];

point p[];
path q;

pickup pencircle scaled (1.0mm, 1.0mm);

m := 15;
n := 15;

q := (-m, -n) -- (m, -n) -- (m, n) -- (-m, n) -- cycle;

k := 128;

for i = 0 upto 71:

   beginfig(i);

     message "i = ";
     show i;
      draw q;
      for j = .5 step 1 until 15.5:

         set c0 with_diameter j with_point_count k;
         c1 := c0;

         rotate c0(i * 5, 0, 0);
         shift c0 by (0, .5);

         rotate c1(-i * 5, 0, 0);
         shift c1 by (0, -.5);

         %p0 := get_pointg 192 c0;
         %p1 := get_point 192 c1;

         %message "p0:"; 
         %show p0;
         %message "p1:"; 
         %show p1;

         draw c0 with_color blue;
         draw c1 with_color red;

         %drawdot p0 with_pen pencircle scaled (2mm, 2mm) with_color red;
         %drawdot p1 with_pen pencircle scaled (2mm, 2mm) with_color red;
      endfor;

      endfig with_focus f;


endfor;

end;



%% ** (2) Interference Pattern 2

circle c[];

point p[];
path q;

pickup pencircle scaled (1.0mm, 1.0mm);

m := 10;
n := 10;

q := (-m, -n) -- (m, -n) -- (m, n) -- (-m, n) -- cycle;

k := 256;


for i = 0 upto 71:
   beginfig(i); 
      draw q;
      for j = .5 step 1 until 15.5:

         set c0 with_diameter j with_point_count k;
         c1 := c0;

         rotate c0(i * 5, 0, 0);
         shift c0 by (0, .5);

         rotate c1(-i * 5, 0, 0);
         shift c1 by (0, -.5);

         %p0 := get_point 192 c0;
         %p1 := get_point 192 c1;

         %message "p0:"; 
         %show p0;
         %message "p1:"; 
         %show p1;

         draw c0;
         draw c1;

         %drawdot p0 with_pen pencircle scaled (2mm, 2mm) with_color red;
         %drawdot p1 with_pen pencircle scaled (2mm, 2mm) with_color red;
      endfor;

   endfig with_projection parallel_x_y no_sort;
endfor;

end;

for j = 0 upto 10:
   beginfig(j); 
   for i = .5 step .75 until 15:
          draw p;
      	  set c0 with_center (0, 0, -k) with_diameter i with_point_count 256;
      	  set c1 with_center (0, 0, k) with_diameter i with_point_count 256;
      	  draw c0;
      	  draw c1;
   endfor;
   k := k - .25;
   endfig with_projection parallel_x_z;
endfor;

end;


%% ** (2) Interference Pattern 1

circle c[];

path p;

pickup pencircle scaled (1.25mm, 1.25mm);

m := 10;
n := 20;

p := (-m, 0, -n) -- (m, 0, -n) -- (m, 0, n) -- (-m, 0, n) -- cycle;

k := 10;

for j = 0 upto 80:
   beginfig(j); 
   for i = .5 step .75 until 15:
          draw p;
      	  set c0 with_center (0, 0, -k) with_diameter i;
      	  set c1 with_center (0, 0, k) with_diameter i;
      	  draw c0;
      	  draw c1;
   endfor;
   k := k - .25;
   endfig with_projection parallel_x_z;
endfor;

end;

%% ** (2) Knitting pattern, dodecahedron.

%% Now putting current sample code here and "old" sample code
%% in `sample1.ldf'.
%% LDF 2007.09.18.

% Row 1:  5 Stitches, P 
% Row 2:  5 Stitches, K 
% Row 3:  6 P 
% Row 4:  6 K 
% Row 5:  6 P 
% Row 6:  7 K 
% Row 7:  7 P 
% Row 8:  8 K 
% Row 9:  6 P 
% Row 10: 4 K 
% Row 11: 2 P

verbatim_metapost "verbatimtex \font\eightrm=cmr8 etex";

%% ** (2)

point p[];

reg_polygon pentagon[];

rectangle r[];

pickup pencircle scaled (.375mm, .375mm, .375mm);

beginfig(1);

w := .625;
h := .4347;

p0 := origin;
p1 := p0 shifted (5w, 0);
p2 := p1 rotated (0, 108);

p3 := p1 rotated (0, 54);

p4 := p1 shifted (0, 1);
p5 := p0 rotated_around (p1, p4) -54;


p6 := (p0 -- p3) intersection_point (p1 -- p5);


%message "length (p6 - p1)";
%show length (p6 - p1);

%message "length (p6 - p0)";
%show length (p6 - p0);

diameter := 2 * length (p6 - p0);


%draw p2 -- p0 -- p1;
%draw p0 -- p3;
%draw p1 -- p5;

%dotlabel.top("$p_0$", p0);
%dotlabel.top("$p_1$", p1);
%dotlabel.bot("$p_2$", p2);
%dotlabel.bot("$p_3$", p3);
%dotlabel.bot("$p_5$", p5);
%dotlabel.bot("$p_6$", p6);


set pentagon0 with_sides 5 with_center p6 with_diameter diameter;

for i = -2 upto 7:
   p[i + 9] := p0 shifted (i * w, 0);
endfor;

%% Bottom

if false: 
   dotlabel.bot("$p_7$",  p7);
   dotlabel.bot("$p_8$",  p8);
   dotlabel.bot("$p_9$",  p9);
   dotlabel.bot("$p_{10}$", p10);
   dotlabel.bot("$p_{11}$", p11);
   dotlabel.bot("$p_{12}$", p12);
   dotlabel.bot("$p_{13}$", p13);
   dotlabel.bot("$p_{14}$", p14);
   dotlabel.bot("$p_{15}$", p15);
   dotlabel.bot("$p_{16}$", p16);
fi; 


p29 := p7 shifted (0, 0, 12h);

%dotlabel.ulft("$p_{29}$", p29);

j := 1;

for i := 30 upto 38:
   p[i] := p29 shifted (j * w, 0);
   j := j + 1;
endfor;


if false: 
   dotlabel.top("$p_{30}$", p30);
   dotlabel.top("$p_{31}$", p31);
   dotlabel.top("$p_{32}$", p32);
   dotlabel.top("$p_{33}$", p33);
   dotlabel.top("$p_{34}$", p34);
   dotlabel.top("$p_{35}$", p35);
   dotlabel.top("$p_{36}$", p36);
   dotlabel.top("$p_{37}$", p37);
   dotlabel.top("$p_{38}$", p38);
fi; 

%% ** (2)

j := 1;
for i := 7 upto 18:
   p[i + 32] := p7 shifted (0, 0, j * h);
   j := j + 1;
endfor;




% for i := 29 upto 38:
%   shift p[i] (0, 0, k);
% endfor;

for i := 7 upto 16:
   draw p[i] -- p[i + 22] withcolor dark_gray;
endfor;


% %% Top


%% Left side

if false: 
   dotlabel.lft("$p_{39}$", p39);
   dotlabel.lft("$p_{40}$", p40);
   dotlabel.lft("$p_{41}$", p41);
   dotlabel.lft("$p_{42}$", p42);
   dotlabel.lft("$p_{43}$", p43);
   dotlabel.lft("$p_{44}$", p44);
   dotlabel.lft("$p_{45}$", p45);
   dotlabel.lft("$p_{46}$", p46);
   dotlabel.lft("$p_{47}$", p47);
   dotlabel.lft("$p_{48}$", p48);
   dotlabel.lft("$p_{49}$", p49);
fi; 

j := 1;
for i := 39 upto 50:
   p[i + 12] := p16 shifted (0, 0, j * h);
   j := j + 1;
endfor;

%% Right side

% dotlabel.rt("$p_{16}$", p16);

% dotlabel.rt("$p_{51}$", p51);
% dotlabel.rt("$p_{52}$", p52);
% dotlabel.rt("$p_{53}$", p53);
% dotlabel.rt("$p_{54}$", p54);
% dotlabel.rt("$p_{55}$", p55);
% dotlabel.rt("$p_{56}$", p56);
% dotlabel.rt("$p_{57}$", p57);
% dotlabel.rt("$p_{58}$", p58);
% dotlabel.rt("$p_{59}$", p59);
% dotlabel.rt("$p_{60}$", p60);
% dotlabel.rt("$p_{61}$", p61);
% dotlabel.rt("$p_{62}$", p62);

draw p7 -- p16 withcolor dark_gray;

for i := 39 upto 50:
   draw p[i] -- p[i + 12] withcolor dark_gray;
endfor;

%% Numbers, bottom 

string s;

for i := 7 upto 15:
   s := "{\eightrm " & decimal (i - 6) & "}";
   label.bot(s, mediate(p[i], p[i + 1]));
endfor;

%% Numbers, right side

verbatim_metapost "verbatimtex \setbox0=\hbox{{\eightrm 00.}} etex";

label.rt("{\eightrm \hbox to \wd0{1.\hss} P 5}", mediate(p16, p51));
label.rt("{\eightrm \hbox to \wd0{2.\hss}  K 6}", mediate(p51, p52));
label.rt("{\eightrm \hbox to \wd0{3.\hss}  P 6}", mediate(p52, p53));
label.rt("{\eightrm \hbox to \wd0{4.\hss}  K 7}", mediate(p53, p54));
label.rt("{\eightrm \hbox to \wd0{5.\hss}  P 7}", mediate(p54, p55));
label.rt("{\eightrm \hbox to \wd0{6.\hss}  K 7}", mediate(p55, p56));
label.rt("{\eightrm \hbox to \wd0{7.\hss}  P 8}", mediate(p56, p57));
label.rt("{\eightrm \hbox to \wd0{8.\hss}  K 7}", mediate(p57, p58));
label.rt("{\eightrm \hbox to \wd0{9.\hss}  P 5}", mediate(p58, p59));
label.rt("{\eightrm \hbox to \wd0{10.\hss} K 3}", mediate(p59, p60));
label.rt("{\eightrm \hbox to \wd0{11.\hss} P 1}", mediate(p60, p61));

% for i := 51 upto 61:
%    label.rt(i - 49, mediate(p[i], p[i + 1]));
% endfor;


p70 := p9 shifted (0, 0, h);
p71 := p10 shifted (0, 0, h);

r0 := (p9, p70, p71, p10);

filldraw r0 with_draw_color black with_fill_color light_gray;

for i := 0 upto 3:
   shift r0 (w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;

shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;

for i := 0 upto 3:
   shift r0 (-w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;

shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;

for i := 0 upto 3:
   shift r0 (w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;

shift r0 (w, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


for i := 0 upto 5:
   shift r0 (-w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;

shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


for i := 0 upto 5:
   shift r0 (w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;


shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


for i := 0 upto 5:
   shift r0 (-w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;


shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


for i := 0 upto 5:
   shift r0 (w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;


shift r0 (0, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


for i := 0 upto 5:
   shift r0 (-w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;


shift r0 (w, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;

for i := 0 upto 3:
   shift r0 (w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;



shift r0 (-w, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;

for i := 0 upto 1:
   shift r0 (-w, 0);
   filldraw r0 with_draw_color black with_fill_color light_gray;
endfor;

shift r0 (w, 0, h);
filldraw r0 with_draw_color black with_fill_color light_gray;


p72 := p39 shifted (1.5w, 0);
p74 := p72 shifted (0, 0, h);

p73 := p39 shifted (2w, 0);
p75 := p73 shifted (0, 0, h);

%% ** (2) Half-rectangles

r1 := (p72, p73, p75, p74);

filldraw r1 with_draw_color black with_fill_color light_gray;

shift r1 (5.5w, 0);
filldraw r1 with_draw_color black with_fill_color light_gray;

shift r1 (0, 0, h);
filldraw r1 with_draw_color black with_fill_color light_gray;

shift r1 (-5.5w, 0);
filldraw r1 with_draw_color black with_fill_color light_gray;

shift r1 (5.5w, 0);
filldraw r1 with_draw_color black with_fill_color light_gray;


shift r1 (w, 0, 4h);
filldraw r1 with_draw_color black with_fill_color light_gray;

shift r1 (-7.5w, 0);
filldraw r1 with_draw_color black with_fill_color light_gray;


draw pentagon0;



%% ** (2)

endfig with_projection parallel_x_z no_sort;  

end;



%% (2) Complex numbers.
%%     Working on adding parser rules and functions.
%%     LDF 2007.12.11.

numeric n[];

n0 := 2;
n1 := 3;

n2 := n0 * n1;

%message "n2:"; 
%show n2;

complex c[];

c0 := (1, 2);
c1 := (3, 4);

message "c0:"; 
show c0;

message "c1:"; 
show c1;

c2 := c1 * c0;

message "c2 == c1 * c0:"; 
show c2;

%c4 := c0 * c1;
%c4 := c0 / c1;

%message "c4 == c0 / c1:"; 
%show c4;

% c5 := -c4;

% message "c5 == -c4:"; 
% show c5;

% c6 := c0 - c1;

% message "c6 == c0 - c1:"; 
% show c6;

% c7 := c0 + c1;

% message "c7 == c0 + c1:"; 
% show c7;

c8 := c0 + c1 * c2;

message "c8 == c0 + c1 * c2:"; 
show c8;

% c9 := +c8;

% message "c9 == +c8:"; 
% show c9;


%complex_vector cv;
%message "cv:"; 
%show cv;

beginfig(1); 

drawdot origin;
endfig; 

end;

%% ** (2) Matrices.

%%     Working on complex numbers and matrices.
%%     LDF 2007.12.18.

%%     Unlike the transformation matrices contained in `transforms',
%%     the number of rows and columns of `matrices' can be set by the user.
%%     
%%     They use data types and functions defined in the GNU Scientific Library
%%     (GSL).  The code from that library is conditionally compiled, depending
%%     on whether it's available on the system on which GNU 3DLDF is installed.
%%
%%     If the GSL is unavailable, the `matrix' type is non-functional
%%     and the functions of `class Matrix' will return "unsuccessfully", 
%%     but no parser errors should occur.
%%     LDF 2007.11.29.

%%     !! TODO:  Add optional `with_precision' argument to `show' commands.
%%     This will require changing the `show' function for _every_ type.
%%     LDF 2007.12.18.

%% *** (3) Global declarations and initializations

%% Code for matrices currently doesn't work and is therefore
%% commented-out.  I'm working on it.  
%% LDF 2007.12.21.

focus f;
set f with_position (7, 8, -20) 
      with_direction (7, 8, 10) with_distance 20; 

matrix m[];

set m0 (2, 2);  %% Set parameters of matrix (rows, columns) 

set m1 (2, 2);

m0 (0, 0) := 1;
m0 (0, 1) := 3;
m0 (1, 0) := 1;
m0 (1, 1) := 4;

m1 (0, 0) := 2;
m1 (0, 1) := 3;
m1 (1, 0) := 0;
m1 (1, 1) := 4;

message "m0:";    
show m0;

message "m1:";    
show m1;

message "m0 is_multipliable m1:"; %% true
show m0 is_multipliable m1;

%m2 := m0 * m1;  %% Matrix multiplication isn't going to work at present.  
                 %% The version of the GSL that I have
                 %% is very out-of-date (1.6), so it doesn't pay to try to get it
                 %% to work.
                 %% LDF 2007.12.23.

%message "m2:"; 
%show m2;

%% **** (4) Multiplying matrices.  Testing.  LDF 2007.12.21.

if false: 

%message "m0 is_multipliable m1:"; %% true
%show m0 is_multipliable m1;


%m3 := m0 * m1;  %% Just starting working on this.  It doesn't work yet.
                 %% It will fail with a segmentation fault if executed.
                 %% |Matrix::operator=(Matrix)| currently returns `void'.
                 %% I probably want to change the return value back to
                 %% `Matrix&'.
                 %% LDF 2007.12.21.

%message "m3:"; 
%show m3;
fi; 

%% **** (4) Non-multipliable matrices.  Causes error messages to be issued.
%%          LDF 2007.12.21.

if false: 
message "m0 is_multipliable m2:"; %% false
show m0 is_multipliable m2;

%m4 := m0 * m2;  %% This now fails, as it should, but no 
                 %% longer causes a segmentation fault.	 
                 %% LDF 2007.12.21.                      

message "m4:"; 
show m4;

fi; 

%% **** (4) 

if false: 

   m0 (1, 2) := 3.5;  %% Set a single element of the matrix.

   message "m0:"; 
   show m0;

   set m1 (3, 3) with_type complex_type;  

   complex c[];

   c0 := (5, 7);

   m1 (1, 2) := c0;  %% Set a single element of the matrix.

   message "m1:"; 
   show m1;

   m0 := identity_matrix;  %% Set matrix to identity matrix 
                           %% (1 in the main diagonal, 0 in every other element)

   message "m0 (identity matrix with `real' values):"; 
   show m0;


   m1 := identity_matrix;  %% Set matrix to identity matrix (complex)
                           %% (1 in the main diagonal, 0 in every other element)

   message "m1 (identity matrix with `complex' values):"; 
   show m1;
fi; 

%% **** (4) Commented-out code.

if false: 

m0 := identity_matrix;  %% Set matrix to identity matrix 
                        %% (1 in the main diagonal, 0 in every other element)

message "m0:"; 
show m0;

m0 := zero_matrix;  %% Set every element to 0

message "m0:"; 
show m0;

m0 := one_matrix;  %% Set every element to 1

message "m0:"; 
show m0;

m0 := 23.7;  %% Set every element to the same value.

message "m0:"; 
show m0;

fi; 

%% **** (4) Dummy figure.

beginfig(1); 

drawdot origin;
endfig; 

end;

%% **** (4) 

%% *** (3) 

%% ** (2) Complex numbers.
%%     Working on adding parser rules and functions.
%%     LDF 2007.12.11.

numeric n[];

n0 := 2;
n1 := 3;

n2 := n0 * n1;

%message "n2:"; 
%show n2;

complex c[];

c0 := (1, 2);
c1 := (3, 4);

message "c0:"; 
show c0;

message "c1:"; 
show c1;

c2 := c1 * c0;

message "c2 == c1 * c0:"; 
show c2;

%c4 := c0 * c1;
%c4 := c0 / c1;

%message "c4 == c0 / c1:"; 
%show c4;

% c5 := -c4;

% message "c5 == -c4:"; 
% show c5;

% c6 := c0 - c1;

% message "c6 == c0 - c1:"; 
% show c6;

% c7 := c0 + c1;

% message "c7 == c0 + c1:"; 
% show c7;

c8 := c0 + c1 * c2;

message "c8 == c0 + c1 * c2:"; 
show c8;

% c9 := +c8;

% message "c9 == +c8:"; 
% show c9;


%complex_vector cv;
%message "cv:"; 
%show cv;

beginfig(1); 

drawdot origin;
endfig; 

end;

%% ** (2) xpart, ypart, zpart, etc.
%%        BUG FIX:  It is now possible to use `xpart <point or transform expression>', 
%%        `ypart <point or transform expression>', in expressions.  Previously,
%%        this didn't work, because the same `vector' of `real' numbers was used
%%        for the "parts" as for the suffixes of variables.
%%        LDF 2007.11.25.

beginfig(1);
drawdot origin;

point p[];

p0 := (1.1, 2.2, 3.3);
p1 := (zpart p0, ypart p0, xpart p0);

message "p0:"; 
show p0;

message "p1:"; 
show p1;

transform t[];
t0 := identity shifted (1, 2, 3) rotated (4, 5, 6);

message "t0:"; 
show t0;

p2 := (xxpart t0, yypart t0, zzpart t0);

message "p2:"; 
show p2;


endfig;  

%% *** (3) End of 3DLDF code

end;

%% (2) Arcs 
%%     Working on this.  LDF 2007.11.25.

%% *** (3) Global declarations and initializations

%% *** (3) Figure 1; 

beginfig(1); 

p0 := (1, 2, 3);

set a0 with_focus (0) p0;

message "a0:"; 
show a0;

drawdot origin;
endfig with_focus f; 

%% *** (3) End of 3DLDF code

end;

%% *** (3) End of 3DLDF code

end;



%% ** (2) Dodecahedron with Sundial Faces.  Model Plan.
%%        LDF 2007.11.04.

input "polyhed.lmc";

%% *** (3) Global declarations and initializations

focus f;
set f with_position (7, 8, -20) 
      with_direction (7, 8, 10) with_distance 20; 

pen hour_line_pen;
pen path_pen;

hour_line_pen := pencircle scaled (.0333, .0333);
path_pen := pencircle scaled (.0333, .0333);

polyhedron d[];

point p[][];  %% Points on pentagons of d0
point n[];    %% normals
point c[];    %% centers
point q[];    %% Scratch points

point g[];    %% Points on gnomen

point_vector pv;  %% Scratch point vector

reg_polygon_vector rpv; %% The faces of the dodecahedron net

reg_polygon r[];

circle k[];

point K[];  %% Points on k1

point E[];  %% Points on equatorial dial

plane epsilon[];
plane rho[];

path h[][];  %% The hour lines on the pentagonal faces of the dodecahedron

point H[][]; %% One point on each of the `h[][]' paths.

path m[];    %% The hour lines on the net

string s;

transform t[];

%% Greenwich, England:  Latitude 51 deg. 28' 38'' N 
%% (+ 51 (/ 28.0 60) (/ 38.0 3600))  51.4772

%% *** (3) Figure 1 has been moved to the bottom, in order to be able to
%%         move the hour lines for face 10 (r10) to the net.

%% *** (3) Figure 2

beginfig(2);
d0 := unit_dodecahedron scaled 2;
%draw d0;

for i = 0 upto 11:
   r[i] := get_reg_polygon (i) d0;
   c[i] := get_center r[i];
   if false: 
      s := decimal i;
      label(s, c[i]);
   fi; 
endfor;

rho10 := get_plane r10;

draw r10;

p[1][3] := get_point 3 r1;


set k0 with_diameter 10 with_point_count 32;

shift k0 (0, ypart p[1][3]);

if false:  
   for i = 0 upto 4:
      s := "$2_" & decimal i & "$";
      label.top(s, get_point (i) r2);
   endfor;

   for i = 0 upto 4:
      s := "$9_" & decimal i & "$";
      label.lft(s, get_point (i) r9);
   endfor;

   for i = 0 upto 4:
      s := "$10_" & decimal i & "$";
      label.rt(s, get_point (i) r10);
   endfor;
fi; 



%label(2, c2) with_text_color red;
%label.bot(1, c1) with_text_color blue;

%label.lft(0, r1);

% filldraw r1 with_draw_color blue;
% filldraw r2;
% filldraw r0;
% filldraw r6;

%% **** (4) Compass rose

point north, south, east, west;

point c_k;

c_k := get_center k0;

y_val := ypart c_k;
diam := get_diameter k0;

direction_val := .6 * diam;

north := ( 0,  y_val,  direction_val);
south := ( 0,  y_val, -direction_val);
east :=  (direction_val,  y_val,   0);
west :=  (-direction_val, y_val,   0);

label.lft("W", west);
label.rt("E", east);
label.bot("S", south);

g0 := south shifted (0, 0, 1);
q0 := south shifted(-1, 0, 0);

curr_latitude := 51.4772;  %% Greenwich, England

rotate_around g0 (q0, south) curr_latitude;

%dotlabel.lft("$q_{0}$", q0);

%% This doesn't work, because the same `vector<real>' is
%% used to store the `numeric' values for the coordinates
%% as is used for the subscripts of the variable `g0'.
%% This will require some effort to fix.
%% LDF 2007.11.04.

%%g1 := (xpart g0, ypart south, zpart g0);  

%% This is a workaround.  
%% LDF 2007.11.04.

a := xpart g0;
b := ypart south;
g := zpart g0;

g1 := (a, b, g);
 
draw south -- g0 -- g1 -- cycle;

%message "g1:"; 
%show g1;

dotlabel.lft("$g_{0}$", g0);
dotlabel.rt("$g_{1}$", g1);


%% **** (4) Gnomon on r10

n10 := (get_normal r10) shifted c10 scaled 3;

for i = 0 upto 4:
   p[10][i] := get_point (i) r10;
endfor;

q0 := mediate(p[10][0], p[10][4]);

dotlabel.top("$q_{0}$", q0);

q1 := p[10][2] shifted (0, 0, 25);

dotlabel.rt("$q_{1}$", q1);

q3 := mediate(c10, q0, .75);

dotlabel.rt("$q_{3}=g_2$", q3);


g2 := g0;
g3 := south;

t0 := identity shifted by (q3 - g0);  %% `by' is necessary, because without it,
                                      %% a `point_variable' would need to be used
                                      %% instead of a `point_primary'.  I can't change
                                      %% the parser rule without `by', because this causes
                                      %% over 200 shift/reduce conflicts.
                                      %% LDF 2007.11.08.
g2 *= g3 *= t0;

g4 := mediate(g2, g3, 1.5);

g5 := get_perpendicular_base g4, r10;


%% **** (4) Equatorial dial

t0 := align (g4 -- g2) with_axis y_axis;

invert t0;

set k1 with_diameter 1 with_point_count 32;

k1 *= t0;

draw k1 with_color blue with_pen path_pen;

size_k1 := size k1;

for i = 0 upto size_k1 - 1:
   K[i] := get_point (i) k1;
endfor;

if false: 
   message "K0:";  %% K0 and K[size_k1 / 2] lie over the z-axis, i.e., their
                   %% x-component is 0.
   show K0;

   message "K[size_k1 / 2]:";  
   show K[size_k1 / 2];
fi; 

%% g4 is the center of k1

for i = 0 step 15 until 180:
   E[i] := K[3 * size_k1 / 4] rotated_around (g2, g4) i;
endfor;

%% **** (4) The hour lines on r10

epsilon[0] := get_plane (g2 -- g4 -- E[0]);
h[10][0] := epsilon[0] intersection rho10;
clear pv;
pv := h[10][0] intersection_points r10;

draw pv0 -- pv1 with_color red;

if xpart pv0 > xpart pv1:
   H[10][0]   := pv0;
   H[10][180] := pv1;
else:
   H[10][0]   := pv1;
   H[10][180] := pv0;
fi;

for i = 15 step 15 until 165:
   epsilon[i] := get_plane (g2 -- g4 -- E[i]);
   h[10][i] := epsilon[i] intersection rho10;
   clear pv;
   pv := h[10][i] intersection_points r10;
   if zpart pv0 < zpart pv1:
      H[10][i] := pv0;
   else:
      H[10][i] := pv1;
   fi;
   draw g2 -- H[10][i] with_color red;
endfor;

dotlabel.rt("\uppercase\expandafter{\romannumeral 18}  $(0^\circ)$",  H[10][0]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$",  H[10][30]);
dotlabel.lrt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", H[10][60]);
dotlabel.bot("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", H[10][90]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", H[10][120]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", H[10][150]);

dotlabel.lft("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", H[10][180]);



%% **** (4) Drawing commands

draw north -- south;
draw west -- east;

if false: 
   draw k0 with_color blue;

   filldraw r1;
   filldraw r2;
   filldraw r6;
   filldraw r9;
   filldraw r10;
   filldraw r11;
fi; 

% filldraw r10;
% filldraw r11;

%n1 := ((get_normal r1) * -1) shifted c1;
%label.urt("$n_1$", n1) with_text_color blue;
%drawarrow c1 -- n1 with_color blue;

%drawarrow c10 -- n10;

draw p[10][2] -- q0 dashed evenly;

draw p[10][2] -- q1 dashed evenly;

%message "(q0 - p[10][2]) angle (q1 - p[10][2]):"; 
%show (q0 - p[10][2]) angle (q1 - p[10][2]);


label.lft("$g_{4}$", g4);
label.rt("$g_{5}$", g5);

draw g2 -- g4 -- g5 -- cycle with_pen path_pen;


g6 := mediate(g2, g4);

%% **** (4) Labels

if false: 
   label( 1, c1);
   label( 2, c2);
   label( 6, c6);
   label( 9, c9);
   label(11, c11);
fi; 

%dotlabel.lrt("$c_{10}$", c10);

dotlabel.top(0, p[10][0]);
dotlabel.urt(1, p[10][1]);
dotlabel.top(2, p[10][2]);
dotlabel.lft(3, p[10][3]);
dotlabel.top(4, p[10][4]);

%label.bot("$n_{10}$", n10);



%% **** (4) End of figure 2

endfig with_focus f no_sort;  

%% *** (3) Figure 3

beginfig(3);
draw d0;
%draw r6 with_color red;
%draw r7 with_color blue;
%draw r8 with_color cyan;
draw r10 with_color green;

draw k0 with_color blue;

draw north -- south;
draw west -- east;

%label.lrt("$r_{6}$", c6) with_text_color red;
%label.lrt("$r_{7}$", c7) with_text_color blue;
%label.lrt("$r_{8}$", c8) with_text_color cyan;
label.lrt("$r_{10}$", c10) with_text_color green;

label.lft("W", west);
label.rt("E", east);
label.bot("S", south);
label.top("N", north);


endfig with_projection parallel_x_z;

%% *** (3) Figure 4

beginfig(4); 

draw d0;
%draw r10 with_color red;

%drawarrow c10 -- n10;

draw north -- south;

q2 := mediate(p[10][2], q1, .333);
label.rt("$q_{2}$", q2);

draw p[10][2] -- q2 dashed evenly;

draw g2 -- g4 -- g5 -- cycle with_pen path_pen;

draw k1 with_color blue with_pen path_pen;

label.lft("$g_{2}$", g2);
label.lft("$g_{4}$", g4);
label.rt("$g_{5}$", g5);

%dotlabel.rt("$g_{6}$", g6);


%label.lrt("$c_{10}$", c10) with_text_color red;
%label.top("$n_{10}$", n10);

label.bot("S", south);
label.bot("N", north);

rotate current_picture (0, -90);
%scale current_picture (.5, .5, .5);

%% **** (4) End of figure 4

endfig with_projection parallel_x_y with_factor 1 no_sort;

%% *** (3) Figure 5

beginfig(5);

draw g2 -- g4 with_color green;
draw r10;

%dotlabel.top(0, k1);

%% **** (4) Labels on r10

dotlabel.bot(0, p[10][0]);
dotlabel.lrt(1, p[10][1]);
dotlabel.lrt(2, p[10][2]);
dotlabel.llft(3, p[10][3]);
dotlabel.bot(4, p[10][4]);

%% **** (4) 

dotlabel.lrt("$g_{4}$", g4);

if false: 
   message "g2"; 
   show g2;
   message "g4"; 
   show g4;
   message "g2 - g4:"; 
   show g2 - g4;
fi; 

%% **** (4) 

if false: 
   message "g4 is_in_plane rho10:";  %% g4 does not lie in rho10.  It just looks like
                                     %% it in the diagram.
                                     %% LDF 2007.11.08.
   show g4 is_in_plane rho10;
fi; 

%% **** (4) The hour lines on r10

draw H[10][0] -- H[10][180] with_color red;

dotlabel.rt("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", H[10][0]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", H[10][180]);

for i = 15 step 15 until 165:
   draw g2 -- H[10][i] with_color red;
endfor;

draw k1 with_color blue;

%% **** (4) Labels for the hour points on r10

dotlabel.rt("\uppercase\expandafter{\romannumeral 18}  $(0^\circ)$",  H[10][0]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 17}  $(15^\circ)$",  H[10][15]);
dotlabel.lrt("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$",  H[10][30]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 15} $(45^\circ)$",  H[10][45]);
dotlabel.urt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", H[10][60]);
dotlabel.top("\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", H[10][75]);

dotlabel.top("\vbox{}", H[10][90]);
q5 := mediate(g5, H[10][90], 1.333);

label("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", q5);

draw q5 -- H[10][90] dashed evenly;

dotlabel.top("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", H[10][105]);
dotlabel.ulft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", H[10][120]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", H[10][135]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", H[10][150]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", H[10][165]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", H[10][180]);

%% ***** (5) Transform current_picture

t0 := align (g4 -- g2) with_axis y_axis;

rotate t0 (0, 90);

current_picture *= t0;

%draw g4 -- g4 shifted (1, 0);
%dotlabel.top("$+x$", g4 shifted (1, 0));

%% **** (4) End of figure 5
 
endfig with_projection parallel_x_z with_factor 5 no_sort;


%% *** (3) Figure 1

beginfig(1); 

draw_dodecahedron_net {4, true, 6, .375mm, .75mm, identity};

rpv := get_net dodecahedron with_diameter 4;

rotate rpv10 (180, 180);  %% This is the rotation performed in draw_dodecahedron_net.

q6 := get_center rpv10;
q7 := q6 shifted (0, 1);

t2 := align (c10 -- n10) with_axis y_axis;
rotate t2 (0, 90);
shift t2 by q6;

m0 := (H[10][0] -- H[10][180]) transformed t2;

draw m0 with_pen hour_line_pen;

for i = 15 step 15 until 165:
   draw (g2 -- H[10][i]) transformed t2 with_pen hour_line_pen;
endfor;

label(10, q6 shifted (1, 0, .75));


dotlabel.ulft(0, get_point 0 rpv[10]);
dotlabel.rt(1, get_point 1 rpv[10]);
dotlabel.bot(2, get_point 2 rpv[10]);
dotlabel.lft(3, get_point 3 rpv[10]);
dotlabel.urt(4, get_point 4 rpv[10]);

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Figure 6

beginfig(6); 

q22 := g2;
q24 := g4;
q25 := g5;

t3 := identity rotated (0, -90);

q22 *= q24 *= q25 *= t3;

q26 := mediate(q22, q25) shifted .333;

s := "\setbox0=\hbox{2.\space}\vbox{\hbox{2.  Gnomon for latitude of Greenwich, England}"
     & "\hbox{\hskip\wd0($51^\circ$ $28'$ $38''$ N)}}";

label.rt(s, q26);

if false: 
   message "q22:"; 
   show q22;

   message "q24:"; 
   show q24;

   message "q25:"; 
   show q25;
fi;

label.top("$g_{2}$", q22);
label.lft("$g_{4}$", q24);
label.rt("$g_{5}$", q25);

draw q22 -- q24 -- q25 -- cycle;

endfig with_projection parallel_x_y; 


%% *** (3) End of 3DLDF code

end;

%% ** (2) Plan for rhombic triacontahedron V(3.5)^2
%%        LDF 2007.10.19.

%% *** (3) Declarations and Initializations

focus f;
set f with_position (3, 2, -20) 
   with_direction (3, 2, 10) with_distance 20; 


%% *** (3)  Working on `Rhombic_Triacontahedron::get_net'
%%          and `Rhombic_Triacontahedron::get_tabs' in
%%          `rhtchdrn.web' and the macro 
%%          `draw_rhombic_triacontahedron_net', below, 
%%          which calls them.
%%          LDF 2007.10.24.

input "polyhed.lmc";

%% *** (3) Figure 1

beginfig(1); 

draw_rhombic_triacontahedron_net {4, false, true, true, 7, 1mm};

rotate current_picture (0, 180 + 75);

%% **** (4) End of figure 1

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Declarations at top level

polygon r[];
point p[];  %% Scratch points
point c[];  %% Centers

path q[];

transform t[];

%% *** (3) Figure 2

rhombus_side_length := 4;

k := 1;

beginfig(2);

%% **** (4) First rhombus

r0 := get_rhombus with_side_length rhombus_side_length;

p0 := get_point 0 r0;
p1 := get_point 1 r0;
p2 := get_point 2 r0;
p3 := get_point 3 r0;

c0 := mediate(p0, p2);
c0 *= -1;

t0 := identity shifted c0;  %% Can't use `-c0' here, because the parser
                            %% rule requires a `point_variable'. 

p0 *= p1 *= p2 *= p3 *= r0 *= t0;

c0 := mediate(p0, p2);

%message "c0:"; 
%show c0;

alpha := (p0 - p3) angle (1, 0);

t0 := identity rotated (0, 180 - alpha);

c0 *= p0 *= p1 *= p2 *= p3 *= r0 *= t0;

draw r0;

label(k, c0);
k += 1;

r1 := r0;  %% r1 and q10 -- q13 stay at the beginning of the rows.
c1 := c0;

q0 :=    unit_vector(p1 - p0) shifted p1
      -- unit_vector(p0 - p1) shifted p0;
q1 :=    unit_vector(p2 - p1) shifted p2
      -- unit_vector(p1 - p2) shifted p1;
q2 :=    unit_vector(p3 - p2) shifted p3
      -- unit_vector(p2 - p3) shifted p2;
q3 :=    unit_vector(p0 - p3) shifted p0
      -- unit_vector(p3 - p0) shifted p3;

for i = 0 upto 3:
   q[10 + i] := q[i];
endfor;

draw q0 dashed evenly;
draw q1 dashed evenly;
draw q2 dashed evenly;
draw q3 dashed evenly;

%% **** (4) Rest of row 1

p4 := (unit_vector(p1 - p2) / 2) shifted p1;
p5 := (unit_vector(p2 - p1) / 2) shifted p2;

%dotlabel.top("$p_{4}$", p4);
%dotlabel.top("$p_{5}$", p5);

p6 := p2 - p4;

t1 := identity shifted p6;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;

endfor;

%% **** (4) Row 2

r0 := r1;
c0 := c1;

p3 := get_point 3 r0;

p7 := (unit_vector(p3 - p2) / 2) shifted p3 shifted 1;

p7 -= p1;

t0 := identity shifted p7;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 3

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

t2 := inverse t1;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 4

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 5

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 6

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 7

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 8

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 4:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 9

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0);
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) Row 10

r0 := r1;
c0 := c1;

for i = 0 upto 3:
   q[i] := q[10 + i];
endfor;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t0;

c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;
c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t2;

draw r0;
label(k, c0);
k += 1;

for j = 0 upto 3:
   draw q[j] dashed evenly;
endfor;

for i = 0 upto 3:
   c0 *= r0 *= q0 *= q1 *= q2 *= q3 *= t1;

   draw r0;
   label(k, c0); 
   k += 1;

   for j = 0 upto 3:
      draw q[j] dashed evenly;
   endfor;
endfor;

%% **** (4) End of figure 2

endfig with_projection parallel_x_z; 

%% **** (4) 

%% *** (3) End of 3DLDF code

end;

%% *** (3) 

%% ** (2) Dodecahedron Model Plan.
%%        LDF 2007.10.19.

input "polyhed.lmc";

%% *** (3) Global declarations and initializations

focus f;
set f with_position (3, 2, -20) 
   with_direction (3, 2, 10) with_distance 20; 

polyhedron d[];

point p[];
point n[];  %% normals
point c[];  %% centers
reg_polygon r[];

string s;

%% *** (3) Figure 1

beginfig(1); 

%% !!TODO:  Find out why I couldn't make `path_pen' and `dot_pen' as typed
%%          arguments!
%%          LDF 2007.10.16.

draw_dodecahedron_net {4, true, 6, .375mm, .75mm, identity};

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Figure 2

beginfig(2);
d0 := unit_dodecahedron scaled 2 rotated (180, 190);
draw d0;


for i = 0 upto 11:
   r[i] := get_reg_polygon (i) d0;
   c[i] := get_center r[i];
   if false: 
      s := decimal i;
      label(s, c[i]);
   fi; 
endfor;

if false:  
   for i = 0 upto 4:
      s := "$2_" & decimal i & "$";
      label.top(s, get_point (i) r2);
   endfor;

   for i = 0 upto 4:
      s := "$9_" & decimal i & "$";
      label.lft(s, get_point (i) r9);
   endfor;

   for i = 0 upto 4:
      s := "$10_" & decimal i & "$";
      label.rt(s, get_point (i) r10);
   endfor;
fi; 

label(1, c1);
label(2, c2);
label(9, c9);
label(11, c11);

label(10, c10);
%label(2, c2) with_text_color red;
%label.bot(1, c1) with_text_color blue;

% filldraw r1 with_draw_color blue;
% filldraw r2;
% filldraw r0;
% filldraw r6;

filldraw r1;
filldraw r2;
filldraw r9;
filldraw r10;
filldraw r11;


% filldraw r10;
% filldraw r11;


n1 := ((get_normal r1) * -1) shifted c1;

%label.urt("$n_1$", n1) with_text_color blue;
%drawarrow c1 -- n1 with_color blue;

endfig with_focus f no_sort;  

%% *** (3) Figure 3

beginfig(3);
d0 := unit_dodecahedron scaled 2 rotated (180, 10);
draw d0;

for i = 0 upto 11:
   r[i] := get_reg_polygon (i) d0;
   c[i] := get_center r[i];
   if false: 
      s := decimal i;
      label(s, c[i]);
   fi; 
endfor;

filldraw r3;
filldraw r4;
filldraw r5;
filldraw r7;
filldraw r8;

% draw r0;
% draw r1;
% draw r2;
% draw r3;
% draw r5;
% draw r6;
% draw r7;
% draw r8;
% draw r9;
% draw r10;
% draw r11;



label(3, c3);
label(4, c4);
label(5, c5);
label(7, c7);
label(8, c8);

endfig with_focus f no_sort;   


%% *** (3) Figure 4

beginfig(4); 

transform t[];
t0 := identity rotated (0, 0, -90);

draw_dodecahedron_net {6, true, 6, .4mm, .75mm, t0};

rotate current_picture (0, -75);

endfig with_projection parallel_x_z no_sort; 

%% *** (3) Figure 5.  Pentagons for cutting out, 4cm.

%% **** (4) Declarations

path q[];


%% **** (4) Figure 5

beginfig(5); 

%% ***** (5) First pentagon, r0

r0 := unit_pentagon scaled 2;

c0 := get_center r0;

%label("$r_0$", c0);

draw r0;

for i = 0 upto 4:
   p[i] := get_point (i) r0;
endfor;

%dotlabel.top("$p_0$", p0);
%dotlabel.top("$p_1$", p1);
%dotlabel.top("$p_2$", p2);
%dotlabel.top("$p_3$", p3);
%dotlabel.top("$p_4$", p4);

j := 0;
for i = 0 upto 3:
   q[i] += --;
   p[10 + j] := unit_vector (p[i] - p[i + 1]) shifted p[i];
   q[i] += p[10 + j];
   j += 1;
   p[10 + j] := unit_vector (p[i + 1] - p[i]) shifted p[i + 1];
   q[i] += p[10 + j];
   j += 1;
endfor;

p[18] := unit_vector (p[4] - p[0]) shifted p[4];
p[19] := unit_vector (p[0] - p[4]) shifted p[0];

q[4] := p[18] -- p[19];

%dotlabel.top("$p_{10}$", p10);
%dotlabel.top("$p_{11}$", p11);
%dotlabel.top("$p_{12}$", p12);
%dotlabel.top("$p_{13}$", p13);
%dotlabel.top("$p_{14}$", p14);
%dotlabel.top("$p_{15}$", p15);
%dotlabel.top("$p_{16}$", p16);
%dotlabel.top("$p_{17}$", p17);
%dotlabel.top("$p_{18}$", p18);
%dotlabel.top("$p_{19}$", p19);

for i := 0 upto 4:
   draw q[i] dashed evenly;
endfor;

%% ***** (5) Second pentagon, r1

t0 := identity shifted by (p15 - p14);

r1 := r0 transformed t0;

draw r1;

c1 := get_center r1;
%
%label("$r_1$", c1);

for i = 0 upto 4:
   p[20 + i] := get_point (i) r1;
   q[20 + i] := q[i] transformed t0;
   draw q[20 + i] dashed evenly; 
endfor;

for i = 0 upto 9:
   p[30 + i] := p[10 + i] transformed t0;
endfor;


%dotlabel.bot("$p_{20}$", p20);
%dotlabel.bot("$p_{21}$", p21);
%dotlabel.bot("$p_{22}$", p22);
%dotlabel.bot("$p_{23}$", p23);
%dotlabel.bot("$p_{24}$", p24);

%dotlabel.bot("$p_{30}$", p30);
%dotlabel.bot("$p_{31}$", p31);
%dotlabel.bot("$p_{32}$", p32);
%dotlabel.bot("$p_{33}$", p33);
%dotlabel.bot("$p_{34}$", p34);
%dotlabel.bot("$p_{35}$", p35);
%dotlabel.bot("$p_{36}$", p36);
%dotlabel.bot("$p_{37}$", p37);
%dotlabel.bot("$p_{38}$", p38);
%dotlabel.bot("$p_{39}$", p39);

%% ***** (5) Third pentagon, r2

r2 := r1 transformed t0;

c2 := get_center r2;
%
%label("$r_2$", c2);

draw r2;

for i = 0 upto 4:
   p[40 + i] := get_point (i) r2;
   q[40 + i] := q[i + 20] transformed t0;
   draw q[40 + i] dashed evenly; 
endfor;

for i = 0 upto 9:
   p[50 + i] := p[30 + i] transformed t0;
endfor;

%dotlabel.bot("$p_{40}$", p40);
%dotlabel.bot("$p_{41}$", p41);
%dotlabel.bot("$p_{42}$", p42);
%dotlabel.bot("$p_{43}$", p43);
%dotlabel.bot("$p_{44}$", p44);

%dotlabel.bot("$p_{50}$", p50);
%dotlabel.bot("$p_{51}$", p51);
%dotlabel.bot("$p_{52}$", p52);
%dotlabel.bot("$p_{53}$", p53);
%dotlabel.bot("$p_{54}$", p54);
%dotlabel.bot("$p_{55}$", p55);
%dotlabel.bot("$p_{56}$", p56);
%dotlabel.bot("$p_{57}$", p57);
%dotlabel.bot("$p_{58}$", p58);
%dotlabel.bot("$p_{59}$", p59);

%% ***** (5) Fourth pentagon, r3

r3 := r2 transformed t0;

c3 := get_center r3;
%
%label("$r_3$", c3);

draw r3;

for i = 0 upto 4:
   p[60 + i] := get_point (i) r3;
   q[60 + i] := q[i + 40] transformed t0;
   draw q[60 + i] dashed evenly; 
endfor;

for i = 0 upto 9:
   p[70 + i] := p[50 + i] transformed t0;
endfor;

%dotlabel.bot("$p_{60}$", p60);
%dotlabel.bot("$p_{61}$", p61);
%dotlabel.bot("$p_{62}$", p62);
%dotlabel.bot("$p_{63}$", p63);
%dotlabel.bot("$p_{64}$", p64);

%dotlabel.bot("$p_{70}$", p70);
%dotlabel.bot("$p_{71}$", p71);
%dotlabel.bot("$p_{72}$", p72);
%dotlabel.bot("$p_{73}$", p73);
%dotlabel.bot("$p_{74}$", p74);
%dotlabel.bot("$p_{75}$", p75);
%dotlabel.bot("$p_{76}$", p76);
%dotlabel.bot("$p_{77}$", p77);
%dotlabel.bot("$p_{78}$", p78);
%dotlabel.bot("$p_{79}$", p79);

%for i = 0 upto 3:
%   filldraw r[i];
%endfor;

%% ***** (5) Second row 

t0 := identity shifted by (p16 - p17);

for i = 0 upto 3:
   c[i] *= r[i] *= t0;
   s := "$r_{" & decimal i & "}$";
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
   q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
   draw q[i] dashed evenly;
   draw q[20 + i] dashed evenly;
   draw q[40 + i] dashed evenly;
   draw q[60 + i] dashed evenly;
endfor;

%% ***** (5) Third row

t1 := identity shifted by (p13 - p12);

for i = 0 upto 3:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t1;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
   q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t1;
   draw q[i] dashed evenly;
   draw q[20 + i] dashed evenly;
   draw q[40 + i] dashed evenly;
   draw q[60 + i] dashed evenly;
  % label(s, c[i]);
endfor;

%% ***** (5) Fourth row 

for i = 0 upto 3:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t0;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
   q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
   draw q[i] dashed evenly;
   draw q[20 + i] dashed evenly;
   draw q[40 + i] dashed evenly;
   draw q[60 + i] dashed evenly;
endfor;


%% ***** (5) Fifth row

for i = 0 upto 3:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t1;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
   q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t1;
   draw q[i] dashed evenly;
   draw q[20 + i] dashed evenly;
   draw q[40 + i] dashed evenly;
   draw q[60 + i] dashed evenly;
endfor;

%% ***** (5) Sixth row 

for i = 0 upto 3:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t0;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
   q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
   draw q[i] dashed evenly;
   draw q[20 + i] dashed evenly;
   draw q[40 + i] dashed evenly;
   draw q[60 + i] dashed evenly;
endfor;

%% ***** (5) End of figure 5

endfig with_projection parallel_x_z no_sort; 


%% *** (3) Figure 6

beginfig(6); 

%% ***** (5) First pentagon, r0

r0 := unit_pentagon scaled 3;
draw r0;

c0 := get_center r0;
%
%label("$r_0$", c0);

for i = 0 upto 4:
   p[i] := get_point (i) r0;
endfor;

%dotlabel.top("$p_0$", p0);
%dotlabel.top("$p_1$", p1);
%dotlabel.top("$p_2$", p2);
%dotlabel.top("$p_3$", p3);
%dotlabel.top("$p_4$", p4);

j := 0;
for i = 0 upto 3:
   q[i] := null_path;
   q[i] += --;
   p[10 + j] := unit_vector (p[i] - p[i + 1]) shifted p[i];
   q[i] += p[10 + j];
   j += 1;
   p[10 + j] := unit_vector (p[i + 1] - p[i]) shifted p[i + 1];
   q[i] += p[10 + j];
   j += 1;
   draw q[i] dashed evenly;
endfor;

p[18] := unit_vector (p[4] - p[0]) shifted p[4];
p[19] := unit_vector (p[0] - p[4]) shifted p[0];

q[4] := p[18] -- p[19];
draw q[4] dashed evenly;

%dotlabel.top("$p_{10}$", p10);
%dotlabel.top("$p_{11}$", p11);
%dotlabel.top("$p_{12}$", p12);
%dotlabel.top("$p_{13}$", p13);
%dotlabel.top("$p_{14}$", p14);
%dotlabel.top("$p_{15}$", p15);
%dotlabel.top("$p_{16}$", p16);
%dotlabel.top("$p_{17}$", p17);
%dotlabel.top("$p_{18}$", p18);
%dotlabel.top("$p_{19}$", p19);


%% ***** (5) Second pentagon, r1

p100 := p15 shifted 1;

t0 := identity shifted by (p100 - p14);

r1 := r0 transformed t0;

c1 := get_center r1;
%
%label("$r_1$", c1);

draw r1;

for i = 0 upto 4:
   p[20 + i] := get_point (i) r1;
   q[20 + i] := q[i] transformed t0;
   draw q[20 + i] dashed evenly; 
endfor;

for i = 0 upto 9:
   p[30 + i] := p[10 + i] transformed t0;
endfor;


%dotlabel.bot("$p_{20}$", p20);
%dotlabel.bot("$p_{21}$", p21);
%dotlabel.bot("$p_{22}$", p22);
%dotlabel.bot("$p_{23}$", p23);
%dotlabel.bot("$p_{24}$", p24);

%dotlabel.bot("$p_{30}$", p30);
%dotlabel.bot("$p_{31}$", p31);
%dotlabel.bot("$p_{32}$", p32);
%dotlabel.bot("$p_{33}$", p33);
%dotlabel.bot("$p_{34}$", p34);
%dotlabel.bot("$p_{35}$", p35);
%dotlabel.bot("$p_{36}$", p36);
%dotlabel.bot("$p_{37}$", p37);
%dotlabel.bot("$p_{38}$", p38);
%dotlabel.bot("$p_{39}$", p39);

%% ***** (5) Third pentagon, r2

r2 := r1 transformed t0;

c2 := get_center r2;
%
%label("$r_2$", c2);

draw r2;

for i = 0 upto 4:
   p[40 + i] := get_point (i) r2;
   q[40 + i] := q[i + 20] transformed t0;
   draw q[40 + i] dashed evenly; 
endfor;

for i = 0 upto 9:
   p[50 + i] := p[30 + i] transformed t0;
endfor;

%dotlabel.bot("$p_{40}$", p40);
%dotlabel.bot("$p_{41}$", p41);
%dotlabel.bot("$p_{42}$", p42);
%dotlabel.bot("$p_{43}$", p43);
%dotlabel.bot("$p_{44}$", p44);

%dotlabel.bot("$p_{50}$", p50);
%dotlabel.bot("$p_{51}$", p51);
%dotlabel.bot("$p_{52}$", p52);
%dotlabel.bot("$p_{53}$", p53);
%dotlabel.bot("$p_{54}$", p54);
%dotlabel.bot("$p_{55}$", p55);
%dotlabel.bot("$p_{56}$", p56);
%dotlabel.bot("$p_{57}$", p57);
%dotlabel.bot("$p_{58}$", p58);
%dotlabel.bot("$p_{59}$", p59);


%% ***** (5) Second row 

t0 := identity shifted (0, 0, -6);

for i = 0 upto 2:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t0;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
  q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
  draw q[i] dashed evenly;
  draw q[20 + i] dashed evenly;
  draw q[40 + i] dashed evenly;
  draw q[60 + i] dashed evenly;
endfor;
 

%% ***** (5) Third row 

for i = 0 upto 2:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t0;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
  q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
  draw q[i] dashed evenly;
  draw q[20 + i] dashed evenly;
  draw q[40 + i] dashed evenly;
  draw q[60 + i] dashed evenly;
endfor;


%% ***** (5) Fourth row 

for i = 0 upto 2:
   s := "$r_{" & decimal i & "}$";
   c[i] *= r[i] *= t0;
   draw r[i];
  % label(s, c[i]);
endfor;

for i = 0 upto 4:
  q[i] *= q[20 + i] *= q[40 + i] *= q[60 + i] *= t0;
  draw q[i] dashed evenly;
  draw q[20 + i] dashed evenly;
  draw q[40 + i] dashed evenly;
  draw q[60 + i] dashed evenly;
endfor;

%% ***** (5) End of figure 6

endfig with_projection parallel_x_z no_sort; 

%% **** (4) 

%% *** (3) End of 3DLDF code

end;

%% ** (2) 

%% *** (3) Rotating labels.
%%         They must be rotated about the z-axis!
%%         I'd forgotten this, and had quite a bit of trouble
%%         before I stumbled on the solution.
%%         LDF 2007.10.14.

%% label("\hbox{ORIGIN}", origin) rotated (0, 0, 45);

%% *** (3) Added the transformer `transposed' and the commands `invert' 
%% 	   and `transpose'.  `transposed' operates on `transform' expressions
%% 	   and `invert' and `transpose' operate on `transform' variables.
%% 	   LDF 2007.10.14.

transform t[];

t0 := identity scaled (1, 2, 3);

t1 := t0;

message "t1 before inversion:"; 
show t1;

invert t1;

message "t1 after inversion:"; 
show t1;

t2 := t0 * t1;  %% This is new.  The multiplication operator `*' is equivalent
                %% to the transformer `transposed' here. 
                %% LDF 2007.10.14.


t3 := t0 shifted (4, 5, 6);
rotate t3 (7, 8, 9);

message "t3:"; 
show t3;

t4 := transposed t3;

message "t4 (transposition of t3):"; 
show t4;

message "t3 == t4:"; 
show t3 == t4;

message "t3 <> t4:"; 
show t3 <> t4;

message "t4 after being transposed:"; 
transpose t4;
show t4;

message "t3 == t4:"; 
show t3 == t4;

message "t3 <> t4:"; 
show t3 <> t4;

%% *** (3)  Added `class Arc' and parser declarations and rules for
%% 	    `arc' expressions.  The rules work but `arcs' are not 
%% 	    yet functional.
%% 	    LDF 2007.10.13.

arc a;
show a;

%% ** (2) 

%% *** (3) Sundials 3.  

%%         The macro `draw_sundial' is now in the file
%%         `sundials.lmc', which this file includes.
%%         I will be using the extension `.lmc' for 
%%         files containing macro definitions.  GNU 3DLDF 
%%         currently doesn't have a means of "fast-loading" macro 
%%         definitions that have been compiled into an easy-to-process
%%         form, as do TeX, METAFONT, and MetaPost.  Programming this
%%         feature is on my "TO DO" list, but it will be a very big job.
%%         LDF 2007.10.10.

focus f[];

set f0 with_position (0, 5, -12) with_direction (0, 5, 10) with_distance 10;

%% Jerusalem   31 deg. 47' 0'' N, 35 deg.  13' 0'' E 
%%             31.783333 deg. N,  35.216667 deg. E
%% Athens, Greece:  latitude:  37 deg. 58' N 23 deg. 43' E
%%                             == 37.9667
%% Chicago:         latitude:  41.8667
%%                  41 deg. 52' 55'' N 87 deg. 37' 40'' W
%%                             == 
%% Rome, Italy 41 deg. 54' N 12 deg. 30' E  %% Not done.
%%
%% London, UK:                 51 deg. 30' 28'' N 0 deg. 7' 41'' W
%%                             == 51.5077 N
%% Goettingen:      latitude:  51 deg 32' N, longitude:   9 deg 56' E
%%                             == 51.5333
%% St. Petersburg, Russia      59 deg. 56' N, 30 deg. 20' E


%%                                      %% Jerusalem
%% (+ 37 (/ 58.0 60) (/ 0 3600)         %% Athens, 
%% (+ 41 (/ 52.0 60) (/ 55 3600))       %% Chicago
%% (+ 51 (/ 30.0 60.0) (/ 28  3600.0))  %% London
%% (+ 51 (/ 32.0 60.0) (/ 0  3600.0))   %% Goettingen
%% (+ 59 (/ 56.0 60.0) (/ 0  3600.0))   %% St. Petersburg

% latitude := 31.7833; %% Jerusalem
% latitude := 37.9667; %% Athens, 
% latitude := 41.8667; %% Chicago
% latitude := 51.5077; %% London
% latitude := 51.533;  %% Goettingen
% latitude := 59.9333; %% St. Petersburg

input "sundials.lmc";

%% **** (4) 

%% These parameters aren't used yet.
%% LDF 2007.10.10.

angle_x := 30;
angle_y := 15;
angle_z := 10;

boolean vertical;
boolean horizontal;

vertical := true;
horizontal := false;

%% **** (4) Call draw_sundial

radius := 5;

%% ***** (5) Jerusalem, Israel

latitude := 31.7833; %% Jerusalem, Israel
                   
start_figure := 1;   %% Figures 1--3 

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};

%% ***** (5) Athens, Greece

latitude := 37.9667;  %% Athens, Greece
                   
start_figure += 3;   %% Figures 4--6 

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};

%% ***** (5) Chicago

latitude := 41.8667;    %% Chicago
start_figure += 3;   %% Figures 7--9
%radius := 5;

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};


%% ***** (5) 

latitude := 51.5777; %% London
start_figure += 3;   %% Figures 10--12
%radius := 5;

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};


%% ***** (5) Goettingen

latitude := 51.533;   %% Goettingen
start_figure += 3;    %% Figures 13--15
%radius := 5;

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};

%% ***** (5) St. Petersburg

latitude := 59.9333;  %% St. Petersburg
start_figure += 3;    %% Figures 16--18
%radius := 5;

draw_sundial {start_figure, 
              f0,
              latitude,
              radius, vertical, 
              angle_x, angle_y, angle_z};

%% ***** (5) End of calls to draw_sundial

%% **** (4) End of Sundials 3.  

end;

%% ** (2) 

%% *** (3) Sundials 2
%%         Full sets of hour lines on the vertical and horizontal planes.
%%         Using the latitude of Goettingen, Germany:
%%         latitude: 51 deg 32' N, longitude:  9 deg 56' E
%%         and Chicago, Illinois, USA:
%%         latitude:  41 deg 54' N  longitude:  87 deg 39' W
%%
%%          London, UK:  51 deg. 30' 28'' N 0 deg. 7' 41'' W
%%          51 deg. 30' 28'' N == 51.5777 N
%%
%%         LDF 2007.10.06.

%% **** (4) 

focus f[];

set f0 with_position (0, 5, -12) with_direction (0, 5, 10) with_distance 10;

%% **** (4) Declarations and Initializations

point p[];     %% Points on the dial

point g[];     %% Points on the gnomon

point gv;      %% Trace of gnomon on vertical plane
point gh;      %% Trace of gnomon on horizontal plane

circle c[];    %% c0 is the dial

point q[];

rectangle r[];  

transform t[];

bool_point_vector bpv;

string s;

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

plane m[];
path h[]v;
path h[]h;

%% **** (4) Parameters

radius := 5;

%% Goettingen:  latitude:  51 deg 32' N, longitude:   9 deg 56' E
%% Chicago:     latitude:  41 deg 54' N  longitude:  87 deg 39' W
%% London, UK:  51 deg. 30' 28'' N 0 deg. 7' 41'' W
%% 51 deg. 30' 28'' N == 51.5777 N

latitude := 51.533;   %% Goettingen
% latitude := 41.9;   %% Chicago
% latitude := 51.5777 %% London

%% **** (4) Set equatorial circle and surrounding rectangles

set c0 with_diameter (2 * radius) with_point_count 32;
r0 := out_rectangle c0;
r1 := r0 scaled (1.3, 0, 1.3);

t0 := identity rotated (90, 90);

c0 *= r0 *= r1 *= t0;

%% **** (4) Figure 1

pickup pencircle scaled (.575mm, .575mm);

beginfig(1); 

dotlabel.lrt("$\rm{origin}$", origin);

g0 := (3 * radius, 0) rotated (0, 0, -latitude);
g1 := (-5 * radius, 0) rotated (0, 0, -latitude);

drawdblarrow g0 -- g1;

label.bot("$g_0$", g0);
label.top("$g_1$", g1);

p0 := (0, 0, radius);

%% **** (4) Points on top of dial (vertical)

for i = 15 step 15 until 180:
  p[i] := p[i - 15] rotated -15;
endfor;

for i = 0 step 15 until 180:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%% **** (4) Points on bottom of dial (horizontal)

for i = -15 step -15 until -165:
  p[i] := p[i + 15] rotated 15;
endfor;

for i = -15 step -15 until -165:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%draw p[75] -- p[-105];


%% **** (4) Rotate dial and surrounding rectangles.

t2 := identity rotated (0, 0, -latitude);

c0 *= r0 *= r1 *= t2;

%% **** (4) Draw and label the rectangles surrounding the dial

draw r0 with_color red;
draw r1 with_color green;

for i = 0 upto 3:
   q[28 + i] := get_point (i) r0;
   q[i] := get_point (i) r1;
endfor;


%% ***** (5) r0

dotlabel.bot("$q_{28}$", q28);
dotlabel.ulft("$q_{29}$", q29);
dotlabel.top("$q_{30}$", q30);
dotlabel.rt("$q_{31}$", q31);

label.lrt("$r_0$", mediate(q28, q31, .25)) with_text_color red;

%% ***** (5) r1

dotlabel.bot("$q_0$", q0);
dotlabel.ulft("$q_1$", q1);
dotlabel.top("$q_2$", q2);
dotlabel.rt("$q_3$", q3);

label.lrt("$r_1$", mediate(q0, q3)) with_text_color green;


%% **** (4) Get the rectangle perpendicular to r1, draw and label it (r4)

q4 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) 90;
q5 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) -90;

dotlabel.lft("$q_4$", q4);
dotlabel.lft("$q_5$", q5);


q6 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) 90;
q7 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) -90;

dotlabel.urt("$q_6$", q6);
dotlabel.lrt("$q_7$", q7);

r4 := (q5, q4, q6, q7);

draw r4 with_color cyan;

label.llft("$r_4$", mediate(q4, q5, .25)) with_text_color cyan;

%% **** (4) Find, draw and label the rectangle representing the vertical plane (r2)

q8 := q4 shifted (0, 14);
q9 := q6 shifted (0, 14);

dotlabel.lft("$q_8$", q8);
dotlabel.lft("$q_9$", q9);

r2 := (q6, q4, q8, q9);

draw r2 with_color red;

label.lft("$r_2$", mediate(q4, q8)) with_text_color red;



bpv := r2 intersection_points (g0 -- g1);

gv := bpv0;

dotlabel.urt("$g_v$", gv);


%% **** (4) 90 deg.  Noon line.

%% ***** (5) Vertical

q11 := mediate(q4, q6); %% Trace of noon line on vertical plane

dotlabel.rt("$q_{11}$", q11);

draw gv -- q11;

q12 := mediate(q5, q7);
dotlabel.lrt("$q_{12}$", q12);

draw q11 -- q12;

%% **** (4) Horizontal plane (plane of r6)

q50 := q0 shifted 12;
q51 := q1 shifted 12;

r6 := (q0, q1, q51, q50);

draw r6 with_color orange;

label.bot("$r_6$", mediate(q0, q50)) with_text_color orange;

q80 := get_center r6;
q81 := (get_normal r6 * -1) shifted q80;

dotlabel.llft("$q_{80}$", q80);
label.rt("\vbox{\hbox{$q_{81}$}\hbox{(normal to $r_6$)}}", q81);

drawarrow q80 -- q81 with_color orange;

dotlabel.bot("$q_{50}$", q50);
dotlabel.rt("$q_{51}$", q51);

bpv := r6 intersection_points (g0 -- g1);

gh := bpv0; %% Trace of gv on r6

dotlabel.urt("$g_h$", gh);

%% **** (4) Planes of the vertical and horizontal rectangles

m2 := get_plane r2;  %% Vertical
m6 := get_plane r6;  %% Horizontal

%% **** (4) 180 deg. (6:00 AM) 

m180 := (origin, gv, p180);

%% ***** (5) Vertical

h180v := m180 intersection m2;

bpv := h180v intersection_points r2;

q75 := bpv0;

dotlabel.lft("$q_{75}$", q75);

draw gv -- q75;

%% ***** (5) Horizontal

h180h := m180 intersection m6;

bpv := h180h intersection_points r6;

q76 := bpv1;

dotlabel.bot("$q_{76}$", q76);

draw gh -- q76;

%% **** (4) 165 deg. (7:00 AM) 

m165 := (origin, gv, p165);

%% ***** (5) Vertical

h165v := m165 intersection m2;

bpv := h165v intersection_points r2;

q73 := bpv0;

dotlabel.lft("$q_{73}$", q73);

draw gv -- q73;

%% ***** (5) Horizontal

h165h := m165 intersection m6;

bpv := h165h intersection_points r6;

q74 := bpv1;

dotlabel.bot("$q_{74}$", q74);

draw gh -- q74;

%% **** (4) 150 deg. (8:00 AM) 

m150 := (origin, gv, p150);

%% ***** (5) Vertical

h150v := m150 intersection m2;

bpv := h150v intersection_points r2;

q71 := bpv0;

dotlabel.lft("$q_{71}$", q71);

draw gv -- q71;

%% ***** (5) Horizontal

h150h := m150 intersection m6;

bpv := h150h intersection_points r6;

q72 := bpv1;

dotlabel.bot("$q_{72}$", q72);

draw gh -- q72;

%% **** (4) 135 deg. (9:00 AM) 

m135 := (origin, gv, p135);

%% ***** (5) Vertical

h135v := m135 intersection m2;

bpv := h135v intersection_points r2;

q69 := bpv0;

dotlabel.lrt("$q_{69}$", q69);

draw gv -- q69;

%% ***** (5) Horizontal

h135h := m135 intersection m6;

bpv := h135h intersection_points r6;

q70 := bpv0;

dotlabel.ulft("$q_{70}$", q70);

draw gh -- q70;




%% **** (4) 120 deg. (10:00 AM) 

m120 := (origin, gv, p120);

%% ***** (5) Vertical

h120v := m120 intersection m2;

bpv := h120v intersection_points r2;

q67 := bpv0;

dotlabel.rt("$q_{67}$", q67);

draw gv -- q67;

%% ***** (5) Horizontal

h120h := m120 intersection m6;

bpv := h120h intersection_points r6;

q68 := bpv0;

dotlabel.lft("$q_{68}$", q68);

draw gh -- q68;


%% **** (4) 105 deg. (11:00 AM) 

m105 := (origin, gv, p105);

%% ***** (5) Vertical

h105v := m105 intersection m2;

bpv := h105v intersection_points r2;

q65 := bpv0;

dotlabel.rt("$q_{65}$", q65);

draw gv -- q65;

%% ***** (5) Horizontal

h105h := m105 intersection m6;

bpv := h105h intersection_points r6;

q66 := bpv0;

dotlabel.lft("$q_{66}$", q66);

draw gh -- q66;


%% **** (4) 90 deg. (Noon)

q13 := mediate(q0, q1); %% Trace of noon line on horizontal plane

dotlabel.llft("$q_{13}$", q13);
draw gh -- q13;


%% **** (4) 75 deg.  (1:00 PM)

%% ***** (5) Vertical

m75 := (origin, gv, p75);

h75v := m75 intersection m2;

bpv := h75v intersection_points r2;

q56 := bpv0;

draw gv -- q56;

dotlabel.rt("$q_{56}$", q56);

%% ***** (5) Horizontal

h75h := m75 intersection m6;

bpv := h75h intersection_points r6;

q57 := bpv0;

draw gh -- q57;
dotlabel.ulft("$q_{57}$", q57);

%% **** (4) 60 deg. (2:00 PM)

m60 := (origin, gv, p60);

%% ***** (5) Vertical

h60v := m60 intersection m2;

bpv := h60v intersection_points r2;

q53 := bpv0;

dotlabel.rt("$q_{53}$", q53);

%% ***** (5) Horizontal

h60h := m60 intersection m6;

bpv := h60h intersection_points r6;

q58 := bpv0;

draw gh -- q58;
dotlabel.lft("$q_{58}$", q58);

%% **** (4) 45 deg. (3:00 PM) 

m45 := (origin, gv, p45);

%% ***** (5) Vertical

h45v := m45 intersection m2;

bpv := h45v intersection_points r2;

q54 := bpv0;

dotlabel.lrt("$q_{54}$", q54);

%% ***** (5) Horizontal

h45h := m45 intersection m6;

bpv := h45h intersection_points r6;

q59 := bpv0;

draw gh -- q59;
dotlabel.lft("$q_{59}$", q59);

%% **** (4) 30 deg. (4:00 PM) 

m30 := (origin, gv, p30);

%% ***** (5) Vertical

h30v := m30 intersection m2;

bpv := h30v intersection_points r2;

q55 := bpv1;

dotlabel.lrt("$q_{55}$", q55);

draw gv -- q55;

%% ***** (5) Horizontal

h30h := m30 intersection m6;

bpv := h30h intersection_points r6;

q60 := bpv0;

dotlabel.ulft("$q_{60}$", q60);

draw gh -- q60;


%% **** (4) 15 deg. (5:00 PM) 

m15 := (origin, gv, p15);

%% ***** (5) Vertical

h15v := m15 intersection m2;

bpv := h15v intersection_points r2;

q61 := bpv1;

dotlabel.urt("$q_{61}$", q61);

draw gv -- q61;

%% ***** (5) Horizontal

h15h := m15 intersection m6;

bpv := h15h intersection_points r6;

q62 := bpv0;

dotlabel.urt("$q_{62}$", q62);

draw gh -- q62;

%% **** (4) 0 deg. (18:00 PM) 

m0 := (origin, gv, p0);

%% ***** (5) Vertical

h0v := m0 intersection m2;

bpv := h0v intersection_points r2;

q63 := bpv1;

dotlabel.rt("$q_{63}$", q63);

draw gv -- q63;

%% ***** (5) Horizontal

h0h := m0 intersection m6;

bpv := h0h intersection_points r6;

q64 := bpv0;

dotlabel.top("$q_{64}$", q64);

draw gh -- q64;

%% **** (4) End of time divisions

%% **** (4) Draw dial

draw c0;

label.urt("$c_0$", get_point(16) c0 * .875 shifted (.1, 0));

%% ***** (5) Draw axes of equatorial dial

draw p0 -- p180 with_color blue with_pen path_pen;
draw p[-90] -- p90 with_color blue with_pen path_pen;

%% ***** (5) Draw time divisions on vertical dial

draw q16 -- gv;  %% 1:00 PM (75 deg.) 
draw gv -- q53;  %% 2:00 PM (60 deg.)
draw gv -- q54;  %% 3:00 PM (45 deg.)

%% ***** (5) 

%% **** (4) Labels for top of vertical dial.

if false: 
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", p180);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", p165);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", p150);
   dotlabel.llft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", p135);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", p120);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", p105);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", p90);
   
   dotlabel.lft("$p_{75} =$\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", p75);
   dotlabel.rt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", p60);

   s := "\setbox0=\hbox{$(45^\circ)$}" 
        & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
        & "\box0}";

   dotlabel.lft(s, p45);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", p30);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", p15);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", p0);
fi;

%% **** (4) Labels for bottom of dial.  (horizontal)

if false: 
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", p[-165]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", p[-135]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", p[-120]);
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", p[-105]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", p[-90]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", p[-75]);
 dotlabel.ulft("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", p[-60]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", p[-45]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", p[-30]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", p[-15]);
fi; 


%% **** (4) Center of r2 and normal of r2, shifted to center of r2

q40 := get_center r2;
q41 := get_normal r2 * -1 shifted q40;

dotlabel.lft("$q_{40}$", q40);

s := "$q_{41}$ (normal to $r_2$)";
label.rt(s, q41);

drawarrow q40 -- q41 with_color red;

%% 90 deg.  Noon line on horizontal plane

%% 1:00 PM line on horizontal plane

%% **** (4) End of figure 1

endfig with_focus f0 no_sort;

%% ** (2) 

%% *** (3) Figure 2.  Parallel projection onto plane of dial.
%%         Since parallel projection onto an arbitrary plane currently isn't 
%%         all of the objects that need to be displayed are transformed 
%%         appropriately.
%%         LDF 2007.09.30.

beginfig(2); 

t1 := identity rotated (0, 0, latitude);
rotate t1 (180, 180);

c1 := c0;

r10 := r0;
r11 := r1;
r12 := r2;

c1 *= r10 *= r11 *= r12 *= t1;

for i = -165 step 15 until 180:
   draw origin -- (p[i] transformed t1);
endfor;


draw c1;
draw r10 with_color red;
draw r11 with_color green;

draw (p[-90] transformed t1) -- (p90 transformed t1) with_color blue;
draw (p0 transformed t1) -- (p180 transformed t1) with_color blue;

%% **** (4) Labels for top of dial.  (vertical)

dotlabel.ulft("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", 
   p180 transformed t1);
dotlabel.ulft("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", 
   p165 transformed t1);
dotlabel.ulft("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", 
   p150 transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", 
   p135 transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", 
   p120 transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", 
   p105 transformed t1);

dotlabel.top("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", 
   p90 transformed t1);

dotlabel.rt("\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", 
   p75 transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", 
   p60 transformed t1);

s := "\setbox0=\hbox{$(45^\circ)$}" 
     & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
     & "\box0}";

dotlabel.rt(s, p45 transformed t1);

dotlabel.rt("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", 
   p30 transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", 
   p15 transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", 
   p0 transformed t1);

%% **** (4) Labels for bottom of dial.  (horizontal)

dotlabel.llft("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", 
   p[-165] transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", 
   p[-150] transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", 
   p[-150] transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", 
   p[-135] transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", 
   p[-120] transformed t1);
dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", 
   p[-105] transformed t1);
dotlabel.bot("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", 
   p[-90] transformed t1);
dotlabel.lrt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", 
   p[-75] transformed t1);
dotlabel.urt("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", 
   p[-60] transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", 
   p[-45] transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", 
   p[-30] transformed t1);
dotlabel.rt("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", 
   p[-15] transformed t1);

%% **** (4) End of figure 2 

endfig with_projection parallel_z_y with_factor 1.25 no_sort; 

%% ** (2) 

%% *** (3) Figure 3:  Parallel projection onto vertical plane (plane of r2)

beginfig(3);

t3 := align (q40 -- q41) with_axis y_axis;
rotate t3 (0, -90);

r5 := r2 transformed t3;

%% **** (4) Get the vertices of r5

q42 := q6 transformed t3;
q43 := q4 transformed t3;
q44 := q8 transformed t3;
q45 := q9 transformed t3;

%% **** (4) Draw and label r5

draw r5;

dotlabel.rt("$q_{42}$", q42);
dotlabel.ulft("$q_{43}$", q43);
dotlabel.lft("$q_{44}$", q44);
dotlabel.rt("$q_{45}$", q45);


%% **** (4) Label the directions

label("Up", mediate(q44, q45) shifted (0, 0, 1));
label("Down", mediate(q42, q43) shifted (0, 0, -1.5));
label("East", mediate(q42, q45) shifted 1);
label("West", mediate(q43, q44) shifted -1);

%% **** (4) Draw the dial

dotlabel.top("$g_v$", gv transformed t3);

%% ***** (5) 6:00 AM (180 deg.)

dotlabel.lft("VI $q_{75}$", q75 transformed t3);

draw (gv -- q75) transformed t3;

%% ***** (5) 7:00 AM (165 deg.)

dotlabel.lft("VII $q_{73}$", q73 transformed t3);

draw (gv -- q73) transformed t3;



%% ***** (5) 8:00 AM (150 deg.)

dotlabel.lft("VIII $q_{71}$", q71 transformed t3);

draw (gv -- q71) transformed t3;

%% ***** (5) 9:00 AM (135 deg.)

dotlabel.bot("\vbox{\hbox{$q_{69}$}\hbox{IX}}", q69 transformed t3);

draw (gv -- q69) transformed t3;

%% ***** (5) 10:00 AM (120 deg.)

dotlabel.bot("\vbox{\hbox{$q_{67}$}\hbox{X}}", q67 transformed t3);

draw (gv -- q67) transformed t3;

%% ***** (5) 11:00 AM (105 deg.)

dotlabel.bot("\vbox{\hbox{$q_{65}$}\hbox{XI}}", q65 transformed t3);

draw (gv -- q65) transformed t3;


%% ***** (5) 90 deg.  (Noon)

draw (gv -- q11) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{11}$}\hbox{XII}}", q11 transformed t3);

%% ***** (5) 75 deg.  (1:00 PM)

draw (gv -- q56) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{56}$}\hbox{XIII}}", q56 transformed t3);

%% ***** (5) 60 deg. (2:00 PM) 

draw (gv -- q53) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{53}$}\hbox{XIV}}", q53 transformed t3);

%% ***** (5) 3:00 PM (45 deg.)

draw (gv -- q54) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{54}$}\hbox{XV}}", q54 transformed t3);

%% ***** (5) 4:00 PM (30 deg.)

dotlabel.rt("$q_{55}$ XVI", q55 transformed t3);

draw (gv -- q55) transformed t3;

%% ***** (5) 5:00 PM (30 deg.)

dotlabel.rt("$q_{61}$ XVII", q61 transformed t3);

draw (gv -- q61) transformed t3;


%% ***** (5) 6:00 PM (0 deg.)

dotlabel.rt("$q_{63}$ XVIII", q63 transformed t3);

draw (gv -- q63) transformed t3;




%% **** (4) End of figure 3

endfig with_projection parallel_x_z with_factor 1.5;  

%% ** (2) 

%% *** (3) Figure 4:  Parallel projection onto horizontal plane 
%% *** (3) (plane of r6)

beginfig(4);

t4 := align (q80 -- q81) with_axis y_axis;
rotate t4 (0, -90);

draw r6 transformed t4;


%% **** (4) Label the directions

label("North", q13 transformed t4 shifted (0, 0, 1.5));
label("South", mediate(q50 transformed t4, q51 transformed t4) shifted (0, 0, -1));
label("East", mediate(q51 transformed t4, q1 transformed t4) shifted 2.5);
label("West", mediate(q50 transformed t4, q0 transformed t4) shifted -2.5);

%% **** (4) Label the vertices of r6

dotlabel.llft("$q_{0}$",  q0 transformed t4);
dotlabel.bot("$q_{50}$", q50 transformed t4);
dotlabel.bot("$q_{51}$", q51 transformed t4);
dotlabel.lrt("$q_{1}$",   q1 transformed t4);

%% **** (4) The trace of the gnomon on the plane of r6

dotlabel.bot("$g_h$", gh  transformed t4);  


%% **** (4) Time division points and lines

%% ***** (5) 180 deg.  (6:00 AM)

draw (gh -- q76) transformed t4;
dotlabel.lft("VI $q_{76}$", q76 transformed t4);

%% ***** (5) 165 deg.  (7:00 AM)

draw (gh -- q74) transformed t4;
dotlabel.lft("VII $q_{74}$", q74 transformed t4);

%% ***** (5) 150 deg.  (8:00 AM)

draw (gh -- q72) transformed t4;
dotlabel.lft("VIII $q_{72}$", q72 transformed t4);

%% ***** (5) 135 deg.  (9:00 AM)

draw (gh -- q70) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{70}$}\hbox{IX}}", q70 transformed t4);


%% ***** (5) 120 deg.  (10:00 AM)

draw (gh -- q68) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{68}$}\hbox{X}}", q68 transformed t4);


%% ***** (5) 105 deg.  (11:00 AM)

draw (gh -- q66) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{66}$}\hbox{XI}}", q66 transformed t4);


%% ***** (5) 90 deg.  (Noon)

draw (gh -- q13) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{13}$}\hbox{XII}}", q13 transformed t4);


%% ***** (5) 75 deg.  (1:00 PM)

draw (gh -- q57) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{57}$}\hbox{XIII}}", q57 transformed t4);

%% ***** (5) 60 deg.  (2:00 PM)

draw (gh -- q58) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{58}$}\hbox{XIV}}", q58 transformed t4);

%% ***** (5) 45 deg. (3:00 PM)

draw (gh -- q59) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{59}$}\hbox{XV}}", q59 transformed t4);

%% ***** (5) 30 deg. (4:00 PM)

draw (gh -- q60) transformed t4;
dotlabel.rt("$q_{60}$ XVI", q60 transformed t4);

%% ***** (5) 15 deg. (5:00 PM)

draw (gh -- q62) transformed t4;
dotlabel.rt("$q_{62}$ XVII", q62 transformed t4);


%% ***** (5) 0 deg. (6:00 PM)

draw (gh -- q64) transformed t4;
dotlabel.rt("$q_{64}$ XVIII", q64 transformed t4);


%% **** (4) End of figure 4

endfig with_projection parallel_x_z with_factor 1.5;  

%% *** (3) Chicago.


%% **** (4) 

%% **** (4) Declarations and Initializations

point p[];     %% Points on the dial

point g[];     %% Points on the gnomon

point gv;      %% Trace of gnomon on vertical plane
point gh;      %% Trace of gnomon on horizontal plane

circle c[];    %% c0 is the dial

point q[];

rectangle r[];  

transform t[];

clear bpv;

string s;

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

plane m[];
path h[]v;
path h[]h;

%% **** (4) Parameters

radius := 5;

%% Goettingen:  latitude:  51 deg 32' N, longitude:   9 deg 56' E
%% Chicago:     latitude:  41 deg 54' N  longitude:  87 deg 39' W
%% London, UK:  51 deg. 30' 28'' N 0 deg. 7' 41'' W
%% 51 deg. 30' 28'' N == 51.5777 N

% latitude := 51.533;  %% Goettingen
latitude := 41.9;    %% Chicago
% latitude := 51.5777 %% London

%% **** (4) Set equatorial circle and surrounding rectangles

set c0 with_diameter (2 * radius) with_point_count 32;
r0 := out_rectangle c0;
r1 := r0 scaled (1.3, 0, 1.3);

t0 := identity rotated (90, 90);

c0 *= r0 *= r1 *= t0;

beginfig(5); 

dotlabel.lrt("$\rm{origin}$", origin);

g0 := (3 * radius, 0) rotated (0, 0, -latitude);
g1 := (-5 * radius, 0) rotated (0, 0, -latitude);

drawdblarrow g0 -- g1;

label.bot("$g_0$", g0);
label.top("$g_1$", g1);

p0 := (0, 0, radius);

%% **** (4) Points on top of dial (vertical)

for i = 15 step 15 until 180:
  p[i] := p[i - 15] rotated -15;
endfor;

for i = 0 step 15 until 180:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%% **** (4) Points on bottom of dial (horizontal)

for i = -15 step -15 until -165:
  p[i] := p[i + 15] rotated 15;
endfor;

for i = -15 step -15 until -165:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%draw p[75] -- p[-105];


%% **** (4) Rotate dial and surrounding rectangles.

t2 := identity rotated (0, 0, -latitude);

c0 *= r0 *= r1 *= t2;

%% **** (4) Draw and label the rectangles surrounding the dial

draw r0 with_color red;
draw r1 with_color green;

for i = 0 upto 3:
   q[28 + i] := get_point (i) r0;
   q[i] := get_point (i) r1;
endfor;


%% ***** (5) r0

dotlabel.bot("$q_{28}$", q28);
dotlabel.ulft("$q_{29}$", q29);
dotlabel.top("$q_{30}$", q30);
dotlabel.rt("$q_{31}$", q31);

label.lrt("$r_0$", mediate(q28, q31, .25)) with_text_color red;

%% ***** (5) r1

dotlabel.bot("$q_0$", q0);
dotlabel.ulft("$q_1$", q1);
dotlabel.top("$q_2$", q2);
dotlabel.rt("$q_3$", q3);

label.lrt("$r_1$", mediate(q0, q3)) with_text_color green;


%% **** (4) Get the rectangle perpendicular to r1, draw and label it (r4)

q4 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) 90;
q5 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) -90;

dotlabel.lft("$q_4$", q4);
dotlabel.lft("$q_5$", q5);


q6 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) 90;
q7 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) -90;

dotlabel.urt("$q_6$", q6);
dotlabel.lrt("$q_7$", q7);

r4 := (q5, q4, q6, q7);

draw r4 with_color cyan;

label.llft("$r_4$", mediate(q4, q5, .25)) with_text_color cyan;

%% **** (4) Find, draw and label the rectangle representing the vertical plane (r2)

q8 := q4 shifted (0, 14);
q9 := q6 shifted (0, 14);

dotlabel.lft("$q_8$", q8);
dotlabel.lft("$q_9$", q9);

r2 := (q6, q4, q8, q9);

draw r2 with_color red;

label.lft("$r_2$", mediate(q4, q8)) with_text_color red;



bpv := r2 intersection_points (g0 -- g1);

gv := bpv0;

dotlabel.urt("$g_v$", gv);


%% **** (4) 90 deg.  Noon line.

%% ***** (5) Vertical

q11 := mediate(q4, q6); %% Trace of noon line on vertical plane

dotlabel.rt("$q_{11}$", q11);

draw gv -- q11;

q12 := mediate(q5, q7);
dotlabel.lrt("$q_{12}$", q12);

draw q11 -- q12;

%% **** (4) Horizontal plane (plane of r6)

q50 := q0 shifted 12;
q51 := q1 shifted 12;

r6 := (q0, q1, q51, q50);

draw r6 with_color orange;

label.bot("$r_6$", mediate(q0, q50)) with_text_color orange;

q80 := get_center r6;
q81 := (get_normal r6 * -1) shifted q80;

dotlabel.llft("$q_{80}$", q80);
label.rt("\vbox{\hbox{$q_{81}$}\hbox{(normal to $r_6$)}}", q81);

drawarrow q80 -- q81 with_color orange;

dotlabel.bot("$q_{50}$", q50);
dotlabel.rt("$q_{51}$", q51);

bpv := r6 intersection_points (g0 -- g1);

gh := bpv0; %% Trace of gv on r6

dotlabel.urt("$g_h$", gh);

%% **** (4) Planes of the vertical and horizontal rectangles

m2 := get_plane r2;  %% Vertical
m6 := get_plane r6;  %% Horizontal

%% **** (4) 180 deg. (6:00 AM) 

m180 := (origin, gv, p180);

%% ***** (5) Vertical

h180v := m180 intersection m2;

bpv := h180v intersection_points r2;

q75 := bpv0;

dotlabel.lft("$q_{75}$", q75);

draw gv -- q75;

%% ***** (5) Horizontal

h180h := m180 intersection m6;

bpv := h180h intersection_points r6;

q76 := bpv1;

dotlabel.bot("$q_{76}$", q76);

draw gh -- q76;

%% **** (4) 165 deg. (7:00 AM) 

m165 := (origin, gv, p165);

%% ***** (5) Vertical

h165v := m165 intersection m2;

bpv := h165v intersection_points r2;

q73 := bpv0;

dotlabel.lft("$q_{73}$", q73);

draw gv -- q73;

%% ***** (5) Horizontal

h165h := m165 intersection m6;

bpv := h165h intersection_points r6;

q74 := bpv1;

dotlabel.bot("$q_{74}$", q74);

draw gh -- q74;

%% **** (4) 150 deg. (8:00 AM) 

m150 := (origin, gv, p150);

%% ***** (5) Vertical

h150v := m150 intersection m2;

bpv := h150v intersection_points r2;

q71 := bpv0;

dotlabel.lft("$q_{71}$", q71);

draw gv -- q71;

%% ***** (5) Horizontal

h150h := m150 intersection m6;

bpv := h150h intersection_points r6;

q72 := bpv1;

dotlabel.bot("$q_{72}$", q72);

draw gh -- q72;

%% **** (4) 135 deg. (9:00 AM) 

m135 := (origin, gv, p135);

%% ***** (5) Vertical

h135v := m135 intersection m2;

bpv := h135v intersection_points r2;

q69 := bpv0;

dotlabel.lrt("$q_{69}$", q69);

draw gv -- q69;

%% ***** (5) Horizontal

h135h := m135 intersection m6;

bpv := h135h intersection_points r6;

q70 := bpv0;

dotlabel.ulft("$q_{70}$", q70);

draw gh -- q70;




%% **** (4) 120 deg. (10:00 AM) 

m120 := (origin, gv, p120);

%% ***** (5) Vertical

h120v := m120 intersection m2;

bpv := h120v intersection_points r2;

q67 := bpv0;

dotlabel.rt("$q_{67}$", q67);

draw gv -- q67;

%% ***** (5) Horizontal

h120h := m120 intersection m6;

bpv := h120h intersection_points r6;

q68 := bpv0;

dotlabel.lft("$q_{68}$", q68);

draw gh -- q68;


%% **** (4) 105 deg. (11:00 AM) 

m105 := (origin, gv, p105);

%% ***** (5) Vertical

h105v := m105 intersection m2;

bpv := h105v intersection_points r2;

q65 := bpv0;

dotlabel.rt("$q_{65}$", q65);

draw gv -- q65;

%% ***** (5) Horizontal

h105h := m105 intersection m6;

bpv := h105h intersection_points r6;

q66 := bpv0;

dotlabel.lft("$q_{66}$", q66);

draw gh -- q66;


%% **** (4) 90 deg. (Noon)

q13 := mediate(q0, q1); %% Trace of noon line on horizontal plane

dotlabel.llft("$q_{13}$", q13);
draw gh -- q13;


%% **** (4) 75 deg.  (1:00 PM)

%% ***** (5) Vertical

m75 := (origin, gv, p75);

h75v := m75 intersection m2;

bpv := h75v intersection_points r2;

q56 := bpv0;

draw gv -- q56;

dotlabel.rt("$q_{56}$", q56);

%% ***** (5) Horizontal

h75h := m75 intersection m6;

bpv := h75h intersection_points r6;

q57 := bpv0;

draw gh -- q57;
dotlabel.ulft("$q_{57}$", q57);

%% **** (4) 60 deg. (2:00 PM)

m60 := (origin, gv, p60);

%% ***** (5) Vertical

h60v := m60 intersection m2;

bpv := h60v intersection_points r2;

q53 := bpv0;

dotlabel.rt("$q_{53}$", q53);

%% ***** (5) Horizontal

h60h := m60 intersection m6;

bpv := h60h intersection_points r6;

q58 := bpv0;

draw gh -- q58;
dotlabel.lft("$q_{58}$", q58);

%% **** (4) 45 deg. (3:00 PM) 

m45 := (origin, gv, p45);

%% ***** (5) Vertical

h45v := m45 intersection m2;

bpv := h45v intersection_points r2;

q54 := bpv0;

dotlabel.lrt("$q_{54}$", q54);

%% ***** (5) Horizontal

h45h := m45 intersection m6;

bpv := h45h intersection_points r6;

q59 := bpv0;

draw gh -- q59;
dotlabel.lft("$q_{59}$", q59);

%% **** (4) 30 deg. (4:00 PM) 

m30 := (origin, gv, p30);

%% ***** (5) Vertical

h30v := m30 intersection m2;

bpv := h30v intersection_points r2;

q55 := bpv1;

dotlabel.lrt("$q_{55}$", q55);

draw gv -- q55;

%% ***** (5) Horizontal

h30h := m30 intersection m6;

bpv := h30h intersection_points r6;

q60 := bpv0;

dotlabel.ulft("$q_{60}$", q60);

draw gh -- q60;


%% **** (4) 15 deg. (5:00 PM) 

m15 := (origin, gv, p15);

%% ***** (5) Vertical

h15v := m15 intersection m2;

bpv := h15v intersection_points r2;

q61 := bpv1;

dotlabel.urt("$q_{61}$", q61);

draw gv -- q61;

%% ***** (5) Horizontal

h15h := m15 intersection m6;

bpv := h15h intersection_points r6;

q62 := bpv0;

dotlabel.urt("$q_{62}$", q62);

draw gh -- q62;

%% **** (4) 0 deg. (18:00 PM) 

m0 := (origin, gv, p0);

%% ***** (5) Vertical

h0v := m0 intersection m2;

bpv := h0v intersection_points r2;

q63 := bpv1;

dotlabel.rt("$q_{63}$", q63);

draw gv -- q63;

%% ***** (5) Horizontal

h0h := m0 intersection m6;

bpv := h0h intersection_points r6;

q64 := bpv0;

dotlabel.top("$q_{64}$", q64);

draw gh -- q64;

%% **** (4) End of time divisions

%% **** (4) Draw dial

draw c0;

label.urt("$c_0$", get_point(16) c0 * .875 shifted (.1, 0));

%% ***** (5) Draw axes of equatorial dial

draw p0 -- p180 with_color blue with_pen path_pen;
draw p[-90] -- p90 with_color blue with_pen path_pen;

%% ***** (5) Draw time divisions on vertical dial

draw q16 -- gv;  %% 1:00 PM (75 deg.) 
draw gv -- q53;  %% 2:00 PM (60 deg.)
draw gv -- q54;  %% 3:00 PM (45 deg.)

%% ***** (5) 

%% **** (4) Labels for top of vertical dial.

if false: 
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", p180);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", p165);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", p150);
   dotlabel.llft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", p135);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", p120);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", p105);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", p90);
   
   dotlabel.lft("$p_{75} =$\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", p75);
   dotlabel.rt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", p60);

   s := "\setbox0=\hbox{$(45^\circ)$}" 
        & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
        & "\box0}";

   dotlabel.lft(s, p45);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", p30);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", p15);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", p0);
fi;

%% **** (4) Labels for bottom of dial.  (horizontal)

if false: 
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", p[-165]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", p[-135]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", p[-120]);
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", p[-105]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", p[-90]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", p[-75]);
 dotlabel.ulft("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", p[-60]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", p[-45]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", p[-30]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", p[-15]);
fi; 


%% **** (4) Center of r2 and normal of r2, shifted to center of r2

q40 := get_center r2;
q41 := get_normal r2 * -1 shifted q40;

dotlabel.lft("$q_{40}$", q40);

s := "$q_{41}$ (normal to $r_2$)";
label.rt(s, q41);

drawarrow q40 -- q41 with_color red;

%% 90 deg.  Noon line on horizontal plane

%% 1:00 PM line on horizontal plane

%% **** (4) End of figure 5

endfig with_focus f0 no_sort;


%% *** (3) Figure 6:  Parallel projection onto vertical plane (plane of r2)

beginfig(6);

t3 := align (q40 -- q41) with_axis y_axis;
rotate t3 (0, -90);

r5 := r2 transformed t3;

%% **** (4) Get the vertices of r5

q42 := q6 transformed t3;
q43 := q4 transformed t3;
q44 := q8 transformed t3;
q45 := q9 transformed t3;

%% **** (4) Draw and label r5

draw r5;

dotlabel.rt("$q_{42}$", q42);
dotlabel.ulft("$q_{43}$", q43);
dotlabel.lft("$q_{44}$", q44);
dotlabel.rt("$q_{45}$", q45);


%% **** (4) Label the directions

label("Up", mediate(q44, q45) shifted (0, 0, 1));
label("Down", mediate(q42, q43) shifted (0, 0, -1.5));
label("East", mediate(q42, q45) shifted 1);
label("West", mediate(q43, q44) shifted -1);

%% **** (4) Draw the dial

dotlabel.top("$g_v$", gv transformed t3);

%% ***** (5) 6:00 AM (180 deg.)

dotlabel.lft("VI $q_{75}$", q75 transformed t3);

draw (gv -- q75) transformed t3;

%% ***** (5) 7:00 AM (165 deg.)

dotlabel.lft("VII $q_{73}$", q73 transformed t3);

draw (gv -- q73) transformed t3;



%% ***** (5) 8:00 AM (150 deg.)

dotlabel.lft("VIII $q_{71}$", q71 transformed t3);

draw (gv -- q71) transformed t3;

%% ***** (5) 9:00 AM (135 deg.)

dotlabel.bot("\vbox{\hbox{$q_{69}$}\hbox{IX}}", q69 transformed t3);

draw (gv -- q69) transformed t3;

%% ***** (5) 10:00 AM (120 deg.)

dotlabel.bot("\vbox{\hbox{$q_{67}$}\hbox{X}}", q67 transformed t3);

draw (gv -- q67) transformed t3;

%% ***** (5) 11:00 AM (105 deg.)

dotlabel.bot("\vbox{\hbox{$q_{65}$}\hbox{XI}}", q65 transformed t3);

draw (gv -- q65) transformed t3;


%% ***** (5) 90 deg.  (Noon)

draw (gv -- q11) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{11}$}\hbox{XII}}", q11 transformed t3);

%% ***** (5) 75 deg.  (1:00 PM)

draw (gv -- q56) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{56}$}\hbox{XIII}}", q56 transformed t3);

%% ***** (5) 60 deg. (2:00 PM) 

draw (gv -- q53) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{53}$}\hbox{XIV}}", q53 transformed t3);

%% ***** (5) 3:00 PM (45 deg.)

draw (gv -- q54) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{54}$}\hbox{XV}}", q54 transformed t3);

%% ***** (5) 4:00 PM (30 deg.)

dotlabel.rt("$q_{55}$ XVI", q55 transformed t3);

draw (gv -- q55) transformed t3;

%% ***** (5) 5:00 PM (30 deg.)

dotlabel.rt("$q_{61}$ XVII", q61 transformed t3);

draw (gv -- q61) transformed t3;


%% ***** (5) 6:00 PM (0 deg.)

dotlabel.rt("$q_{63}$ XVIII", q63 transformed t3);

draw (gv -- q63) transformed t3;

%% **** (4) End of figure 6

endfig with_projection parallel_x_z with_factor 1.5;  

%% *** (3) Figure 7:  Parallel projection onto horizontal plane 
%% *** (3) (plane of r6)

beginfig(7);

t4 := align (q80 -- q81) with_axis y_axis;
rotate t4 (0, -90);

draw r6 transformed t4;


%% **** (4) Label the directions

label("North", q13 transformed t4 shifted (0, 0, 1.5));
label("South", mediate(q50 transformed t4, q51 transformed t4) shifted (0, 0, -1));
label("East", mediate(q51 transformed t4, q1 transformed t4) shifted 2.5);
label("West", mediate(q50 transformed t4, q0 transformed t4) shifted -2.5);

%% **** (4) Label the vertices of r6

dotlabel.llft("$q_{0}$",  q0 transformed t4);
dotlabel.bot("$q_{50}$", q50 transformed t4);
dotlabel.bot("$q_{51}$", q51 transformed t4);
dotlabel.lrt("$q_{1}$",   q1 transformed t4);

%% **** (4) The trace of the gnomon on the plane of r6

dotlabel.bot("$g_h$", gh  transformed t4);  


%% **** (4) Time division points and lines

%% ***** (5) 180 deg.  (6:00 AM)

draw (gh -- q76) transformed t4;
dotlabel.lft("VI $q_{76}$", q76 transformed t4);

%% ***** (5) 165 deg.  (7:00 AM)

draw (gh -- q74) transformed t4;
dotlabel.lft("VII $q_{74}$", q74 transformed t4);

%% ***** (5) 150 deg.  (8:00 AM)

draw (gh -- q72) transformed t4;
dotlabel.lft("VIII $q_{72}$", q72 transformed t4);

%% ***** (5) 135 deg.  (9:00 AM)

draw (gh -- q70) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{70}$}\hbox{IX}}", q70 transformed t4);


%% ***** (5) 120 deg.  (10:00 AM)

draw (gh -- q68) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{68}$}\hbox{X}}", q68 transformed t4);


%% ***** (5) 105 deg.  (11:00 AM)

draw (gh -- q66) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{66}$}\hbox{XI}}", q66 transformed t4);


%% ***** (5) 90 deg.  (Noon)

draw (gh -- q13) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{13}$}\hbox{XII}}", q13 transformed t4);


%% ***** (5) 75 deg.  (1:00 PM)

draw (gh -- q57) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{57}$}\hbox{XIII}}", q57 transformed t4);

%% ***** (5) 60 deg.  (2:00 PM)

draw (gh -- q58) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{58}$}\hbox{XIV}}", q58 transformed t4);

%% ***** (5) 45 deg. (3:00 PM)

draw (gh -- q59) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{59}$}\hbox{XV}}", q59 transformed t4);

%% ***** (5) 30 deg. (4:00 PM)

draw (gh -- q60) transformed t4;
dotlabel.rt("$q_{60}$ XVI", q60 transformed t4);

%% ***** (5) 15 deg. (5:00 PM)

draw (gh -- q62) transformed t4;
dotlabel.rt("$q_{62}$ XVII", q62 transformed t4);


%% ***** (5) 0 deg. (6:00 PM)

draw (gh -- q64) transformed t4;
dotlabel.rt("$q_{64}$ XVIII", q64 transformed t4);

%% **** (4) End of figure 7

endfig with_projection parallel_x_z with_factor 1.5;  

%% *** (3) End of code for Chicago

%% *** (3) Beginning of code for London 

%% **** (4) Declarations and Initializations

point p[];     %% Points on the dial

point g[];     %% Points on the gnomon

point gv;      %% Trace of gnomon on vertical plane
point gh;      %% Trace of gnomon on horizontal plane

circle c[];    %% c0 is the dial

point q[];

rectangle r[];  

transform t[];

clear bpv;

string s;

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

plane m[];
path h[]v;
path h[]h;

%% **** (4) Parameters

radius := 5;

%% Goettingen:  latitude:  51 deg 32' N, longitude:   9 deg 56' E
%% Chicago:     latitude:  41 deg 54' N  longitude:  87 deg 39' W
%% London, UK:  51 deg. 30' 28'' N 0 deg. 7' 41'' W
%% 51 deg. 30' 28'' N == 51.5777 N

% latitude := 51.533;  %% Goettingen
% latitude := 41.9;    %% Chicago

latitude := 51.5777; %% London

%% **** (4) Set equatorial circle and surrounding rectangles

set c0 with_diameter (2 * radius) with_point_count 32;
r0 := out_rectangle c0;
r1 := r0 scaled (1.3, 0, 1.3);

t0 := identity rotated (90, 90);

c0 *= r0 *= r1 *= t0;


beginfig(8); 

dotlabel.lrt("$\rm{origin}$", origin);

g0 := (3 * radius, 0) rotated (0, 0, -latitude);
g1 := (-5 * radius, 0) rotated (0, 0, -latitude);

drawdblarrow g0 -- g1;

label.bot("$g_0$", g0);
label.top("$g_1$", g1);

p0 := (0, 0, radius);

%% **** (4) Points on top of dial (vertical)

for i = 15 step 15 until 180:
  p[i] := p[i - 15] rotated -15;
endfor;

for i = 0 step 15 until 180:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%% **** (4) Points on bottom of dial (horizontal)

for i = -15 step -15 until -165:
  p[i] := p[i + 15] rotated 15;
endfor;

for i = -15 step -15 until -165:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%draw p[75] -- p[-105];


%% **** (4) Rotate dial and surrounding rectangles.

t2 := identity rotated (0, 0, -latitude);

c0 *= r0 *= r1 *= t2;

%% **** (4) Draw and label the rectangles surrounding the dial

draw r0 with_color red;
draw r1 with_color green;

for i = 0 upto 3:
   q[28 + i] := get_point (i) r0;
   q[i] := get_point (i) r1;
endfor;


%% ***** (5) r0

dotlabel.bot("$q_{28}$", q28);
dotlabel.ulft("$q_{29}$", q29);
dotlabel.top("$q_{30}$", q30);
dotlabel.rt("$q_{31}$", q31);

label.lrt("$r_0$", mediate(q28, q31, .25)) with_text_color red;

%% ***** (5) r1

dotlabel.bot("$q_0$", q0);
dotlabel.ulft("$q_1$", q1);
dotlabel.top("$q_2$", q2);
dotlabel.rt("$q_3$", q3);

label.lrt("$r_1$", mediate(q0, q3)) with_text_color green;


%% **** (4) Get the rectangle perpendicular to r1, draw and label it (r4)

q4 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) 90;
q5 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) -90;

dotlabel.lft("$q_4$", q4);
dotlabel.lft("$q_5$", q5);


q6 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) 90;
q7 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) -90;

dotlabel.urt("$q_6$", q6);
dotlabel.lrt("$q_7$", q7);

r4 := (q5, q4, q6, q7);

draw r4 with_color cyan;

label.llft("$r_4$", mediate(q4, q5, .25)) with_text_color cyan;

%% **** (4) Find, draw and label the rectangle representing the vertical plane (r2)

q8 := q4 shifted (0, 14);
q9 := q6 shifted (0, 14);

dotlabel.lft("$q_8$", q8);
dotlabel.lft("$q_9$", q9);

r2 := (q6, q4, q8, q9);

draw r2 with_color red;

label.lft("$r_2$", mediate(q4, q8)) with_text_color red;



bpv := r2 intersection_points (g0 -- g1);

gv := bpv0;

dotlabel.urt("$g_v$", gv);


%% **** (4) 90 deg.  Noon line.

%% ***** (5) Vertical

q11 := mediate(q4, q6); %% Trace of noon line on vertical plane

dotlabel.rt("$q_{11}$", q11);

draw gv -- q11;

q12 := mediate(q5, q7);
dotlabel.lrt("$q_{12}$", q12);

draw q11 -- q12;

%% **** (4) Horizontal plane (plane of r6)

q50 := q0 shifted 12;
q51 := q1 shifted 12;

r6 := (q0, q1, q51, q50);

draw r6 with_color orange;

label.bot("$r_6$", mediate(q0, q50)) with_text_color orange;

q80 := get_center r6;
q81 := (get_normal r6 * -1) shifted q80;

dotlabel.llft("$q_{80}$", q80);
label.rt("\vbox{\hbox{$q_{81}$}\hbox{(normal to $r_6$)}}", q81);

drawarrow q80 -- q81 with_color orange;

dotlabel.bot("$q_{50}$", q50);
dotlabel.rt("$q_{51}$", q51);

bpv := r6 intersection_points (g0 -- g1);

gh := bpv0; %% Trace of gv on r6

dotlabel.urt("$g_h$", gh);

%% **** (4) Planes of the vertical and horizontal rectangles

m2 := get_plane r2;  %% Vertical
m6 := get_plane r6;  %% Horizontal

%% **** (4) 180 deg. (6:00 AM) 

m180 := (origin, gv, p180);

%% ***** (5) Vertical

h180v := m180 intersection m2;

bpv := h180v intersection_points r2;

q75 := bpv0;

dotlabel.lft("$q_{75}$", q75);

draw gv -- q75;

%% ***** (5) Horizontal

h180h := m180 intersection m6;

bpv := h180h intersection_points r6;

q76 := bpv1;

dotlabel.bot("$q_{76}$", q76);

draw gh -- q76;

%% **** (4) 165 deg. (7:00 AM) 

m165 := (origin, gv, p165);

%% ***** (5) Vertical

h165v := m165 intersection m2;

bpv := h165v intersection_points r2;

q73 := bpv0;

dotlabel.lft("$q_{73}$", q73);

draw gv -- q73;

%% ***** (5) Horizontal

h165h := m165 intersection m6;

bpv := h165h intersection_points r6;

q74 := bpv1;

dotlabel.bot("$q_{74}$", q74);

draw gh -- q74;

%% **** (4) 150 deg. (8:00 AM) 

m150 := (origin, gv, p150);

%% ***** (5) Vertical

h150v := m150 intersection m2;

bpv := h150v intersection_points r2;

q71 := bpv0;

dotlabel.lft("$q_{71}$", q71);

draw gv -- q71;

%% ***** (5) Horizontal

h150h := m150 intersection m6;

bpv := h150h intersection_points r6;

q72 := bpv1;

dotlabel.bot("$q_{72}$", q72);

draw gh -- q72;

%% **** (4) 135 deg. (9:00 AM) 

m135 := (origin, gv, p135);

%% ***** (5) Vertical

h135v := m135 intersection m2;

bpv := h135v intersection_points r2;

q69 := bpv0;

dotlabel.lrt("$q_{69}$", q69);

draw gv -- q69;

%% ***** (5) Horizontal

h135h := m135 intersection m6;

bpv := h135h intersection_points r6;

q70 := bpv0;

dotlabel.ulft("$q_{70}$", q70);

draw gh -- q70;




%% **** (4) 120 deg. (10:00 AM) 

m120 := (origin, gv, p120);

%% ***** (5) Vertical

h120v := m120 intersection m2;

bpv := h120v intersection_points r2;

q67 := bpv0;

dotlabel.rt("$q_{67}$", q67);

draw gv -- q67;

%% ***** (5) Horizontal

h120h := m120 intersection m6;

bpv := h120h intersection_points r6;

q68 := bpv0;

dotlabel.lft("$q_{68}$", q68);

draw gh -- q68;


%% **** (4) 105 deg. (11:00 AM) 

m105 := (origin, gv, p105);

%% ***** (5) Vertical

h105v := m105 intersection m2;

bpv := h105v intersection_points r2;

q65 := bpv0;

dotlabel.rt("$q_{65}$", q65);

draw gv -- q65;

%% ***** (5) Horizontal

h105h := m105 intersection m6;

bpv := h105h intersection_points r6;

q66 := bpv0;

dotlabel.lft("$q_{66}$", q66);

draw gh -- q66;


%% **** (4) 90 deg. (Noon)

q13 := mediate(q0, q1); %% Trace of noon line on horizontal plane

dotlabel.llft("$q_{13}$", q13);
draw gh -- q13;


%% **** (4) 75 deg.  (1:00 PM)

%% ***** (5) Vertical

m75 := (origin, gv, p75);

h75v := m75 intersection m2;

bpv := h75v intersection_points r2;

q56 := bpv0;

draw gv -- q56;

dotlabel.rt("$q_{56}$", q56);

%% ***** (5) Horizontal

h75h := m75 intersection m6;

bpv := h75h intersection_points r6;

q57 := bpv0;

draw gh -- q57;
dotlabel.ulft("$q_{57}$", q57);

%% **** (4) 60 deg. (2:00 PM)

m60 := (origin, gv, p60);

%% ***** (5) Vertical

h60v := m60 intersection m2;

bpv := h60v intersection_points r2;

q53 := bpv0;

dotlabel.rt("$q_{53}$", q53);

%% ***** (5) Horizontal

h60h := m60 intersection m6;

bpv := h60h intersection_points r6;

q58 := bpv0;

draw gh -- q58;
dotlabel.lft("$q_{58}$", q58);

%% **** (4) 45 deg. (3:00 PM) 

m45 := (origin, gv, p45);

%% ***** (5) Vertical

h45v := m45 intersection m2;

bpv := h45v intersection_points r2;

q54 := bpv0;

dotlabel.lrt("$q_{54}$", q54);

%% ***** (5) Horizontal

h45h := m45 intersection m6;

bpv := h45h intersection_points r6;

q59 := bpv0;

draw gh -- q59;
dotlabel.lft("$q_{59}$", q59);

%% **** (4) 30 deg. (4:00 PM) 

m30 := (origin, gv, p30);

%% ***** (5) Vertical

h30v := m30 intersection m2;

bpv := h30v intersection_points r2;

q55 := bpv1;

dotlabel.lrt("$q_{55}$", q55);

draw gv -- q55;

%% ***** (5) Horizontal

h30h := m30 intersection m6;

bpv := h30h intersection_points r6;

q60 := bpv0;

dotlabel.ulft("$q_{60}$", q60);

draw gh -- q60;


%% **** (4) 15 deg. (5:00 PM) 

m15 := (origin, gv, p15);

%% ***** (5) Vertical

h15v := m15 intersection m2;

bpv := h15v intersection_points r2;

q61 := bpv1;

dotlabel.urt("$q_{61}$", q61);

draw gv -- q61;

%% ***** (5) Horizontal

h15h := m15 intersection m6;

bpv := h15h intersection_points r6;

q62 := bpv0;

dotlabel.urt("$q_{62}$", q62);

draw gh -- q62;

%% **** (4) 0 deg. (18:00 PM) 

m0 := (origin, gv, p0);

%% ***** (5) Vertical

h0v := m0 intersection m2;

bpv := h0v intersection_points r2;

q63 := bpv1;

dotlabel.rt("$q_{63}$", q63);

draw gv -- q63;

%% ***** (5) Horizontal

h0h := m0 intersection m6;

bpv := h0h intersection_points r6;

q64 := bpv0;

dotlabel.top("$q_{64}$", q64);

draw gh -- q64;

%% **** (4) End of time divisions

%% **** (4) Draw dial

draw c0;

label.urt("$c_0$", get_point(16) c0 * .875 shifted (.1, 0));

%% ***** (5) Draw axes of equatorial dial

draw p0 -- p180 with_color blue with_pen path_pen;
draw p[-90] -- p90 with_color blue with_pen path_pen;

%% ***** (5) Draw time divisions on vertical dial

draw q16 -- gv;  %% 1:00 PM (75 deg.) 
draw gv -- q53;  %% 2:00 PM (60 deg.)
draw gv -- q54;  %% 3:00 PM (45 deg.)

%% ***** (5) 

%% **** (4) Labels for top of vertical dial.

if false: 
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", p180);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", p165);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", p150);
   dotlabel.llft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", p135);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", p120);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", p105);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", p90);
   
   dotlabel.lft("$p_{75} =$\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", p75);
   dotlabel.rt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", p60);

   s := "\setbox0=\hbox{$(45^\circ)$}" 
        & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
        & "\box0}";

   dotlabel.lft(s, p45);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", p30);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", p15);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", p0);
fi;

%% **** (4) Labels for bottom of dial.  (horizontal)

if false: 
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", p[-165]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", p[-135]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", p[-120]);
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", p[-105]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", p[-90]);

 dotlabel.urt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", p[-75]);
 dotlabel.ulft("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", p[-60]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", p[-45]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", p[-30]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", p[-15]);
fi; 


%% **** (4) Center of r2 and normal of r2, shifted to center of r2

q40 := get_center r2;
q41 := get_normal r2 * -1 shifted q40;

dotlabel.lft("$q_{40}$", q40);

s := "$q_{41}$ (normal to $r_2$)";
label.rt(s, q41);

drawarrow q40 -- q41 with_color red;

%% 90 deg.  Noon line on horizontal plane

%% 1:00 PM line on horizontal plane

%% **** (4) End of figure 8

endfig with_focus f0 no_sort;


%% *** (3) Figure 9:  Parallel projection onto vertical plane (plane of r2)

beginfig(9);

t3 := align (q40 -- q41) with_axis y_axis;
rotate t3 (0, -90);

r5 := r2 transformed t3;

%% **** (4) Get the vertices of r5

q42 := q6 transformed t3;
q43 := q4 transformed t3;
q44 := q8 transformed t3;
q45 := q9 transformed t3;

%% **** (4) Draw and label r5

draw r5;

dotlabel.rt("$q_{42}$", q42);
dotlabel.ulft("$q_{43}$", q43);
dotlabel.lft("$q_{44}$", q44);
dotlabel.rt("$q_{45}$", q45);


%% **** (4) Label the directions

label("Up", mediate(q44, q45) shifted (0, 0, 1));
label("Down", mediate(q42, q43) shifted (0, 0, -1.5));
label("East", mediate(q42, q45) shifted 1);
label("West", mediate(q43, q44) shifted -1);

%% **** (4) Draw the dial

dotlabel.top("$g_v$", gv transformed t3);

%% ***** (5) 6:00 AM (180 deg.)

dotlabel.lft("VI $q_{75}$", q75 transformed t3);

draw (gv -- q75) transformed t3;

%% ***** (5) 7:00 AM (165 deg.)

dotlabel.lft("VII $q_{73}$", q73 transformed t3);

draw (gv -- q73) transformed t3;



%% ***** (5) 8:00 AM (150 deg.)

dotlabel.lft("VIII $q_{71}$", q71 transformed t3);

draw (gv -- q71) transformed t3;

%% ***** (5) 9:00 AM (135 deg.)

dotlabel.bot("\vbox{\hbox{$q_{69}$}\hbox{IX}}", q69 transformed t3);

draw (gv -- q69) transformed t3;

%% ***** (5) 10:00 AM (120 deg.)

dotlabel.bot("\vbox{\hbox{$q_{67}$}\hbox{X}}", q67 transformed t3);

draw (gv -- q67) transformed t3;

%% ***** (5) 11:00 AM (105 deg.)

dotlabel.bot("\vbox{\hbox{$q_{65}$}\hbox{XI}}", q65 transformed t3);

draw (gv -- q65) transformed t3;


%% ***** (5) 90 deg.  (Noon)

draw (gv -- q11) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{11}$}\hbox{XII}}", q11 transformed t3);

%% ***** (5) 75 deg.  (1:00 PM)

draw (gv -- q56) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{56}$}\hbox{XIII}}", q56 transformed t3);

%% ***** (5) 60 deg. (2:00 PM) 

draw (gv -- q53) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{53}$}\hbox{XIV}}", q53 transformed t3);

%% ***** (5) 3:00 PM (45 deg.)

draw (gv -- q54) transformed t3; 
dotlabel.bot("\vbox{\hbox{$q_{54}$}\hbox{XV}}", q54 transformed t3);

%% ***** (5) 4:00 PM (30 deg.)

dotlabel.rt("$q_{55}$ XVI", q55 transformed t3);

draw (gv -- q55) transformed t3;

%% ***** (5) 5:00 PM (30 deg.)

dotlabel.rt("$q_{61}$ XVII", q61 transformed t3);

draw (gv -- q61) transformed t3;


%% ***** (5) 6:00 PM (0 deg.)

dotlabel.rt("$q_{63}$ XVIII", q63 transformed t3);

draw (gv -- q63) transformed t3;

%% **** (4) End of figure 9

endfig with_projection parallel_x_z with_factor 1.5;  

%% *** (3) Figure 10:  Parallel projection onto horizontal plane 
%% *** (3) (plane of r6)

beginfig(10);

t4 := align (q80 -- q81) with_axis y_axis;
rotate t4 (0, -90);

draw r6 transformed t4;


%% **** (4) Label the directions

label("North", q13 transformed t4 shifted (0, 0, 1.5));
label("South", mediate(q50 transformed t4, q51 transformed t4) shifted (0, 0, -1));
label("East", mediate(q51 transformed t4, q1 transformed t4) shifted 2.5);
label("West", mediate(q50 transformed t4, q0 transformed t4) shifted -2.5);

%% **** (4) Label the vertices of r6

dotlabel.llft("$q_{0}$",  q0 transformed t4);
dotlabel.bot("$q_{50}$", q50 transformed t4);
dotlabel.bot("$q_{51}$", q51 transformed t4);
dotlabel.lrt("$q_{1}$",   q1 transformed t4);

%% **** (4) The trace of the gnomon on the plane of r6

dotlabel.bot("$g_h$", gh  transformed t4);  


%% **** (4) Time division points and lines

%% ***** (5) 180 deg.  (6:00 AM)

draw (gh -- q76) transformed t4;
dotlabel.lft("VI $q_{76}$", q76 transformed t4);

%% ***** (5) 165 deg.  (7:00 AM)

draw (gh -- q74) transformed t4;
dotlabel.lft("VII $q_{74}$", q74 transformed t4);

%% ***** (5) 150 deg.  (8:00 AM)

draw (gh -- q72) transformed t4;
dotlabel.lft("VIII $q_{72}$", q72 transformed t4);

%% ***** (5) 135 deg.  (9:00 AM)

draw (gh -- q70) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{70}$}\hbox{IX}}", q70 transformed t4);


%% ***** (5) 120 deg.  (10:00 AM)

draw (gh -- q68) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{68}$}\hbox{X}}", q68 transformed t4);


%% ***** (5) 105 deg.  (11:00 AM)

draw (gh -- q66) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{66}$}\hbox{XI}}", q66 transformed t4);


%% ***** (5) 90 deg.  (Noon)

draw (gh -- q13) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{13}$}\hbox{XII}}", q13 transformed t4);


%% ***** (5) 75 deg.  (1:00 PM)

draw (gh -- q57) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{57}$}\hbox{XIII}}", q57 transformed t4);

%% ***** (5) 60 deg.  (2:00 PM)

draw (gh -- q58) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{58}$}\hbox{XIV}}", q58 transformed t4);

%% ***** (5) 45 deg. (3:00 PM)

draw (gh -- q59) transformed t4;
dotlabel.top("\vbox{\hbox{$q_{59}$}\hbox{XV}}", q59 transformed t4);

%% ***** (5) 30 deg. (4:00 PM)

draw (gh -- q60) transformed t4;
dotlabel.rt("$q_{60}$ XVI", q60 transformed t4);

%% ***** (5) 15 deg. (5:00 PM)

draw (gh -- q62) transformed t4;
dotlabel.rt("$q_{62}$ XVII", q62 transformed t4);


%% ***** (5) 0 deg. (6:00 PM)

draw (gh -- q64) transformed t4;
dotlabel.rt("$q_{64}$ XVIII", q64 transformed t4);

%% **** (4) End of figure 10

endfig with_projection parallel_x_z with_factor 1.5;  


%% *** (3) End of  code for London 

end;

%% ** (2) 

%% *** (3) Sundial 1

%% \begingroup

%% **** (4) TeX code explaining figure 1

%% \parskip=.5\baselineskip
%% \advance\hsize by -2cm

%% Let $g_0$ and $g_1$ be points on a line passing through the origin
%% such that the line $g_0g_1$ lies in the x-y plane and its angle to the
%% x-z plane is $51^\circ 32'$ (the latitude of G{\"o}ttingen, Germany).
%% $g_0g_1$ represents the gnomon.

%% Let $c_0$ be a circle with its center at the origin and lying in a
%% plane perpendicular to $g_0g_1$. Let $r_0$ be the square enclosing
%% $c_0$ and $r_1$ be a larger square in the same plane as $r_0$ and
%% $c_0$, whose center is also at the origin and whose sides are parallel
%% to those of $r_0$.

%% Let $r_4$ be a rectangle perpendicular to $r_1$ such that the vertices $q_0$
%% and $q_1$ of $r_1$ are the midpoints of the sides $q_4q_5$ and $q_6q_7$ of
%% $r_4$.

%% Let $r_2$ be the rectangle ${q_4}{q_6}{q_9}{q_8}$ such that 
%% the vectors $q_8 - q_4$ and $q_9 - q_6$ are vertical, i.e., their
%% y-components are non-zero and their x and z components are 0.

%% Let $q_{13}$ be the intersection point of the line $q_0q_1$ with the
%% x-y plane.  The line through the origin and $q_{13}$ is the
%% intersection of the x-y plane with the plane of $c_0$ and represents 
%% the projection of the gnomon $g_0g_1$ onto the plane of $c_0$ at noon.
%% (The section of this line within the circumference of $c_0$ is drawn
%% in blue.)

%% The point $q_{10}$ is the intersection of the gnomon $g_0g_1$ with the
%% plane of $r_2$ and the line $q_{10}q_{11}$ is the intersection of the
%% x-y plane with the plane of $r_2$.  It represents the projection of
%% the gnomon $g_0g_1$ onto the plane of $r_2$ at noon.

%% Let point $p_{75}$ be the point on the circumference of $c_0$ such
%% that the angle between the line from the origin to $p_{75}$ and the
%% line from the origin through $q_{13}$ is $15^\circ$ and the
%% z-coordinate of $p_{75}$ is positive (in a left-handed coordinate
%% system).  (The point is to the {\it right\/} of the label.  This point
%% is also labelled 
%% ``\uppercase\expandafter{\romannumeral 13} $(75^\circ)$''.)
%% The line from the origin to $p_{75}$ thus represents the 
%% projection of the gnomon $g_0g_1$ onto the plane of $c_0$ at 1:00 PM.

%% The origin and the points $q_{10}$ and $p_{75}$ determine the plane
%% $w_0$.  The point $q_{14}$ is an intersection point of $w_0$ with the
%% rectangle $r_1$ and the point $q_{16}$ is an intersection point of
%% $w_0$ with the rectangle $r_2$.

%% The line $q_{10}q_{16}$ thus represents the projection of the gnomon
%% onto the plane of $r_2$ at 1.00 PM.

%% The same principle would apply to any ``hour lines'' or other lines
%% representing time divisions on $c_0$, which represents the
%% dial of an equatorial sundial:  The intersection of the plane $w_n$ through
%% the origin, a point on the line representing the time division, and a
%% point on the gnomon not in the plane of $c_0$ and 
%% the plane of $r_2$ will be a line representing the same time division
%% on the plane of $r_2$.  The set of these lines on the plane of $r_2$
%% would constitute the dial of a vertical sundial.  They would radiate
%% from $q_{10}$.

%% In addition, the intersection of a plane $w_n$ representing a time
%% division on $c_0$ with any other plane $v$ will also represent the
%% corresponding time division on a dial lying in $v$.

%% The rectangle $r_3$ was found by rotating $r_2$ about the axis
%% $q_4q_8$ by $5^\circ$ (counterclockwise as seen when looking 
%% downward from $q_8$ onto $q_4$).  The point $q_{17} = q_{23}$ was
%% found by taking the point $q_6$ and performing the same rotation on
%% it. $r_3$ was then rotated about the
%% axis $q_4q_{17}$ by $5^\circ$ (counterclockwise as seen when looking 
%% from $q_4$ onto $q_17$). 

%% The point $q_{18}$ is the intersection of the gnomon $g_0g_1$ with the
%% plane of $r_3$.  The line $q_{18}q_{22}$ is the intersection of the
%% plane $w_0$ with the plane of $r_3$. 
%% It thus represents the projection of the gnomon onto 
%% the plane of $r_3$ at 1.00 PM.
%% \par
%% \endgroup

%% \vfil\eject


%% !! TODO:  There seems to be a bug in the rule and/or function for
%%           finding the intersection point of two paths.
%%           Finding the intersection points of a path and a rectangle
%%           works, though, so that's what's used here.
%%
%%           This doesn't quite make sense to me, because 
%%           `Polygon::intersection_point' calls 
%%           `Point::intersection_point'.  That is, ultimately,
%%           the same function is being called.  I also 
%%           programmed `Point::intersection_point' carefully.
%%           LDF 2007.09.30.

%% **** (4) 

focus f[];

set f0 with_position (0, 5, -12) with_direction (0, 5, 10) with_distance 10;

%% **** (4) Parameters

radius := 5;

%% Goettingen:  latitude:  51 deg 32' N, longitude:  9 deg 56' E

latitude := 51.533;  %% Goettingen

%% **** (4) Declarations and Initializations

point p[];     %% Points on the dial

point g[];     %% Points on the gnomon

circle c[];    %% c0 is the dial

point q[];

path m[];

rectangle r[];  

transform t[];

bool_point_vector bpv;

string s;

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

%% **** (4) 

set c0 with_diameter (2 * radius) with_point_count 32;
r0 := out_rectangle c0;
r1 := r0 scaled (1.3, 0, 1.3);

t0 := identity rotated (90, 90);

c0 *= r0 *= r1 *= t0;

%% **** (4) Figure 1

pickup pencircle scaled (.575mm, .575mm);

beginfig(1); 

dotlabel.lrt("$\rm{origin}$", origin);

g0 := (3 * radius, 0) rotated (0, 0, -latitude);
g1 := (-5 * radius, 0) rotated (0, 0, -latitude);

drawdblarrow g0 -- g1;

label.bot("$g_0$", g0);
label.top("$g_1$", g1);

p0 := (0, 0, radius);

%% **** (4) Points on top of dial (vertical)

for i = 15 step 15 until 180:
  p[i] := p[i - 15] rotated -15;
endfor;

for i = 0 step 15 until 180:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

%% **** (4) Points on bottom of dial (horizontal)

for i = -15 step -15 until -165:
  p[i] := p[i + 15] rotated 15;
endfor;

for i = -15 step -15 until -165:
   rotate p[i] (0, 0, -latitude);
   if false: 
      draw origin -- p[i];
   fi; 
endfor;

draw p[75] -- p[-105];


%% **** (4) Rotate dial and surrounding rectangles.

t2 := identity rotated (0, 0, -latitude);

c0 *= r0 *= r1 *= t2;

%% **** (4) Draw and label the rectangles surrounding the dial

draw r0 with_color red;
draw r1 with_color green;

for i = 0 upto 3:
   q[28 + i] := get_point (i) r0;
   q[i] := get_point (i) r1;
endfor;

%% ***** (5) r0

dotlabel.bot("$q_{28}$", q28);
dotlabel.ulft("$q_{29}$", q29);
dotlabel.top("$q_{30}$", q30);
dotlabel.rt("$q_{31}$", q31);

label.lrt("$r_0$", mediate(q28, q31, .25)) with_text_color red;

%% ***** (5) r1

dotlabel.bot("$q_0$", q0);
dotlabel.ulft("$q_1$", q1);
dotlabel.top("$q_2$", q2);
dotlabel.rt("$q_3$", q3);

label.lrt("$r_1$", mediate(q0, q3)) with_text_color green;

%% **** (4) Get the rectangle perpendicular to r1, draw and label it (r4)

q4 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) 90;
q5 := unit_vector(q3 - q0) * 2 shifted q0 rotated_around(q0, q1) -90;

dotlabel.lft("$q_4$", q4);
dotlabel.lft("$q_5$", q5);


q6 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) 90;
q7 := unit_vector(q2 - q1) * 2 shifted q1 rotated_around(q0, q1) -90;

dotlabel.urt("$q_6$", q6);
dotlabel.lrt("$q_7$", q7);


r4 := (q5, q4, q6, q7);

draw r4 with_color cyan;

label.llft("$r_4$", mediate(q4, q5, .25)) with_text_color cyan;

%% **** (4) Find, draw and label the rectangle representing the vertical plane (r2)

q8 := q4 shifted (0, 14);
q9 := q6 shifted (0, 14);

dotlabel.lft("$q_8$", q8);
dotlabel.lft("$q_9$", q9);

r2 := (q6, q4, q8, q9);

draw r2 with_color red;

label.lft("$r_2$", mediate(q4, q8)) with_text_color red;

%% **** (4) 

bpv := r2 intersection_points (g0 -- g1);

q10 := bpv0;

dotlabel.rt("$q_{10}$", q10);

q11 := mediate(q4, q6);

dotlabel.llft("$q_{11}$", q11);

draw q10 -- q11;

q12 := mediate(q5, q7);
dotlabel.lrt("$q_{12}$", q12);

draw q11 -- q12;

q13 := mediate(q0, q1);
dotlabel.llft("$q_{13}$", q13);

draw p90 -- q13 with_color blue;

bpv := (p[-105] -- p75) intersection_points r1;

q14 := bpv0;
q15 := bpv1;

dotlabel.top("$q_{14}$", q14) with_text_color magenta;
dotlabel.top("$q_{15}$", q15) with_text_color magenta;

draw q14 -- q15 dashed evenly;

point n[];

n0 := (get_normal c0 * -1) shifted q14;


bpv := (q14 -- n0) intersection_points r2;

q16 := bpv0;

draw q16 -- q10 dashed evenly;

dotlabel.rt("$q_{16}$ $(75^\circ)$", q16);
draw q14 -- q16 dashed evenly;

t3 := identity rotated_around (q4, q8) 5;

q17 := q6;
r3 := r2;

r3 *= q17 *= t3;

dotlabel.llft("$q_{17}$", q17);

rotate_around r3 (q4, q17) 5;

%% **** (4) Find the points on r3 (the skew plane)

for i = 0 upto 3:
   q[23 + i] := get_point (i) r3;
endfor;

q27 := mediate(q24, q25);

%% Label the points on r3 (the skew plane)

dotlabel.ulft("$q_{23}$", q23); 
dotlabel.rt("$q_{24}$", q24);
dotlabel.top("$q_{25}$", q25);
dotlabel.top("$q_{26}$", q26);

%% **** (4) Label r3 (the skew plane)

label.lft("$r_{3}$", q27) with_text_color magenta;

draw r3 with_color magenta;

bpv := r3 intersection_points (g0 -- g1);

q18 := bpv0;

dotlabel.rt("$q_{18}$", q18);

q19 := mediate(q16, q10);

dotlabel.lrt("$q_{19}$", q19);

q20 := .5 * q10;

dotlabel.rt("$q_{20}$", q20);

bpv := r3 intersection_points (q20 -- q19);

q21 := bpv0;

drawarrow q20 -- q21 dashed evenly;

label.llft("$q_{21}$", q21);

bpv := r3 intersection_points (q18 -- q21);

q22 := bpv0;
dotlabel.lft("$q_{22}$", q22);

draw q18 -- q22 dashed evenly with_color red;

%% **** (4) Find the normal to r3

q32 := get_center r3;

s := "\setbox0=\hbox{(center of $r_3$)}\vbox{\hbox to \wd0{\hfil $q_{32}$}\box0}";

dotlabel.lft(s, q32);

q33 := get_normal r3 * -6 shifted q32;

s := "\setbox0=\hbox{(normal to $r_3$)}\vbox{\hbox to \wd0{$q_{33}$\hfil}\box0}";

drawarrow q32 -- q33 dashed evenly with_color magenta;

label.lrt(s, q33);

t4 := align (q32 -- q33) with_axis y_axis;


%% **** (4) Draw dial


draw c0;

label.urt("$c_0$", get_point(16) c0 * .875 shifted (.1, 0));


%% **** (4) Draw axes of dial

draw p0 -- p180 with_color blue with_pen path_pen;
draw p[-90] -- p90 with_color blue with_pen path_pen;

%% **** (4) Labels for top of dial.  (vertical)

if false: 
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", p180);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", p165);
   dotlabel.lrt("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", p150);
   dotlabel.llft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", p135);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", p120);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", p105);

fi; 

dotlabel.lft("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", p90);
dotlabel.lft("$p_{75} =$\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", p75);


if false: 
   dotlabel.lft("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", p60);

   s := "\setbox0=\hbox{$(45^\circ)$}" 
        & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
        & "\box0}";

   dotlabel.lft(s, p45);

   dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", p30);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", p15);
   dotlabel.lft("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", p0);
fi; 

%% **** (4) Labels for bottom of dial.  (horizontal)

if false: 
 dotlabel.lrt("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", p[-165]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", p[-135]);
 dotlabel.rt("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", p[-120]);
fi;

dotlabel.lrt("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", p[-105]);
dotlabel.urt("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", p[-90]);

if false: 
 dotlabel.urt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", p[-75]);
 dotlabel.ulft("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", p[-60]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", p[-45]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", p[-30]);
 dotlabel.lft("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", p[-15]);
fi; 



%% **** (4) End of figure 1

endfig with_focus f0 no_sort;

%% *** (3) Figure 2.  Parallel projection onto plane of dial.
%%         Since parallel projection onto an arbitrary plane currently isn't 
%%         all of the objects that need to be displayed are transformed 
%%         appropriately.
%%         LDF 2007.09.30.

beginfig(2); 

t1 := identity rotated (0, 0, latitude);
rotate t1 (180, 180);

c0 *= r0 *= r1 *= r2 *= t1;

for i = -165 step 15 until 180:
   p[i] *= t1;
   draw origin -- p[i];
endfor;

for i = 0 upto 16:
   q[i] *= t1;
endfor;

dotlabel.top("$q_{14}$ $(75^\circ)$", q14);
dotlabel.bot("$q_{15}$", q15);

draw c0;
draw r0 with_color red;
draw r1 with_color green;

draw p[-90] -- p90 with_color blue;
draw p0 -- p180 with_color blue;

draw q14 -- q15 dashed evenly;
draw q14 -- q16 dashed evenly;


%% **** (4) Labels for top of dial.  (vertical)

dotlabel.ulft("\uppercase\expandafter{\romannumeral 6} $(180^\circ)$", p180);
dotlabel.ulft("\uppercase\expandafter{\romannumeral 7} $(165^\circ)$", p165);
dotlabel.ulft("\uppercase\expandafter{\romannumeral 8} $(150^\circ)$", p150);
dotlabel.lft("\uppercase\expandafter{\romannumeral 9} $(135^\circ)$", p135);
dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(120^\circ)$", p120);
dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(105^\circ)$", p105);

dotlabel.top("\uppercase\expandafter{\romannumeral 12} $(90^\circ)$", p90);

dotlabel.rt("\uppercase\expandafter{\romannumeral 13} $(75^\circ)$", p75);
dotlabel.rt("\uppercase\expandafter{\romannumeral 14} $(60^\circ)$", p60);

s := "\setbox0=\hbox{$(45^\circ)$}" 
     & "\vbox{\hbox to \wd0{\hfil\uppercase\expandafter{\romannumeral 15}}"
     & "\box0}";

dotlabel.rt(s, p45);

dotlabel.rt("\uppercase\expandafter{\romannumeral 16} $(30^\circ)$", p30);
dotlabel.rt("\uppercase\expandafter{\romannumeral 17} $(15^\circ)$", p15);
dotlabel.rt("\uppercase\expandafter{\romannumeral 18} $(0^\circ)$", p0);

%% **** (4) Labels for bottom of dial.  (horizontal)

dotlabel.llft("\uppercase\expandafter{\romannumeral 7} $(-165^\circ)$", p[-165]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 8} $(-150^\circ)$", p[-150]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 9} $(-135^\circ)$", p[-135]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 10} $(-120^\circ)$", p[-120]);
dotlabel.lft("\uppercase\expandafter{\romannumeral 11} $(-105^\circ)$", p[-105]);
dotlabel.bot("\uppercase\expandafter{\romannumeral 12} $(-90^\circ)$", p[-90]);
dotlabel.lrt("\uppercase\expandafter{\romannumeral 13} $(-75^\circ)$", p[-75]);
dotlabel.urt("\uppercase\expandafter{\romannumeral 14} $(-60^\circ)$", p[-60]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 15} $(-45^\circ)$", p[-45]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 16} $(-30^\circ)$", p[-30]);
dotlabel.rt("\uppercase\expandafter{\romannumeral 17} $(-15^\circ)$", p[-15]);

%% **** (4) End of figure 2 

endfig with_projection parallel_z_y with_factor 1.25 no_sort; 


%% *** (3) Figure 3.  Parallel projection onto the skew plane r3

beginfig(3); 

%% **** (4) Transform objects such that r3 comes to lie on the x-z plane. 

rotate t4 (0, -90);

q18 *= q22 *= q23 *= q24 *= q25 *= q26 *= r3 *= t4;

%% **** (4) Draw and label r3 and its corner points.

draw r3 with_color magenta;

dotlabel.urt("$q_{23}$", q23);   
dotlabel.lrt("$q_{24}$", q24);   
dotlabel.llft("$q_{25}$", q25);   
dotlabel.ulft("$q_{26}$", q26);   

%% **** (4) Label q18, the intersection of the gnomon with r3 and q22, the
%% **** (4) intersection of the hour line for 1:00 PM with the bottom edge 
%% **** (4) of r3.         

dotlabel.top("$q_{18}$", q18);   
dotlabel.bot("$q_{22}$", q22);   

draw q18 -- q22 dashed evenly with_color red;


q34 := mediate(q23, q24);

endfig with_projection parallel_x_z;

end;

%% ** (2) 

%% *** (3) Finding the "apparent edge" of a cylinder.
%%         (This is what all the following is in aid of.)

%%         LDF 2007.09.26.

%%         The following code performs these actions:

%%         1.  Draw points and paths representing
%%             a focus f0 and its plane of projection along with a circle c0
%%             that lies in the x-z plane.  

%%         2.  Take points on c0 and finds their projections 
%%             on the plane of projection for f0.  
%%
%%         3.  Create a conic_section_lattice k using
%%             the projections of the points on c0.

%%         4.  Traverse k to find points on the ellipse e that
%%             represents the projection of c0 on the plane of projection
%%             for f0.

%%         The next step will be to find the parameters of e
%%         and create a corresponding object of type `ellipse'.

%%         I have already tested this procedure by writing a prototype 
%%         using 3DLDF.  The sample is in `sample0.ldf' or `sample1.ldf'.
%%         I now need to go back to the C++ function 
%%         `Conic_Section_Lattice::get_ellipse', which already exists,
%%         and get it to work.  It will require a considerable amount 
%%         of error-handling code, which wasn't needed in the prototype. 

%%         The plane of projection belonging to f0 is represented by the
%%         rectangle r0.
%%         Figure 1 is output using another focus, f1,
%%         which is located behind f0, but with the same direction.
%%         This makes it possible to draw the objects which represent f0.
%%         Figure 2 is output using f0 itself.
%%         Figure 3 is output using a different focus, which makes it 
%%         possible to see the objects represent f0 from the side, along with 
%%         c0.
%%         Making this example has turned out to be trickier than expected.

%% **** (4) Declarations and Initializations

focus f[];

transform t[];

circle c[];
ellipse e[];

conic_section_lattice k;

point p[];

point L[];  %% Lattice points of conic_section_lattice

path q[];
rectangle r[];

bool_point_vector bpv;
point_vector pv;
point_vector qv;

string s[];

pen dot_pen;
pen path_pen;

dist := 5;  %% Distance for the focuses f0 and f2.

%% **** (4) Focus 0

p0 := (0, 10, 10);  	        %% Position		   
p1 := (0, 10, 11);  	        %% Direction		   
p2 := p0 shifted (0, 0, dist);  %% Center of projection plane

r0 := unit_rectangle scaled (12, 0, 12) rotated (90, 0) shifted p2;

shift r0 by 3;

t0 := identity shifted (0, 0, -10);
rotate t0 (15, 15);
shift t0 (0, 10, 10);

r0 *= p0 *= p1 *= p2 *= t0;

% for i = 0 upto 2:
%   s0 := "p" & decimal i & ":";
%   message s0; 
%   show p[i];
% endfor;

set f0 with_position p0 with_direction p1 with_distance dist;

%% **** (4) Focus 1
%%          Behind f0 so that the latter can be drawn.

p3 := mediate(p1, p0, 1.5);  %% position f1

set f1 with_position p3 with_direction p1 with_distance 5;

%% **** (4) Circle c0

set c0 with_diameter 100;
rotate c0 (30, 0);
shift c0 (0, 0, 150);

p9 := get_point 0 c0;
p10 := p9 projected f0;

p11 := get_point 5 c0;
p12 := p11 projected f0;

p13 := get_point 10 c0;
p14 := p13 projected f0;

p15 := get_point 15 c0;
p16 := p15 projected f0;

p17 := get_point 20 c0;
p18 := p17 projected f0;

p19 := get_point 25 c0;
p20 := p19 projected f0;

p21 := get_point 30 c0;
p22 := p21 projected f0;


%% ***** (5) Test projected points here.

q0 := r0;  %% For use with `distance_to_plane'.
           %% TODO:  Add parser rule for this command with a `rectangle'
           %% argument.


% bpv := (p17 -- p0) intersection_points r0;

% message "bpv0:"; 
% show bpv0;

% message "p18:"; 
% show p18;

% message "p18 distance_to_plane q0:"; 
% show p18 distance_to_plane q0;


%% **** (4) Put together the path representing the projection 
%%          of c0 on the plane of projection for f0

%% **** (4) Make a conic_section_lattice using these points.

for i = 10 step 2 until 22:
   pv += p[i];
endfor;

k := get_conic_section_lattice pv;

% message "k:"; 
% show k;

qv := traverse k (0, 5) with_increment .1;

% message "size qv:"; 
% show size qv;

% message "qv:"; 
% show qv;

% message "last qv"; 
% show last qv;

L0 := get_lattice_point 0, k;

%% **** (4) Call `get_ellipse' on k.  Working on the underlying function,
%%          i.e., `Conic_Section_Lattice::get_ellipse'.
%%          LDF 2007.09.26.

e0 := get_ellipse k;

message "e0:"; 
show e0;

show "\n";

message "size e0:"; 
show size e0;



%% **** (4) Focus 2

p3 := p0; %% Position		   
p4 := p1; %% Direction		   
p5 := p2; %% Center of projection plane

p8 := get_up f0;

t1 := identity;
shift t1 (20, 0);
rotate_around t1 (p0, p8) 45;

p3 *= p4 *= p5 *= t1;

set f2 with_position p3 with_direction p4 with_distance 5;

p6 := unit_vector(p1 - p0) shifted p0;

pickup pencircle scaled (.3mm, .3mm);
dot_pen := pencircle scaled (1mm, 1mm);
path_pen := pencircle scaled (.5mm, .5mm);



%% **** (4) Figure 1 (focus 1)

beginfig(1);

draw c0 with_color blue with_pen path_pen;
draw r0;

dotlabel.top("$p_0$", p0); 

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

% dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
% dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
% dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
% dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
% dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
% dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
% dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0


for i = 0 upto (size qv - 1):
   drawdot qv[i] with_color green with_pen dot_pen;
endfor;

draw_lattice k, .5 with_color red with_pen path_pen;

dotlabel.top("$L_0$", L0);

endfig with_focus f1; 

%% **** (4) Figure 2 (focus 0)

beginfig(2);

draw c0 with_color blue with_pen path_pen;

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

% dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
% dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
% dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
% dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
% dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
% dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
% dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0

draw r0;

for i = 0 upto (size qv - 1):
   drawdot qv[i] with_color green with_pen dot_pen;
endfor;

draw_lattice k, .5 with_color red with_pen path_pen;
dotlabel.top("$L_0$", L0);

endfig with_focus f0;

%% **** (4) Figure 3 (focus 2)

beginfig(3);

draw c0 with_color blue with_pen path_pen;
draw r0;

dotlabel.top("$p_0$", p0);  %% Position of f0

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

% dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
% dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
% dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
% dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
% dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
% dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
% dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0

draw p9  -- p0 dashed evenly;
draw p11 -- p0 dashed evenly;
draw p13 -- p0 dashed evenly;
draw p15 -- p0 dashed evenly;
draw p17 -- p0 dashed evenly;
draw p19 -- p0 dashed evenly;
draw p21 -- p0 dashed evenly;

for i = 0 upto (size qv - 1):
   drawdot qv[i] with_color green with_pen dot_pen;
endfor;

draw_lattice k, .5 with_color red with_pen path_pen;
dotlabel.top("$L_0$", L0);

endfig with_focus f2 no_sort;

end;

%% ** (2) 

%% *** (3) Rotating objects.
%%
%%         Adding special rules for rotating focuses has made it necessary 
%%         to add individual rules for rotating objects of other types.
%%         In the past, this was done by two rules which used the 
%%         non-terminal symbol `any_variable'.  (This symbol is used
%%         in the code for the GNU Bison grammar and has no 
%%         corresponding type in the 3DLDF language.)
%%       
%%         I would like to get rid of the `any_variable' symbol anyway,
%%         but it still works for the other transformation commands 
%%         (i.e., other than `rotate'), so I'm keeping it for the present.
%%         
%%         LDF 2007.09.26.

beginfig(1); 

circle c;
ellipse e;

rectangle r;

e := unit_ellipse scaled 5;
c := unit_circle scaled 5;
r := unit_rectangle scaled 5;

% rotate c (5, 0);
% rotate c by 5;

rotate e (15, 0);
rotate e by 5;
shift e (0, 0, 10);
draw e;

%rotate r (5, 0);
%rotate r by 5;

endfig; 

end;

%% ** (2) 

%% *** (3) Finding the "apparent edge" of a cylinder.
%%         (This is what all the following is in aid of.)
%%
%%         LDF 2007.09.26.
%%         
%%         The following code draws points and paths representing
%%         a focus f0 and its plane of projection along with a circle c0
%%         that lies in the x-z plane.  
%%         It then takes points on c0 and finds their projections 
%%         on the plane of projection for f0.  The points representing
%%         the projections are put onto the path q1.
%%
%%         The plane of projection belonging to f0 is represented by the
%%         rectangle r0.
%%         Figure 1 is output using another focus, f1,
%%         which is located behind f0, but with the same direction.
%%         This makes it possible to draw the objects which represent f0.
%%         Figure 2 is output using f0 itself.
%%         Figure 3 is output using a different focus, which makes it 
%%         possible to see the objects represent f0 from the side, along with 
%%         c0.
%%         Making this example has turned out to be trickier than expected.
%% 
%%         The next step will be to create a `conic_section_lattice' using
%%         the points on q1.

%% **** (4) Declarations

point p[];
path q[];
focus f[];
circle c[];
rectangle r[];

transform t[];
bool_point_vector bpv;

string s[];

dist := 5;  %% Distance for the focuses f0 and f2.

%% **** (4) Focus 0

p0 := (0, 10, 10);  	        %% Position		   
p1 := (0, 10, 11);  	        %% Direction		   
p2 := p0 shifted (0, 0, dist);  %% Center of projection plane

r0 := unit_rectangle scaled (7, 0, 7) rotated (90, 0) shifted p2;

t0 := identity shifted (0, 0, -10);
rotate t0 (15, 15);
shift t0 (0, 10, 10);

r0 *= p0 *= p1 *= p2 *= t0;

for i = 0 upto 2:
  s0 := "p" & decimal i & ":";
  message s0; 
  show p[i];
endfor;

set f0 with_position p0 with_direction p1 with_distance dist;

%% **** (4) Focus 1
%%          Behind f0 so that the latter can be drawn.

p3 := mediate(p1, p0, 1.5);  %% position f1

set f1 with_position p3 with_direction p1 with_distance 5;

%% **** (4) Circle c0

set c0 with_diameter 50;
rotate c0 (30, 0);
shift c0 (0, 0, 150);

p9 := get_point 0 c0;
p10 := p9 projected f0;

p11 := get_point 5 c0;
p12 := p11 projected f0;

p13 := get_point 10 c0;
p14 := p13 projected f0;

p15 := get_point 15 c0;
p16 := p15 projected f0;

p17 := get_point 20 c0;
p18 := p17 projected f0;

p19 := get_point 25 c0;
p20 := p19 projected f0;

p21 := get_point 30 c0;
p22 := p21 projected f0;


%% ***** (5) Test projected points here.

q0 := r0;  %% For use with `distance_to_plane'.
           %% TODO:  Add parser rule for this command with a `rectangle'
           %% argument.


bpv := (p17 -- p0) intersection_points r0;

message "bpv0:"; 
show bpv0;

message "p18:"; 
show p18;

message "p18 distance_to_plane q0:"; 
show p18 distance_to_plane q0;


%% **** (4) Put together the path representing the projection 
%%          of c0 on the plane of projection for f0

q1 := p10 .. p12 .. p14 .. p16 .. p18 .. p20 .. p22 .. cycle;

%% **** (4) Focus 2

p3 := p0; %% Position		   
p4 := p1; %% Direction		   
p5 := p2; %% Center of projection plane

p8 := get_up f0;

t1 := identity;
shift t1 (20, 0);
rotate_around t1 (p0, p8) 45;

p3 *= p4 *= p5 *= t1;

set f2 with_position p3 with_direction p4 with_distance 5;

p6 := unit_vector(p1 - p0) shifted p0;

%% **** (4) Figure 1 (focus 1)

beginfig(1);

draw c0 with_color blue;
draw r0;

draw q1 with_color red;

dotlabel.top("$p_0$", p0); 

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0

endfig with_focus f1; 

%% **** (4) Figure 2 (focus 0)

beginfig(2);

draw c0 with_color blue;
draw q1 with_color red dashed evenly;

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0

draw r0;

endfig with_focus f0;

%% **** (4) Figure 3 (focus 2)

beginfig(3);

draw c0 with_color blue;
draw r0;
draw q1 with_color red;

dotlabel.top("$p_0$", p0);  %% Position of f0

dotlabel.bot("$p_9$",    p9);   %% Point 0 of c0
dotlabel.bot("$p_{11}$", p11);  %% Point 5 of c0
dotlabel.bot("$p_{13}$", p13);  %% Point 10 of c0
dotlabel.bot("$p_{15}$", p15);  %% Point 15 of c0
dotlabel.bot("$p_{17}$", p17);  %% Point 20 of c0
dotlabel.bot("$p_{19}$", p19);  %% Point 25 of c0
dotlabel.bot("$p_{21}$", p21);  %% Point 30 of c0

dotlabel.top("$p_{10}$", p10);  %% Projection of p9 using f0
dotlabel.top("$p_{12}$", p12);  %% Projection of p11 using f0
dotlabel.top("$p_{14}$", p14);  %% Projection of p13 using f0
dotlabel.top("$p_{16}$", p16);  %% Projection of p15 using f0
dotlabel.top("$p_{18}$", p18);  %% Projection of p17 using f0
dotlabel.top("$p_{20}$", p20);  %% Projection of p19 using f0
dotlabel.top("$p_{22}$", p22);  %% Projection of p21 using f0

draw p9  -- p0 dashed evenly;
draw p11 -- p0 dashed evenly;
draw p13 -- p0 dashed evenly;
draw p15 -- p0 dashed evenly;
draw p17 -- p0 dashed evenly;
draw p19 -- p0 dashed evenly;
draw p21 -- p0 dashed evenly;

endfig with_focus f2;

end;

%% ** (2) 

%% *** (3) Transforming a focus.  
%%         The `tilt' command.
%%         LDF 2007.09.24.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 28cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% **** (4) Tilting

%% ***** (5) Declarations

focus f[];

circle c[];

c0 := unit_circle shifted (0, 0, 5) scaled 2;
c1 := c0 shifted (0, 5);

point p[];

path q[];

%% **** (4) Focus 0

p0 := (1, 10, 0);         %% position f0     
p1 := (-3.765, 4, 5);     %% direction f0    

set f0 with_position p0 with_direction p1 with_distance 20;

%% ***** (5) Figure 1

beginfig(1); 

p2 := get_up f0;

p3 := get_normal f0;

label.rt("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
%label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 1

endfig;

%% ***** (5) Focus 1 (f1)
%% f1 is like f0, but with its position point behind that of f0 on the line
%% position -- direction (p0 -- p1).  
%% The perspective of a picture output using f1 is therefore similar 
%% (but not exactly the same) as the perspective of a picture output using f0, 
%% but the position of f0 can be drawn in it.
%%
%% The line p0 -- p1 is represented as a point, because it is the line of vision
%% when using f1, too.
%%
%% LDF 2007.09.17.

p10 := mediate(p1, p0, 2.5);

set f1 with_position p10 with_direction p1 with_distance 20;

%% ***** (5) Figure 2

beginfig(2); 

dotlabel.lft("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 2

endfig with_focus f1;

%% ***** (5) Figure 3

beginfig(3); 

message "up of f0 before rotation:"; 
show p2;

message "normal of f0 before rotation:"; 
show p3;

%tilt f0 (45, 0, 0);   %% "Tilting" performs rotation about the "focus axes"
                         %% per default.  If the `with_main_axes' is used,
                         %% it performs rotation about the main axes instead.
                         %% The option `with_focus_axes' can be used explicitly 
                         %% for rotation about the focus axes.
                         %% LDF 2007.09.24.

%tilt f0 (0, 45, 0);   %% Rotation about the y-axis.

%tilt f0 (0, 0, 45);   %% Rotation about the z-axis.

%tilt f0 (5, 10, 0);   %% Rotation about the x and y-axes.

%tilt f0 (5, 0, 15);   %% Rotation about the x and z-axes.

%tilt f0 (0, 10, 15);   %% Rotation about the y and z-axes.

tilt f0 (5, 10, 15);   %% Rotation about all three axes.

p20 := get_position f0;
p21 := get_direction f0;
p22 := get_up f0;
p23 := get_normal f0;

message "";

message "up of f0 after rotation:"; 
show p22;

message "normal of f0 after rotation:"; 
show p23;

dotlabel.ulft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.lrt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 3

endfig;

%% ***** (5) Figure 4

beginfig(4); 

dotlabel.lft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.rt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 4

endfig with_focus f1;

end;

%% ***** (5)

%% **** (4)
 
%% ** (2) 

%% *** (3) Transforming a focus.  
%%
%%         Changed the way rotation works.  `rotate' no causes rotation 
%%         about the main axes by default.  Rotation about the
%%         focus axes now requires the option `with_focus_axes'.  
%%
%%         Added the command `tilt', which performs rotation 
%%         about the focus axes by default.  Have not tested it yet.
%%         I plan to add the "transformer" `tilted' and get 
%%         the "transformer" `rotated' to work with focuses.
%%         LDF 2007.09.24.
%%
%%         Rotating about the main axes.
%%         This seems to work, but I haven't tested it at all, 
%%         except to confirm that the following code doesn't 
%%         fail.
%%         LDF 2007.09.19.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 28cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% **** (4) Rotation about the main axes.

%% ***** (5) Declarations

focus f[];

circle c[];

c0 := unit_circle shifted (0, 0, 5) scaled 2;
c1 := c0 shifted (0, 5);

point p[];

path q[];

%% **** (4) Focus 0

p0 := (1, 10, 0);         %% position f0     
p1 := (-3.765, 4, 5);     %% direction f0    

set f0 with_position p0 with_direction p1 with_distance 20;

%% ***** (5) Figure 1

beginfig(1); 

p2 := get_up f0;

p3 := get_normal f0;

label.rt("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
%label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 1

endfig;

%% ***** (5) Focus 1 (f1)
%% f1 is like f0, but with its position point behind that of f0 on the line
%% position -- direction (p0 -- p1).  
%% The perspective of a picture output using f1 is therefore similar 
%% (but not exactly the same) as the perspective of a picture output using f0, 
%% but the position of f0 can be drawn in it.
%%
%% The line p0 -- p1 is represented as a point, because it is the line of vision
%% when using f1, too.
%%
%% LDF 2007.09.17.

p10 := mediate(p1, p0, 2.5);

set f1 with_position p10 with_direction p1 with_distance 20;

%% ***** (5) Figure 2

beginfig(2); 

dotlabel.lft("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 2

endfig with_focus f1;

%% ***** (5) Figure 3

beginfig(3); 

message "up of f0 before rotation:"; 
show p2;

message "normal of f0 before rotation:"; 
show p3;

%rotate f0 (45, 0, 0);   %% Rotation about the main axes is the default.
                         %% Rotation about the focus axes must be
                         %% specified explicitly.  

%rotate f0 (0, 45, 0);   %% Rotation about the y-axis.

%rotate f0 (0, 0, 45);   %% Rotation about the z-axis.

%rotate f0 (5, 10, 0);   %% Rotation about the x and y-axes.

%rotate f0 (5, 0, 15);   %% Rotation about the x and z-axes.

%rotate f0 (0, 10, 15);   %% Rotation about the y and z-axes.

rotate f0 (5, 10, 15);   %% Rotation about all three axes.

p20 := get_position f0;
p21 := get_direction f0;
p22 := get_up f0;
p23 := get_normal f0;

message "";

message "up of f0 after rotation:"; 
show p22;

message "normal of f0 after rotation:"; 
show p23;

dotlabel.ulft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.lrt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 3

endfig;

%% ***** (5) Figure 4

beginfig(4); 

dotlabel.lft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.rt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 4

endfig with_focus f1;

end;

%% ***** (5)

%% **** (4)
 
%% ** (2) 

%% *** (3) Transforming a focus.  Rotating about the "focus axes".
%%         LDF 2007.09.19.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 28cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% **** (4) Rotation.

%% ***** (5) Declarations

focus f[];

circle c[];

c0 := unit_circle shifted (0, 0, 5) scaled 2;
c1 := c0 shifted (0, 5);

point p[];

path q[];

%% **** (4) Focus 0

p0 := (1, 10, 0);         %% position f0     
p1 := (-3.765, 4, 5);     %% direction f0    

set f0 with_position p0 with_direction p1 with_distance 20;

%% ***** (5) Figure 1

beginfig(1); 

p2 := get_up f0;

p3 := get_normal f0;

label.rt("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
%label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 1

endfig;

%% ***** (5) Focus 1 (f1)
%% f1 is like f0, but with its position point behind that of f0 on the line
%% position -- direction (p0 -- p1).  
%% The perspective of a picture output using f1 is therefore similar 
%% (but not exactly the same) as the perspective of a picture output using f0, 
%% but the position of f0 can be drawn in it.
%%
%% The line p0 -- p1 is represented as a point, because it is the line of vision
%% when using f1, too.
%%
%% LDF 2007.09.17.

p10 := mediate(p1, p0, 2.5);

set f1 with_position p10 with_direction p1 with_distance 20;

%% ***** (5) Figure 2

beginfig(2); 

dotlabel.lft("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);
label.lft("$p_3$ (normal of $f_0$)", p3);

drawarrow p0 -- p1;
drawarrow p0 -- p2;
drawarrow p0 -- p3;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 2

endfig with_focus f1;

%% ***** (5) Figure 3

beginfig(3); 

message "up of f0 before rotation:"; 
show p2;

message "normal of f0 before rotation:"; 
show p3;

%rotate f0 (15);                 %% Default is rotation about the "focus axes".
%rotate f0 (15) with_focus_axes; %% This can be specified explicitly.
                                 %% Rotation about the focus axes seems to work now.
                                 %% However, I have not yet tested it thoroughly.

%rotate f0 (15) with_main_axes;  %% Rotation about the main axes must be specified
                                 %% explicitly.  PLEASE NOTE:  This doesn't work yet.

%% The `position', `direction', and `up' elements of a focus, together with the normal
%% to the plane that they form, can be considered to form a set of axes similar to those
%% of the main coordinate axes.  

%% x-axis: normal   -- position.   Rotation about this axis affects `direction' and `up'
%% y-axis: position -- up.         Rotation about this axis affects `direction' and `normal'
%% z-axis: position -- direction.  Rotation about this axis affects `up' and `normal'

%% PLEASE NOTE!  When a focus is rotated using the focus axes, the axis about which
%% the rotation is performed doesn't move, but the other two do.  If more than one
%% angle is specified (and greater than the `tolerance' value), the second and/or third 
%% rotations are performed about the axes _in their new positions_.

%% Rotation never affects the `position' element of a `focus', only `direction', 
%% `up', and `normal'. 

rotate f0 (45, 0, 0);  %% Rotation about the x-axis.

%rotate f0 (0, 45, 0);   %% Rotation about the y-axis.

%rotate f0 (0, 0, 45);   %% Rotation about the z-axis.

%rotate f0 (5, 10, 0);   %% Rotation about the x and y-axes.

%rotate f0 (5, 0, 15);   %% Rotation about the x and z-axes.

%rotate f0 (0, 10, 15);   %% Rotation about the y and z-axes.

%rotate f0 (5, 10, 15);   %% Rotation about all three axes.

p20 := get_position f0;
p21 := get_direction f0;
p22 := get_up f0;
p23 := get_normal f0;

message "up of f0 after rotation:"; 
show p22;

message "normal of f0 after rotation:"; 
show p23;

dotlabel.ulft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.lrt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 3

endfig;

%% ***** (5) Figure 4

beginfig(4); 

dotlabel.lft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.rt("$p_{22}$ (new up of $f_0$)", p22);
label.lft("$p_{23}$ (new normal of $f_0$)", p23);

drawarrow p20 -- p21;
drawarrow p20 -- p22;
drawarrow p20 -- p23;

%% ****** (6) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ****** (6) End of Figure 4

endfig with_focus f1;

end;

%% ***** (5)

%% **** (4)
 
%% ** (2) 

%% *** (3) Finding the apparent edge of a cylinder.
%%         Started working on this.
%%         LDF 2007.08.29.

%% Changed the way the "up" point of a focus is set.
%% IMPORTANT!! This change will change the meaning of existing 
%% user code!

%% I also plan to add functions for zooming, panning, rotating, and
%% shifting them.
%% LDF 2007.09.03.

%% Added parser rules for the following operations on `focuses'
%% (`get_transform' already existed):
%% LDF 2007.09.02.

%% get_position
%% get_direction
%% get_distance
%% get_up
%% get_perspective_transform

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% **** (4) Declarations

focus f[];

circle c[];

c0 := unit_circle shifted (0, 0, 5) scaled 2;
c1 := c0 shifted (0, 5);

point p[];
point n[];  %% normals

path q[];

%% **** (4) Focus 0

p0 := (1, 10, 0);         %% position f0     
p1 := (-3.765, 4, 5);     %% direction f1    

set f0 with_position p0 with_direction p1 with_distance 20 with_angle 15;

%% **** (4) Figure 1

beginfig(1); 

p2 := get_up f0;

label.rt("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);

drawarrow p0 -- p1;
drawarrow p0 -- p2;

%% ***** (5) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
%label.bot("$+z$", (0, 0, 1));

%% ***** (5) End of Figure 1

endfig;

%% **** (4) Focus 1 (f1)
%% f1 is like f0, but with its position point behind that of f0 on the line
%% position -- direction (p0 -- p1).  
%% The perspective of a picture output using f1 is therefore similar 
%% (but not exactly the same) as the perspective of a picture output using f0, 
%% but the position of f0 can be drawn in it.
%%
%% The line p0 -- p1 is represented as a point, because it is the line of vision
%% when using f1, too.
%%
%% LDF 2007.09.17.

p10 := mediate(p1, p0, 1.5);

set f1 with_position p10 with_direction p1 with_distance 20;

%% **** (4) Figure 2

beginfig(2); 

dotlabel.lft("$p_0$ (position of $f_0$)", p0);
label.rt("$p_1$ (direction of $f_0$)", p1);
label.rt("$p_2$ (up of $f_0$)", p2);

drawarrow p0 -- p1;
drawarrow p0 -- p2;

%% ***** (5) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ***** (5) End of Figure 2

endfig with_focus f1;

%% **** (4) Figure 3

beginfig(3); 

message "up of f0 before resetting angle:"; 
show p2;

reset_angle f0 (0);

p20 := get_position f0;
p21 := get_direction f0;
p22 := get_up f0;

message "up of f0 after resetting angle:"; 
show p22;

dotlabel.lft("$p_20$ (new position of $f_0$)", p20);
label.rt("$p_{21}$ (new direction of $f_0$)", p21);
label.rt("$p_{22}$ (new up of $f_0$)", p22);

drawarrow p20 -- p21;
drawarrow p20 -- p22;

%% ***** (5) Cross-hairs for main axes

drawdblarrow (-1, 0) -- (1, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, 0, -1) -- (0, 0, 1);

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
label.bot("$+z$", (0, 0, 1));

%% ***** (5) End of Figure 3

endfig with_focus f1;

end;

%% **** (4) 

%% ** (2) 

%% *** (3) Finding the apparent edge of a cylinder.
%%         Started working on this.
%%         LDF 2007.08.29.

%% Figured out how to fix a problem with the way in which 
%% the `up' direction of a `focus' is set.  
%%
%% This procedure seems like it might be an improvement:
%% 1.  Take the point P such that P == (0, 1, 0).  That is, P is 
%%     the point that represents a unit vector in the direction 
%%     of the y-axis.
%% 2.  Shift P to the "position" of the focus.
%% 3.  Find the plane q = position -- direction -- P.
%% 4.  Find the point N such that N is a normal to q.
%% 5.  Set the point R equal to P and rotate R about the axis 
%%     N -- position to make it perpendicular to the line 
%%     position -- direction.
%% I believe this should result in the up - position being 
%% the vector perpendicular to the line position -- direction 
%% with the maximum y-component, since R is both perpendicular to 
%% position -- direction and lies in the plane q.
%%
%% The following code produces an example of what needs to be done,
%% The next step will be to do the same thing in the C++ functions 
%% that create and set `Focuses'.
%%
%% LDF 2007.09.17.

%% I also plan to add functions for zooming, panning, rotating, and
%% shifting them.
%% LDF 2007.09.03.

%% Added parser rules for the following operations on `focuses'
%% (`get_transform' already existed):
%% LDF 2007.09.02.

%% get_position
%% get_direction
%% get_distance
%% get_up
%% get_perspective_transform

%% **** (4) Declarations

focus f[];

circle c[];

c0 := unit_circle shifted (0, 0, 5) scaled 2;
c1 := c0 shifted (0, 5);

point p[];
point n[];  %% normals

path q[];

%% **** (4) Focus 0

p0 := (1, 10, 0);         %% position f0     
p1 := (-3.765, 4, 5);     %% direction f1    

set f0 with_position p0 with_direction p1 with_distance 20;

p2 := get_up f0;          %% up f0
p3 := p0 shifted (0, 1);  %% y-axis direction f0

%% **** (4) Figure 0

beginfig(0); 

drawarrow p0 -- p1;  %% position -- direction f0
drawarrow p0 -- p2;  %% position -- up f0
drawarrow p0 -- p3;  %% position -- y-axis direction f0

drawdblarrow (-1, 0, 0) -- (1, 0, 0);
drawdblarrow (0, -1, 0) -- (0, 1, 0);
drawdblarrow (0, -0, 1) -- (0, 0, 1);

dotlabel.lft("$p_0$ (pos $f_0$)", p0);        %% position f0     
label.lft("$p_1$ (dir $f_0$)", p1);	      %% direction f1    
label.lft("$p_2$ (up $f_0$)", p2);            %% up f0
label.lft("$p_3$ (y-axis dir $f_0$)", p3);    %% y-axis direction

q0 := p0 -- p1 -- p2;

n0 := get_normal q0 shifted p0;

drawarrow p0 -- n0;

label.lft("$n_0$ (normal of $q_0$)", n0);


alpha := (p3 - p0) angle (p1 - p0);

message "alpha:"; 
show alpha;

p4 := p3 rotated_around (p0, n0) 90 - alpha;

drawarrow p0 -- p4;
label.rt("$p_4$ (new up $f_0$)", p4);

message "p4:"; 
show p4;

message "(p4 - p0) angle (p1 - p0):"; 
show (p4 - p0) angle (p1 - p0);

q1 := p0 -- p1 -- p3;

message "p4 distance_to_plane q1:"; 
show p4 distance_to_plane q1;

%% ***** (5) Cross-hairs for main axes

label.bot("$+x$", (1, 0));
label.rt("$+y$", (0, 1));
%label.bot("$+z$", (0, 0, 1));

%% ***** (5) End of Figure 0

endfig;  %%  with_focus f1;

end;

%% ** (2) 

%% *** (3) Finding the parameters of an ellipse from points on a `conic_section_lattice'.
%%         This works now.  The next step will be to implement it in C++.
%%         in the function `Conic_Section_Lattice::get_ellipse'.
%%         LDF 2007.08.29.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Focus

focus f;
set f with_position (-3, 10, -20) 
   with_direction (-3, 10, 100) with_distance 20; 

%% **** (4) Pens

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

%% **** (4) Colors

color_vector cv;

cv += green;
cv += blue;
cv += blue;
cv += black;

%% **** (4) Other declarations

point p[];
path q[];
ellipse e[];
conic_section_lattice c;

circle k[];

point_vector pv;
point_vector qv;
bool_point_vector bpv;
bool_point_vector hpv;

point A, B, C, D, E, F;
point X;
point Y;
point Z;

transform t[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3) rotated (0, 30);

%% **** (4) Set circle k0

k0 := unit_circle scaled (4, 0, 4);

%% **** (4) Transform ellipse e0 and circle k0.

t0 := identity rotated (15, 30) shifted (1, 2, 3);

e0 *= k0 *= t0;

%% **** (4) Set initial points.

p0 := get_point (4)  e0;
p1 := get_point (6)  e0;
p2 := get_point (10) e0;
p3 := get_point (18) e0;
p4 := get_point (24) e0;
p5 := get_point (28) e0;


%% **** (4) Put points onto `point_vector'.

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

%% **** (4)

A := get_lattice_point 0, c;
B := get_lattice_point 1, c;
C := get_lattice_point 2, c;
D := get_lattice_point 3, c;
E := get_lattice_point 4, c;
F := get_point_six c;

%% **** (4) Figure 1

beginfig(1); 

%% ***** (5) 

dotlabel.top("$A$", A) with_dot_color red;
dotlabel.llft("$B$", B) with_dot_color red;
dotlabel.bot("$C$", C) with_dot_color red;
dotlabel.lrt("$D$", D) with_dot_color red;
dotlabel.urt("$E$", E) with_dot_color red;
dotlabel.top("$F$", F) with_dot_color red;

pickup path_pen;

%% ***** (5) 

draw e0 dashed evenly;

draw k0 with_color blue;

%dotlabel.bot("$p_{10}$", p10);
%dotlabel.top("$p_{11}$", p11);

%draw_lattice c, (i + .5) with_pen path_pen with_color_vector cv;
%dotlabel_lattice.top (c, 0) with_dot_color red;  

%% ***** (5) Call `intersection_points' on `conic_section_lattice' and `circle'.

bpv := c intersection_points k0;  
%message "bpv:"; 
%show bpv;

p10 := bpv0;
p11 := bpv1;
p12 := bpv2;
p13 := bpv3;

dotlabel.llft("$p_{10}$", p10) with_dot_color green;
dotlabel.lrt ("$p_{11}$", p11) with_dot_color green;
dotlabel.lrt ("$p_{12}$", p12) with_dot_color green;
dotlabel.lrt ("$p_{13}$", p13) with_dot_color green;

drop_pen;

q0 := p10 -- p11;
q1 := p12 -- p13;

q2 := p10 -- p13;
q3 := p11 -- p12;


%% Find the mid-points of the lines.  The lines connecting them
%% are the axes of the ellipse.
%% LDF 2007.08.29.

draw q0;
draw q1;
draw q2;
draw q3;

p20 := mediate(p11, p12);
p21 := mediate(p10, p13);

dotlabel.bot ("$p_{20}$", p20) with_dot_color green;
dotlabel.top ("$p_{21}$", p21) with_dot_color green;

p22 := mediate(p20, p21, 1.5);
p23 := mediate(p21, p20, 1.5);

dotlabel.bot ("$p_{22}$", p22) with_dot_color green;
dotlabel.top ("$p_{23}$", p23) with_dot_color green;

% polygon hex;
% hex := get_hexagon c;
% draw hex with_color red;

q4 := p22 -- p23;
draw q4;

bpv := c intersection_points q4;  

p24 := bpv0;
p25 := bpv1;

%message "bpv:"; 
%show bpv;

dotlabel.ulft("$p_{24}$", p24) with_dot_color yellow;
dotlabel.lrt("$p_{25}$", p25) with_dot_color yellow;

p26 := mediate(p10, p11, .5);
p27 := mediate(p12, p13, .5);

dotlabel.top("$p_{26}$", p26) with_dot_color green;
dotlabel.top("$p_{27}$", p27) with_dot_color green;

p28 := mediate(p26, p27, 1.5);
p29 := mediate(p27, p26, 1.5);

dotlabel.top("$p_{28}$", p28) with_dot_color green;
dotlabel.top("$p_{29}$", p29) with_dot_color green;

q5 := p28 -- p29;
draw q5;

bpv := c intersection_points q5;  

% message "bpv:"; 
% show bpv;

p30 := bpv0;
p31 := bpv1;

dotlabel.llft("$p_{30}$", p30) with_dot_color green;
dotlabel.llft("$p_{31}$", p31) with_dot_color green;

%% ****** (6) Create new ellipse.

a := magnitude (p25 - p24) / 2;
b := magnitude (p30 - p31) / 2;

% message "a:"; 
% show a;

% message "b:"; 
% show b;

e1 := unit_ellipse scaled (a, 0, b) rotated (0, 30);

e1 *= t0;

pen thin_pen;
thin_pen := pencircle scaled (.25mm, .25mm);

draw e1 with_color yellow with_pen path_pen;
draw e0 with_pen thin_pen dashed evenly;

%% ***** (5) End of Figure 1

output current_picture with_focus f no_sort;
clear current_picture;
draw frame shifted (4, 0, -7) with_pen path_pen;
endfig with_projection parallel_x_z;

%% **** (4) 

end;

%% ** (2) 

%% *** (3) Intersection of a `conic_section_lattice' and a `circle'.
%%         LDF 2007.08.26.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);

%% **** (4) Focus

focus f;
set f with_position (-3, 10, -20) 
   with_direction (-3, 10, 100) with_distance 20; 

%% **** (4) Pens

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

%% **** (4) Colors

color_vector cv;

cv += green;
cv += blue;
cv += blue;
cv += black;

%% **** (4) Other declarations

point p[];
path q[];
ellipse e[];
conic_section_lattice c;

circle k[];

point_vector pv;
point_vector qv;
bool_point_vector bpv;
bool_point_vector hpv;

point A, B, C, D, E, F;
point X;
point Y;
point Z;

transform t[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3);

%% **** (4) Set circle k0

k0 := unit_circle scaled (4, 0, 4);

%% **** (4) Transform ellipse e0 and circle k0.

t0 := identity rotated (30, 30) shifted (1, 2, 3);

e0 *= k0 *= t0;

%% **** (4) Set initial points.

p0 := get_point (4)  e0;
p1 := get_point (6)  e0;
p2 := get_point (10) e0;
p3 := get_point (18) e0;
p4 := get_point (24) e0;
p5 := get_point (28) e0;


%% **** (4) Put points onto `point_vector'.

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

%% **** (4)

A := get_lattice_point 0, c;
B := get_lattice_point 1, c;
C := get_lattice_point 2, c;
D := get_lattice_point 3, c;
E := get_lattice_point 4, c;
F := get_point_six c;

%% **** (4) Figure 1

beginfig(1); 

%% ***** (5) 

dotlabel.top("$A$", A) with_dot_color red;
dotlabel.llft("$B$", B) with_dot_color red;
dotlabel.bot("$C$", C) with_dot_color red;
dotlabel.lrt("$D$", D) with_dot_color red;
dotlabel.urt("$E$", E) with_dot_color red;
dotlabel.top("$F$", F) with_dot_color red;

pickup path_pen;

%% ***** (5) 

draw e0 dashed evenly;

draw k0 with_color blue;

%dotlabel.bot("$p_{10}$", p10);
%dotlabel.top("$p_{11}$", p11);

%draw_lattice c, (i + .5) with_pen path_pen with_color_vector cv;
%dotlabel_lattice.top (c, 0) with_dot_color red;  

%% ***** (5) Call `intersection_points' on `conic_section_lattice' and `circle'.

bpv := c intersection_points k0;  
%message "bpv:"; 
%show bpv;

dotlabel.llft("$j_0$", bpv0) with_dot_color green;
dotlabel.lrt("$j_1$", bpv1) with_dot_color green;
dotlabel.lrt("$j_2$", bpv2) with_dot_color green;
dotlabel.lrt("$j_3$", bpv3) with_dot_color green;

%% ***** (5) End of Figure 1

output current_picture with_focus f;
clear current_picture;

draw frame shifted (3, 0, -7);

endfig with_projection parallel_x_z;

%% **** (4) 

end;



%% *** (3) Intersection of a `conic_section_lattice' and a linear `path'.
%%         This now works, but I haven't tested it for any other cases.
%%         LDF 2007.08.20.

%% **** (4) Frame

pen_width := .5mm; 

pickup pencircle scaled (pen_width, pen_width, pen_width);

w := 18cm;
h := 18cm;

frame_w := w - .5pen_width;
frame_h := h - .5pen_width;

path frame;
frame := origin -- (frame_w, 0) -- (frame_w, 0, frame_h) 
                -- (0, 0, frame_h) -- cycle;

shift frame (-.5frame_w, 0, -.5frame_h);


%% **** (4) Focus

focus f;
set f with_position (-3, 10, -20) 
   with_direction (-3, 10, 100) with_distance 20; 

%% **** (4) Pens

pen path_pen;
path_pen := pencircle scaled (.75mm, .75mm);

%% **** (4) Colors

color_vector cv;

cv += green;
cv += blue;
cv += blue;
cv += black;

%% **** (4) Other declarations

point p[];
path q[];
ellipse e[];
conic_section_lattice c;

point_vector pv;
point_vector qv;
bool_point_vector bpv;
bool_point_vector hpv;

point X;
point Y;
point Z;

transform t[];

%% **** (4) Set ellipse and initial points.

e0 := unit_ellipse scaled (5, 0, 3);

p0 := get_point (6)  e0;
p1 := get_point (11) e0;
p2 := get_point (18) e0;
p3 := get_point (2)  e0;
p4 := get_point (25) e0;
p5 := get_point (19) e0;

%% **** (4) Put points onto `point_vector'.

pv += p0;
pv += p2;  
pv += p3;  
pv += p1;  
pv += p5;  
pv += p4;  

%% **** (4) Set conic section lattice.

c := get_conic_section_lattice pv;

t0 := get_transform c;

%% **** (4) Set line `q0'.

a := 5;

p10 := (-a, 0, -a);
p11 := (a, 0, a);

q0 := p10 -- p11;


%% **** (4) Transform the elements of the drawing.

%%          Added parser rules and functions for 
%%          accessing, setting, resetting, and deleting
%%          the `transform' element of 
%%          `conic_section_lattices'.
%%          LDF 2007.08.21.

%%          They work;  I've just commented them out since 
%%          they're not needed here.
%%          LDF 2007.08.21.

t1 := identity rotated (30, 30) shifted (2, 0);

p10 *= p11 *= c *= q0 *= e0 *= t1;

%set_transform c, t1;

%t0 := get_transform c;

%message "t1:"; 
%show t1;

%message "t0 after setting:"; 
%show t0;

%reset_transform c;

%t0 := get_transform c;

%message "t0 after resetting:"; 
%show t0;

%delete_transform c;

%%t0 := get_transform c;  %% Causes an error, which is correct behavior.
%%message "t0 after deleting:"; 
%%show t0;

%% **** (4) Figure 1

beginfig(1); 

%% ***** (5) 

pickup path_pen;

%% ***** (5) 

draw e0;
draw q0;

dotlabel.bot("$p_{10}$", p10);
dotlabel.top("$p_{11}$", p11);

%draw_lattice c, (i + .5) with_pen path_pen with_color_vector cv;
%dotlabel_lattice.top (c, 0) with_dot_color red;  

polygon hex;
hex := get_hexagon c;

draw hex with_color red;

%show hex;
%show q0;

point A, B, C, D, E, F;
A := get_point (0) hex;
B := get_point (1) hex;
C := get_point (2) hex;
D := get_point (3) hex;
E := get_point (4) hex;
F := get_point (5) hex;

dotlabel.rt("$A$", A) with_dot_color red;
dotlabel.top("$B$", B) with_dot_color red;
dotlabel.top("$C$", C) with_dot_color red;
dotlabel.llft("$D$", D) with_dot_color red;
dotlabel.llft("$E$", E) with_dot_color red;
dotlabel.bot("$F$", F) with_dot_color red;

%% ***** (5) Call `intersection_points' on `conic_section_lattice' and `path'.

hpv := hex intersection_points q0;
%message "hpv:"; 
%show hpv;

dotlabel.lft("$i_0$", hpv0) with_dot_color green;
dotlabel.ulft("$i_1$", hpv1) with_dot_color green;

bpv := c intersection_points q0;
message "bpv:"; 
show bpv;

dotlabel.lrt("$j_0$", bpv0) with_dot_color blue;
dotlabel.lrt("$j_1$", bpv1) with_dot_color blue;

%% ***** (5) End of Figure 1

if false: 
   axis_value := 5;

   drawdblarrow (-axis_value, 0, 0) -- (axis_value, 0, 0) dashed evenly;
   drawdblarrow (0, -axis_value, 0) -- (0, axis_value, 0) dashed evenly;
   drawdblarrow (0, 0, -axis_value) -- (0, 0, axis_value) dashed evenly;
fi;

picture temp_picture;

temp_picture := current_picture;

output temp_picture with_focus f;
clear current_picture;
draw frame shifted (3, 0, -10);
endfig with_projection parallel_x_z;

beginfig(2);
current_picture := temp_picture;
draw frame;
endfig with_projection parallel_x_z;

%% **** (4) 

end;

%% ** (2)

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metafont
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% eval:(setq font-lock-mode nil)
%% End:
