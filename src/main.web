@q main.web @>
                           
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>
 
@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Main.@>
@** Main\quad ({\tt main\PERIOD web}).\hfil

\LOG
\initials{LDF 2002.11.18.}  
Changed name of this file from
\filename{persp.web} to \filename{main.web}.  

\initials{LDF 2003.08.29.}  
Moved \filename{getopt.h} from \filename{loader.web}
to here, because it's only used here.  
@:!! TO DO@> TO DO:  Move the rest of
the include commands to the files where they're needed, 
{\bf and get rid of \filename{loader.web}}.

\initials{LDF 2003.11.12.}  
Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.01.}  
Put the version control identifiers back
into the release versions, because I've put them in their own RCS repository.
\ENDLOG 

@q * (1) Include files.@>
@ Include files.

\filename{getopt.h} is included for 
processing the command line options.
\initials{LDF 2003.08.14.}

\LOG
\initials{LDF 2004.04.16.}  
No longer including the library header
file \filename{map} here.  It's now included in
\filename{loader.web}.

\initials{LDF 2004.05.21.}  
Now including \filename{pens.h}.

\initials{LDF 2004.07.21.}  
No longer including \filename{bitset}.  
It's included in \filename{loader.web} instead.

\initials{LDF 2004.12.21.}
Now including \filename{deftfncs.h}.  It contains function definitions for 
|Definition_Info_Node|.

\initials{LDF 2005.11.12.}
@:BUG FIX@> BUG FIX:  Now including \filename{nurbs.h}.

\initials{LDF 2006.01.23.}
Now including \filename{parabold.h}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"

#include <string.h>

#ifdef __GNUC__
#include <getopt.h> 
#endif 

#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "helices.h++"
#include "origami.h++"

#if 0
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++" 
#include "sphrdevl.h++" 
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++" 
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"
#include "scanprse.h++"   
#include "figures.h++"   
#include "parser.h++"   
#include "parser_1.h++"   
#include "scan.h++"
#include "scanprsf.h++"
#include "imetfncs.h++"
#include "deftfncs.h++"
#include "sctpcrt.h++"  
#include "sctpfncs.h++"  
#include "prrfnc0.h++"

#if 0 
#include "parser2.h++"   
#include "scanner2.h++"   
#endif 

@q * (1) Scanning and parsing input.@>
@* Scanning and parsing input.

@q ** (2) yyparse. @>

@*1 {\it yyparse} and {\it zzparse}. 
\initials{LDF Undated}

\LOG
\initials{LDF 2009.11.04.}
Added declaration of |zzparse|.
\ENDLOG

@<Declare scanning and parsing functions@>=
int
yyparse(yyscan_t);

#if 0 
int
zzparse (yyscan_t);
#endif 

@q ** yywrap. @>
@ {\it yywrap}.
@<Declare scanning and parsing functions@>=
#if 0 
int
yywrap(void);
#endif 

@
@<Define scanning and parsing functions@>=
#if 0 
int
yywrap(void)
{
    return 1;
}
#endif 

@q * Actions in |main|.@>
@* Actions in {\it main\/}.

@<Actions in |main|@>=

#if 1 
vector <const Color*> v;
v.push_back(&red);
v.push_back(&magenta);
v.push_back(&orange);

#if 0 
v.push_back(&yellow);
v.push_back(&violet);
v.push_back(&yellow_green);
v.push_back(&green_yellow);
v.push_back(&blue_violet);
v.push_back(&red);
v.push_back(&green);
v.push_back(&blue);
v.push_back(&cyan);
v.push_back(&yellow);
v.push_back(&magenta);
v.push_back(&orange);
v.push_back(&violet);
v.push_back(&yellow_green);
v.push_back(&green_yellow);
v.push_back(&blue_violet);
v.push_back(&violet_red);
#endif 
#endif 

@q * Process command line options.@>
@* Process command line options.
This section includes one of (currently) two other sections, one for
the GCC/Linux version and one for the DEC version.  The section to be
included is chosen by testing whether preprocessor macros are defined
or not.  Put another way, the command line option processing code is
conditionally compiled.  \initials{LDF 2003.08.14.}  

The problem is that, unlike GCC, the DEC \CPLUSPLUS/ compiler doesn't support
long command line options,  So I have to implement the command line
option processing code separately for each version.  \initials{LDF 2003.08.14.}

\LOG
\initials{LDF 2003.08.14.}  Added this section.
\ENDLOG 
@<Process command line options@>=
#ifdef __GNUC__
@<GCC command line option processing@>@;
#else
#ifdef __DECCXX
@<DEC command line option processing@>@;
#endif 
#endif 


@q ** (2) GCC version of command line processing.@>
@*1 GCC version of command line processing.

\LOG
\initials{LDF 2003.08.14.}  
Added this section. 

\initials{LDF 2003.08.14.}  
Added code for handling the ``{\tt --silent}'' option,
including the constant |SILENT_INDEX|.

\initials{LDF 2004.03.26.}  
Added code for processing the new options
``\.{multiprocess-input}'', ``\.{multiprocess-output}'',
``\.{multithread-input}'', and ``\.{multithread-output}''.
Also added the following |const unsigned shorts| to correspond with
these options:
|MULTIPROCESS_INPUT_INDEX|, |MULTIPROCESS_OUTPUT_INDEX|,
|MULTITHREAD_INPUT_INDEX|, and |MULTITHREAD_OUTPUT_INDEX|.  

\initials{LDF 2004.06.23.}
Removed the |const unsigned shorts| |MULTIPROCESS_INPUT_INDEX| and 
|MULTIPROCESS_OUTPUT_INDEX|.  Changed the numbering for the other 
|const unsigned shorts| accordingly.

\initials{LDF 2004.06.23.}
Removed |"multiprocess-input"| and |"multiprocess-output"| from 
the |long_options struct|.  Changed the output for the ``\.{--help}'' option
accordingly.  Removed the code for handling these options.

\initials{LDF 2004.07.02.}
Added the index constant |MULTITHREAD_INCLUDE_INDEX| and
|"multithread-include"| to |long_options|.  Added code for handling this
option. 
\ENDLOG 

@q *** @>

@<GCC command line option processing@>=
{
  bool DEBUG = false; /* |true| */ 
  int option_ctr;
  int digit_optind = 0;
 
@q *** (3) Index constants.@>
@*2 Index constants.

\LOG
\initials{LDF 2004.09.30.}
Added |const unsigned short QUIET_INDEX|.

\initials{LDF 2004.11.01.}
Added |const unsigned short BISON_TRACE_INDEX|.
\ENDLOG 

@<GCC command line option processing@>=

  const unsigned short BISON_TRACE_INDEX          = 0;
  const unsigned short HELP_INDEX                 = 1;
  const unsigned short MULTITHREAD_INPUT_INDEX    = 2;
  const unsigned short MULTITHREAD_OUTPUT_INDEX   = 3;
  const unsigned short MULTITHREAD_INCLUDE_INDEX  = 4;
  const unsigned short SILENT_INDEX               = 5;
  const unsigned short QUIET_INDEX                = 6;
  const unsigned short VERBOSE_INDEX              = 7;
  const unsigned short VERSION_INDEX              = 8;

@q *** Option struct.@>
@ Option struct.

\LOG
\initials{LDF 2004.09.30.}
Added the ``\.{--quiet}'' option.
\ENDLOG 

@<GCC command line option processing@>=

  static struct option long_options[] = {
    {"bison-trace", 0, 0, 0},
    {"help", 0, 0, 0},
    {"multithread-input", 0, 0, 0},
    {"multithread-output", 0, 0, 0},
    {"multithread-include", 0, 0, 0},
    {"silent", 0, 0, 0},
    {"quiet", 0, 0, 0},
    {"verbose", 0, 0, 0},
    {"version", 0, 0, 0},
    {0, 0, 0, 0}
  };
  
  int option_index = 0;
  int this_option_optind = optind ? optind : 1;  

@q *** (3) Loop for handling options.@>
@*2 Loop for handling options.

@<GCC command line option processing@>=

  while (1) {


    option_ctr = getopt_long_only (argc, argv, "hv",
                          long_options, &option_index);
#if 0 
    if (DEBUG)
      {
        cerr << "option_ctr == " << option_ctr << endl;
        cerr << "option_index == " << option_index << endl;
        if (optarg)
          cerr << "optarg == " << optarg << endl;
      }
#endif     

    if (option_ctr == -1)
      {
        if (DEBUG)
          cerr << "No more option arguments." << endl << endl << flush;
        break;
      }

    if (option_ctr == 0)
      {
        if (DEBUG)
          {
            cerr << "option " << long_options[option_index].name;
            if (optarg)
              cerr << " with arg " << optarg;
            cerr << endl;
          }

@q **** (4) bison-trace.@>
@ bison-trace.

\LOG
\initials{LDF 2004.11.01.}
Added this section.
\ENDLOG

@<GCC command line option processing@>=

        if (option_index == BISON_TRACE_INDEX)
          {
             bison_trace = true;

          } /* |if (option_index == BISON_TRACE_INDEX)|  */

@q **** (4) help.@>
@ help.

\LOG
\initials{LDF 2004.09.30.}
Added output for the ``quiet'' option.  
Now calling |cerr_mutex.lock| and |cerr_mutex.unlock|
to make this output thread-safe.

\initials{LDF 2004.11.01.}
Added text explaining the ``--bison-trace'' option.
Edited the output.
\ENDLOG 

@<GCC command line option processing@>=

        else if (option_index == HELP_INDEX)
          {
            cerr_mutex.lock(); 
            cerr << "GNU 3DLDF Version " << VERSION_3DLDF << ". "
                 << COPYRIGHT_3DLDF << endl 
                 << endl
                 << "Valid options for GNU 3DLDF are:" << endl
                 << endl
                 << "--bison-trace:           Prints information generated by Bison "
                 << endl << "                         "
                 << "for tracing which parser rules are reduced "
                 << endl << "                         "
                 << "and the state of the Bison stack." << endl
                 << endl
                 << "--help:                  Prints this message and exits "
                 << "with return value 0." << endl
                 << endl
                 << "--multithread-input:     Enables the use of multiple "
                 << "threads for input."
                 << endl
                 << endl
                 << "--multithread-output:    Enables the use of multiple "
                 << "threads for output."
                 << endl
                 << endl
                 << "--multithread-include:   Enables the use of multiple "
                 << "threads for input" << endl 
                 << "                         files included in other input files."
                 << endl
                 << endl
                 << "--quiet:                 Suppresses some output to standard "
                 << "output"
                 << endl 
                 << "                         and standard error when `3dldf' is run." 
                 << endl << endl
                 << "--silent:                Suppresses almost all output "
                 << "to standard output" << endl
                 << "                         and standard error when "
                 << "`3dldf' is run."
                 << endl << endl
                 << "--verbose:               Causes status information to be "
                 << "printed to standard output" << endl 
                 << "                         when `3dldf' is run."
                 << endl << endl 
                 << "--version:               Prints the version number of "
                 << "GNU 3DLDF" << endl 
                 << "                         to standard output and exits with "
                 << "return value 0."
                 << endl << endl; 


#if DEBUG_COMPILE
            if (DEBUG)
              {
                  cerr << "Exiting with return value 0." << endl;
              }
#endif /* |DEBUG_COMPILE|  */@; 
 
            cerr_mutex.unlock(); 
            exit(0);

          } /* |if (option_index == HELP_INDEX)|  */




@q **** (4) multithread input.@>
@ multithread input.
@<GCC command line option processing@>=

        else if (option_index == MULTITHREAD_INPUT_INDEX)
          {

#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
            if (DEBUG) 
              cerr << "Setting `run_state_initial.multithread_input' "
                   << "to `true'." << endl;
#endif /* |DEBUG_COMPILE|  */@; 

            run_state_initial.multithread_input = true;

#else  /* |HAVE_PTHREAD_H| is undefined. */@; 


#if DEBUG_COMPILE
            if (DEBUG) 
              cerr << "`HAVE_PTHREAD_H' is undefined." << endl
                   << "Setting `run_state_initial.multithread_input' "
                   << "to `false'." << endl;
#endif /* |DEBUG_COMPILE|  */@; 

            run_state_initial.multithread_input = false;

#endif /* |HAVE_PTHREAD_H| is undefined. */@; 

          } /* |else if (option_index == MULTITHREAD_INPUT_INDEX)|  */


@q **** (4) multithread output.@>
@ multithread output.

@<GCC command line option processing@>=

        else if (option_index == MULTITHREAD_OUTPUT_INDEX)
          {
#ifdef HAVE_PTHREAD_H  
#if DEBUG_COMPILE
              if (DEBUG) 
                cerr << "Setting `run_state_initial.multithread_output' "
                     << "to `true'." << endl;

#endif /* |DEBUG_COMPILE|  */@; 

            run_state_initial.multithread_output = true;

#else /* |HAVE_PTHREAD_H| is undefined. */@; 

#if DEBUG_COMPILE
              if (DEBUG) 
                cerr << "`HAVE_PTHREAD_H' is undefined." << endl
                     << "Setting `run_state_initial.multithread_output' "
                     << "to `false'." << endl;

              run_state_initial.multithread_output = false;

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H| is undefined. */@; 

          } /* |else if (option_index == MULTITHREAD_OUTPUT_INDEX)|  */ 



@q **** (4) multithread include.@>
@ multithread include.

@<GCC command line option processing@>=

        else if (option_index == MULTITHREAD_INCLUDE_INDEX)
          {

#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
            if (DEBUG) 
              cerr << "Setting `run_state_initial.multithread_include' "
                   << "to `true'." << endl;
#endif /* |DEBUG_COMPILE|  */@; 

            run_state_initial.multithread_include = true;

#else  /* |HAVE_PTHREAD_H| is undefined. */@; 


#if DEBUG_COMPILE
            if (DEBUG) 
              cerr << "`HAVE_PTHREAD_H' is undefined." << endl
                   << "Setting `run_state_initial.multithread_include' "
                   << "to `false'." << endl;
#endif /* |DEBUG_COMPILE|  */@; 

            run_state_initial.multithread_include = false;

#endif /* |HAVE_PTHREAD_H| is undefined. */@; 

          } /* |else if (option_index == MULTITHREAD_INCLUDE_INDEX)|  */


@q **** (4) quiet.@>
@ quiet.

@<GCC command line option processing@>=

        else if (option_index == QUIET_INDEX)
          {
            if (DEBUG) 
              cerr << "Setting QUIET_GLOBAL to true." << endl;
            QUIET_GLOBAL = true;
          }


@q **** (4) silent.@>
@ silent.

@<GCC command line option processing@>=

        else if (option_index == SILENT_INDEX)
          {
            if (DEBUG) 
              cerr << "Setting SILENT_GLOBAL to true." << endl;
            SILENT_GLOBAL = true;
          }



@q **** (4) verbose.@>
@ verbose.
@<GCC command line option processing@>=

        else if (option_index == VERBOSE_INDEX)
          {
            if (DEBUG) 
              cerr << "Setting VERBOSE_GLOBAL to true." << endl; 
            VERBOSE_GLOBAL = true;
          }

@q **** (4) version.@>
@ version.

\LOG
\initials{LDF 2007.07.03.}
Changed the text that's printed out when the executable is 
called using the ``\.{version}'' option.
\ENDLOG 

@<GCC command line option processing@>=

        else if (option_index == VERSION_INDEX)
          {
            cerr << "GNU 3DLDF Version " << VERSION_3DLDF << "."
                 << endl 
                 << COPYRIGHT_3DLDF << endl
                 << "License GPLv3+: GNU GPL version 3 or later "
                 << "<http://gnu.org/licenses/gpl.html> "
                 << endl
                 << "This is free software: you are free to change and redistribute it."
                 << endl
                 << "There is NO WARRANTY, to the extent permitted by law."
                 << endl;

#if DEBUG_COMPILE
            if (DEBUG)
               {
                  cerr << "Exiting with return value 0." << endl << flush;
               }
#endif /* |DEBUG_COMPILE|  */@; 
  
            exit(0);
          }

@q **** (4) Invalid option_index value.@>
@ Invalid {\tt option\_index} value.

@<GCC command line option processing@>=

        else 
          {
            cerr << "This can't happen! "
                 << "option_index has invalid value: "
                 << option_index << endl
                 << "Will try to continue." 
                 << endl << endl << flush;
          }
      }

@q **** (4) Ambiguous option.@>
@ Ambiguous option.

@<GCC command line option processing@>=

    else if (option_ctr == '?')
      {
        cerr << "getopt_long() returned ambiguous match. Breaking."
             << endl << endl << flush;
        break;
      }

@q **** (4) Invalid option.@>
@ Invalid option.

@<GCC command line option processing@>=

    else
      {
        cerr << "getopt_long() returned invalid option."
             << endl << flush;
      }

@q **** (4) End of while loop.@>
@ End of while loop.

@<GCC command line option processing@>=

    if (DEBUG) 
      cerr << "*********************\n\n";
    } /* |while|  */
  

@q *** (3) Filename arguments.@>
@*2 Filename arguments.

@<GCC command line option processing@>=
        
  if (optind < argc)
    {
#if 0 
      if (DEBUG)
        cerr << "non-option ARGV-elements: ";
#endif 
      unsigned short i = 0;      
      for (; optind < argc && i < MAX_FILE_ARGS; ++i, ++optind)
        {
       
#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr << "argv[" << optind << "] == " << argv[optind] << endl << flush;
              cerr << "strlen(argv[optind]) == " << strlen(argv[optind]) << endl
                   << flush;
            }
#endif


          if (strlen(argv[optind]) < MAX_FILENAME)
            {

#if 0 
#if DEBUG_COMPILE
              if (DEBUG)
                cerr << "It's less" << "\n" << flush;
#endif
#endif 
              strcpy(filename_array[i], argv[optind]);

              if (DEBUG)
                {
                  cerr << "filename_array[" << i << "] == " 
                       << filename_array[i] << endl << flush;
                }
            }
          else
            {
              cerr << "WARNING: In main():\n"
                   << "Filename argument from the command line is too long:\n"
                   << argv[optind] << endl << "Ignoring.\n\n" << flush;
              break;
            }
        } /* |for| */ 
         
     filename_array_ctr = i;
      if (DEBUG)
        {
          for(unsigned short j  = 0; j < i; ++j)
            cerr << "filename_array[" << j << "] == "
                 << filename_array[j] << endl << flush;
        } 

   
  } /* |if|  */
#if 0 
  if (DEBUG)
    {
      cerr << "Exiting. (Debugging command line option processing.)" 
           << endl << endl << flush;
      exit(0);
    }
#endif 
} /* End of group.  */


@q ** DEC version.@>
@ DEC version.
@ This section doesn't contain any code yet.  
\LOG
\initials{LDF 2003.08.14.}  Added this section. 
\ENDLOG 
@<DEC command line option processing@>=
/* Do nothing. */


@q * Print version, copyright, and license information.@>
@ Print version, copyright, and license information.
The version, copyright, and license information is printed to standard output
when 3DLDF is run, unless the ``{\tt --quiet}'' and/or ``{\tt --silent}''
option was used.  The code for this differs for the GCC 2.95/Linux version on
the one hand, and the other versions (currently, GCC 3.3/Linux and DEC) on the 
other.  The reason for this is, that GCC 2.95 doesn't handle stream
formatting in the same way as the others.  I assume that the others
adhere to the standard and that GCC 2.95 doesn't, but I haven't
checked this.  At any rate, the non-GCC 2.95 version corresponds to
what Stroustrup describes in 
{\it The \CPLUSPLUS/ Programming Language}. 

\LOG
\initials{LDF 2003.08.14.}  
Added this section.

\initials{LDF 2004.09.30.}
Added test for whether |QUIET_GLOBAL == true|.
\ENDLOG 

@<Print version, copyright, and license information@>=
if (!(SILENT_GLOBAL || QUIET_GLOBAL))
{
#ifdef LDF_GCC_2_95
  @<GCC 2.95 print version, copyright, and license information@>@;
#else
  @<GCC 3.3 and DEC print version, copyright, and license information@>@;
#endif 
} 

@q ** GCC 2.95 version.@>
@ GCC 2.95 version.
\LOG
\initials{LDF 2003.08.14.}  Added this section.
\ENDLOG 

@<GCC 2.95 print version, copyright, and license information@>=

cerr.setf(ios::fixed, ios::floatfield);
cerr.precision(1); 
cerr << "3DLDF Version " << VERSION_3DLDF << "."
<< endl << COPYRIGHT_3DLDF << endl << DISCLAIMER_3DLDF << endl << endl;


cerr.setf(ios::fmtflags(0), ios::floatfield); /* Reset to defaults.
                                                 \initials{LDF 2003.08.14.}  */
cerr.precision(6);



@q ** GCC 3.3 and DEC version.@>
@ GCC 3.3 and DEC version.
\LOG
\initials{LDF 2003.08.14.}  Added this section.
\ENDLOG 

@<GCC 3.3 and DEC print version, copyright, and license information@>=

cerr_mutex.lock(); 
cerr.precision(1); 
cerr << "GNU 3DLDF Version " << VERSION_3DLDF 
     << endl << COPYRIGHT_3DLDF << endl
     << "Author:  Laurence D. Finston" 
     << endl      << endl
     << DISCLAIMER_3DLDF << endl 
     << endl;
cerr.precision(6);
cerr_mutex.unlock(); 


@q * Main itself.@>
@ Main itself.
\LOG
\initials{LDF 2003.08.29.}
Changed the string that's passed to |initialize_io| as the name of
the input file.  It's a dummy name, since I've changed
|initialize_io| today, so that no |in_stream| isn't opened.  
Also, commented-out the line where |in_stream| is closed.

\initials{LDF 2003.11.28.}
Removed {\TeX} text above, that referred to the precision used when
printing out |VERSION_3DLDF|.  This is no longer relevant, because
|VERSION_3DLDF| is now a |string| rather than a |real|.

\initials{LDF 2004.06.23.}
Added |vector<pthread_t*> pthread_t_ptr_vector|.

\initials{LDF 2004.07.02.}
No longer declaring and initializing 
|unsigned short filename_array_ctr| here.  It is now declared in 
|namespace Scan_Parse| in \filename{scanprse.web}.  
This makes it accessible to |Scanner_Type::create|.

\initials{LDF 2004.07.03.}
Added call to |pthread_key_create|.

\initials{LDF 2004.07.05.}
Now setting thread-specific data containing the name of the initial 
thread.

\initials{LDF 2004.07.06.}
Now setting |Thread_Info_Type::thread_ctr| to 1 so that the internal 
numbering of the threads {\it might\/} correspond to the numbering GDB 
(the GNU debugger) uses.  There's no guarantee that it will, though.

\initials{LDF 2004.07.12.}
Changed |vector<pthread_t*> pthread_t_ptr_vector| to 
|main_thread_vector|.

\initials{LDF 2004.07.18.}
Now using |Thread_Info_Type::get_thread_info| instead of calling 
|pthread_setspecific| explicitly.

\initials{LDF 2004.07.21.}
Now using |Scan_Parse::log_message|.

\initials{LDF 2004.09.16.}
Now only compiling code using pthreads if |HAVE_PTHREAD_H| 
is defined. 

\initials{LDF 2004.09.30.}
Added |bool stop_value| for use in error and debugging code.

\initials{LDF 2004.10.20.}
Now calling |cerr.setf(ios::fixed, ios::floatfield)| and 
|cerr.precision(6)|.

\initials{LDF 2004.11.01.}
Added |bool bison_trace|.  It's initialized to |false|.  If the 
``bison-trace'' command line option is used, it's set to |true|.  
In this case, |set_yydebug| is called.  Otherwise, 
|unset_yydebug| is called.
\ENDLOG 

@q ** Definition.@>

@<Main@>=
int
main(int argc, char *argv[])
{
  using namespace Colors;
  using namespace Projections;
  using namespace Scan_Parse;


#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @;
#endif /* |DEBUG_COMPILE|  */@; 

  string thread_name = "";

#ifdef HAVE_PTHREAD_H  

  pthread_key_create(&Thread_Info_Type::identity_key,
                  Thread_Info_Type::destroy_key_value);

  Thread_Info_Type::mutex.lock();
  Thread_Info_Type::thread_ctr = 1;
  Thread_Info_Type::mutex.unlock();

  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info(true);
  thread_name = Thread_Info_Type::get_thread_name(thread_info);

#endif /* |HAVE_PTHREAD_H|  */@; 

  bool error_stop_value = (run_state_initial.error_stop_mode == Run_State::STOPPING)
                    ? true : false;
  
  stringstream cerr_strm;
  
#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "Entering `main()'.";
      log_message(cerr_strm);
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  filename_array_ctr = 0;

#ifdef HAVE_PTHREAD_H  

  vector<pthread_t*> main_thread_vector;

#endif 

  /* !! START HERE.  LDF 2004.09.22.  Try to figure out how to work
     non-interactively.  */@; 

  bool bison_trace = false;


  @<Process command line options@>;

#if DEBUG_COMPILE
  if (DEBUG)
    {
        cerr << "filename_array_ctr == " << filename_array_ctr << endl;
    }
#endif /* |DEBUG_COMPILE|  */@; 
 


  @<Print version, copyright, and license information@>;

  if (ldf_real_float)
    MAX_REAL = System::get_second_largest<float>(FLT_MAX, false);
  else if (ldf_real_double)
    MAX_REAL = System::get_second_largest<double>(DBL_MAX, false);
  
  MAX_REAL_SQRT = sqrt(MAX_REAL);

  cerr.setf(ios::fixed, ios::floatfield);
  cerr.precision(6);


@q ** Handle filename arguments. @>
@ Handle filename arguments.
@<Main@>=


vector<Scanner_Node> scanner_node_vector;

string curr_filename;

Scanner_Node curr_scanner_node = 0;

ifstream* in_file;
ofstream* out_file; 

string in_filename;
string s;  


for ( unsigned short i = 0; i < filename_array_ctr; ++i)
   {

      s = filename_array[i];

      curr_scanner_node = Scanner_Type::create(s, run_state_initial, true);

      if (curr_scanner_node == static_cast<Scanner_Node>(0))
         {
            cerr << "ERROR! In main(): "
                 << "Failed to open input and/or output files for "
                 << filename_array[i] 
                 << ".\nWill try to continue.\n\n" << flush;
             continue;
         }
      else
         {
            scanner_node_vector.push_back(curr_scanner_node);
#if DEBUG_COMPILE
            if (DEBUG)
              {  
                  cerr << "scanner_node_vector[" << i 
                       << "]->get_in_filename() == " 
                       << scanner_node_vector[i]->get_in_filename() << endl 
                       << "scanner_node_vector[" << i << "]->"
                       << "out[Run_State::METAPOST]->filename == " 
           << scanner_node_vector[i]->out[Run_State::METAPOST]->filename 
           << endl << flush;
              } /* |if (DEBUG)|  */@;
#endif /* |DEBUG_COMPILE|  */@; 
 

         } /* |else|  */@;

    } /* |for|  */@;



@q ** Scan input.@>
@ Scan input.
We only scan from standard input in two cases:  1. if there were no valid
filename arguments or 2. if there was exactly one valid filename argument.
\initials{LDF 2004.03.28.}
  
If there were no valid filename arguments, output
caused by input to standard input is written to the default output files,
currently \filename{3DLDFput.mp}, \filename{3DLDFput.png}, etc.  
If |run_state_initial.single_output_file| 
is |true|, an {\bf input} command is encountered, and the filename argument is
valid, then output caused by input from that file is also written to
\filename{3DLDFput.mp}, etc.  Otherwise the output filenames are generated in
the same way as for the filename arguments.  However, output generated from
input from standard input after a file has been scanned will still be written to
the default output files.
\initials{LDF 2004.03.28.}

If there was exactly one valid filename argument and
|run_state_initial.single_output_file| is |true|, and we reach the end of the
file without encountering an {\bf end} command, then we continue scanning from
standard input, but output caused by input from standard input is written to the
original output files.  However, if |run_state_initial.single_output_file| is
|false|, then output caused by input from standard input is written to the
default output files.

If there was more than one valid filename argument, 
we never read from standard input.  
\initials{LDF 2004.03.28.}


\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.04.02.} 
Write footers and close the streams after |yyparse| returns.  
Adapt |initialize_io|, |write_footers|, |define_colors_mp|, and
|initialize_colors| for use with |Scanner_Node|.  Write rules for ``end'',
``input'', and ``endinput'' in scanner and parser.  
\ENDTODO 

\LOG
\initials{LDF 2004.05.05.}  
Now calling |set_yydebug|.

\initials{LDF 2004.07.01.}
Removed declaration of |vector<pid_t> outer_pid_vector|, since it's no longer
used. 

\initials{LDF 2004.11.01.}
Now calling |set_yydebug| if |bison_trace == true| and 
|unset_yydebug| if |bison_trace == false|.  Previously, the calls to these
functions were conditionally compiled.

\initials{LDF 2005.04.02.}
Now calling |Shape::initialize_type_name_map|.
\ENDLOG 

@q *** @>
@<Main@>=

   if (initialize_name_map() != 0)
     {
       cerr_strm << thread_name 
                 << "ERROR! `In main()': `initialize_name_map()' failed!"
                 << endl << "Will try to continue.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

     } /* |if (initialize_name_map() != 0)|  */


  Shape::initialize_type_name_map();


  vector<Scanner_Node>::size_type vector_size
    = scanner_node_vector.size();

  Scanner_Node scanner_node_stdin = 0;

  int yyparse_return_value;

  if (bison_trace)
     set_yydebug();               
  else
     unset_yydebug();  


@q *** (3) No filename arguments.  We read from |stdin|.  @>
@ No filename arguments.  We read from |stdin|.  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.04.20.}
Make this case work with |multiprocess_input| and
|multiprocess_output|.  Turn it off when reading from |stdin|, turn it back on
if we scan an {\bf input} command.  
\ENDTODO 

\LOG
\initials{LDF 2004.07.02.}
Now deleting |scanner_node_stdin|.

\initials{LDF 2004.08.08.}
This code now works, but when I try to use it a memory fault error occurs in
|yyparse|.  Currently, it's too hard to debug because it takes so long for
\filename{parser.c++} to compile.  I'll try to debug it once I've removed more
code from the parser rules and put it into functions.


\initials{LDF 2004.09.19.}
Now writing header to the default {\MP/} output file.  
Currently not using other output formats.

\initials{LDF 2004.10.13.}
Added |do|---|while| loop that wraps the call to |yyparse|.
\ENDLOG 

@<Main@>=
  if ( vector_size  == 0)
    {

#if DEBUG_COMPILE
      bool DEBUG_SAVE = DEBUG;
      DEBUG = false; /* |true|  */

      if (DEBUG)
        {
          cerr_strm << thread_name << "vector_size == 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
   
      scanner_node_stdin = Scanner_Type::create("", run_state_initial, true);

      for (int i = Run_State::METAPOST; i <= Run_State::LIBPLOT; ++i)
        scanner_node_stdin->open_default_out_file(i, run_state_initial);

#ifdef __DECCXX
      scanner_node_stdin->out[Run_State::METAPOST]->stream_ptr->setf(
                                   ios_base::fixed, ios_base::floatfield);
#else
#ifdef __GNUC__ 
      scanner_node_stdin->out[Run_State::METAPOST]->stream_ptr->setf(
                                              ios::fixed, ios::floatfield);
#endif 
#endif 

      time_t tt;
      tm *lt;
      tt = time(0);
      lt =localtime(&tt);

      string datestamp(asctime(lt));
      datestamp.erase(datestamp.size() - 1); /*  Remove terminal line-feed.  */


      *(scanner_node_stdin->out[Run_State::METAPOST]->stream_ptr) 
                         << "%%%% " << default_out_filename_metapost 
                         << "." << endl
                         << "%%%% Generated on " << datestamp << endl 
                         << "%%%% from standard input by GNU 3DLDF "
                         << VERSION_3DLDF << "."
                         << endl << endl << flush; 

         yyparse_return_value
            = yyparse(static_cast<void*>(scanner_node_stdin));

#if 0 
     do 
       {
         yyparse_return_value
            = yyparse(static_cast<void*>(scanner_node_stdin));


         /* !! START HERE.  LDF 2004.10.12.  
            Test this and add error handling.  */ 

         if (yyparse_return_value != 0)
            {
               cerr_strm << thread_name << "ERROR! In `main()':"
                         << endl << "`yyparse()' returned " 
                         << yyparse_return_value << ". "
                         << "Calling `yyparse()' again.";

               log_message(cerr_strm);
               cerr_message(cerr_strm);
               cerr_strm.str("");

                 
            } /* |if (yyparse_return_value != 0)|  */

       } /* |do|  */

      while (yyparse_return_value != 0);  
#endif 

      delete scanner_node_stdin;

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "yyparse_return_value == " << yyparse_return_value;
          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str(""); 
        }
      
      DEBUG = DEBUG_SAVE;
#endif



          
        } /* |if ( vector_size  == 0)| */ @;

@q *** (3) At least one filename argument.  @>
@ At least one filename argument.

\LOG
\initials{LDF 2004.07.03.}
Removed special handling for the case where there's only one 
filename argument.  |scanner_node_vector[0]->up| is currently not set to 
|scanner_node_stdin|.
\ENDLOG 

@<Main@>=
 else /* |vector_size > 0| */ @;
    {

      stringstream ctr_str;

@q **** (4) Multithread input.  @>
@ Multithread input.  
\initials{LDF 2004.06.30.}

\LOG
\initials{LDF 2004.06.30.}
Added this section.
\ENDLOG 

@<Main@>=


#ifdef HAVE_PTHREAD_H  
      if (run_state_initial.multithread_input)
        {

#if DEBUG_COMPILE
          bool SAVE_DEBUG = DEBUG;
          DEBUG = false; /* |true|  */
#endif /* |DEBUG_COMPILE|  */@; 
 
          int status;

          for (int i = 0; i < vector_size; ++i)
            {

              main_thread_vector.push_back(new pthread_t);


/* !! START HERE.  LDF 2004.10.12.  Check |parse_func| and wrap 
   |yyparse| in a do-while loop.  */ 

              status = pthread_create(main_thread_vector.back(), 0,
                                      Scan_Parse::parse_func,
                                      static_cast<void*>(scanner_node_vector[i]));


#if DEBUG_COMPILE
              if (DEBUG)
                {
                    cerr_strm << "In `main()': After `pthread_create()':"
                              << endl << "`status' == " << status << ".";
                  
                    log_message(cerr_strm);
                    cerr_message(cerr_strm);
                    cerr_strm.str("");
                }
#endif /* |DEBUG_COMPILE|  */@; 
              

            } /* |for|  */@;

#if DEBUG_COMPILE
          DEBUG = SAVE_DEBUG;
#endif /* |DEBUG_COMPILE|  */@; 
 


        } /* |if (run_state_initial.multithread_input)|  */

#else /* |HAVE_PTHREAD_H| is undefined.  */@; 

      if (0)
        ; /* Do nothing.  */@; 
#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

@q **** (4) Single-threaded input.  @>
@ Single-threaded input.  
\initials{LDF 2004.06.30.}


\LOG
\initials{LDF 2004.07.02.}
Now deleting |scanner_node_vector[i]|.
\ENDLOG 

@<Main@>=

      else /* |(!run_state_initial.multithread_input)|  */
        {


@q ***** (5) |vector_size == 1|.@> 
@ |vector_size == 1|.  Read from standard input if we ``fall of the end'' 
of the input file.
\initials{LDF 2004.09.30.}

\LOG
\initials{LDF 2004.09.30.}
Added this section.

\initials{LDF 2004.10.13.}
Added |do|---|while| loop that wraps the calls to |yyparse|.
\ENDLOG

@<Main@>=

  if (vector_size == 1)
    {
      scanner_node_vector[0]->in->up = new Input_Struct;
      scanner_node_vector[0]->in->up->stream_ptr = &cin;
      scanner_node_vector[0]->in->up->type = Io_Struct::STDIN_TYPE;
    } /* |if (vector_size == 1)|  */

@q ***** (5).@> 
@
\LOG
\initials{LDF 2006.11.09.}
Now exiting if |yyparse| returns unsuccessfully.  This prevents a flood of
annoying error messages from glibc.
\ENDLOG 
@<Main@>=

          for (int i = 0; i < vector_size; ++i)
            {
#if DEBUG_COMPILE
                if (DEBUG)
                  {   
                      ctr_str << "*scanner_node_vector[" << i << "]"; 
                      scanner_node_vector[i]->show(ctr_str.str());
                  }
#endif /* |DEBUG_COMPILE|  */@; 
 

           yyparse_return_value
                  = yyparse(static_cast<void*>(scanner_node_vector[i]));

           if (yyparse_return_value != 0)
              {
                 cerr_strm << thread_name << "ERROR! In `main()':"
                           << endl << "`yyparse()' returned " 
                           << yyparse_return_value << ".";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm);
                 cerr_strm.str("");


#ifdef HAVE_PTHREAD_H  

                 pthread_exit(0);

#else

                 return (1);

#endif /* |HAVE_PTHREAD_H|  */@; 




              } /* |if (yyparse_return_value != 0)|  */

#if 0 
           do 
             {
                yyparse_return_value
                  = yyparse(static_cast<void*>(scanner_node_vector[i]));
            

                if (yyparse_return_value != 0)
                  {
                     cerr_strm << thread_name << "ERROR! In `main()':"
                               << endl << "`yyparse()' returned " 
                               << yyparse_return_value << ". "
                               << "Calling `yyparse()' again.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm);
                      cerr_strm.str("");

                 
                  } /* |if (yyparse_return_value != 0)|  */

            } /* |do|  */

           while (yyparse_return_value != 0);

#endif 
             
           delete scanner_node_vector[i];

         } /* |for|  */@;

      } /* |else| (|!run_state_initial.multithread_input|)  */


    } /* |else| (|vector_size > 0|)  */@;

@q *** End of code for scanning input.  @>

@q ** Clean up and terminate.  @>
@ Clean up and terminate.

@q *** Join with threads.@>
@ Join with threads.
\initials{LDF 2004.06.24.}

\LOG
\initials{LDF 2004.06.24.}
Added this section.

\initials{LDF 2004.07.06.}
Now setting |i| to 2, so that the numbering for the threads 
used in the debugging output {\it might\/} correspond to the 
numbering GDB (the GNU debugger) uses.  There's no guarantee that it will, 
though.
\ENDLOG 

@<Main@>=


  {
    int status;
    int* return_value = 0;
    void* v = 0;
    int i = 2;

    for (vector<pthread_t*>::iterator iter = main_thread_vector.begin();
         iter != main_thread_vector.end();
         ++iter)
      {
     
        status = pthread_join(**iter, &v);

        return_value = static_cast<int*>(v); 
  

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << "In `main()': After join, thread " << i++
                   << ":  status == " << status << "."
                   << endl << "`*return_value' == " << *return_value 
                   << ".";

         log_message(cerr_strm);
         cerr_message(cerr_strm);
         cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
        delete return_value;

      } /* |for|  */

  } /* End of group.  */@;

@q *** (3) Clear |scanner_node_vector|.@>
@ Clear |scanner_node_vector|.
The group surrounding the |for| statement is needed because it's not possible
to declare |int i| within the initializer part.  I think it should work
to put it there, separated by a comma from the declaration of |iter|,
but it doesn't.
\initials{LDF 2004.04.20.}

\LOG
\initials{LDF 2004.07.02.}  
Removed the loop that called |Scanner_Type::clear| on the |Scanner_Type|
objects pointed to by the pointers on |scanner_node_vector|.  
|Scanner_Type::clear| has been replaced by the |Scanner_Type| destructor, and
|delete| is called on the |Scanner_Nodes| after |yyparse| returns.
When using the multithreaded input option, |yyparse| is called within 
|Scan_Parse::parse_func|.  Otherwise, it's called directly.

\initials{LDF 2004.07.02.}
@:??@> 
It didn't work to test whether the |Scanner_Nodes| were 0 here, just in case.
Even though I set them to 0 after calling |delete| on them, they were non-null,
and |Scanner_Type::out[2]| was also non-null.  This caused a segmentation fault
when the |Scanner_Type| destructor tried to delete it.  I don't know why this
happened.

\initials{LDF 2004.07.16.}
Now calling |pthread_exit| instead of |return| if |HAVE_PTHREAD_H| is defined.
\ENDLOG 

@<Main@>=
 
#if DEBUG_COMPILE
  if (DEBUG) 
    cerr << "Clearing scanner_node_vector" << "\n" << flush;
#endif /* |DEBUG_COMPILE|  */@; 

  scanner_node_vector.clear(); 

#if DEBUG_COMPILE
   if (DEBUG) 
     cerr << "scanner_node_vector.size() == " << scanner_node_vector.size()
          << endl << flush;
#endif /* |DEBUG_COMPILE|  */@;    


@
\LOG
\initials{LDF 2005.12.06.}
Now calling |Prime_Numbers::write_primes_file|, if required.
Now deleting |Prime_Numbers::primes_table| and setting it to 0.
\ENDLOG 

@<Main@>=

#if 0 
  @<Actions in |main|@>;
#endif 

   if (Prime_Numbers::do_write_primes_file)
      {
#if 0 
          cerr_mutex.lock(); 
          cerr << "Writing primes file." << endl;
          cerr_mutex.unlock(); 
#endif 

          Prime_Numbers::write_primes_file();

      }

   else if (Prime_Numbers::primes_table)
      {
#if 0 
          cerr_mutex.lock(); 
          cerr << "Compressing primes file." << endl;
          cerr_mutex.unlock(); 
#endif 

          system("gzip primes.lbn");
      }

    else 
      {
#if 0 
          cerr_mutex.lock(); 
          cerr << "Not writing or compressing primes file." << endl;
          cerr_mutex.unlock(); 
#endif 
      }

   delete Prime_Numbers::primes_table;
   Prime_Numbers::primes_table = 0;
   
#if 0 
  write_footers();
   
  out_stream.close();
  tex_stream.close();
#endif 

@

\LOG
\initials{LDF 2004.09.30.}
Added test for whether |QUIET_GLOBAL == true|.
Now calling |cerr_mutex.lock| and |cerr_mutex.unlock| around the output in
order to make it thread-safe.
\ENDLOG 

@<Main@>=


if (!(SILENT_GLOBAL || QUIET_GLOBAL))
  {
      cerr_mutex.lock(); 
      cerr << "Exiting GNU 3DLDF Version " << VERSION_3DLDF 
           << endl << endl;
      cerr_mutex.unlock(); 
  }

@
@<Main@>=

#ifdef HAVE_PTHREAD_H  

  pthread_exit(0);

#else

   return (0);

#endif /* |HAVE_PTHREAD_H|  */@; 


} /* End of |main| definition.  */

@q * Putting Main together.@>
@ Putting Main together.

@q ** Compilation. @>
@ This is what's compiled.  
@c
@<Include files@>@;
@<Declare scanning and parsing functions@>@;
@<Main@>@;
@<Define scanning and parsing functions@>@;


@q ** Header file. @>
@ This is what's written to \filename{main.h}.
\TODO
@:TO DO}{{\bf TO DO}@>
Currently, nothing is written to \filename{main.h}, but it has to
exist, so that the shell script \filename{tsthdweb} works properly.  I
plan to change the way \filename{tsthdweb} works soon, and then I'll
be able to get rid of this section.
\ENDTODO 
@(main.h@>=



@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t))                          @>

  
@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

