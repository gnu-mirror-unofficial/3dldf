@q ellipses.web @>
    
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,            @>
@q 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022   @>
@q The Free Software Foundation, Inc.                                       @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * Ellipse.@>
@** Ellipse\quad ({\tt ellipses\PERIOD web}).\hfil

\LOG
\initials{LDF 2003.11.12.}  Removed the version control identifiers from the CWEB
files for the distribution of 3DLDF 1.1.  They're still used in my
development versions.

\initials{LDF 2003.12.10.}  Put the version control identifiers back
into my release versions for 3DLDF 1.1.4.  I've already put some of
them back in, now I'm doing the rest of them.  However, the release
versions are now in their own RCS repository.
\ENDLOG 

@f Ellipse Path

@q * Include files.@>
@ Include files.

\LOG
\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"  
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
  
@q * (1) Ellipse Class definition.@>
@* {\bf Ellipse} class definition.

\LOG
\initials{LDF 2003.07.25.}  
Added |focus0|, |focus1|, and |linear_eccentricity|.

\initials{LDF 2003.07.27.}  
Added |numerical_eccentricity|.

\initials{LDF 2004.10.18.}
Added |friend| declaration for |Path::is_elliptical|.

\initials{LDF 2005.11.01.}
Moved the following |protected| data members from here  to 
the |class| declaration of |Conic_Section| in \filename{conicsct.web}:
|Point focus0|, |Point focus1|, |real linear_eccentricity|,
and |real numerical_eccentricity|.

\initials{LDF 2005.11.25.}
Removed |real axis_h| and |real axis_v|.  They are now members 
of |class Conic_Section|.
\ENDLOG 

@q ** (2) Definition.@> 

@<Define |class Ellipse|@>=
class Ellipse : public Reg_Cl_Plane_Curve, public Conic_Section
{

  friend bool Path::is_elliptical(Scanner_Node scanner_node) const; 

  protected:

    static unsigned short DEFAULT_NUMBER_OF_POINTS;

  public:
    @<Declare |Ellipse| functions@>@;
};

@q * Static data members. @>
@ Static data members.
\initials{LDF Undated.}

\LOG
\initials{LDF Undated.}
Added this section.

\initials{LDF 2007.07.15.}
Now setting |DEFAULT_NUMBER_OF_POINTS| to 32 instead of 16.
\ENDLOG

@<Define |static| |Ellipse| data members@>=
unsigned short Ellipse::DEFAULT_NUMBER_OF_POINTS = 32; /* \initials{LDF 2002.11.06.}
                                                          Must be a
                                                          multiple of 4.  */
@q * (1) Constructors.@>
@* Constructors.

@q ** (2) Default constructor. No arguments.@>
@*1 Default constructor. No arguments.
@^\cfunc{Ellipse}{Ellipse}@>

\LOG
\initials{LDF 2004.06.18.}  
Now setting |dash_pattern| and |pen| to 0.

\initials{LDF 2005.01.24.}
Now setting |shape_type = ELLIPSE_TYPE|.

\initials{LDF 2005.03.18.}
Now setting |pen_vector| and |dash_pattern_vector| to 0 rather than
|pen| and |dash_pattern|, which I've removed.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q *** Declaration.  @>

@<Declare |Ellipse| functions@>=
Ellipse(void);

@q *** Definition.  @>

@
@<Define |Ellipse| functions@>= 
Ellipse::Ellipse(void)
{
   shape_type = ELLIPSE_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   line_switch = false;
   cycle_switch = true;
   pen_vector = 0; 
   dash_pattern_vector = 0;
}

@q ** (2) Center, lengths, and angles of rotation.@>
@*1 Center, lengths, and angles of rotation. 

@q *** (3) Constructor.@>
@*2 Constructor.
@^\cfunc{Ellipse}{Ellipse}@>

The ellipse is always generated in the x-z plane with the center at
the origin.  Then it is rotated about the main axes according to the
values of the angle arguments and shifted to |center|.  

\LOG
\initials{LDF 2002.11.06.}  
Made |real| arguments |const|.

\initials{LDF 2003.07.25.}  
Added code for setting |focus0|, |focus1|, and
|linear_eccentricity|. 

\initials{LDF 2003.07.27.}  
Added code for setting |numerical_eccentricity|. 

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.06.18.}  
Now setting |dash_pattern| and |pen| to 0.

\initials{LDF 2005.01.24.}
Now setting |shape_type = ELLIPSE_TYPE|.

\initials{LDF 2005.03.31.}
Now setting |surface_hiding_ctr = 0|.

\initials{LDF 2005.04.18.}
Now setting |decomposition_level = 0|.
\ENDLOG 

@q **** (4) Declaration.  @>

@<Declare |Ellipse| functions@>=
Ellipse(const Point& ccenter,
        const real aaxis_h,
        const real aaxis_v,
        const real angle_x = 0,
        const real angle_y = 0,
        const real angle_z = 0,
        const unsigned short nnumber_of_points = DEFAULT_NUMBER_OF_POINTS);

@q **** (4) Definition.  @>

@
@<Define |Ellipse| functions@>= 
Ellipse::Ellipse(const Point& ccenter,
                 const real aaxis_h,
                 const real aaxis_v,
                 const real angle_x,
                 const real angle_y,
                 const real angle_z,
                 const unsigned short nnumber_of_points) 
{

   axis_h = aaxis_h;
   axis_v = aaxis_v;

   shape_type = ELLIPSE_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;
   Point origin_pt(0, 0, 0);

   pen_vector = 0; 
   dash_pattern_vector = 0;

   center = ccenter;
   center.apply_transform();

   focus_0 = origin_pt;    
   focus_1 = origin_pt;

   real axis_h_half = axis_h / 2;
   real axis_v_half = axis_v / 2;

   if (axis_h >= axis_v)
      {
          linear_eccentricity = sqrt((axis_h_half * axis_h_half)
                              - (axis_v_half * axis_v_half));
          focus_0.shift(-linear_eccentricity);
          focus_1.shift(linear_eccentricity);
          numerical_eccentricity = linear_eccentricity / axis_h_half;
      }
    else
      {
          linear_eccentricity = sqrt((axis_v_half * axis_v_half)
                              - (axis_h_half * axis_h_half));
          focus_0.shift(0, 0, -linear_eccentricity);
          focus_1.shift(0, 0, linear_eccentricity);
          numerical_eccentricity = linear_eccentricity / axis_v_half;
      }

    if (nnumber_of_points % 4 != 0)
      {
          cerr << "WARNING! In Ellipse(): Invalid value for number_of_points:"
            << nnumber_of_points << "." << endl 
              << "Using default instead: " << DEFAULT_NUMBER_OF_POINTS 
                << endl;
          number_of_points = DEFAULT_NUMBER_OF_POINTS; 
      }
    else
      number_of_points = nnumber_of_points;

    line_switch = false;
    cycle_switch = true;

    *this += string("..");

    Transform t;

    if (angle_x != ZERO_REAL || angle_y != ZERO_REAL || angle_z != ZERO_REAL)
      t.rotate(angle_x, angle_y, angle_z);
    
    t.shift(center);

    focus_0 *= focus_1 *= t;

    real curr_angle;
    real curr_x;
    real curr_z;
    
    for (int i = 0; i < number_of_points; i++)  /* LDF 2002.11.06.
                                                   Modified this code.  */
      {
          curr_angle = 2*i*PI/number_of_points;
          curr_x = axis_h/2 * cos(curr_angle);
          curr_z = axis_v/2 * sin(curr_angle);
          points.push_back(create_new<Point>(0));
          points.back()->set(curr_x, 0, curr_z);
          *(points.back()) *= t;  /* Rotate |*(points.back())| around the 
            x, y, and z-axes and shift it to
              |center|.  */

      }  /* |for|  */

}  /* End of |Ellipse::Ellipse| definition.  */

@q *** (3) Setting function.@>
@*2 Setting function.
@^\cfunc{Ellipse}{set}@>
\LOG
\initials{LDF 2003.03.01.}  Added this function.
\ENDLOG 
@<Declare |Ellipse| functions@>=
void
set(const Point& ccenter, const real aaxis_h, const real aaxis_v,
        const real angle_x = 0, const real angle_y = 0, const real angle_z = 0,
        const unsigned short nnumber_of_points = DEFAULT_NUMBER_OF_POINTS);

@
@<Define |Ellipse| functions@>= 
void
Ellipse::set(const Point& ccenter, const real aaxis_h, const real aaxis_v,
                 const real angle_x, const real angle_y, const real angle_z,
                 const unsigned short nnumber_of_points)
     
{
    Ellipse e(ccenter, aaxis_h, aaxis_v, angle_x, angle_y, angle_z, 
              nnumber_of_points);
    *this = e;
}

@q ** (2) Constructor with |Path| argument and additional arguments.@>
@*2 Constructor with |Path| argument and additional arguments.
@^\cfunc{Ellipse}{Ellipse}@>
\initials{LDF 2005.12.15.}

\LOG
\initials{LDF 2005.12.15.}
Added this function.

\initials{LDF 2007.07.09.}
Changed call to |Path::get_size| to a call to |Path::size|.  
Removed the former function, since it simply duplicated the latter one.
\ENDLOG

@q **** (4) Declaration.  @>

@<Declare |Ellipse| functions@>=
Ellipse(const Point& ccenter,
        const real aaxis_h,
        const real aaxis_v,
        const Path& p,
        Scanner_Node scanner_node = 0);

@q **** (4) Definition.  @>

@
@<Define |Ellipse| functions@>= 
Ellipse::Ellipse(const Point& ccenter,
                 const real aaxis_h,
                 const real aaxis_v,
                 const Path& p,
                 Scanner_Node scanner_node)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

   axis_h = aaxis_h;
   axis_v = aaxis_v;

   shape_type = ELLIPSE_TYPE;
   surface_hiding_ctr = 0;
   decomposition_level = 0;

   pen_vector = 0; 
   dash_pattern_vector = 0;

   center = ccenter;
   center.apply_transform();

   real axis_h_half = axis_h / 2;
   real axis_v_half = axis_v / 2;

@q **** (4)@> 

   if (axis_h >= axis_v)
      {
          linear_eccentricity = sqrt((axis_h_half * axis_h_half)
                              - (axis_v_half * axis_v_half));
          numerical_eccentricity = linear_eccentricity / axis_h_half;
      }
    else
      {
          linear_eccentricity = sqrt((axis_v_half * axis_v_half)
                              - (axis_h_half * axis_h_half));
          numerical_eccentricity = linear_eccentricity / axis_v_half;
      }

@q **** (4)@> 

   Transform t;

   Point normal = p.get_normal();
   Point temp_center = center;

   Point temp_pt = p.get_point(0);

   normal.shift(temp_center); 

   t.align_with_axis(temp_center, normal, 'y');

   temp_pt *= temp_center *= normal *= t;

   real angle = temp_pt.angle(Point(1, 0, 0));
  
   temp_center *= temp_pt *= t.rotate(0, -angle);

   if (temp_pt.get_x() < ZERO_REAL || temp_pt.get_z() != ZERO_REAL)
         temp_center *= normal *= temp_pt *= t.rotate(0, 2 * angle);

@q **** (4)@> 

   if (temp_pt.get_x() < ZERO_REAL || temp_pt.get_z() != ZERO_REAL)
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse' constructor:"
                    << endl  
                    << "Failed to align `Points' on the x-z plane.  "
                    << "Can't set `focus0' and `focus1'."
                    << endl
                    << "Will set them to `INVALID_POINT' instead.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          focus_0 = focus_1 = INVALID_POINT;
                  
      }  /* |if (temp_pt.get_x() < ZERO_REAL || temp_pt.get_z() != ZERO_REAL)|  */
  
   else 
      {
          if (axis_h >= axis_v)
             {
                 focus_0.shift(-linear_eccentricity);
                 focus_1.shift(linear_eccentricity);
             }

          else
             {
                 focus_0.shift(0, 0, -linear_eccentricity);
                 focus_1.shift(0, 0, linear_eccentricity);
             }

          focus_0 *= focus_1 *= t.inverse();
      }

    number_of_points = p.size();

    Path::operator=(p);

    line_switch = false;
    cycle_switch = true;

    return;

}  /* End of |Ellipse| definition.  */

@q ** (2) Pseudo-constructor for dynamic allocation.@>
@*1 Pseudo-constructor for dynamic allocation.

@q *** (3) Pointer argument.@>
@*2 Pointer argument.

\LOG
\initials{LDF 2002.11.06.}  
Added optional |const Ellipse*| argument.

\initials{LDF 2003.12.30.}  
Replaced |Ellipse::create_new_ellipse|
with a specialization of |template <class C> C* create_new| for
|Ellipse|. 

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.
\ENDLOG 

@<Declare non-member template functions for |Ellipse|@>=

Ellipse* 
create_new(const Ellipse* c, Scanner_Node scanner_node);

@q *** (3) Reference argument.@>
@*2 Reference argument.

\LOG
\initials{LDF 2002.11.06.}  
Added this function.

\initials{LDF 2003.12.30.}  
Replaced |Ellipse::create_new_ellipse|
with a specialization of |template <class C> C* create_new| for
|Ellipse|. 

\initials{LDF 2004.10.11.}
Added |Scanner_Node scanner_node| argument.
\ENDLOG 

@<Declare non-member template functions for |Ellipse|@>=
Ellipse* 
create_new(const Ellipse& c, Scanner_Node scanner_node);

@q * (1) Destructor. @>
@* Destructor. 
@^\cfunc{Ellipse}{\~{}Ellipse}@>

\LOG
\initials{LDF 2002.10.09.}  
Removed the destructor.  |Path::~Path| or
|Path::clear|\newline
should be used instead, unless I add dynamically
allocated data members to |Ellipse| (rather than |Path|).
\ENDLOG 
    
@q * (1) Assignment. @>
@* Assignment.
@^\cofunc{Ellipse}{=}@>

\LOG
\initials{LDF 2002.11.06.}  
Added error handling code to prevent self-assignment.

\initials{LDF 2002.11.10.}  
Changed return value to |Ellipse&|.
\ENDLOG 

@<Declare |Ellipse| functions@>=

Ellipse&
operator=(const Ellipse& e);

@ @:!!@> !! Remember to put anything specific to |Ellipses| in here! 

@<Define |Ellipse| functions@>= 

Ellipse&
Ellipse::operator=(const Ellipse& e)
{
  if (this == &e)  /* \initials{LDF 2002.11.06.}  Make sure it's not
                      self-assignment.  */
    return *this;

  Path::operator=(e);

center = e.center;  /* |Ellipse| members. */
  axis_h = e.axis_h;
  axis_v = e.axis_v;
  focus_0 = e.focus_0;
  focus_1 = e.focus_1;

  number_of_points = e.number_of_points; /* |Reg_Cl_Plane_Curve| members. */

  return *this;
}

@q * (1) Get copy.@>
@* Get copy.
@^\cfunc{Ellipse}{get\_copy}@>
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@<Declare |Ellipse| functions@>=
virtual
Shape*
get_copy() const;

@
@<Define |Ellipse| functions@>=
Shape*
Ellipse::get_copy() const
{
  Ellipse* p = create_new<Ellipse>(0);
  *p = *this;

  return static_cast<Shape*>(p);
}

@q * (1) Reflection in a |Plane|.@> 
@* Reflection in a |Plane|.
\initials{LDF 2004.10.05.}
@^\cfunc{Ellipse}{reflect\_in}@>

Please note that this function tries to allocate memory on the free 
store for the |Ellipse| pointed to by the pointer to |Shape| which is 
its return value.  Therefore, programmers who use this function must 
ensure that this memory is freed.
\initials{LDF 2004.10.05.}

If allocation fails, this function throws a |bad_alloc| exception.  
If the reflection of |*this| cannot be found in the |Plane|, 
this function returns 0.
\initials{LDF 2004.10.05.}

\LOG
\initials{LDF 2004.10.05.}
Added this function.

\initials{LDF 2004.10.12.}
Rewrote this function.
Following a system update, 
having |Shape*| as the return value no longer worked.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual
int
reflect_in(const Plane& p, 
           void* v,
           const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Ellipse| functions@>=
int
Ellipse::reflect_in(const Plane& p, 
                    void* v,
                    const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q *** (3).@> 

  Ellipse* ellipse_reflection = static_cast<Ellipse*>(v);  

@q *** (3) If |ellipse_reflection == static_cast<Ellipse*>(0)|, @>
@q *** (3) try to allocate memory on the free store for it.     @> 

@ If |ellipse_reflection == static_cast<Ellipse*>(0)|, 
try to allocate memory on the free store for it.                            
\initials{LDF 2004.10.12.}

@<Define |Ellipse| functions@>=

 if (ellipse_reflection == static_cast<Ellipse*>(0))
 {
  try
     {
       ellipse_reflection = create_new<Ellipse>(0, scanner_node);
     }

@q **** (4) Error handling:  |new Ellipse| failed.  Rethrow |bad_alloc|.@> 

@ Error handling:  |new Ellipse| failed.  Rethrow |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>=

  catch (bad_alloc)
     {

       cerr_strm << thread_name << "ERROR! In `Point::reflect_in()':" 
                 << endl
                 << "`create_new<Ellipse>()' failed. "
                 << "Rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       throw;

} /* |catch (bad_alloc)|  */

@q *** (3).@> 

  } /* |if (ellipse_reflection == static_cast<Ellipse*>(0))|  */

@q *** (3) Call |Reg_Cl_Plane_Curve::reflect_in|.@> 

@ Call |Reg_Cl_Plane_Curve::reflect_in|.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>=

  Reg_Cl_Plane_Curve reg_cl_plane_curve_reflection;

  int status;

  try
     {
       status = Reg_Cl_Plane_Curve::reflect_in(p,
                            static_cast<void*>(&reg_cl_plane_curve_reflection),
                            scanner_node);  
     }

@q **** (4) Error handling:  |Reg_Cl_Plane_Curve::reflect_in| threw |bad_alloc|.@> 

@ Error handling:  |Reg_Cl_Plane_Curve::reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>=

  catch (bad_alloc)
     {
       cerr_strm << thread_name << "ERROR! In `Ellipse::reflect_in():'"
                 << endl 
                 << "`Reg_Cl_Plane_Curve::reflect_in()' threw `bad_alloc'."
                 << endl << "Deleting `ellipse_reflection' and "
                 << "rethrowing `bad_alloc'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       delete ellipse_reflection;

       throw;

     } /* |catch (bad_alloc)|  */

@q **** (4) Error handling:  |Reg_Cl_Plane_Curve::reflect_in| returned 1.@> 

@ Error handling:  |Reg_Cl_Plane_Curve::reflect_in| returned 1.
\initials{LDF 2004.10.12.}

@<Define |Ellipse| functions@>=

  if (status == 1)
    {

      cerr_strm << thread_name << "ERROR! In `Ellipse::reflect_in():'"
                << endl 
                << "`Reg_Cl_Plane_Curve::reflect_in()' failed and returned 1."
                << endl << "Deleting `ellipse_reflection' "
                << "and exiting function with return value 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
  
      delete ellipse_reflection;

      return 1;

}  /* |if (status == 1)|  */

@q **** (4) |Reg_Cl_Plane_Curve::reflect_in| succeeded.@> 

@ |Reg_Cl_Plane_Curve::reflect_in| succeeded.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Ellipse::reflect_in()':"
                  << endl << "`Reg_Cl_Plane_Curve::reflect_in()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

   ellipse_reflection->Reg_Cl_Plane_Curve::operator=(
                            reg_cl_plane_curve_reflection);

@q *** (3) Set other data members of |*ellipse_reflection|.@> 

@ Set other data members of |*ellipse_reflection|.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>=

  ellipse_reflection->focus_0  = focus_0; 
  ellipse_reflection->focus_1  = focus_1; 

  ellipse_reflection->linear_eccentricity = linear_eccentricity;
  ellipse_reflection->numerical_eccentricity = numerical_eccentricity;
  ellipse_reflection->axis_h = axis_h;
  ellipse_reflection->axis_v = axis_v;

@q *** (3) Exit function successfully with   @> 
@q *** (3) return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.10.05.}

@<Define |Ellipse| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << thread_name << "In `Ellipse::reflect_in()':"
                  << endl << "Exiting function successfully with "
                  << "return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */ 

  return 0;

} /* End of |Ellipse::reflect_in| definition.  */

@q * (1) Reflection off of a |Plane|.@> 
@* Reflection off of a |Plane|.
\initials{LDF 2004.12.14.}
@^\cfunc{Ellipse}{reflect\_off}@>

\LOG
\initials{LDF 2004.12.14.}
Added this function.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual
int
reflect_off(const Plane& p, 
            Point direction,
            void* v,
            const Scanner_Node scanner_node = 0) const;

@q ** (2) Definition.@>

@
@<Define |Ellipse| functions@>=
int
Ellipse::reflect_off(const Plane& p, 
                     Point direction,
                     void* v,
                     const Scanner_Node scanner_node) const

{

@q *** (3) Preliminaries.@> 

   bool DEBUG = false; /* |true| */

   using namespace Scan_Parse;

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

@q *** (3).@> 

   if (v == static_cast<void*>(0))
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`void* v' argument is null.  "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

      } /* |if (v == static_cast<void*>(0))|  */

  Pointer_Vector<Ellipse>* ellipse_ptr_vector 
     = static_cast<Pointer_Vector<Ellipse>*>(v);

@q *** (3) Call |Path::reflect_off|.@> 

@ Call |Path::reflect_off|.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

   int status = Path::reflect_off(p, direction, ellipse_ptr_vector, scanner_node);

@q **** (4) Error handling:  |Path::reflect_off| failed.@>   
@ Error handling:  |Path::reflect_off| failed.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

   if (status != 0)
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`Path::reflect_off()' failed.   "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

      }  /* |if (status != 0)|  */

@q *** (3)  Try to allocate memory for three pointers to |Point_Vector<Point>|.@> 

@ Try to allocate memory for three pointers to |Point_Vector<Point>|.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

   Pointer_Vector<Point>* cvp;  
   Pointer_Vector<Point>* f0vp; 
   Pointer_Vector<Point>* f1vp; 

   try 
      {
          cvp  = new Pointer_Vector<Point>;
          f0vp = new Pointer_Vector<Point>;
          f1vp = new Pointer_Vector<Point>;
      }

@q **** (4) Error handling:  |new Pointer_Vector<Point>| failed.@>   
@ Error handling:  |new Pointer_Vector<Point>| failed.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

   catch (bad_alloc) 
      {

          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`new Pointer_Vector<Point>' failed.  "
                    << "Rethrowing `bad_alloc'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          throw;
         
      }  /* |catch (bad_alloc)|  */

@q *** (3) Set up |Point_Vector<Point>| objects.@> 

@ Set up |Point_Vector<Point>| objects.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

   for (int i = 0; i < 4; ++i)
      {
         *cvp += &(ellipse_ptr_vector->v[i]->center);
         *f0vp += &(ellipse_ptr_vector->v[i]->focus_0);
         *f1vp += &(ellipse_ptr_vector->v[i]->focus_1);

      }  /* |for|  */

@q *** (3)  Call |Point::reflect_off| on |center|, |focus_0|, and |focus_1|.@> 

@ Call |Point::reflect_off| on |center|, |focus_0|, and |focus_1|.
Return 1 upon error.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=

@q **** (4) @>   

   status = center.reflect_off(p, direction, cvp, scanner_node);

   if (status != 0)
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`Point::reflect_off()' failed.   "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

      }  /* |status != 0|  */

@q **** (4) @>   

   status = center.reflect_off(p, direction, f0vp, scanner_node);

   if (status != 0)
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`Point::reflect_off()' failed.   "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

      }  /* |status != 0|  */

@q **** (4) @>   

   status = center.reflect_off(p, direction, f1vp, scanner_node);

   if (status != 0)
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::reflect_off()':"
                    << endl << "`Point::reflect_off()' failed.   "
                    << "Exiting function with return value 1.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

      }  /* |status != 0|  */

@q *** (3) Exit function successfully with return value 0.@> 

@ Exit function successfully with return value 0.
\initials{LDF 2004.12.14.}

@<Define |Ellipse| functions@>=
   
   return 0;

} /* End of |Ellipse::reflect_off| definition.  */

@q * (1) Labelling. @>
@* Labelling.

@q ** (2) Label@>
@*1 Label.
@^\cfunc{Ellipse}{label}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to 
|Point::label|.

\initials{LDF 2005.08.14.}
Now passing 0 as the |Transform*| argument to |Point::label|.
\ENDLOG 

@<Declare |Ellipse| functions@>=
void
label(Picture& picture,
      const string pos = "top",
      Color* ttext_color = 0,
      Color* ddot_color = 0,
      const bool dot = false) const;

@
@<Define |Ellipse| functions@>=
void
Ellipse::label(Picture& picture, 
               const string pos, 
               Color* ttext_color,
               Color* ddot_color,
               const bool dot) const
{
    if (Label::DO_LABELS == false)
      {
          return;
      }

    string s;
    char c = 'a';
    for(vector<Point*>::const_iterator iter = points.begin();
        iter != points.end();
        iter++)
      {
          s = c;
          (**iter).label(picture, s, pos, 0, ttext_color, ddot_color, dot);
          c++;
      }
}

@q ** (2) Dotlabel@>
@*1 Dotlabel.
@^\cfunc{Ellipse}{dotlabel}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2002.11.06.}  
Changed this function so that it just calls
|Ellipse::label| with |dot = true|.  Made it |inline|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2005.01.31.}
Added the arguments |Color* ttext_color| and |Color* ddot_color|, 
both with default 0.  Passing these arguments on to 
|Ellipse::label|.

\initials{LDF 2005.08.14.}
Now passing 0 as the |Transform*| argument to |Point::label|.
\ENDLOG 

@<Declare |Ellipse| functions@>=
inline
void
dotlabel(Picture& picture, 
         string pos = "top", 
         Color* ttext_color = 0,
         Color* ddot_color = 0) const
{
  label(picture, pos, ttext_color, ddot_color, true);
}

@q * (1) Returning elements and information.@>
@* Returning elements and information.
\initials{LDF Undated.}

@q ** (2) Get |Shape| type.@> 
@*1 Get {\bf Shape} type.
\initials{LDF 2005.03.18.}

\LOG
\initials{LDF 2005.03.18.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual 
inline
unsigned short 
get_shape_type(void) const
{
   return ELLIPSE_TYPE;
}

@q ** (2) Is |Ellipse|.@> 
@*1 Is {\bf Ellipse}.
\initials{LDF 2005.03.31.}

\LOG
\initials{LDF 2005.03.31.}
Added this function.

\initials{LDF 2005.04.04.}
Made this function |const|
\ENDLOG

@<Declare |Ellipse| functions@>=
virtual
inline
bool
is_ellipse(void) const 
{
   return true;
}

@q ** (2) Is elliptical.@>
@*1 Is elliptical.

@q *** (3) |Path| version.@> 
@*2 {\bf path} version.
@^\cfunc{Path}{is\_elliptical}@>
\initials{LDF 2004.10.16.}

\LOG
\initials{LDF 2004.10.16.}
Added this function.  It is declared in \filename{paths.web}.
It must be defined in this file (\filename{ellipses.web}), 
because it uses an |Ellipse|, which is an incompletely defined 
type in \filename{paths.web}.
\ENDLOG

@q **** (4) Definition.@> 
  
@
@<Define |Path| functions@>=
bool
Path::is_elliptical(Scanner_Node scanner_node) const
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true| */

  using namespace Scan_Parse;

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

@q ***** (5) Error handling:  |*this| is non-planar.@> 

@ Error handling:  |*this| is non-planar.
\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  if (!is_planar())
    {

#if DEBUG_COMPILE
     if (DEBUG)
       {
           cerr_strm << thread_name << "In Path::is_elliptical(): "
                     << endl 
                     << "`*this' is non-planar. Returning false.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */ 
           
        return false;

    } /* |if (!is_planar())|  */

@q ***** (5) Error handling:  |points.size() % 4 != 0|.@> 

@ Error handling:  |points.size() % 4 != 0|.
Of course, a |Path| which fulfills this condition might 
still be elliptical.  However, it would be harder to test this.

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.10.16.}
Rewrite this function so that it can test arbitrary |Paths|.
\ENDTODO 

\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  if (points.size() % 4 != 0)
     {
#if DEBUG_COMPILE
       if (DEBUG)
         {
             cerr_strm << thread_name << "In Path::is_elliptical(): "
                       << endl 
                       << "`points.size()' % 4 != 0. Returning false.";

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");
         }
#endif /* |DEBUG_COMPILE|  */ 
           
        return false;
        
     } /* |if (points.size() % 4 != 0)|  */

@q ***** (5) Create an |Ellipse| using the |Points| on |points| @> 
@q ***** (5) and test whether it's elliptical.                  @> 

@ Create an |Ellipse| using the |Points| on |points|
and test whether it's elliptical.
\initials{LDF 2004.10.16.}

@<Define |Path| functions@>=

  Ellipse e;

  e.number_of_points = points.size();

  for (vector<Point*>::const_iterator iter = points.begin();
       iter != points.end();
       iter++)
     {
        e += **iter;

     } /* |for|  */

  for (vector<Connector_Type*>::const_iterator iter = connector_type_vector.begin();
       iter != connector_type_vector.end(); 
       iter++)
    {

       e += *iter;

    } /* |for|  */

  Point p0 = get_point(0);
  Point p_half = get_point(points.size() / 2);

  e.center = p0.mediate(p_half);

  return e.is_elliptical();

} /* End of |Path::is_elliptical| definition.  */

@q *** (3) |Ellipse| version.@> 

@*2 {\bf Ellipse} version.
@^\cfunc{Ellipse}{is\_elliptical}@>
\initials{LDF 2004.10.16.}

|is_elliptical| 
first checks whether |*this| is planar by calling\newline
|get_normal|.  If
the latter function returns |INVALID_POINT|, then |is_elliptical|
returns |false|.  Otherwise, it makes a copy of |*this| called |e|,
puts |e| into the x-z plane, and rotates it,  so that
|*(e.points[0])| lies on the x-axis.  Then, it plugs the x and
z-coordinates of the |Points| on |e| into the ellipse equation, i.e.,
$x^2/a^2 + z^2/b^2 = 1$, where $a$ is half of the horizontal axis of
the ellipse, and $b$ is half of the vertical axis.  
Let $r = x^2/a^2 + z^2/b^2$ and $\epsilon$ stand for the return value
of |Point::epsilon|.  
If $\vert r-1\vert > \epsilon$ 
for any of the
|Points| on |e|,
|is_elliptical| returns |false|, otherwise it returns |true|.
\initials{LDF 2003.07.20.}  

\LOG
\initials{LDF 2003.07.20.}  
Added this function.

\initials{LDF 2003.07.25.}  
Now checking |normal == INVALID_POINT|.  If it is,
|is_elliptical| returns |false|.  

\initials{LDF 2004.05.02.}  
Changed |Point x_axis_pt(1)| to 
|Point x_axis_pt(1, 0, 0)| because this |Point| constructor now
requires three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type::id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.
\ENDLOG 

@q **** (4) Declaration.@>

@<Declare |Ellipse| functions@>=
bool
is_elliptical() const;

@q **** (4) Definition.@> 
  
@
@<Define |Ellipse| functions@>=
bool
Ellipse::is_elliptical() const
{
  bool DEBUG = false; /* true */

  Point normal = get_normal();

  if (normal == INVALID_POINT)
    {
        if (DEBUG) 
          cerr << "In Ellipse::is_elliptical(): "
               << "get_normal() returned INVALID_POINT." << endl
               << "*this is non-planar. Returning false."
            << endl << endl;
        return false;
    }

  Ellipse e = *this;

  normal.shift(center);
  Transform t;
  t.align_with_axis(center, normal, 'y');
  e.do_transform(t);

  if (DEBUG) 
    e.show("e after alignment:");
  
  Point x_axis_pt(1, 0, 0);
  Point p0 = e.get_point(0);
  real ang = p0.angle(x_axis_pt);
  
  t.reset();
  t.rotate(0, ang);
  p0 *= e.do_transform(t);

  p0.unit_vector(true);
  if (p0 != x_axis_pt)
    {
      t.reset();
      t.rotate(0, -2 * ang);
      e.do_transform(t);
    }
  p0 = e.get_point(0);
  p0.unit_vector(true);
  
  if (p0 != x_axis_pt)
    {
        if (DEBUG) 
          cerr << "ERROR! In is_elliptical():\n"
            << "Rotation failed.\nReturning false\n\n";
        return false;
    }
  if (DEBUG) 
    e.show("e after rotation in x-z plane:");
  
  real x;
  real z;

  real a = (e.get_point(0) - e.get_center()).magnitude();
  real b = (e.get_point(number_of_points / 4)
            - e.get_center()).magnitude();

  if (DEBUG)
    {
      cerr << "a == " << a << endl;
      cerr << "b == " << b << endl;
    }

  real r;

  int i = 0;
  for (vector<Point*>::const_iterator iter = e.points.begin();
       iter != e.points.end(); ++iter)
    {
      x = (**iter).get_x();
      z = (**iter).get_z();

      if (DEBUG)
        {
          cerr << "Point " << i << ": " << endl;
          (**iter).show("iter:");
          cerr << "x == " << x << endl;
          cerr << "z == " << z << endl;
        }
      
      r =  ((x * x) / (a * a)) + ((z * z) / (b * b));

      if (DEBUG)       
        cerr << "r == " << r << endl;
      
      if (fabs(r - 1) > Point::epsilon())
        {
          if (DEBUG) 
            cerr << "Point " << i << " doesn't satisfy ellipse equation.\n"
                 << "Returning false.\n\n";
          return false;
        }
      ++i;
    }

  if (DEBUG) 
    cerr << "Exiting Ellipse::is_elliptical().  Returning true."
         << endl << endl;
  return true;

} /* End of |Ellipse::is_elliptical| definition.  */

@q ** (2) Is whatever.@>
@*1 Is whatever.
@^\cfunc{Ellipse}{is\_whatever}@>

\LOG
\initials{LDF 2004.09.08.}
Added this function.
\ENDLOG 

@<Declare |Ellipse| functions@>=
virtual
bool
is_whatever(void) const
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
   if (DEBUG)
     {
       cerr_mutex.lock(); 
       cerr << "Entering `Ellipse::is_whatever()'." << endl;
       cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
  return is_elliptical();
}

@q ** (2) Is quadratic.@>
@*1 Is quadratic.
@^\cfunc{Ellipse}{is\_quadratic}@>
@<Declare |Ellipse| functions@>=
inline
bool
is_quadratic() const
{
  return true;
}

@q ** Is cubic.@>
@ Is cubic.
@^\cfunc{Ellipse}{is\_cubic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Ellipse| functions@>=
virtual
bool
is_cubic() const;

@
@<Define |Ellipse| functions@>=
bool
Ellipse::is_cubic() const
{
  return false;
}

@q ** Is quartic.@>
@ Is quartic.
@^\cfunc{Ellipse}{is\_quartic}@>
\LOG
\initials{LDF 2003.07.27.}  Made |virtual| and non-inline.
\ENDLOG
@<Declare |Ellipse| functions@>=
virtual
bool
is_quartic() const;

@
@<Define |Ellipse| functions@>=
bool
Ellipse::is_quartic() const
{
  return false;
}

@q ** Solve.@>
@*1 Solve.
@^\cfunc{Ellipse}{solve}@>
\initials{LDF 2002.11.06.}  |solve| assumes that the |Ellipse| lies in a
major plane with its center at the origin.  Code that calls it
must ensure that these conditions are fulfilled.  |solve| returns
the two possible values for either the horizontal or the vertical
coordinate. 

@:!! TO DO@> TO DO:  Read through, and then explain this function.  

\LOG
\initials{LDF 2003.07.20.}  Now using |get_axis_v| and |get_axis_h|, instead
of accessing |axis_h| and |axis_v| directly.

\initials{LDF 2003.07.25.}  Removed some commented-out code, and an explanatory
comment.  
\ENDLOG 
@<Declare |Ellipse| functions@>=
Real_Pair
solve(char axis_unknown, real known) const;

@
@<Define |Ellipse| functions@>=
Real_Pair
Ellipse::solve(char axis_unknown, real known) const
{
  real radius_known;
  real radius_unknown;

  axis_unknown = tolower(axis_unknown);

  Real_Pair r;
  
  if (axis_unknown == 'h')
    {
      radius_known = get_axis_v() / 2;
      radius_unknown = get_axis_h() / 2;
    }

  else if (axis_unknown == 'v')
    {
      radius_known = get_axis_h() / 2;
      radius_unknown = get_axis_v() / 2;
    }

  else
    {
      cerr << "ERROR! In Ellipse::solve().\n"
        << "Invalid character for axis_unknown: "
          << axis_unknown << "\nReturning INVALID_REAL_PAIR.\n\n";
      return INVALID_REAL_PAIR;
    }

  if (fabs(known) > radius_known)
    {
     return INVALID_REAL_PAIR;
    }
  
@ The equation for an ellipse in the x-y plane with its center at the
origin is
$$x^2/a^2 + y^2/b^2 = 1$$
where $a$ is half the horizontal axis
and $b$ is half the vertical axis. Therefore,
$$y = \sqrt{(1 - x^2/a^2) \times b^2}$$ 
and 
$$x = \sqrt{(1 - y^2/b^2) \times a^2}.$$
@<Define |Ellipse| functions@>=

r.first = sqrt((1 - ((known * known) / (radius_known * radius_known)))
                 * (radius_unknown * radius_unknown));
  r.second = -r.first;
  return r;
}

@q ** Get coefficients.@>
@ Get coefficients.
@^\cfunc{Ellipse}{get\_coefficients}@>
This is used for getting the coefficients of the quadratic equation
that results from replacing $y$ with $mx + b$ from the line equation,
where $m$ is the slope and $b$ the intercept with the vertical axis,
(whichever that might be in a particular case; it needn't be the y-axis)
in the equation for the ellipse   
$$x^2/\alpha^2 + y^2/\beta^2 = 1$$ 
namely 
!! TO DO.  Check this.  I think the $x$ in the coefficient
for $x^2$ is wrong.

$$x^2/\alpha^2 + (mx + b)^2/\beta^2 - 1 = 0 \equiv 
(\beta^2x + \alpha^2m^2)x^2 + 2\alpha^2bmx 
+ (\alpha^2b^2 - \alpha^2\beta^2) = 0.$$
The coefficients are returned in the |struct Real_Triple| in the order
one would expect: |r.first| is the coefficient of $x^2$, |r.second| of
$x$ and |r.third| of the constant term ($x^0$).

\LOG
\initials{LDF 2003.07.20.}  Now using |get_axis_v| and |get_axis_h|, instead
of accessing |axis_h| and |axis_v| directly.

\initials{LDF 2003.07.27.}  Corrected a typo in the math mode material showing the
coefficients. 

\ENDLOG 
@<Declare |Ellipse| functions@>=
Real_Triple
get_coefficients(real Slope, real v_intercept) const;

@
@<Define |Ellipse| functions@>=
Real_Triple
Ellipse::get_coefficients(real Slope, real v_intercept) const
  {
    Real_Triple r;

    real ax_h = get_axis_h();
    real ax_v = get_axis_v();

    r.first = ((ax_v / 2) * (ax_v / 2)) + (((ax_h / 2) * (ax_h / 2))
                                              * (Slope * Slope));  /* a */

r.second = 2 * Slope * v_intercept *
      ((ax_h / 2) * (ax_h / 2));  /* b */

r.third = (((ax_h / 2) * (ax_h / 2)) * (v_intercept * v_intercept))
      - (((ax_v / 2) * (ax_v / 2)) * ((ax_h / 2) * (ax_h /
                                                          2)));  /* c */
    
    return r;
    
  }

@q ** Get center.@>
@*1 Get center.

@q *** Non-const version.@>
@ Non-{\bf const} version.
@^\cfunc{Ellipse}{get\_center}@>
\LOG
\initials{LDF 2002.11.10.}  Made this function |virtual| and non-|inline|.

\initials{LDF 2003.05.09.}  Changed return value from |Point&| to |const
Point&|. 
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual 
const Point&
get_center();

@
@<Define |Ellipse| functions@>=
const Point&
Ellipse::get_center()
{
  center.apply_transform();
  return center;
}

@q *** const version.@>
@ {\bf const} version.
@^\cfunc{Ellipse}{get\_center}@>
\LOG
\initials{LDF 2002.11.10.}  Made this function |virtual| and non-|inline|.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
Point
get_center() const;

@
@<Define |Ellipse| functions@>=
Point
Ellipse::get_center() const
{
  Point p(center);
  p.apply_transform();
  return p;
}

@q ** (2) Get focus.@>
@*1 Get focus.
\initials{LDF 2003.07.25.}  

\LOG
\initials{LDF 2003.07.25.}  
Added this function.

\initials{LDF 2005.11.17.}
Made this version |const| and removed the original |const| version.
The return type of the other version conflicted with that of 
|Conic_Section::get_focus|.
No longer calling |Point::apply_transform| on |focus_0| or |focus_1|.
Commented-out the error message, because it's not thread-safe.

\initials{LDF 2005.11.17.}
Added optional |Scanner_Node scanner_node| argument with the default 0.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
const Point&
get_focus(const unsigned short s, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Ellipse| functions@>=
const Point&
Ellipse::get_focus(const unsigned short s, Scanner_Node scanner_node) const
{
    if (s == 0)
      {
          return focus_0;
      }
    else if (s == 1)
      {
          return focus_1;
      }
    else
      {
#if 0 
          cerr << "ERROR! In |Ellipse::get_focus|:\n"
               << "Invalid argument: " << s << endl
               << "Valid arguments are 0 and 1.\n"
               << "Returning INVALID_POINT.\n\n";
#endif 
          return INVALID_POINT;
      }

}  /* End of |Ellipse::get_focus(const unsigned short s, [etc.])| definition.  */

@q ** (2) Get vertex.@>
@*1 Get vertex.
\initials{LDF 2005.12.16.}

\LOG
\initials{LDF 2005.12.16.}
Added this function.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
Point
get_vertex(const unsigned short s, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Ellipse| functions@>=
Point
Ellipse::get_vertex(const unsigned short s, Scanner_Node scanner_node) const
{
@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q **** (4).@>

    if (s == 0)
      {
          return get_point(0);
      }
    else if (s == 1)
      {
          return get_point(number_of_points / 4);
      }
    else if (s == 2)
      {
          return get_point(number_of_points / 2);
      }

    else if (s == 3)
      {
          return get_point(3 * number_of_points / 4);
      }

    else 
      {
          cerr_strm << thread_name << "ERROR!  In `Ellipse::get_vertex()':"
                    << "Invalid vertex number:  " << s 
                    << endl
                    << "Exiting function unsuccessfully with return value " 
                    << "`INVALID_POINT'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return INVALID_POINT;

      }  /* |else|  */

}  /* End of |Ellipse::get_vertex| definition.  */

@q ** (2) Get linear eccentricity.@>
@*1 Get linear eccentricity.

\LOG
\initials{LDF 2003.07.25.}  
Added this function.
\ENDLOG

@<Declare |Ellipse| functions@>=
real
get_linear_eccentricity() const;

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_linear_eccentricity() const
{
    return linear_eccentricity;
}

@q ** (2) Get numerical eccentricity.@>
@*1 Get numerical eccentricity.
\initials{LDF 2003.07.27.}  

\LOG
\initials{LDF 2003.07.27.}  
Added this function.
\ENDLOG

@<Declare |Ellipse| functions@>=
real
get_numerical_eccentricity() const;

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_numerical_eccentricity() const
{
    return numerical_eccentricity;
}

@q ** (2) Get discriminant.@>
@*1 Get discriminant.

\LOG
\initials{LDF 2005.11.17.}
Added this function.  It currently has a dummy definition, 
returning |INVALID_REAL| immediately.  It's needed because 
|Conic_Section::get_discriminant| is a pure virtual function.

\initials{LDF 2005.11.17.}
Changed the return type of this function from |real| to |Real_Triple|.
It now returns |INVALID_REAL_TRIPLE|.

\initials{LDF 2005.11.18.}
Changed |Path&| argument to |const Path&|.  Added optional 
|Transform*| argument with default 0.
\ENDLOG

@<Declare |Ellipse| functions@>=
Real_Triple
get_discriminant(const Path& p,
                 Transform* t = 0,
                 Scanner_Node scanner_node = 0) const;

@
@<Define |Ellipse| functions@>=
Real_Triple
Ellipse::get_discriminant(const Path& p,
                          Transform* t,
                          Scanner_Node scanner_node) const
{
    return INVALID_REAL_TRIPLE;
}
 
@q ** (2) Get axes.@>
@*1 Get axes. 
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.07.20.}  
Rewrote the |const| versions of the functions in this
section, and added non-|const| versions.  All of them now check
whether |*this| is still elliptical using 
|is_ellipse|.  
If it is, the value |axis_v| or |axis_h| should have is recalculated,
and this value is 
returned.  In the non-|const| versions, |axis_v| or |axis_h| is reset
to the new value.  
If |*this| is no longer elliptical, the function returns |INVALID_REAL|,
and |axis_h| or |axis_v| is set to |INVALID_REAL| in the non-|const|
versions.  

\initials{LDF 2003.07.20.}  
|axis_h| and |axis_v| are updated by the
transformation functions, and these are presumably the only ones that
could cause an |Ellipse| to become non-elliptical.  So, checking and
recalculating them here is probably redundant.  However, this may
change, so it's safer to do this here.

\initials{LDF 2003.07.25.} 
@:BUG FIX@> BUG FIX:  |axis_h| and |axis_v| were too
small by half.  Now multiplying by 2 in all versions of |get_axis_h|
and |get_axis_v|.
\ENDLOG

@q *** (3) Get vertical axis.@>
@*2 Get vertical axis. 

@q **** (4) |const| version.@>
@ {\bf const} version.
@^\cfunc{Ellipse}{get\_axis\_v}@>
@<Declare |Ellipse| functions@>=
real
get_axis_v() const;

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_axis_v() const
{
  if (is_elliptical())
    return (2 * (get_point(number_of_points / 4) -
            get_center()).magnitude());
  else
    return INVALID_REAL;
}

@q **** (4) Non-|const| version.@>
@ Non-{\bf const} version.
@^\cfunc{Ellipse}{get\_axis\_v}@>
@<Declare |Ellipse| functions@>=
real
get_axis_v();

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_axis_v()
{
  if (is_elliptical())
    axis_v = ((get_point(number_of_points / 4) -
              get_center()).magnitude() * 2);
  else
    axis_v = INVALID_REAL;
  return axis_v;
}

@q *** Get horizontal axis.@>
@*2 Get horizontal axis. 

@q **** (4) |const| version.@>
@ {\bf const} version.
@^\cfunc{Ellipse}{get\_axis\_h}@>
@<Declare |Ellipse| functions@>=
real
get_axis_h() const;

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_axis_h() const
{
  if (is_elliptical())
    return ((get_point(0) - get_center()).magnitude() * 2);
  else
    return INVALID_REAL;
}

@q **** (4) Non-|const| version.@>
@ Non-{\bf const} version.
@^\cfunc{Ellipse}{get\_axis\_h}@>
@<Declare |Ellipse| functions@>=
real
get_axis_h();

@
@<Define |Ellipse| functions@>=
real
Ellipse::get_axis_h()
{
  if (is_elliptical())
    axis_h = (get_point(0) - get_center()).magnitude() * 2;
  else
    axis_h = INVALID_REAL;

  return axis_h;
}

@q ** (2) Angle point.@>
@*1 Angle point.
@^\cfunc{Ellipse}{angle\_point}@>

|angle_point| returns a point on the ellipse given an angle.  
Effectively, |point[0]| is rotated about the center in the plane of
the ellipse and the intersection of the ray from the center through
|point[0]| and the ellipse is returned.
\initials{LDF 2003.07.27.}  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.11.03.}
Try to get the rotation to
always go in the direction I would like.
\ENDTODO 

\LOG
\initials{LDF 2003.07.01.}  
@:BUG FIX@> BUG FIX:  Now returning |bpp.first.pt| if
it's not equal to |INVALID_POINT|.  Otherwise, |bpp.second.pt| is
returned.  The latter may be a valid |Point|, or |INVALID_POINT|.
Before, |INVALID_POINT| was returned if |bpp.first.b| and
|bpp.second.b| were |false|, but this is the case, if the intersection
points didn't lie on the line segment between |center| and |pt0|.  

\initials{LDF Undated.}
@:BUG FIX@> BUG FIX:  Now checking to make sure that the intersection
point lies in the proper direction.  Now that the intersection point
doesn't have to be on the line segment, it's necessary to check this. 

\initials{LDF 2003.07.20.}  
Now using |get_axis_v| and |get_axis_h|, instead
of accessing |axis_h| and |axis_v| directly.

\initials{LDF 2003.07.27.}  
Made |const|.  Made |angle| argument |const|.  Now
using |get_center| instead of |center|.
\ENDLOG

@<Declare |Ellipse| functions@>=

Point
angle_point(const real angle) const;

@ 
@<Define |Ellipse| functions@>=
Point
Ellipse::angle_point(const real angle) const
{
    Point Center = get_center();
    Point normal = get_normal();
    normal.shift(Center);
    Point pt0 = get_point(0);

    pt0 -= Center;
    pt0.unit_vector(true);
    pt0 *= max(get_axis_h(), get_axis_v()) / 2;  /* \initials{LDF 2002.11.06.}
                                       |pt0| will either lie on the
                                       perimeter of the |Ellipse|
                                       or beyond it.  */
    
    pt0.shift(Center);

    pt0.rotate(Center, normal, angle);

    Bool_Point_Pair bpp = intersection_points(Center, pt0);

    Point direction_line(pt0 - Center);
    direction_line.unit_vector(true);

    Point direction_pt;

if (bpp.first.pt != INVALID_POINT)
      {
        direction_pt = bpp.first.pt;
        direction_pt -= Center;
        direction_pt.unit_vector(true);
        if(direction_pt == direction_line)
          return bpp.first.pt;
      }
      return bpp.second.pt;    
}

@q * (1) Equality.@>
@* Equality.
@:!! TO DO@> TO DO: 
I'll need to define |Path::operator==| in order to be able
to define this function.
@<Declare |Ellipse| functions@>=
#if 0 
virtual
bool
operator==(const Ellipse& e);
#endif 

@ 
@<Define |Ellipse| functions@>=
#if 0 
virtual
bool
Ellipse::operator==(const Ellipse& e)
{

}

#endif 

@q * (1) Location of a |Point| with respect to an |Ellipse|.@>
@* Location of a {\bf Point} with respect to an {\bf Ellipse}.
@^\cfunc{Ellipse}{location}@>
\initials{LDF 2003.07.25.}  
This function overloads\newline
|Reg_Cl_Plane_Curve::location|.  It's
simpler, because it doesn't need to copy the |Ellipse| and transform
the copy into a major plane.  Nor does it require the use of
|solve|.  

\initials{LDF 2003.07.25.}
If the |Point| argument $P$ lies in the same plane as |*this|, 
|location| compares the sum of the distances of 
$P$ from the foci to 2 times the maximum of |axis_h| and
|axis_v|.   

\initials{LDF 2003.07.25.}
Let $m$ stand for 
|(P - focus_0).magnitude() + (P - focus_0).magnitude|,
$d$ for |2 * max(axis_h, axis_v)|, and $\epsilon$ for
|Point::epsilon|.  
The return values are as follows:
\BRVS{-1}

\RV{0}\relax   $\vert m - d\vert < \epsilon$.  $P$ lies on the
   perimeter of the |Ellipse|. 

\RV{-1}\relax  $m > d$.  $P$ lies outside the |Ellipse|.

\RV{1}\relax   $m < d$.  $P$ lies inside the perimeter of the |Ellipse|.

\RV{-2}\relax  $P$ is not in the same plane as the
|Ellipse|.  

\RV{-3}\relax  The |Ellipse| is non-elliptical.

\ERVS

\LOG
\initials{LDF 2003.07.25.}  
Added this function.  

\initials{LDF 2007.08.26.}
Added optional |real tolerance| argument with the default $-1$.
Added optional |Scanner_Node| argument with default $0$.
\ENDLOG

@q ** Declaration.@>

@<Declare |Ellipse| functions@>=
virtual
signed short
location(const Point& p, 
         real tolerance = -1, 
         Scanner_Node scanner_node = 0) const;

@
@<Define |Ellipse| functions@>=
signed short
Ellipse::location(const Point& p, 
                  real tolerance,
                  Scanner_Node scanner_node) const
{
    bool DEBUG = false; /* true */ 

    real ax_h = get_axis_h();
    real ax_v = get_axis_v();
    
    if (ax_h == INVALID_REAL || ax_v == INVALID_REAL)
      {
          cerr << "ERROR! In `Ellipse::location':"
               << endl 
               << "Ellipse is non-elliptical. Returning -3.\n\n";

          return -3;
      }

    if (!p.is_on_plane(get_plane()))
      {
          cerr  << "WARNING! In Ellipse::location():\n"
                << "Point doesn't lie in plane of Ellipse.\n"
                << "Returning -2.\n\n";

          return -2;
      }

    real max_ax = max(ax_h, ax_v);

Point q = p - get_focus(0);
    real mag = q.magnitude();

    q = p - get_focus(1);
    mag += q.magnitude();

    if (tolerance < 0)
       tolerance = Point::epsilon();

    if (fabs(mag - max_ax) < tolerance)
      {

#if 0 
         cerr << "Point lies on perimeter of |Ellipse|.\n";
#endif 

          return 0;
      }
    else if (mag > max_ax)
      {
#if 0 
          cerr << "Point lies outside of perimeter of |Ellipse|.\n";
#endif 
          return -1;
      }
    else
      {
#if 0 
          cerr << "Point lies inside of perimeter of |Ellipse|.\n";
#endif 
          return 1;
      }

} /* End of |Ellipse::location| definition.  */

@q * (1) Intersection points.@>
@* Intersection points.  

@q ** (2) Point arguments.@>
@*1 {\bf Point} arguments.
@^\cfunc{Ellipse}{intersection\_points}@>

\LOG
\initials{LDF 2003.07.27.}  
Made the arguments |const Point&|.
\ENDLOG

@<Declare |Ellipse| functions@>=
virtual
Bool_Point_Pair
intersection_points(const Point& p0, const Point& p1) const;

@
@<Define |Ellipse| functions@>=
Bool_Point_Pair
Ellipse::intersection_points(const Point& pt0, const Point& pt1) const   
{
    return Reg_Cl_Plane_Curve::intersection_points(center, pt0, pt1);
}

@q ** (2) Plane argument.@>
@*1 {\bf Plane} argument.  
@^\cfunc{Ellipse}{intersection\_points}@>
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this function.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual
Point_Pair
intersection_points(const Plane& p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Ellipse| functions@>=
Point_Pair
Ellipse::intersection_points(const Plane& p, Scanner_Node scanner_node) const
{
    Plane e_plane = get_plane();

    Line line = e_plane.intersection_line(p);

    if (line == INVALID_LINE)
       {
           return INVALID_POINT_PAIR;
       }

     else 
          {
               Point q = line.direction + line.position;
               Bool_Point_Pair bpp = intersection_points(line.position, q);
               return Point_Pair(bpp.first.pt, bpp.second.pt);
          }
}

@q ** (2) Path argument.@>
@*1 {\bf Path} argument.  
@^\cfunc{Ellipse}{intersection\_points}@>

This function just checks to be sure that
|Path p| is a line, extracts the |Points|, and calls the version with
|Point| arguments, returning the latter's return value.

\LOG
\initials{LDF 2003.07.09.}  
Made this function |virtual|.

\initials{LDF 2003.07.27.}  
Made argument |p| a |const Path&|.  Changed, so that
|is_linear| is used, and\newline
|get_last_point| rather than |get_point(1)|. 

\initials{LDF 2005.11.03.}
Added |Scanner_Node scanner_node| argument with default 0.
Added code for the case |!p.is_linear() && p.is_planar|.
\ENDLOG 

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual
Bool_Point_Pair
intersection_points(const Path& p, Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Ellipse| functions@>=
Bool_Point_Pair
Ellipse::intersection_points(const Path& p, Scanner_Node scanner_node) const
{
#if DEBUG_COMPILE
    bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

    stringstream cerr_strm;

    bool error_stop_value   = true;
    bool warning_stop_value = true;
    string thread_name      = "";

    if (scanner_node)
       scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

    using namespace Scan_Parse;

@q **** (4).@>

   if (p.is_linear())
      return intersection_points(p.get_point(0), p.get_last_point());

@q **** (4)@> 
@
\LOG
\initials{LDF 2005.11.04.}
Now setting |bpp.first.bp = bpp.second.bp = false|.

\initials{LDF 2005.11.04.}
Now calling |Ellipse::intersections_points(const Plane&, [etc.])|.
\ENDLOG

@<Define |Ellipse| functions@>=

   else if(p.is_planar())
      {
          Plane p_plane       = p.get_plane();
 
          Point_Pair pp = intersection_points(p_plane, scanner_node);

          Bool_Point_Pair bpp;
          bpp.first.b = bpp.second.b = false;
          bpp.first.pt  = pp.first;
          bpp.second.pt = pp.second;
          return bpp;

      }  /* |else if(p.is_planar())|  */

@q **** (4)@> 

   else  /* (|!(p.is_linear() || p.is_planar())|)  */
     {
       cerr_strm << thread_name 
                 << "ERROR! In Ellipse::intersection_points(const Path&):"
                 << endl 
                 << "Path argument is non-linear and non-planar.  "
                 << "Haven't programmed this case yet."
                 << endl 
                 << "Exiting function unsuccessfully "
                 << "with return value `INVALID_BOOL_POINT_PAIR'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return INVALID_BOOL_POINT_PAIR;

     }  /* |else| (|!(p.is_linear() || p.is_planar())|)  */

@q **** (4)@> 

}  /* End of |Ellipse::intersection_points(const Path& p, [etc.])| definition.  */

@q ** (2) Ellipse argument.@>
@*1 {\bf Ellipse} argument.
@^\cfunc{Ellipse}{intersection\_points}@>

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2002.11.06.}  
Read through and explain.  
\ENDTODO 

@:!! TO DO@> TO DO: 
\initials{LDF 2003.07.20.}  
The following code found only one
intersection:
@c
#if 0   
Ellipse t(origin, 5, 4, 90);
Circle c(origin, 3, 90);
c.shift(3);
c.rotate(0, 0, 30);
Bool_Point_Quadruple bpq = t.intersection_points(c);
#endif

@ \initials{LDF 2003.07.20.}  
When |c| was rotated by $15^\circ$ or $45^\circ$, 
|intersection_points| found both intersections.  Try to find out
why!  I want to write a |Circle| version with an |Ellipse| argument,
and vice versa.  If I do, I may not have to worry about this problem. 

If the |verbose| argument is |true|, information about the
intersection points is printed to standard output.  \initials{LDF 2003.07.01.} 

If the |Ellipses| are coplanar, the intersection points of the
perimeters of the |Ellipses| are returned.  If the planes of the
|Ellipses| are perpendicular or skew, the intersection line of the
planes is found.  Then, the intersection points of the this line with
the |Ellipses|, if they exist.  

\LOG
\initials{LDF 2002.04.12.}  Actually, it looks as if the equations
Dr.~Schwardmann gave me won't do the trick.  They assume both ellipses
are centered about the origin.  When I tried to have Mathematica solve
the equations for $x^2/a^2 + y^2/b^2 = (x-m)^2/c^2 + (y-n)^2/d^2$,
Mathematica produced solutions that took up over 35,000 lines of text!

\initials{LDF 2002.04.12.}  I've rewritten the other cases (parallel,
perpendicular, and skew) in this function completely, and it seems
like it wasn't really worth 
the effort.  The new version does however make use of |Planes| and
|Lines|, which is not a bad thing, and it checks whether the
intersection |Points| are on the |Ellipse|, so it wasn't a total loss.

\initials{LDF 2002.04.12.}  I've written to Dr.~Schwardmann and asked him about
this problem.  It 
may just be my ignorance, or perhaps I've overlooked something
simple.  I'm not too hopeful, however, so I'll probably have to
implement the numerical solution I'd started, after all.

\initials{LDF 2002.04.12.}  Removed old definition.  Dr.~Ulrich Schwardmann of
the Gesellschaft f{\"u}r wissen\-schaft\-liche Daten\-ver\-ar\-bei\-tung,
G{\"o}ttingen, Germany showed me how to use Mathematica's ``Solve''
command to solve the systems of equations that describe the
intersections between two ellipses.  Therefore, I've removed the old
definition of this function, which wasn't complete, anyway, and I'll
put in a new definition soon.

\initials{LDF 2002.04.14.}  About to start work on implementing the coplanar
case again.  The equations produced by Mathematica will work for the
case that the ellipses have the same center.  I will catch the case
that they are congruent and have the same center and the case that
they are non-congruent and have the same center before going on to
implement a numerical solution for the case that they have different
centers. 

\initials{LDF 2002.04.14.}  Changed argument from |const Ellipse&| to |Ellipse|,
since I was having to copy it, anyway. 

\initials{LDF 2003.07.01.}  Added |verbose| argument.

\initials{LDF 2003.07.01.}  Changed ``perpendicular and skew case''.  
Debugged coplanar case, where the |Ellipses| don't have the same
centers and/or axis orientation.

\initials{LDF 2003.07.06.}  Made a minor change to the conditional that
determines whether the |Ellipses| are coplanar or not.

\initials{LDF 2003.08.14.}  Setting |verbose| to |true| if |VERBOSE_GLOBAL| is
|true|.  Added |VERBOSE_GLOBAL| to\newline
\filename{pspglb.web} today.

\initials{LDF 2004.06.08.}  Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2004.11.07.}
Replaced the |bool verbose = false| argument with 
|Scanner_Node scanner_node = 0| so that this function corresponds to 
|Circle::intersection_points(const Circle& c, Scanner_Node scanner_node)|.
However, I have added a local |bool verbose| and have not yet made the 
debugging and error output in this function thread-safe.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.11.07.}
Make the debugging and error output in this function thread-safe.
\ENDTODO 

@q *** Declaration.@>

@<Declare |Ellipse| functions@>=

virtual
Bool_Point_Quadruple
intersection_points(Ellipse e, Scanner_Node scanner_node = 0) const;  

@q *** (3) Definition.@>
@
@<Define |Ellipse| functions@>=

Bool_Point_Quadruple
Ellipse::intersection_points(Ellipse e, Scanner_Node scanner_node) const
{
  bool DEBUG = false; /* |true| */

  bool verbose = false;

  if (VERBOSE_GLOBAL)
    verbose = true;

  if (DEBUG || verbose)
    cerr << "Entering Ellipse::intersection_points(Ellipse e, const bool verbose)"
         << endl;

  Point origin_pt(0, 0, 0);
  
  Bool_Point_Quadruple bpq = INVALID_BOOL_POINT_QUADRUPLE;
  
  Plane this_plane = this->get_plane();
  Plane e_plane   = e.get_plane();

  if (DEBUG)
    {
      this_plane.show("this_plane:");
      e_plane.show("e_plane:");
    }

  if (this_plane.normal == e_plane.normal
      || this_plane.normal == -e_plane.normal)
    {
@q **** (4) Coplanar case.@>
@ Coplanar case.
\LOG
\initials{LDF 2003.07.20.}  Now using |get_axis_v| and |get_axis_h|, instead
of accessing |axis_h| and |axis_v| directly.
\ENDLOG 
@<Define |Ellipse| functions@>=
if (fabs(fabs(this_plane.distance) - fabs(e_plane.distance))
    < Point::epsilon())
  {
    if (DEBUG)
      {
        cerr << "Ellipses are coplanar.\n";
      }

    real ax_h = get_axis_h();
    real ax_v = get_axis_v();

@q ***** (5) Congruent, same location and axis orientation.@>
@ Congruent, same location and axis orientation.
\initials{LDF 2002.04.15.}  Added check for the axis orientation.  If the axes are not 
all vertical or horizontal, then this fails (floating exception).
This means that the circular case will not be caught here, but I plan
to program a specialization for |Circles|, so this shouldn't cause too
much of a problem.

\initials{LDF 2002.04.14.}  Added this section.

This routine only works if the axis orientation of the |Ellipses| is the
same, or rotated $90^\circ$ or $180^\circ$ about an axis through the
center in the direction of 
the normal to the plane of the |Ellipse|, or in the opposite
direction.  The axis orientation is tested on the basis of the vector from
the center to |points[0]|.  If the axis orientation is the same, or rotated
$180^\circ$ about the above-mentioned axis, then |axis_h| of |*this|
must equal |axis_h| of |e| and |axis_v| of |*this| must equal |axis_v|
of |e|.  If the axis orientation is rotated at an angle of $\pm 90^\circ$, 
then |axis_h| of |*this| must equal |axis_v| of |e| and |axis_v| of
|*this| must equal |axis_h| of |e|.  

The maximum
number of intersection points of two non-congruent ellipses is four, so
checking five points eliminates the possibility that we could
accidentally choose intersection points on two non-congruent ellipses
and mistakenly conclude that they are congruent.
@<Define |Ellipse| functions@>=

Point this_axis_orientation(get_point(0));
this_axis_orientation -= get_center();
this_axis_orientation.unit_vector(true);    

Point e_axis_orientation(e.get_point(0));
e_axis_orientation -= e.get_center();
e_axis_orientation.unit_vector(true);    

if (DEBUG)
  {
    this_axis_orientation.show("this_axis_orientation");
    e_axis_orientation.show("e_axis_orientation");
  }

Point normal_point(this_plane.normal);
normal_point.unit_vector(true);

if (DEBUG)
  normal_point.show("normal_point");

Point e_axis_orientation_rotated(e_axis_orientation);

@q ****** (6) @>
@  \initials{LDF 2002.09.26.}  !! TO DO.   
Added the |if| condition.
I think this should be done, but 
I should check to be sure.  Apparently I haven't programmed the
case that the centers aren't the same, but it would be easy enough
to do, I think. 
@<Define |Ellipse| functions@>=

if (e_axis_orientation != this_axis_orientation)
  e_axis_orientation_rotated.rotate(origin_pt, normal_point, 90);

if (DEBUG)
  e_axis_orientation_rotated.show("e_axis_orientation");

if (   this->center == e.center
    && (   (   this_axis_orientation == e_axis_orientation
            || this_axis_orientation == -e_axis_orientation)
        || (   this_axis_orientation == e_axis_orientation_rotated
            || this_axis_orientation == -e_axis_orientation_rotated)))
  {
    if (DEBUG)
      cerr << "Centers and axis orientation are the same.\n";

/* \initials{LDF 2002.04.14.}
   Pick the maximum of |axis_h| and |axis_v| and multiply it by 1.5.
   We'll use a line segment of this length to find intersection points
   with the two |Ellipses|.  Using this length guarantees we'll find
   them.  Actually, |max(axis_h, axis_v)| ought to do the trick.  */

    Point pt0;
    if (ax_h >= ax_v)
      pt0 = get_point(0);
    else
      pt0 = get_point(number_of_points / 4);

    pt0 -= center;

    pt0 *= 1.5;

    pt0.shift(center);

    if (DEBUG)
      {
        this_plane.normal.show("normal");
        center.show("center");
      }

    /* \initials{LDF 2002.04.14.}
       We'll rotate |pt0| around the normal to the plane of the
       ellipse from |center|, i.e., the line segment from |center| to
       |pt1|.  */

    Point pt1(this_plane.normal);
    pt1.shift(center);

    if (DEBUG)
      pt1.show("pt1");

    /* \initials{LDF 2002.04.14.}
       |pt2| is the intersection of the line from |center| to |pt0|
       with |*this|, and |pt3| is the intersection of the same line
       with |e|.  */

    Point pt2;
    Point pt3;

    Bool_Point_Pair bpp_this;
    Bool_Point_Pair bpp_e;

    bool congruent_flag = true;

    /* \initials{LDF 2002.04.14.}
       We'll find intersection points for five values of |pt0|.
       If one set of intersection points are not the same, this means
       the we |Ellipses| are not congruent and in the same location,
       so we break out of the loop.  */

    for (int i = 0; i < 5; i++)
      {
        if (DEBUG)
          cerr << "i == " << i << endl;

        if (i != 0)
          pt0.rotate(center, pt1, 30);

#if 0
        if (DEBUG)
          pt0.dotlabel("0");
#endif 

        bpp_this = intersection_points(center, pt0);
        bpp_e = e.intersection_points(center, pt0);

        if (bpp_this.first.b == true)
          {
            if (DEBUG)
              cerr << "first is an intersection point (this).\n";

            pt2 = bpp_this.first.pt;
          }

        else if (bpp_this.second.b == true)
          {
            if (DEBUG)
              cerr << "second is an intersection point (this).\n";

            pt2 = bpp_this.second.pt;
          }
        else
          {
            cerr << "In Ellipse::intersection_points(Ellipse).\n"
                 << "This can't happen (this)!\n"
                 << "Will try to continue.\n\n";

            pt2 = INVALID_POINT;
          }

        if (bpp_e.first.b == true)
          {
            if (DEBUG)
              cerr << "first is an intersection point (e).\n";
            
            pt3 = bpp_e.first.pt;
          }

        else if (bpp_e.second.b == true)
          {
            if (DEBUG)
              cerr << "second is an intersection point (e).\n";

            pt3 = bpp_e.second.pt;
          }
        else
          {
            cerr << "In Ellipse::intersection_points(Ellipse).\n"
              << "This can't happen (e)!\nWill try to continue.\n\n";

            pt3 = INVALID_POINT;
          }

#if 0
        if (DEBUG)
          {
            pt2.show("2");
            pt2.dotlabel("2");
        
            pt3.show("3");
            pt3.dotlabel("3", "bot");
          }
#endif 
        
        if (pt2 == INVALID_POINT || pt3 == INVALID_POINT
            || pt2 != pt3)
          {
            if (DEBUG)
              cerr << "Ellipses are not congruent. Breaking.\n";

            congruent_flag = false;
            break;
          }
        else
          continue;
      } /* |for| */
    
    if (DEBUG)
      {
        cerr << "congruent_flag == " << congruent_flag << endl;
      }

    if (congruent_flag == true)
      {
        cerr << "WARNING! In Ellipse::intersection_points(Ellipse).\n"
          << "Ellipses are congruent and in the same location.\n"
             << "Returning INVALID_BOOL_POINT_QUADRUPLE.\n\n" <<
               flush;
        return INVALID_BOOL_POINT_QUADRUPLE;
      }
    else if (DEBUG)
      {
        cerr << "All five points are not on both ellipses.\n";

      }

  }  /* End of test of congruency and same location.  */

/* \initials{LDF 2002.09.26.}  !! TO DO.  Programm this case!! */ 
else if (DEBUG)
  {
    cerr << "The centers are different, or the  axis orientation "
         << "is different, or both. "
         << "Haven't programmed this case yet.\n";
  }

Ellipse copy(*this);

Point copy_center(copy.get_center());

Transform t;
Transform t_inverse;

@q ***** (5) Shift to origin (if necessary).@>
@ Shift to origin (if necessary).
@<Define |Ellipse| functions@>=
    if (copy_center != origin_pt)
      {
        if (DEBUG)
          {
            cerr << "Shifting copy to origin_pt.\n";
          }
          
          t.shift(-copy_center.get_x(), -copy_center.get_y(),
                         -copy_center.get_z());
          copy   *= t;
          copy_center *= t;
          e *= t;
      }
    else if (DEBUG)
      {
        cerr << "copy is already at origin_pt.\n";
      }

@q ***** (5) Get coordinates of normal.@>
@ Get coordinates of normal.
@<Define |Ellipse| functions@>=
    real normal_x = this_plane.normal.get_x();
    real normal_y = this_plane.normal.get_y();
    real normal_z = this_plane.normal.get_z();

@q ***** (5) Determine orientation and rotate (if necessary).@>
@ Determine the orientation of the ellipse and rotate, if it's not
already in a plane parallel to a major plane. 
Rotating the |Ellipse| can cause inaccuracies in 
the coordinate values, so if the ellipse is already in a major
plane, (i.e., one perpendicular to a major axis), we leave it
where it is.  
\LOG
\initials{LDF 2003.08.27.}  Commented-out the declaration of |OTHER|, because
it's never used.  I haven't deleted it, just in case.
\ENDLOG 
@<Define |Ellipse| functions@>=

unsigned short orientation;
const unsigned short X_Y   = 0;
const unsigned short X_Z   = 1;
const unsigned short Z_Y   = 2;
#if 0 
const unsigned short OTHER = 3;
#endif 
if (normal_x == ZERO_REAL && normal_y == ZERO_REAL && normal_z == ZERO_REAL)
  {
    cerr << "ERROR! In Ellipse::intersection_points():\n"
      << "Normal == 0. "
        << "Returning INVALID_BOOL_POINT_QUADRUPLE\n\n";

    return INVALID_BOOL_POINT_QUADRUPLE;
  }
          
else if (normal_x == ZERO_REAL && normal_y == ZERO_REAL) /* Ellipse lies in a plane
                                            parallel to x-y plane. */
  {
    if (DEBUG)
      cerr << "Ellipse lies in a plane parallel to x-y plane\n";

    orientation = X_Y;
  }

else if (normal_x == ZERO_REAL && normal_z == ZERO_REAL) /* Ellipse lies in a plane
                                            parallel to x-z plane. */
  {
    if (DEBUG)
      cerr << "Ellipse lies in a plane parallel to x-z plane\n";
    orientation = X_Z;      
  }

else if (normal_z == ZERO_REAL && normal_y == ZERO_REAL) /* Ellipse lies in a plane 
                                            parallel to z-y plane. */
  {
    if (DEBUG)
      cerr << "Ellipse lies in a plane parallel to z-y plane\n";
    orientation = Z_Y;
  }

else  /* Ellipse doesn't lie in a plane parallel to a major plane. */
  {
    if (DEBUG)
      cerr << "Ellipse doesn't lie in a plane parallel to a major plane.\n";

    /* Put it in x-z plane. */

#if 0 
    if (DEBUG)
      {
        copy_center.dotlabel("c");
      }
#endif
    
    Point ellipse_pt0 = copy.get_point(0);

    Transform t0;
    t0.align_with_axis(copy_center, ellipse_pt0, 'x');

    copy *= t0;
    copy_center *= t0;
    ellipse_pt0 *= t0;
    e *= t0;

    if (DEBUG)
      {
        ellipse_pt0.show("ellipse_pt0");
#if 0
        ellipse_pt0.dotlabel("0");
#endif 
      }

    Point ellipse_pt4 = copy.get_point(number_of_points / 4);

    if (DEBUG)
      ellipse_pt4.show("ellipse_pt4");

    Transform t1;

    t1.align_with_axis(copy_center, ellipse_pt4, 'z');

    copy *= t1;
    copy_center *= t1;
    e *= t1;
    ellipse_pt4 *= t1;

    t *= t0;
    t *= t1;
    orientation = X_Z;
  }

    t_inverse = t.inverse();

    Point e_center = e.get_center();

    if (DEBUG)
      {
        copy_center.show("copy_center");
        e_center.show("e_center");
      }

@q ***** (5) Ellipses have the same center and axis orientation.@>
@ Ellipses have the same center and orientation.
If they do, then there is an algebraic solution we can apply to find
the intersection points. 
@<Define |Ellipse| functions@>=

Point copy_axis_orientation(copy.get_point(0));
copy_axis_orientation -= copy_center;
copy_axis_orientation.unit_vector(true);

e_axis_orientation = e.get_point(0);
e_axis_orientation -= e_center;
e_axis_orientation.unit_vector(true);

if (   (e_center == origin_pt && copy_center == origin_pt)
    && ((   copy_axis_orientation == e_axis_orientation
         || copy_axis_orientation == -e_axis_orientation)
        || (   copy_axis_orientation == e_axis_orientation_rotated
            || copy_axis_orientation == -e_axis_orientation_rotated)))
  {
    if (DEBUG)
      cerr << "Both ellipses have the same center and axis orientation.\n";
    
    Point pt20;
    Point pt21;
    Point pt22;
    Point pt23;

    real x;
    real y;
    real a = ax_h / 2.0;
    real b = ax_v / 2.0;
    real c = e.get_axis_h() / 2.0;
    real d = e.get_axis_v() / 2.0;

    if (DEBUG)
      {
        cerr << "a == " << a << endl;
        cerr << "b == " << b << endl;
        cerr << "c == " << c << endl;
        cerr << "d == " << d << endl;
      }

    real aa = (a * a);
    real bb = (b * b);
    real cc = (c * c);
    real dd = (d * d);

    if (DEBUG)
      {
        cerr << "aa == " << aa << endl;
        cerr << "bb == " << bb << endl;
        cerr << "cc == " << cc << endl;
        cerr << "dd == " << dd << endl;
      }

    real denominator;
    real numerator;

    if (DEBUG)
      cerr << "x coordinate.\n";

    denominator = (aa - ((bb * cc) / dd)) * dd;
    numerator = bb * (aa - cc);

    if (DEBUG)
      {
        cerr << "numerator == " << numerator << endl;
        cerr << "denominator == " << denominator << endl;
      }
    
    if (denominator == ZERO_REAL)
      {
        if (DEBUG)
          cerr << "x == INVALID_REAL.\n";
        x = INVALID_REAL;
      }
    else
      {
        try
          {
            x =
              -(c * sqrt(1 - (numerator / denominator)));
          }
        catch (...)
          {
            x = INVALID_REAL;
            if (DEBUG)
              cerr << "x == INVALID_REAL\n";
          }
      }
    
    if (DEBUG)
      {
        cerr << "x == " << x << endl;
        cerr << "y coordinate:\n";
      }
    
    numerator   = b * sqrt(fabs(aa - cc));
    denominator = sqrt(fabs(aa - ((bb * cc) / dd))); 

    if (DEBUG)
      {
        cerr << "numerator == " << numerator << endl;
        cerr << "denominator == " << denominator << endl;
      }

    if (denominator == ZERO_REAL)
      {
        if (DEBUG)
          cerr << "y == INVALID_REAL.\n";
        y = INVALID_REAL;
      }
    else
      {

        try
          {
            y = -( numerator / denominator);
          }
        catch (...)
          {
            y = INVALID_REAL;
            if (DEBUG)
              cerr << "y == INVALID_REAL\n";
          }
      }

    if (DEBUG)
      {
        cerr << "y == " << y << endl;
      }

@q ****** (6) The points.@>
@ The ellipses can intersect at no points, two points, or four
points.  
\item{$\bullet$} If they do not intersect, then one of the ellipses must be
   inside the other.  
\item{$\bullet$} If they intersect at two points, then either $x = 0$
or $y = 0$ (but not both).
\item{$\bullet$} Otherwise, they intersect at four points.

@<Define |Ellipse| functions@>=

    if (x == INVALID_REAL || y == INVALID_REAL)
      {
        cerr << "WARNING! In Ellipse::intersection_points(Ellipse).\n"
             << "Ellipses don't intersect. "
             << "Returning INVALID_BOOL_POINT_QUADRUPLE.\n\n";
        return INVALID_BOOL_POINT_QUADRUPLE;
      }
    else if (orientation == X_Y)
      {
        pt20.set( x,  y, 0);
        pt21.set(-x, -y, 0);       
 
        if (y != ZERO_REAL && x != ZERO_REAL)
          {
            pt22.set( x, -y, 0);
            pt23.set(-x,  y, 0);
          }
        else
          {
            pt22 = INVALID_POINT;
            pt23 = INVALID_POINT;
          }
      }
    else if (orientation == X_Z)
      {
        pt20.set( x, 0,  y);
        pt21.set(-x, 0, -y); 

        if (y != ZERO_REAL && x != ZERO_REAL)
          {
            pt22.set( x, 0, -y);
            pt23.set(-x, 0,  y);
          }
        else
          {
            pt22 = INVALID_POINT;
            pt23 = INVALID_POINT;
          }
      }
    else if (orientation == Z_Y)
      {
        pt20.set(0,  y,  x);
        pt21.set(0, -y, -x); 
        
        if (x != ZERO_REAL && y != ZERO_REAL)
          {
            pt22.set(0,  y, -x);
            pt23.set(0, -y,  x);
          }
        else
          {
            pt22 = INVALID_POINT;
            pt23 = INVALID_POINT;
          }
      }
    else
      {
        cerr << "ERROR! In Ellipse::intersection_points(Ellipse).\n"
             << "This can't happen! orientation has invalid value: "
             << orientation << endl
             << "Will to try to continue.\n\n";

      }

    if (DEBUG)
      {
        pt20.show("pt20");
        pt21.show("pt21");
        pt22.show("pt22");
        pt23.show("pt23");

#if 0
        pt20.dotlabel("20");
        pt21.dotlabel("21");
        pt22.dotlabel("22");
        pt23.dotlabel("23");
#endif 
      }

    signed short ss_copy;
    signed short ss_e;

    if (pt20 != INVALID_POINT)
      {
        ss_copy = copy.location(pt20);

        if (DEBUG)
          cerr << "ss_copy == " << ss_copy << endl;

        ss_e = e.location(pt20);

        if (DEBUG)
          cerr << "ss_e == " << ss_e << endl;
      }

    if (ss_copy == 0 && ss_e == 0)
      {

        pt20 *= t_inverse;
        pt21 *= t_inverse;
        
        bpq.first.b = true;
        bpq.first.pt = pt20;

        bpq.second.b = true;
        bpq.second.pt = pt21;

        if (pt22 != INVALID_POINT)
          {
            if (DEBUG)
              cerr << "Ellipses intersect at four points.\n";

            pt22 *= t_inverse;
            bpq.third.b = true;
            bpq.third.pt = pt22;
          }
        else
          {
            if (DEBUG)
              cerr << "Ellipses intersect at two points.\n";
          }

        if (pt23 != INVALID_POINT)
          {
            pt23 *= t_inverse;
            bpq.fourth.b = true;
            bpq.fourth.pt = pt23;
          }

        return bpq;
      } /* |if| */
    else
      {
        cerr << "WARNING! In Ellipse::intersection_points(Ellipse).\n";
        ss_e = e.location(copy.get_point(0));

        if (ss_e == 1)
          cerr << "*this is inside of e.\n";
        else if (ss_e == -1)
          cerr << "e is inside of *this.\n";
        else
          {
            cerr << "This can't happen! Invalid value for ss_e: "
                 << ss_e << endl;
          }
 
        cerr << "No intersection.\n"
             << "Returning INVALID_BOOL_POINT_QUADRUPLE.\n\n";
        return INVALID_BOOL_POINT_QUADRUPLE;
      }

  } /* End of ``Ellipses have the same center and axis orientation''.  */

@q ***** (5) Ellipses have different centers and/or axis orientation.@>
@ Ellipses have different centers and/or axis orientation.
There is no simple algebraic solution for this case, so I have to
implement a numerical one here.
@<Define |Ellipse| functions@>=
else
  {
    if (DEBUG)
      cerr << "The two ellipses don't have the same center and/or "
           << "the axis orientation is different.\n";

    Point curr_point;
    signed short curr_location;
    signed short location_switch;
    unsigned short intersection_ctr = 0;
    real save_angle;
    real in_angle;
    real out_angle;
    real test_angle;

    if (DEBUG)
      {
        e.show("e:");
        copy.show("copy:");
      }
    cerr << "In Ellipse::intersection_points():\n"
         << "Searching for Ellipse intersections. "
         << "This can take some time...\n\n";

    for (real i = 0; i < 360; i += .5)
      {
        if (DEBUG)
          cerr << "i == " << i << endl;

        curr_point = copy.angle_point(i);
        if (DEBUG)
          curr_point.show("curr_point");

        curr_location = e.location(curr_point);

        if (DEBUG) 
          cerr << "curr_location == " << curr_location << endl;

        if (curr_location == 0)
          {
            if (DEBUG)
              {
                cerr << "Found an intersection point!\n";
                curr_point.show("curr_point:");
              }                

            @<Handle intersection point@>@;

            i += .5;
            save_angle = i;
            curr_point = copy.angle_point(i);
            location_switch = e.location(curr_point);

            continue;
          } /* |if|.  End of ``Found an intersection point''.  */

        else if (i == ZERO_REAL)
          {
            location_switch = curr_location;
            save_angle = 0;
            continue;
          }

         else if (curr_location == 1)
           {
             if (DEBUG)
               cerr << "Point is inside e.\n";
           }
          else if (curr_location == -1)
            {  
              if (DEBUG)
                cerr << "Point is outside e.\n";
            }
        else
          {
            cerr << "ERROR! In Ellipse::intersection_points():\n"
                 << "This can't happen! curr_location has bad value: "
                 << curr_location << " "
                 << "Returning INVALID_BOOL_POINT_QUADRUPLE\n\n";

            return INVALID_BOOL_POINT_QUADRUPLE;
          }

        if (curr_location != location_switch)
          {
            if (DEBUG)
              {
                cerr << "Found a transition!\n";
                cerr << "i == " << i << endl;
                cerr << "save_angle == " << save_angle << endl;
                cerr << "curr_location == " << curr_location << endl;
                cerr << "location_switch == "
                  << location_switch << endl;
              }
            if (location_switch == 1)
              {
                in_angle = save_angle;
                out_angle = i;
              }
            else
              {
                in_angle = i;
                out_angle = save_angle;
              }
            while (true)
              {
                test_angle = (in_angle + out_angle) / 2;
                curr_point = copy.angle_point(test_angle);
                curr_location = e.location(curr_point);
                if (curr_location == 0)
                  {
                    if (DEBUG)
                      {
                        cerr << "Found an intersection point!\n";
                        curr_point.show("curr_point:");
                      }

                    @<Handle intersection point@>@;

                    i = floor(test_angle);
                    i += .5;
                    
                    if (i < test_angle)
                      i += .5;

                    save_angle = i;
                    curr_point = copy.angle_point(i);
                    location_switch = e.location(curr_point);
                    break;
                  }
                else if (curr_location == 1)
                  {
                    in_angle = test_angle;
                    continue;
                  }
                else if (curr_location == -1)
                  {
                    out_angle = test_angle;
                    continue;
                  }
                else
                  {
                    cerr << "ERROR! In Ellipse::intersection_points(Ellipse).\n"
                         << "This can't happen! Invalid value for curr_location: "
                         << curr_location 
                         << "\nReturning INVALID_BOOL_POINT_QUADRUPLE.\n\n";

                    return INVALID_BOOL_POINT_QUADRUPLE;
                  }
              } /* |while| */

          } /* |if| */

      } /* |for| */
    
          cerr << "Finished searching for Ellipse intersections."
               << endl << endl;

 } /*  End of ``Ellipses have different centers 
      and/or axis orientation''.  */

}  /* End of coplanar case.  */

@q ******* (7) Handle intersection point.@>
@ Handle intersection point.
@<Handle intersection point@>=
{
  ++intersection_ctr;

  if (DEBUG)
    {
      cerr << "intersection_ctr == "
        << intersection_ctr << endl;
    }
  
  if (intersection_ctr == 1)
    {
      bpq.first.b = true;
      bpq.first.pt = curr_point;
      bpq.first.pt *= t_inverse;
    }
  
  else if (intersection_ctr == 2)
    {
      bpq.second.b = true;
      bpq.second.pt = curr_point;
      bpq.second.pt *= t_inverse;
    }

  else if (intersection_ctr == 3)
    {
      bpq.third.b = true;
      bpq.third.pt = curr_point;
      bpq.third.pt *= t_inverse;
    }

  else if (intersection_ctr == 4)
    {
      bpq.fourth.b = true;
      bpq.fourth.pt = curr_point;
      bpq.fourth.pt *= t_inverse;
      if (DEBUG || verbose)
        {
          cerr << "In Ellipse::intersection_points(Ellipse e, const bool verbose)"
               << "Found fourth intersection point.\n"
               << "Returning bpq.\n\n";
        }
      return bpq;
    }

  else
    {
      cerr << "ERROR! In Ellipse::intersection_points(Ellipse).\n"
        << "This can't happen!  Invalid value for "
          << "intersection_ctr: " << intersection_ctr
            << ".\nReturning INVALID_BOOL_POINT_QUADRUPLE.\n\n";
      return INVALID_BOOL_POINT_QUADRUPLE;
    }
}

@q **** (4) Parallel and non-coplanar case.@>
@  Parallel and non-coplanar case.
@<Define |Ellipse| functions@>=
      else
        {
          cerr << "WARNING! In Ellipse::intersection_points(Ellipse).\n"
               << "Ellipses are in parallel planes, "
               << "so they don't intersect.\n"
               << "Returning INVALID_BOOL_POINT_QUADRUPLE.\n\n";
          return INVALID_BOOL_POINT_QUADRUPLE;

        }
    }
@q **** (4) Perpendicular and skew cases.@>
@ Perpendicular and skew cases.  These cases are handled in exactly
the same way. 
@<Define |Ellipse| functions@>=
else  
{
  if (DEBUG)
    cerr << "Ellipses are in perpendicular or skew planes.\n";

Line isect_line(this_plane.intersection_line(e_plane));

  if (DEBUG) 
    isect_line.show("isect_line:");

  Point pt0(isect_line.direction);
  pt0.shift(isect_line.position);

  Bool_Point_Pair bpp =
    intersection_points(isect_line.position,
                              pt0);
  
  if (DEBUG)
    {
      cerr << "bpp.first.b == " << bpp.first.b << endl;
      bpp.first.pt.show("bpp first point:");
      cerr << "bpp.second.b == " << bpp.second.b << endl;
      bpp.second.pt.show("bpp second point:");
    }
  
  bpq.first.pt = bpp.first.pt;
  bpq.first.b = (bpp.first.pt == INVALID_POINT) ? false : true;

  bpq.second.pt = bpp.second.pt;      
  bpq.second.b = (bpp.second.pt == INVALID_POINT) ? false : true;

  bpp = e.intersection_points(isect_line.position, pt0);

  bpq.third.pt = bpp.first.pt;
  bpq.third.b = (bpp.first.pt == INVALID_POINT) ? false : true;

  bpq.fourth.pt = bpp.second.pt;      
  bpq.fourth.b = (bpp.second.pt == INVALID_POINT) ? false : true;

  signed short s_t;
  signed short s_e;
  bool temp_bool;
  string temp_string;

  if (bpq.first.b)
    {
      s_t = location(bpq.first.pt);
      s_e = e.location(bpq.first.pt);
      temp_bool = bpq.first.b;
      temp_string = "First";
      @<Check intersection point locations@>@;
    }
  else if (verbose)
    cerr << "First intersection point is INVALID_POINT.\n";
    
  if (bpq.second.b)
    {
      s_t = location(bpq.second.pt);
      s_e = e.location(bpq.second.pt);
      temp_bool = bpq.second.b;
      temp_string = "Second";
      @<Check intersection point locations@>@;
    }
  else if (verbose)
    cerr << "Second intersection point is INVALID_POINT.\n";

  if (bpq.third.b)
    {
      s_t = location(bpq.third.pt);
      s_e = e.location(bpq.third.pt);
      temp_bool = bpq.third.b;
      temp_string = "Third";
      @<Check intersection point locations@>@;
    }
  else if (verbose)
    cerr << "Third intersection point is INVALID_POINT.\n";

  if (bpq.fourth.b)
    {
      s_t = location(bpq.fourth.pt);
      s_e = e.location(bpq.fourth.pt);
      temp_bool = bpq.fourth.b;
      temp_string = "Fourth";
      @<Check intersection point locations@>@;
    }
  else if (verbose)
    cerr << "Fourth intersection point is INVALID_POINT.\n";

} /* |else|.  End of perpendicular and skew cases.  */

if (DEBUG || verbose)
     cerr << "Exiting Ellipse::intersection_points(Ellipse)\n";
     return bpq;
}

@q ***  Check intersection point locations.@>
@ Check intersection point locations.  This is used in the
``Perpendicular and Skew Cases'' of 
|intersection_points(Ellipse e, const bool verbose)|.  \initials{LDF 2003.07.01.} 
\LOG
\initials{LDF 2003.07.01.}  Added this section.
\ENDLOG
@<Check intersection point locations@>=
  if (temp_bool)
    {
      if (verbose)
        {
          if (s_t == 0 && s_e == 0)
            cerr << temp_string << " point lies on the perimeter of both ellipses.\n";
          else if (s_t == 0)
            cerr << temp_string << " point lies on the perimeter of *this.\n";
          else if (s_t == -1)
            cerr << temp_string << " point lies outside *this.\n";
          else if (s_t == 1)
            cerr << temp_string << " point lies inside *this.\n";
          else if (s_t == -2)
            cerr << temp_string << " point doesn't lie in the plane of *this.\n";

          if (s_e == 0 && s_t != 0)
            cerr << temp_string << " point lies on the perimeter of e.\n";
          
          if (s_e == -1)
            cerr << temp_string << " point lies outside e.\n";
          else if (s_e == 1)
            cerr << temp_string << " point lies inside e.\n";
          else if (s_e == -2)
            cerr << temp_string << " point doesn't lie in the plane of e.\n";
        }
}  

@q * (1) Transformations.@>
@* Transformations. 

\LOG
\initials{LDF 2003.04.27.}  
Finished adding the transformation functions.  I
already had |shift|, now I have the rest of them.
\ENDLOG 

@q ** (2) Performing a transformation. @>
@*1 Performing a transformation.

@q *** (3) Do transform. @>
@*2 Do transform.
@^\cofunc{Ellipse}{do\_transform}@>
\initials{LDF 2003.07.20.}  
This function performs a transformation on |*this|.  

If |check == true|, |is_elliptical| is called on |*this| following
the transformation.
If the latter causes |*this| to
become non-elliptical, |axis_h|, |axis_v|, |linear_eccentricity|,
and |numerical_eccentricity| are set to
|INVALID_REAL|, and a warning is issued to |stderr|.  
|center|, |focus_0|, and |focus_1| are not set to |INVALID_POINT|.  They
may no longer really be
the center and foci of the (non-elliptical) |Ellipse|, but they may
have some use for the programmer and/or user.

If |check == true|, and the transformation does not cause |*this| to
become non-elliptical, |axis_h| and |axis_v| are recalculated.

\LOG
\initials{LDF 2003.07.20.}  
Added this function.  It makes it possible to perform
a transformation on an |Ellipse|, optionally calling
|is_elliptical|.  It is called in |is_elliptical| with 
|check ==  false|.  This prevents |operator*=| and |is_elliptical|
from calling each other {\it ad infinitum}.

\initials{LDF 2003.07.25.}  
Added code for recalculating |linear_eccentricity|, |focus_0|
and |focus1|. 

\initials{LDF 2003.07.25.} 
@:BUG FIX@> BUG FIX:  |axis_h| and |axis_v| were too
small by half.  Now multiplying by 2.

\initials{LDF 2003.07.25.}  
Added code for recalculating |numerical_eccentricity|. 
\ENDLOG

@q **** (4) Declaration.@>

@<Declare |Ellipse| functions@>=
virtual
Transform
do_transform(const Transform& t, bool check = false);

@q **** (4) Definition.@>   

@
@<Define |Ellipse| functions@>=
Transform
Ellipse::do_transform(const Transform& t, bool check)
{

    bool DEBUG = false; /* true */ 

    focus_0 *= focus_1 *= center *= Path::operator*=(t);
   
    real old_axis_h = axis_h;
    real old_axis_v = axis_v;

   if (check)
     {
       if (is_elliptical())
         {
           Point c = get_center();
           axis_h = (get_point(0) - c).magnitude() * 2;
           axis_v = (get_point(number_of_points / 4) - c).magnitude()
             * 2;
           
           real axis_h_half = axis_h / 2;
           real axis_v_half = axis_v / 2;

           if (fabs(axis_h - old_axis_h) > Point::epsilon()
               || fabs(axis_v - old_axis_v) > Point::epsilon())
             {
                 if (DEBUG) 
                   cerr << "Recalculating linear_eccentricity, "
                        << "numerical_eccentricity and foci.\n";

                 if (axis_h >= axis_v)
                   {
                       linear_eccentricity = sqrt((axis_h_half * axis_h_half)
                                           - (axis_v_half * axis_v_half));

                       numerical_eccentricity = linear_eccentricity / axis_h_half;
                       focus_1 =  focus_0 = (get_point(0) - get_center());
                   }
                 else
                   {
                       linear_eccentricity = sqrt((axis_v_half * axis_v_half)
                                           - (axis_h_half * axis_h_half));

                       numerical_eccentricity = linear_eccentricity / axis_v_half;
                       focus_1 =  focus_0
                         = (get_point(number_of_points / 4)
                            - get_center());
                   }

                 focus_0.unit_vector(true);
                 focus_1.unit_vector(true);
                 focus_0 *= -linear_eccentricity;
                 focus_1 *= linear_eccentricity;
                 focus_1 *= focus_0.shift(get_center());
             }
           else if (DEBUG) 
             cerr << "axis_h and axis_v are unchanged.\n"
                  << "Not recalculating foci.\n";

         } /* |if (is_elliptical())| */

@q ***** (5).@> 
@
\LOG
\initials{LDF 2005.01.14.}
Turned off warning message.
\ENDLOG 

@<Define |Ellipse| functions@>=

       else
         {
#if 0 
           cerr << "WARNING! In Ellipse::do_transform(const Transform&):\n"
             << "This transformation has made *this non-elliptical!"
               << endl << endl;
#endif 
           axis_h = axis_v = linear_eccentricity = INVALID_REAL;
           numerical_eccentricity = INVALID_REAL;
         }
     }
   return t;

}  /* End of |Ellipse::do_transform| definition.  */

@q *** (3) Multiplication with assignment operator.@>
@*2 Multiplication with assignment operator.
@^\cofunc{Ellipse}{*=}@>
\initials{LDF 2002.04.12.}

\LOG
\initials{LDF 2002.04.12.}  
Added this function.

\initials{LDF 2003.07.20.}  
Changed this function, so that it calls |do_transform| with
|check == true|, so that |is_elliptical| is called.  
\ENDLOG 

@<Declare |Ellipse| functions@>=
virtual
Transform
operator*=(const Transform& t);

@
@<Define |Ellipse| functions@>=
Transform
Ellipse::operator*=(const Transform& t)
{
  return do_transform(t, true);
}

@q ** (2) Rotatation around the main axes.@>
@*1 Rotation  around the main axes. 
@^\cfunc{Ellipse}{rotate}@>

\LOG
\initials{LDF 2003.07.25.}  
Changed this function, so that |do_transform| is called with
|check == false|.  Rotation can neither change the lengths of |axis_h|
or |axis_v|, nor make an |Ellipse| non-elliptical, so there's no need
to check |*this| after rotation.
\ENDLOG 

@<Declare |Ellipse| functions@>=
virtual
Transform 
rotate(const real x, const real y = 0, const real z = 0);

@
@<Define |Ellipse| functions@>=
Transform 
Ellipse::rotate(const real x, const real y, const real z)
{
  Transform t;
  t.rotate(x, y, z);
  return do_transform(t, false);
}

@q ** Scale. @>
@ Scale. 
@^\cfunc{Ellipse}{scale}@>
\LOG
\initials{LDF 2003.07.20.}  Added check for whether |*this| is still elliptical
after the scaling operation.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
Transform 
scale(real x, real y = 1, real z = 1);

@
@<Define |Ellipse| functions@>=
Transform 
Ellipse::scale(real x, real y, real z)
{
  Transform t;
  t.scale(x, y, z);
  return (*this *= t);
}

@q ** (2) Shear.@>
@*1 Shear. 
@^\cfunc{Ellipse}{shear}@>

\LOG
\initials{LDF 2003.07.20.}  
Added check for whether |*this| is still elliptical
after the shearing operation.
\ENDLOG 

@<Declare |Ellipse| functions@>=

virtual
Transform 
shear(real xy, real xz = 0, real yx = 0, real yz = 0, 
      real zx = 0, real zy = 0);

@
@<Define |Ellipse| functions@>=
Transform 
Ellipse::shear(real xy, real xz, real yx, real yz, 
      real zx, real zy)
{
  Transform t;
  t.shear(xy, xz, yx, yz, zx, zy);
  return (*this *= t);

}

@q ** Shift. @>
@ Shift. 

@q *** real arguments. @>
@ {\bf real} arguments. 
@^\cfunc{Ellipse}{shift}@>
\LOG
\initials{LDF 2003.07.25.}  Changed, so that |do_transform| is called with
|check == false|.  Shifting can neither change the lengths of |axis_h|
or |axis_v|, nor make an |Ellipse| non-elliptical, so there's no need
to check |*this| after shifting.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
Transform 
shift(real xx, real yy = 0, real zz = 0);

@
@<Define |Ellipse| functions@>=
Transform
Ellipse::shift(real xx, real yy, real zz)
{
  Transform t;
  t.shift(xx, yy, zz);
  return do_transform(t, false);
}

@q *** Point argument. @>
@ {\bf Point} argument. 
@^\cfunc{Ellipse}{shift}@>
@<Declare |Ellipse| functions@>=
virtual
Transform 
shift(const Point& p);

@
@<Define |Ellipse| functions@>=
Transform 
Ellipse::shift(const Point& p)
{
  return shift(p.get_x(), p.get_y(), p.get_z());
}

@q ** Shift times. @>
@ Shift times. 

@q **** (4) real arguments. @>
@ {\bf real} arguments. 
@^\cfunc{Ellipse}{shift\_times}@>
\LOG
\initials{LDF 2003.07.25.}  Now performing |shift_times| on |focus0| and
|focus1|, too.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
void 
shift_times(real x, real y = 1, real z = 1);

@
@<Define |Ellipse| functions@>=
void 
Ellipse::shift_times(real x, real y, real z)
{
  Path::shift_times(x, y, z);
    focus_1.shift_times(x, y, z);
    focus_0.shift_times(x, y, z);
    center.shift_times(x, y, z);
    return;
}

@q *** Point argument. @>
@ {\bf Point} argument. 
@^\cfunc{Ellipse}{shift\_times}@>
@<Declare |Ellipse| functions@>=
virtual
void
shift_times(const Point& p);

@
@<Define |Ellipse| functions@>=
void
Ellipse::shift_times(const Point& p)
{
  return shift_times(p.get_x(), p.get_y(), p.get_z());
}

@q ** Rotatation around an arbitrary axis. @>
@ Rotatation around an arbitrary axis. 

@q *** Point arguments.@>
@ {\bf Point} arguments.
@^\cfunc{Ellipse}{rotate}@>
\LOG
\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.

\initials{LDF 2003.07.25.}  Changed, so that |do_transform| is called with
|check == false|.  Rotation can neither change the lengths of |axis_h|
or |axis_v|, nor make an |Ellipse| non-elliptical, so there's no need
to check |*this| after rotation.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
Transform 
rotate(const Point& p0, const Point& p1, const real angle = 180);

@
@<Define |Ellipse| functions@>=
Transform 
Ellipse::rotate(const Point& p0, const Point& p1, const real angle)
{
  Transform t;
  t.rotate(p0, p1, angle);
  return do_transform(t, false);
}

@q *** Path argument.@>
@ {\bf Path} arguments.
@^\cfunc{Ellipse}{rotate}@>
\LOG
\initials{LDF 2003.05.02.}  Changed name of this function from |rotate_around|
to |rotate|.  This function now overloads |rotate| with three
|real| arguments.
\ENDLOG 
@<Declare |Ellipse| functions@>=
virtual
Transform 
rotate(const Path& p, const real angle = 180);

@
\LOG
\initials{LDF 2003.04.27.}  Changed |get_point(1)| to |get_last_point|.
\ENDLOG 
@<Define |Ellipse| functions@>=
Transform 
Ellipse::rotate(const Path& p, const real angle)
{
  if (!p.is_linear())
    {
      cerr << "ERROR! In Ellipse::rotate(Path, real).\n"
        << "Path is not a line.  Returning INVALID_TRANSFORM.\n\n";
      return INVALID_TRANSFORM;
    }
  return rotate(p.get_point(0),
                       p.get_last_point(), angle);  
}   

@q ** (2) Standardize.@> 
@*1 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.  It currently has a dummy definition.

\initials{LDF 2005.11.27.}
Changed return type from |Transform| to |Transform*|.
\ENDLOG

@q *** (3) Declaration.@> 

@<Declare |Ellipse| functions@>=
virtual
Transform*
standardize(Scanner_Node scanner_node = 0) const;

@q *** (3) Definition.@> 

@
@<Define |Ellipse| functions@>=
Transform*
Ellipse::standardize(Scanner_Node scanner_node) const
{
    Transform* t = 0;

    return t;
}

@q * (1) Showing.@>
@* Showing.
@^\cfunc{Ellipse}{show}@>
\initials{LDF 2004.12.14.}

\LOG
\initials{LDF 2004.12.14.}
Added this function.
\ENDLOG

@q ** (2) Declaration.@> 

@<Declare |Ellipse| functions@>=

virtual 
void 
show(string text = "", 
     char coords = 'w',
     const bool do_persp = true, 
     const bool do_apply = true,
     Focus* f = 0, 
     const unsigned short proj = 0,
     const real factor = 1,
     int show_connectors = 0) const;

@
@<Define |Ellipse| functions@>=
void 
Ellipse::show(string text, char coords,
              const bool do_persp, const bool do_apply,
              Focus* f, const unsigned short proj,
              const real factor,
              int show_connectors) const

{
   if (text == "")
     text = "Ellipse:";

   Path::show(text, coords, do_persp, do_apply,
              f, proj, factor);

   center.show("center:");
   focus_0.show("focus_0:");
   focus_1.show("focus_1:");

   return;

}  /* End of |Ellipse::show| definition.  */

@q * Rectangles.@>
@* Rectangles.

@q ** Surrounding rectangle. (out_rectangle())@>
@ Surrounding rectangle.
@^\cfunc{Ellipse}{out\_rectangle}@>

\LOG
\initials{LDF 2003.07.18.}  
Made |const|.
\ENDLOG 

@<Declare |Ellipse| functions@>=
Rectangle
out_rectangle() const;

@
@<Define |Ellipse| functions@>=
Rectangle
Ellipse::out_rectangle() const
{
  Point C(get_center());
  Point pt0(get_point(0));
  Point pt1(get_point(number_of_points / 2));
  Path pa0(pt0, pt1);

Point pt2(get_point(number_of_points / 4));
  Point pt3(get_point(3 * number_of_points / 4));

  Point pt4(pt1);
  pt4 -= C;

  Point pt5(pt2);
  pt5.shift(pt4);

  Point pt6(pt3);
  pt6.shift(pt4);

  Point pt7(pt0);
  pt7 -= C;

  Point pt8(pt2);
  pt8.shift(pt7);

  Point pt9(pt3);
  pt9.shift(pt7);

#if 0 
  pt0.dotlabel("0");
  pt1.dotlabel("1");
  pt2.dotlabel("2");
  pt3.dotlabel("3");
  pt5.dotlabel("5");
  pt6.dotlabel("6");
  pt8.dotlabel("8");
  pt9.dotlabel("9");
#endif 

  Rectangle r(pt6, pt9, pt8, pt5);
  return r;

}

@q ** Inscribed rectangle. (in_rectangle())@>
@ Inscribed rectangle.
@^\cfunc{Ellipse}{in\_rectangle}@>
\LOG
\initials{LDF 2003.07.18.}  Made |const|.
\ENDLOG 
@<Declare |Ellipse| functions@>=
Rectangle
in_rectangle() const;

@
@<Define |Ellipse| functions@>=
Rectangle
Ellipse::in_rectangle() const
{

  Rectangle r0 = out_rectangle();

  Bool_Point_Pair bpp0 = intersection_points(r0.get_point(0),
                                             r0.get_point(2));
  
  Bool_Point_Pair bpp1 = intersection_points(r0.get_point(1),
                                             r0.get_point(3));

  if (bpp0.first.pt == INVALID_POINT || bpp0.second.pt == INVALID_POINT
      || bpp1.first.pt == INVALID_POINT || bpp1.second.pt == INVALID_POINT)
    {
      cerr << "Intersection didn't work.\n"
           << "Returning empty rectangle.\n\n";
      Rectangle r2;
      return r2;
    }

  Rectangle r1(bpp0.second.pt, bpp1.first.pt, bpp0.first.pt, bpp1.second.pt);
  return r1;
}

@q ** (2) Drawing the rectangles.@>

@q *** (3) Draw surrounding rectangle.@>
@*2 Draw surrounding rectangle.
@^\cfunc{Ellipse}{draw\_out\_rectangle}@>
\initials{LDF Undated.}

\LOG
\initials{LDF 2003.07.01.}  
Changed the return value from |void| to |Rectangle|.
Now the surrounding |Rectangle| is returned.

\initials{LDF 2003.07.18.}  
Made this function |const|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| argument to 
|const Dash_Pattern* ddashed| and changed the default from |""| to 0.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.05.25.}
Change the call to |draw| when I've made the |Picture| argument its
first argument.
\ENDTODO 

@<Declare |Ellipse| functions@>=
Rectangle
draw_out_rectangle(Picture& picture,
                   Pointer_Vector<Color>* ddraw_color_vector = 0,
                   Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
                   Pointer_Vector<Pen>* ppen_vector = 0) const;

@
@<Define |Ellipse| functions@>=
Rectangle
Ellipse::draw_out_rectangle(Picture& picture,
                            Pointer_Vector<Color>* ddraw_color_vector,
                            Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                            Pointer_Vector<Pen>* ppen_vector) const
{
  Rectangle r = out_rectangle();
  r.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
  return r;

}

@q *** (3) Draw inscribed rectangle.@>
@*2 Draw inscribed rectangle.

\LOG
\initials{LDF 2003.07.01.}  
Changed the return value from |void| to |Rectangle|.
Now the inscribed |Rectangle| is returned.

\initials{LDF 2003.07.18.}  
Made this function |const|.

\initials{LDF 2004.05.25.}  
Made |Picture& picture| the first argument
and removed the default, which was formerly |current_picture|.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.03.}  
Changed default for |ddraw_color| from
|Colors::default_color| to 0, since I've gotten rid of the former.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| argument to 
|const Dash_Pattern* ddashed| and changed the default from |""| to 0.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG

@<Declare |Ellipse| functions@>=
Rectangle
draw_in_rectangle(Picture& picture,
                  Pointer_Vector<Color>* ddraw_color_vector = 0,
                  Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0,
                  Pointer_Vector<Pen>* ppen_vector = 0) const;

@
@<Define |Ellipse| functions@>=
Rectangle
Ellipse::draw_in_rectangle(Picture& picture,
                           Pointer_Vector<Color>* ddraw_color_vector,
                           Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                           Pointer_Vector<Pen>* ppen_vector) const
{
   Rectangle r = in_rectangle();
   r.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
   return r;
}

@q * (1) |Rectangle| functions.@>
@* {\bf Rectangle} functions.

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.07.18.}
Add |undraw_in_ellipse|, |fill_out_ellipse|, etc.  Also, I should add
versions with the |Picture| argument first.
\ENDTODO 

\LOG
\initials{LDF 2003.07.18.}  
Added this section.  These functions are declared in
\filename{rectangs.web}, but must be defined
here, because |Ellipse| is an incomplete type there.
\ENDLOG 

@q ** (2) |Ellipses|.@>
@*1 {\bf Ellipses}.

@q *** (3) Surrounding |Ellipse|.@>
@*2 Surrounding {\bf Ellipse}.
\initials{LDF 2003.07.18.}  

\LOG
\initials{LDF 2003.07.18.}  
Added this function.

\initials{LDF 2004.05.02.}  
Changed |Point x_axis_pt(1)| to 
|Point x_axis_pt(1, 0, 0)| because this |Point| constructor now
requires three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.
\ENDLOG 

@q **** (4) Definition.@> 

@<Define |Rectangle| functions@>=

Ellipse
Rectangle::out_ellipse() const
{
 
  Point C = get_center();
  Point p0 = get_point(0);
  Point M = get_mid_point(1);
  Point normal = get_normal();
  normal.shift(C);

  Point origin_pt(0, 0, 0);

  real out_distance = (p0 - C).magnitude();

  Transform t;

  real h_length = (get_point(1) - p0).magnitude();
  real v_length = (get_point(3) - p0).magnitude();

  p0 *= M *= C *= t.align_with_axis(C, normal, 'y');

  Point x_axis_pt(1, 0, 0);
  real angle = M.angle(x_axis_pt);

  p0 *= M *= t.rotate(0, angle);

  if (M.unit_vector() != x_axis_pt)
    {
      cerr << "WARNING! In |Rectangle::in_ellipse|:\n"
           << "M is not (1, 0, 0)!\n";
      M.show("M:"); /* I'd rather output this to |stderr|, but
                       I don't have a way to do this yet.  
                       \initials{LDF 2003.07.18.}  */
      cerr << endl;                                            
    }
    
  Ellipse e(origin_pt, h_length, v_length);

  Bool_Point_Pair bpp = e.intersection_points(origin_pt, p0);

  real in_distance;

  if (bpp.first.b)
    {
      in_distance = bpp.first.pt.magnitude();
    }
  else if (bpp.second.b)
    {
      in_distance = bpp.second.pt.magnitude();
    }
  else
    {
      cerr << "ERROR! In |Rectangle::out_ellipse|:\n"
           << "Couldn't find intersection point.\n"
           << "Returning empty Ellipse.\n\n";
      Ellipse r;
      return r;
    }

  real scale_value = out_distance / in_distance;

  e.scale(scale_value, 0, scale_value);

  e *= t.inverse();

  return e;
}

@q *** (3) Enclosed |Ellipse|.@>
@*2 Enclosed {\bf Ellipse}.

\LOG
\initials{LDF 2003.07.18.}  
Added this function.

\initials{LDF 2004.05.02.}  
Changed |Point x_axis_pt(1)| to 
|Point x_axis_pt(1, 0, 0)| because this |Point| constructor now
requires three explicit |real| arguments.  This is because |CURR_Y| and 
|CURR_Z| are no longer |static| members of |class Point|, but rather 
internal quantities, stored in |Scanner_Type.id_map_node->id_map|.  This way, 
each |Scanner_Node| can its own |CURR_Y| and |CURR_Z|, and code using them 
will be reentrant.

\initials{LDF 2004.06.08.}  
Changed |origin| to |origin_pt|, because I've
removed the global variable |origin|.  I'm replacing it with a predefined
variable defined in |Scanner_Type::create|.

\initials{LDF 2005.11.02.}
Added |Scanner_Node scanner_node| argument.  Made warning output thread-safe.

\initials{LDF 2005.11.02.}
Added |unsigned int point_count| argument. 
Now using the mid-points to find the lengths of the horizontal 
and vertical axes.  This should make it possible to use this function for
non-rectangular |Rectangles|, until I write a version for quadrilateral 
|Paths|, as long as the lines connecting the horizontal and vertical mid-points, 
respectively, are perpendicular.  
@:BUG FIX@> BUG FIX: 
Added code for adjusting the position of 
|Point M|, if rotating it by |real angle| doesn't put it onto the x-axis.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.11.02.}
Write a version of this function and |out_ellipse| for quadrilateral 
|Paths|.
\ENDTODO 

@q **** (4) Definition.@> 

@<Define |Rectangle| functions@>=
Ellipse
Rectangle::in_ellipse(unsigned int point_count, Scanner_Node scanner_node) const
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

    Point origin_pt(0, 0, 0);
    
    Point C = get_center();
    Point M = get_mid_point(1);
    Point normal = get_normal();
    normal.shift(C);

    Transform t;

    real h_length = (get_mid_point(1) - get_point(3)).magnitude();
    real v_length = (get_mid_point(0) - get_point(2)).magnitude();

    M *= C *= t.align_with_axis(C, normal, 'y');

    Point x_axis_pt(1, 0, 0);
    Point minus_x_axis_pt(-1, 0, 0);

    real angle = M.angle(x_axis_pt);

    M *= t.rotate(0, angle);

    if (!(M.unit_vector() == x_axis_pt || M.unit_vector() == minus_x_axis_pt))
       M *= t.rotate(0, -2 * angle);

    if (!(M.unit_vector() == x_axis_pt || M.unit_vector() == minus_x_axis_pt))
      {
          cerr_strm << thread_name << "WARNING! In `Rectangle::in_ellipse()':"
                    << endl 
                    << "`M' is not (1, 0, 0) or (-1, 0, 0)!" << endl;

          log_message(cerr_strm);
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          cerr_mutex.lock(); 
          M.show("M:");      
          cerr_mutex.unlock();                    

      }  /* |if (M.unit_vector() != x_axis_pt)|  */
      
    Ellipse e(origin_pt, h_length, v_length, 0, 0, 0, point_count);
    e *= t.inverse();
    return e;

@q ***** (5)@> 

}  /* End of |Rectangle::in_ellipse| definition.  */

@q *** (3) Draw surrounding |Ellipse|.@>
@*2 Draw surrounding {\bf Ellipse}.
\initials{LDF 2003.07.18.}  

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2003.07.18.}  
Add version with |Picture| argument first.
\ENDTODO 

\LOG
\initials{LDF 2003.07.18.}  
Added this function.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| argument to 
|const Dash_Pattern* ddashed|.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@<Define |Rectangle| functions@>=

Ellipse
Rectangle::draw_out_ellipse(Pointer_Vector<Color>* ddraw_color_vector,
                            Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                            Pointer_Vector<Pen>* ppen_vector,
                            Picture& picture) const
{
  Ellipse e = out_ellipse();
  e.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
  return e;
}

@q *** (3) Draw enclosed |Ellipse|.@>
@*2 Draw enclosed {\bf Ellipse}.
\initials{LDF 2003.07.18.}  

\LOG
\initials{LDF 2003.07.18.}  
Added this function.

\initials{LDF 2004.06.02.}  
Changed |const Color& ddraw_color| 
to |const Color* ddraw_color| and |const string ppen| to 
|const Pen* ppen|.

\initials{LDF 2004.06.07.}  
Changed |string ddashed| argument to 
|const Dash_Pattern* ddashed|.

\initials{LDF 2005.03.15.}
Replaced the optional argument |const Color* ddraw_color|, 
with default 0, with the optional argument 
|Pointer_Vector<Color>* ddraw_color_vector|, also with default 0.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Pen* ppen = 0| 
with the optional argument |Pointer_Vector<Pen>* ppen_vector = 0|.

\initials{LDF 2005.03.18.}
Replaced the optional argument |const Dash_Pattern* ddash_pattern = 0| 
with the optional argument 
|Pointer_Vector<Dash_Pattern>* ddash_pattern_vector = 0|.
\ENDLOG 

@<Define |Rectangle| functions@>=

Ellipse
Rectangle::draw_in_ellipse(Pointer_Vector<Color>* ddraw_color_vector,
                           Pointer_Vector<Dash_Pattern>* ddash_pattern_vector,
                           Pointer_Vector<Pen>* ppen_vector,
                           Picture& picture) const
{
  Ellipse e = in_ellipse();
  e.draw(picture, ddraw_color_vector, ddash_pattern_vector, ppen_vector);
  return e;
}




@q * (1) Putting Ellipse together.@>
@* Putting {\bf Ellipse} together.
\initials{LDF Undated.}

This is what's compiled.
\initials{LDF Undated.}

@c
@<Include files@>@;
@<Define |class Ellipse|@>@;
@<Define |static| |Ellipse| data members@>@;
@<Define |Ellipse| functions@>@;
@<Define |Path| functions@>@;
@<Define |Rectangle| functions@>@;
@<Declare non-member template functions for |Ellipse|@>@;

@ This is what's written to \filename{ellipses.h}.
\initials{LDF Undated.}

@(ellipses.h@>=
@<Define |class Ellipse|@>@;
@<Declare non-member template functions for |Ellipse|@>@;

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>

@q * Local variables for Emacs.@>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
