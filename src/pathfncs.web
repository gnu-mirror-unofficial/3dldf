@q pathfncs.web @>
   
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Path functions.@>       
@** Path functions\quad ({\tt pathfncs\PERIOD web}).\hfil
\initials{LDF 2022.04.04.}

\LOG
\initials{LDF 2022.04.04.}
Created this file.
\ENDLOG 

@q * Include files. @>
@ Include files.

@<Include files@>=

#include "loader.h++"

#include <sys/types.h>
#include <sys/stat.h>

#include <string.h>
#include <math.h>

#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "utility.h++"
#include "scnmptpt.h++"
#include "paths.h++"
#include "mpoutput.h++"

@q * (1) @>
@
@<Define |Path| functions@>=
Path
Path::append(const Path& p, string connector, bool assign)
{

  bool DEBUG = true; /* |false| */ 

  int i = 0;
  int j = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Entering `Path::append'." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

  Path r(*this);

  string last_connector;
  Connector_Type *last_connector_type = 0;

  r.set_cycle(false);

@q **** (4) @>   

@ If there isn't an explicit connector for every pair
of |Points| in |points|, then we have to fill up
|connectors| so that there are enough. Otherwise, the ``{\AM}'' 
will be at the wrong place.  
\initials{LDF 2002.4.6.}  

@<Define |Path| functions@>=

@q **** (4) @>

  if (r.connector_type_vector.size() == 0)
  {
    last_connector_type = create_new<Connector_Type>(0);
    last_connector_type->type0 = Connector_Type::PLAIN_TYPE;
    last_connector_type->type1 = Connector_Type::CT_NULL_TYPE;
    last_connector_type->connector_string = "--";
  }
  else
    last_connector_type = r.connector_type_vector.back();

@q **** (4) @>
@
@<Define |Path| functions@>=

  if (r.points.size() > 0)
  {
@q ***** (5) @>

     i = r.points.size() - 1;
     j = r.connector_type_vector.size();

     cerr << "i == " << i << endl;
     cerr << "j == " << j << endl;

@q ***** (5) @>

      while (r.connector_type_vector.size() < i)
      {
@q ****** (6) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
            cerr << "In `Path::append':" << endl 
                 << "Pushing Connector_Type* onto connector_type_vector." << endl;  /* LDF 2022.01.14.  */
         }
#endif /* |DEBUG_COMPILE|  */@; 

        r.connector_type_vector.push_back(create_new<Connector_Type>(last_connector_type));

        if (j >= i)
        {

#if DEBUG_COMPILE
           if (DEBUG)
           { 
               cerr << "In `Path::append':" << endl 
                    << "j >= i.  Breaking." << endl;
           }     
#endif /* |DEBUG_COMPILE|  */@; 

           break;

        }

        ++j;

@q ****** (6) @>

      }  /* |while| */   

@q ***** (5) @>

  }  /* |if (r.points.size() > 0)| */

@q **** (4) @>

  r.connector_type_vector.push_back(create_new<Connector_Type>(0));
  r.connector_type_vector.back()->type0 = Connector_Type::PLAIN_TYPE;
  r.connector_type_vector.back()->type1 = Connector_Type::CT_NULL_TYPE;
  r.connector_type_vector.back()->connector_string = connector;

@q **** (4) @>   

@ Copy the |Points| in |p| and put the copies onto |points|.
\initials{LDF 2002.4.6.} 

@<Define |Path| functions@>=


  for(vector<Point*>::const_iterator iter = p.points.begin();
      iter != p.points.end();
      iter++)
    r.points.push_back(create_new<Point>(*iter));

@q **** (4) @>   
   
@ Put the connectors from |p| onto the new |Path|.  Since they're
|strings|, and not pointers, we don't have to copy them.  
\initials{LDF 2002.4.6.}

\LOG
\initials{LDF 2004.11.01.}
Now removing excess connectors.
\ENDLOG 

@<Define |Path| functions@>= 

#if 0
 cerr << "p.connector_type_vector.size() == " << p.connector_type_vector.size() << endl;
#endif 

  i = 0;

@q **** (4) @>
@
@<Define |Path| functions@>=

  for(vector<Connector_Type*>::const_iterator iter = p.connector_type_vector.begin();
      iter != p.connector_type_vector.end();
      iter++)
    {
@q ***** (5) @>


#if DEBUG_COMPILE
        if (DEBUG)
        {
           cerr << "In `Path::YYY append':" << endl 
                << "`i' == " << i << endl 
                << "Pushing Connector_Type* onto r.connector_type_vector." << endl;  /* LDF 2022.01.14.  */
        }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

        r.connector_type_vector.push_back(create_new<Connector_Type>(*iter));

@q ***** (5) @>

        if (i > 20)
        {
#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr << "In `Path::append':" << endl 
                   << "`i' == " << i << " > 20.  Breaking" << endl;
           }  
#endif /* |DEBUG_COMPILE|  */@; 

           break;

        }

@q ***** (5) @>

        else
        {
#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr << "In `Path::append':" << endl 
                   << "`i' == " << i << " <= 20.  Not breaking" << endl;

           }  
#endif /* |DEBUG_COMPILE|  */@; 

        }

@q ***** (5) @>
 
        ++i;

@q ***** (5) @>

   } /* |for| */

@q **** (4) @>
@
@<Define |Path| functions@>=

   while (r.connector_type_vector.size() >= r.points.size())
   {
      delete r.connector_type_vector.back();
      r.connector_type_vector.back() = 0;
      r.connector_type_vector.pop_back();
   }

@q **** (4) @>

  if (assign == true)
    *this = r;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Path::append' with return value `Path r'." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

  return r;

} /* End of |Path::append| definition.  */





@q * (1) Putting Path functions together.@>
@ Putting {\bf Path} functions together.
\initials{LDF 2022.04.04.}

@q ** (2).@> 

@ This is what's compiled.
\initials{LDF 2022.04.04.}

@c
@<Include files@>@;
@<Define |Path| functions@>@;

@q ** (2).@> 

@ This is what's written to \filename{pathfncs.h}. 
\initials{LDF 2022.04.04.}

@(pathfncs.h@>=
/* Empty */

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t))                          @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
