@q pathfncs.web @>
   
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2022 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>

@q * (0) Path functions.@>       
@** Path functions\quad ({\tt pathfncs\PERIOD web}).\hfil
\initials{LDF 2022.04.04.}

\LOG
\initials{LDF 2022.04.04.}
Created this file.
\ENDLOG 

@q * Include files. @>
@ Include files.

@<Include files@>=

#include "loader.h++"

#include <sys/types.h>
#include <sys/stat.h>

#include <string.h>
#include <math.h>

#include "pspglb.h++"
#include "io.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++"
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "utility.h++"
#include "scnmptpt.h++"
#include "paths.h++"
#include "mpoutput.h++"

@q * (1) Show.  @>
@* Show.

\LOG
\initials{LDF 2022.04.04.}
Moved this definition to this file from \filename{paths.web}.
\ENDLOG

@<Define |Path| functions@>=
void 
Path::show(string text, char coords,
           const bool do_persp, const bool do_apply,
           Focus* f, const unsigned short proj,
           const real factor,
           int show_connectors_option) const
{
@q ** (2) @>

#if DEBUG_COMPILE

   bool DEBUG = true; /* |false| */ 

   if (DEBUG)
   { 
       cerr << "Entering `Path::show'." << endl;

       cerr << "show_connectors_option == " << show_connectors_option << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ** (2) @>

   bool quiet              = show_connectors_option & 1U;
   bool verbose            = show_connectors_option & 2U;
   int with_connectors_val = 0;

   if (show_connectors_option & 16U)
      with_connectors_val = 3;
   else if (show_connectors_option & 8U)
      with_connectors_val = 2;
   else if (show_connectors_option & 4U)
      with_connectors_val = 1;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "In `Path::show':" << endl
           << "`quiet'               == " << quiet << endl 
           << "`verbose'             == " << verbose << endl 
           << "`with_connectors_val' == " << with_connectors_val << endl;

cerr << "XXX Enter <RETURN> to continue: ";
getchar();

   }  
#endif /* |DEBUG_COMPILE|  */@;    

@q ** (2) @>
@
@<Define |Path| functions@>=

   if (text == "")
     text = "Path:";

   cerr << text << endl;
   
   coords = tolower(coords);
   
   if (coords == 'w')
     ; /* Do nothing.  */

   else if (coords == 'p')
      cerr << "Projective coordinates.\n";

   else if (coords == 'u')
     cerr << "User coordinates.\n";

   else if (coords == 'v')
     cerr << "View coordinates.\n";

   else
     {
       cerr << "WARNING!  In `Path::show':  "
            << "Invalid character for coords argument.\n" 
            << "Showing world coordinates.\n";
       coords = 'w';
     }

   valarray <real> v;
   v.resize(4, 0);  /* LDF 2002.12.13.  Added this line.  Needed 
                       for porting to Intel Linux (i686).  */
   
   cerr << "type:  " << Shape::type_name_map[get_shape_type()] << endl;
   cerr << "surface_hiding_ctr:  " << surface_hiding_ctr << endl;

   cerr << "decomposition_level:  " << decomposition_level << endl;

   cerr << "points.size() == " 
        << points.size() << endl;  

   cerr << "connector_type_vector.size() == " 
        << connector_type_vector.size() << endl;  

   int loop_ctr = 0;

   string connector_string;

   if (points.size() > 0)
      cerr << "points:" << endl;
   else 
      cerr << "points is empty.  Not showing." << endl;

@q ** (2) @>
@
@<Define |Path| functions@>=

   vector<Connector_Type*>::const_iterator c_iter = connector_type_vector.begin();

   int i = 0;

   for(vector <Point*>::const_iterator points_iter = points.begin();
       points_iter != points.end();
       ++points_iter)
   {
@q *** (3) @>

     if (loop_ctr == 2) /* Break each line after 2 |Points|.  */
     {
       cerr << endl;
       loop_ctr = 0;
     }
     ++loop_ctr;     
     
     v = (**points_iter).get_all_coords(coords, do_persp, do_apply,
                                        f, proj, factor);
     
     cerr << "(" << v[0] << ", " << v[1] << ", " << v[2] << ") ";

@q *** (3) @>
@
@<Define |Path| functions@>=

     if (c_iter != connector_type_vector.end())
     {
@q **** (4) @>

         if ((*c_iter)->type0 == Connector_Type::CONTROLS_TYPE)
         {
@q ***** (5) @>

            if (with_connectors_val < 3)
            {
@q ****** (6) @>

               if ((*c_iter)->pt0 != 0 && (*c_iter)->pt1 != 0)
                  cerr << "..CC.. ";

@q ****** (6) @>

               else if ((*c_iter)->pt0 != 0 && (*c_iter)->pt1 == 0)
                  cerr << "..C.. ";
@q ****** (6) @>

               else
               {
                  cerr << "WARNING!  In `Path::show':" << endl
                       << "`Connector_Type' " << i << " is of type `CONTROLS_TYPE' but "
                       << "`Point *pt0' and `Point *pt1' are both NULL."
                       << endl
                       << "This shouldn't be possible.  Continuing."
                       << endl;
 
                  cerr << "..CC.. ";
               }
@q ****** (6) @>
              
            }  /* |if (with_connectors_val < 3)|  */

@q ***** (5) @>
@
@<Define |Path| functions@>=

            else if (with_connectors_val >= 3)
            {
@q ****** (6) @>

               if ((*c_iter)->pt0 != 0 && (*c_iter)->pt1 != 0)
                  cerr << ".. controls (" << (*c_iter)->pt0->get_x() << ", "
                       << (*c_iter)->pt0->get_y() << ", " << (*c_iter)->pt0->get_z()
                       << ") and (" << (*c_iter)->pt1->get_x() << ", "
                       << (*c_iter)->pt1->get_y() << ", " << (*c_iter)->pt1->get_z()
                       << ") .. ";

@q ****** (6) @>

               else if ((*c_iter)->pt0 != 0 && (*c_iter)->pt1 == 0)
                  cerr << ".. controls (" << (*c_iter)->pt0->get_x() << ", "
                       << (*c_iter)->pt0->get_y() << ", " << (*c_iter)->pt0->get_z()
                       << ") .. ";

@q ****** (6) @>

               else if ((*c_iter)->pt0 == 0 && (*c_iter)->pt1 != 0)
               {
                  cerr << "WARNING!  In `Path::show':" << endl
                       << "`Connector_Type' " << i << " is of type `CONTROLS_TYPE' but "
                       << "`Point *pt0' is NULL and `Point *pt1' is non-NULL."
                       << endl
                       << "This shouldn't be possible.  Continuing."
                       << endl;

                  cerr << ".. controls (" << (*c_iter)->pt1->get_x() << ", "
                       << (*c_iter)->pt1->get_y() << ", " << (*c_iter)->pt1->get_z()
                       << ") .. ";
               }


@q ****** (6) @>

               else if ((*c_iter)->pt0 == 0 && (*c_iter)->pt1 == 0)
               {
                  cerr << "WARNING!  In `Path::show':" << endl
                       << "`Connector_Type' " << i << " is of type `CONTROLS_TYPE' but "
                       << "`Point *pt0' and `Point *pt1' are both NULL."
                       << endl
                       << "This shouldn't be possible.  Continuing."
                       << endl;

                  cerr << ".. controls NULL and NULL .. ";

               }

@q ****** (6) @>

            } /* |else if (with_connectors_val >= 3)| */

@q ***** (5) @>

         }  /* |if ((*c_iter)->type0 == Connector_Type::CONTROLS_TYPE)|  */

@q **** (4) @>

#if 0
#if DEBUG_COMPILE
         if (DEBUG)
         { 
             cerr << endl << "Connector " << i << ":" << endl;

             (*c_iter)->show();

cerr << "YYY Enter <RETURN> to continue: ";
getchar(); 

         }    
#endif /* |DEBUG_COMPILE|  */@; 
#endif 
         ++c_iter;

     } /* |if (c_iter != connector_type_vector.end())| */

@q *** (3) @>
@
@<Define |Path| functions@>=

     ++i;

@q *** (3) @>

   }  /* |for|  */

@q ** (2) @>
@
@<Define |Path| functions@>=

   if (cycle_switch)
   {
#if 0 
      if (c_iter != connector_type_vector.end())
        cerr << (*c_iter)->connector_string;
      else if (connector_type_vector.size() > 0)
        cerr << connector_type_vector.back()->connector_string;
      else 
        cerr << "--";
#endif

      cerr << "cycle";
   }

   cerr << ";" << endl;

@q ** (2) @>
@
@<Define |Path| functions@>=

   cerr << "fill_draw_value == ";

   if (fill_draw_value == DRAW_VALUE)
     cerr << "DRAW_VALUE";

   else if (fill_draw_value == FILL_VALUE)
     cerr << "FILL_VALUE";

   else if (fill_draw_value == FILLDRAW_VALUE)
     cerr << "FILLDRAW_VALUE";

   else if (fill_draw_value == UNDRAW_VALUE)
     cerr << "DRAW_VALUE";

   else if (fill_draw_value == UNFILL_VALUE)
     cerr << "FILL_VALUE";

   else if (fill_draw_value == UNFILLDRAW_VALUE)
     cerr << "FILLDRAW_VALUE";
   
   else
     cerr << fill_draw_value;

   cerr << endl;

   if (fill_color_vector == static_cast<Pointer_Vector<Color>*>(0))
     cerr << "fill_color_vector == 0" << endl;
   else
     fill_color_vector->show("fill_color_vector:");

   if (draw_color_vector == static_cast<Pointer_Vector<Color>*>(0))
      cerr << "draw_color_vector == 0" << endl;
   else
      draw_color_vector->show("draw_color_vector:");

   if (pen_vector == static_cast<Pointer_Vector<Pen>*>(0))
      cerr << "pen_vector == 0" << endl;
   else
      pen_vector->show("pen_vector:");

   if (dash_pattern_vector == static_cast<Pointer_Vector<Dash_Pattern>*>(0))
      cerr << "dash_pattern_vector == 0" << endl;
   else
      dash_pattern_vector->show("dash_pattern_vector:");

   if (arrow == SINGLE_ARROW)
     cerr << "arrow == `Path::SINGLE_ARROW'.";

   else if (arrow == DOUBLE_ARROW)
     cerr << "arrow == `Path::DOUBLE_ARROW'." << endl;

   else
     cerr << "arrow == `Path::NO_ARROW'." << endl;

   cerr << "turningnumber == " << turningnumber << endl;

   cerr << "connector_type_vector.size() == " << connector_type_vector.size() << endl;

   if (connector_type_vector.size() > 0)
      cerr << "connector_type_vector:" << endl;

@q ** (2) @>
@
@<Define |Path| functions@>=

#if 0
   for (vector<Connector_Type*>::const_iterator iter = connector_type_vector.begin();
        iter != connector_type_vector.end();
        ++iter)
   {
       (*iter)->show();
   }
#endif 

   cerr << endl;

@q ** (2) @>
@
@<Define |Path| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   { 
       cerr << "Exiting `Path::show' successfully with a void return value." 
            << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

  return;

} /* End of |Path::show| definition.  */

@q ** (2) @>

@q * (1) @>
@
@<Define |Path| functions@>=
Path
Path::append(const Path& p, string connector, bool assign)
{

  bool DEBUG = true; /* |false| */ 

  int i = 0;
  int j = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Entering `Path::append'." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

  Path r(*this);

  string last_connector;
  Connector_Type *last_connector_type = 0;

  r.set_cycle(false);

@q **** (4) @>   

@ If there isn't an explicit connector for every pair
of |Points| in |points|, then we have to fill up
|connectors| so that there are enough. Otherwise, the ``{\AM}'' 
will be at the wrong place.  
\initials{LDF 2002.4.6.}  

@<Define |Path| functions@>=

@q **** (4) @>

  if (r.connector_type_vector.size() == 0)
  {
    last_connector_type = create_new<Connector_Type>(0);
    last_connector_type->type0 = Connector_Type::PLAIN_TYPE;
    last_connector_type->type1 = Connector_Type::CT_NULL_TYPE;
    last_connector_type->connector_string = "--";
  }
  else
    last_connector_type = r.connector_type_vector.back();

@q **** (4) @>
@
@<Define |Path| functions@>=

  if (r.points.size() > 0)
  {
@q ***** (5) @>

     i = r.points.size() - 1;
     j = r.connector_type_vector.size();

     cerr << "i == " << i << endl;
     cerr << "j == " << j << endl;

@q ***** (5) @>

      while (r.connector_type_vector.size() < i)
      {
@q ****** (6) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
            cerr << "In `Path::append':" << endl 
                 << "Pushing Connector_Type* onto connector_type_vector." << endl;  /* LDF 2022.01.14.  */
         }
#endif /* |DEBUG_COMPILE|  */@; 

        r.connector_type_vector.push_back(create_new<Connector_Type>(last_connector_type));

        if (j >= i)
        {

#if DEBUG_COMPILE
           if (DEBUG)
           { 
               cerr << "In `Path::append':" << endl 
                    << "j >= i.  Breaking." << endl;
           }     
#endif /* |DEBUG_COMPILE|  */@; 

           break;

        }

        ++j;

@q ****** (6) @>

      }  /* |while| */   

@q ***** (5) @>

  }  /* |if (r.points.size() > 0)| */

@q **** (4) @>

  r.connector_type_vector.push_back(create_new<Connector_Type>(0));
  r.connector_type_vector.back()->type0 = Connector_Type::PLAIN_TYPE;
  r.connector_type_vector.back()->type1 = Connector_Type::CT_NULL_TYPE;
  r.connector_type_vector.back()->connector_string = connector;

@q **** (4) @>   

@ Copy the |Points| in |p| and put the copies onto |points|.
\initials{LDF 2002.4.6.} 

@<Define |Path| functions@>=


  for(vector<Point*>::const_iterator iter = p.points.begin();
      iter != p.points.end();
      iter++)
    r.points.push_back(create_new<Point>(*iter));

@q **** (4) @>   
   
@ Put the connectors from |p| onto the new |Path|.  Since they're
|strings|, and not pointers, we don't have to copy them.  
\initials{LDF 2002.4.6.}

\LOG
\initials{LDF 2004.11.01.}
Now removing excess connectors.
\ENDLOG 

@<Define |Path| functions@>= 

#if 0
 cerr << "p.connector_type_vector.size() == " << p.connector_type_vector.size() << endl;
#endif 

  i = 0;

@q **** (4) @>
@
@<Define |Path| functions@>=

  for(vector<Connector_Type*>::const_iterator iter = p.connector_type_vector.begin();
      iter != p.connector_type_vector.end();
      iter++)
    {
@q ***** (5) @>


#if DEBUG_COMPILE
        if (DEBUG)
        {
           cerr << "In `Path::YYY append':" << endl 
                << "`i' == " << i << endl 
                << "Pushing Connector_Type* onto r.connector_type_vector." << endl;  /* LDF 2022.01.14.  */
        }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>

        r.connector_type_vector.push_back(create_new<Connector_Type>(*iter));

@q ***** (5) @>

        if (i > 20)
        {
#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr << "In `Path::append':" << endl 
                   << "`i' == " << i << " > 20.  Breaking" << endl;
           }  
#endif /* |DEBUG_COMPILE|  */@; 

           break;

        }

@q ***** (5) @>

        else
        {
#if DEBUG_COMPILE
           if (DEBUG)
           {
              cerr << "In `Path::append':" << endl 
                   << "`i' == " << i << " <= 20.  Not breaking" << endl;

           }  
#endif /* |DEBUG_COMPILE|  */@; 

        }

@q ***** (5) @>
 
        ++i;

@q ***** (5) @>

   } /* |for| */

@q **** (4) @>
@
@<Define |Path| functions@>=

   while (r.connector_type_vector.size() >= r.points.size())
   {
      delete r.connector_type_vector.back();
      r.connector_type_vector.back() = 0;
      r.connector_type_vector.pop_back();
   }

@q **** (4) @>

  if (assign == true)
    *this = r;

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      cerr << "Exiting `Path::append' with return value `Path r'." << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

  return r;

} /* End of |Path::append| definition.  */

@q * (1) Replace connectors.  @>
@ Replace connectors.
\initials{LDF 2022.04.05.}

\LOG
\initials{LDF 2022.04.05.}
Added this function.
\ENDLOG 

@<Define |Path| functions@>=
int
Path::replace_connectors(string s)
{
#if DEBUG_COMPILE
 
   bool DEBUG = true; /* |false| */ 

   if (DEBUG)
   { 
       cerr << "Entering `Path::replace_connectors'.  `string s' == " << s << "."
            << endl;
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ** (2) @>
@
@<Define |Path| functions@>=

   Connector_Type c;

   if (!(s == ".." || s == "..." || s == "--" || s == "---"))
   {
      cerr << "ERROR!  In `Path::replace_connectors':  `string s' is invalid:"
           << endl 
           << "`s' == " << s << "." << endl
           << "Not replacing connectors.  Exiting function unsuccessfully with return value 1."
           << endl;

      return 1;
   }

   c.connector_string = s;

   for (vector<Connector_Type*>::iterator iter = connector_type_vector.begin();
        iter != connector_type_vector.end();
        ++iter)
   {
      **iter = c;

#if DEBUG_COMPILE
      if (DEBUG)
      { 
          cerr << "In `Path::replace_connectors':  After replacement:" << endl;
          (**iter).show();

cerr << "BBB Enter <RETURN> to continue: ";
getchar(); 

      }  
#endif /* |DEBUG_COMPILE|  */@; 

   } /* |for|  */

@q ** (2) @>

#if DEBUG_COMPILE
   if (DEBUG)
   { 
       cerr << "Exiting `Path::replace_connectors' successfully with return value 0."
            << endl;

cerr << "AAA Enter <RETURN> to continue: ";
getchar(); 

   }  
#endif /* |DEBUG_COMPILE|  */@; 

   return 0;

} /* End of |Path::replace_connectors| definition  */



@q * (1) Putting Path functions together.@>
@ Putting {\bf Path} functions together.
\initials{LDF 2022.04.04.}

@q ** (2).@> 

@ This is what's compiled.
\initials{LDF 2022.04.04.}

@c
@<Include files@>@;
@<Define |Path| functions@>@;

@q ** (2).@> 

@ This is what's written to \filename{pathfncs.h}. 
\initials{LDF 2022.04.04.}

@(pathfncs.h@>=
/* Empty */

@q * (1) @>

@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t))                          @>

@q * (1) Local Variables for Emacs @> 

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
