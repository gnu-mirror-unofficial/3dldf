@q scanprse.web @>
  
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,            @>
@q 2011, 2012, 2013 The Free Software Foundation                                        @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>



@q * Scanning and Parsing.@>
@** Scanning and Parsing\quad ({\tt scanprse\PERIOD web}).\hfil

\LOG
\initials{LDF 2004.02.03.}  
Added this file.

\initials{LDF 2004.04.16.}  
Removed most of the code from this file.
I've moved the declarations of the types used for ``identifier
mapping'', the declaration of |struct Scanner_Node| and the
definitions of its member functions, the declarations of a couple of
global variables, and the definitions of |initialize_id_map_node|
and |check_id| from this file to \filename{io.web}.  The reason for
this is, that I want to pass a |Scanner_Node*| as an argument to
|Picture::output|, and to the various |output| functions called on
the |Shapes| belonging to the |Picture|.

\initials{LDF 2006.09.28.}
@:BUG FIX@> BUG FIX:  Deleted |Scan_Parse::| from the declarations 
of template functions with specific types for instantiation.
Thanks to Martin J{\o}rgensen for the bug report and fix.
\ENDLOG 

\immediate\write\functexifile{File:  scanprse.web^^J}

@q * Include files.@>
@ Include files.
\filename{getopt.h} is included for 
processing the command line options.
\initials{LDF 2003.08.14.}

\LOG
\initials{LDF 2004.04.16.}  No longer including the library header
file \filename{map} here.  It's now included in
\filename{loader.web}.

\initials{LDF 2004.05.21.}  Now including \filename{pens.web}.
\ENDLOG 

@<Include files@>=
#include "loader.h++"
#include "pspglb.h++"
#include "io.h++"
#include "gsltmplt.h++"
#include "creatnew.h++"
#include "pntrvctr.h++"
#include "primes.h++"
#include "complex.h++"
#include "matrices.h++"
#include "colors.h++"
#include "transfor.h++"
#include "pens.h++"
#include "dashptrn.h++"
#include "shapes.h++" 
#include "pictures.h++"
#include "points.h++"
#include "lines.h++"
#include "planes.h++"
#include "nurbs.h++"
#include "paths.h++"
#include "curves.h++"
#include "polygons.h++"
#include "triangle.h++"
#include "rectangs.h++"
#include "conicsct.h++"
#include "ellipses.h++"
#include "circles.h++"
#include "ellpsslc.h++"
#include "crclslc.h++"
#include "parabola.h++"
#include "hyprbola.h++"
#include "cncsctlt.h++"
#include "arc.h++"
#include "helices.h++"
#include "origami.h++"

#if 0 
   #include "patterns.h++"
#endif 

#include "solids.h++"
#include "solfaced.h++"
#include "cuboid.h++"
#include "polyhed.h++"
#include "ddchdrn.h++"
#include "rhtchdrn.h++"
#include "plyhdslc.h++"
#include "cones.h++"
#include "cylinder.h++" 
#include "ellpsoid.h++"
#include "spheres.h++"
#include "sphrdevl.h++"
#include "parabold.h++"
#include "paraellp.h++"
#include "parahypr.h++"
#include "glyphs.h++"
#include "pctfncs0.h++"
#include "utility.h++"
#include "pntrvcf0.h++"
#include "predctes.h++"

@q * Namespace |Scan_Parse|.@>
@* Namespace {\bf Scan\_Parse}.

@q ** (2) Preprocessor macro definitions.  @>
@*1 Preprocessor macro definitions.
\initials{LDF 2006.09.26.}

\LOG
\initials{LDF 2006.09.26.}
@:BUG FIX@> 
Added this section with the definitions of 
|MAX_FILE_ARGS| and |MAX_FILENAME|
\initials{LDF 2006.09.26.}
This is a bug fix.
They were formerly declared as |extern const unsigned shorts|
in |namespace Scan_Parse|.  This caused problems when porting
to Mac OS.  Thanks to Martin J{\o}rgensen for the bug report.
\ENDLOG

@<Preprocessor macro definitions@>=

#define MAX_FILE_ARGS 32
#define MAX_FILENAME  64

@q ** (2) Namespace |Scan_Parse| declaration.@>
@*1 Namespace {\bf Scan\_Parse} declaration.
\initials{LDF Undated}

\LOG
\initials{LDF 2004.07.03.}
Added |vector<string> in_filename_vector|.

\initials{LDF 2006.09.26.}
@:BUG FIX@> BUG FIX:  No longer declaring 
|extern const unsigned short MAX_FILE_ARGS|
and 
|extern const unsigned short MAX_FILENAME|. 
I've replaced them with preprocessor macros of the same name.
Put |MAX_FILE_ARGS| inside the first pair of square brackets
in the declaration of 
|char filename_array[MAX_FILE_ARGS][MAX_FILENAME]|.
\ENDLOG 

@<Declare |namespace Scan_Parse|@>=

#define MAX_FILE_ARGS 32
#define MAX_FILENAME  64

namespace
Scan_Parse
{

#if 0 
  extern const unsigned short MAX_FILE_ARGS         = 32;
  extern const unsigned short MAX_FILENAME          = 64;
#endif 

  char filename_array[MAX_FILE_ARGS][MAX_FILENAME];
  unsigned short filename_array_ctr                 = 0;

  vector<string> in_filename_vector;
  vector<string> out_filename_vector;

  @<|struct Picture_Output_Arg_Type| declaration@>@;

  @<Declare |Scan_Parse| functions@>@;

};

@
\LOG
\initials{LDF 2006.09.26.}
Commented-out the declarations of |MAX_FILE_ARGS| and |MAX_FILENAME|.
See log entry for |@<Declare |namespace Scan_Parse|@>| above.
\ENDLOG 

@<|extern| |namespace Scan_Parse| declaration@>=
namespace
Scan_Parse
{
#if 0 
   extern const unsigned short MAX_FILE_ARGS;
   extern const unsigned short MAX_FILENAME;
#endif 
   extern char filename_array[MAX_FILE_ARGS][MAX_FILENAME];
   extern unsigned short filename_array_ctr;

   extern vector<string> in_filename_vector;
   extern vector<string> out_filename_vector;

   @<|struct Picture_Output_Arg_Type| declaration@>@;


   @<Declare |Scan_Parse| functions@>@;

};


@q ** (2) |struct Picture_Output_Arg_Type| declaration.@>
@*1 {\bf struct picture\_output\_arg\_type} declaration.
\initials{LDF 2004.04.22.}

\LOG
\initials{LDF 2004.04.22.}
Added this declaration.

\initials{LDF 2004.06.23.}
Changed |struct endfig_func_arg_type| to 
|struct Picture_Output_Arg_Type|.  
Added |Picture* picture| and |pthread_mutex t* mutex_ptr|.

\initials{LDF 2004.06.23.}
Added |int* return_value|.

\initials{LDF 2004.06.26.}
Added |real factor|.

\initials{LDF 2004.06.29.}
Added |int sort_value|, |bool do_warnings|, 
|real min_x_proj|, |real max_x_proj|, 
|real min_y_proj|, |real max_y_proj|, 
|real min_z_proj|, and |real max_z_proj|.
Changed constructors and setting function accordingly.

\initials{LDF 2004.07.13.}
Changed |Run_State* run_state| to
|Scanner_Node scanner_node|.

\initials{LDF 2004.07.15.}
Added |bool endfig|.

\initials{LDF 2005.03.14.}
Added |unsigned short surface_hiding_value|.
\ENDLOG 

@q *** Declaration.@> 

@<|struct Picture_Output_Arg_Type| declaration@>=
struct
Picture_Output_Arg_Type
{

  Picture* picture;
  Scanner_Node scanner_node;

  Focus* focus;  

  bool endfig;

  int projection;
  real factor;
  int sort_value;
  bool do_warnings;
  real min_x_proj;
  real max_x_proj;
  real min_y_proj;
  real max_y_proj;
  real min_z_proj;
  real max_z_proj;
 
  unsigned short surface_hiding_value;


  @<Declare |struct Picture_Output_Arg_Type| functions@>@;

};


@q *** |struct Picture_Output_Arg_Type| functions.@>
@*2 {\bf struct picture\_output\_arg\_type} functions.


@q **** (4) Destructor.@>
@*3 Destructor.

\LOG
\initials{LDF 2004.06.23.}
Added this function.
It recovers the memory allocated for |return_value|.

\initials{LDF 2004.07.09.}
No longer deleting |return_value|.  It must be deleted by the caller 
of the function that uses a |Picture_Output_Arg_Type| object.
\ENDLOG 


@q ***** (5) Declaration.@>

@<Declare |struct Picture_Output_Arg_Type| functions@>=
~Picture_Output_Arg_Type(void);


@q ***** (5) Definition.@>

@
@<Define |struct Picture_Output_Arg_Type| functions@>=
Scan_Parse::Picture_Output_Arg_Type::~Picture_Output_Arg_Type(void)
{
  if (picture != static_cast<Picture*>(0))
    {
      picture->clear();
      delete picture;
      picture = 0;
    }

  if (focus != static_cast<Focus*>(0))
    {
      delete focus;
      focus = 0;
    }

  return;
}


@q ** (2) |Scan_Parse| functions.@>
@*1 |Scan_Parse| functions.

\LOG
\initials{LDF 2004.06.22.}
Added this section.
\ENDLOG 


@q *** (3) |parse_func|.@>
@*2 {\bf parse\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.06.23.}
Added this function.  It's used as the start routine for a 
thread in |main| and calls |yyparse|.
The argument is a |Scanner_Node|, cast to |void*|.

\initials{LDF 2004.07.02.}
Now deleting the |Scanner_Node| passed as the |void* arg| to this function,
after |yyparse| returns.  

\initials{LDF 2004.07.05.}
Now using |Thread_Info_Type* thread_info| rather than 
|scanner_node->thread_info|, since I've removed the |thread_info| member 
from |Scanner_Type|.

\initials{LDF 2004.07.09.}
Now declaring |int* return_value| and allocating memory for it, since it is no
longer declared in |@<Common code for thread start functions@>|.

\initials{LDF 2004.07.16.}
Now waiting for pending outputs before joining with sub-threads.

\initials{LDF 2004.07.21.}
Removed |@<Common code for thread start functions@>| and put the code that was
formerly in that section at the beginning of this function.  That section wasn't
used in any other functions.
\ENDLOG


@q **** (4) Definition.@>

@
@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::parse_func(void* arg)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  Scanner_Node scanner_node;

  stringstream cerr_strm;

  int status;
  
  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info(true);
  
  string thread_name = Thread_Info_Type::get_thread_name(thread_info);


#if DEBUG_COMPILE
  if (DEBUG)
        {
           cerr_strm << thread_name << "Entering `parse_func().'";
           cerr_message(cerr_strm);
           cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

  scanner_node = static_cast<Scanner_Node>(arg);

  scanner_node->thread_info = thread_info;

  int* return_value = new int;

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
                   ? true : false;


  *return_value = yyparse(arg);

  if (*return_value == 0)
    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
        
          cerr_strm << thread_name << "In `parse_func()': `yyparse()' "
                    << "returned with return value "
                    << "0 (success)."
                    << endl << "Will delete `scanner_node'.";
          cerr_message(cerr_strm);
          cerr_strm.str("");
                      
        }
#endif /* |DEBUG_COMPILE|  */@; 
      

    } /* |if (*return_value == 0)| (success)  */

  else /* (|*return_value != 0|) (failure)  */
    {

        cerr_strm << thread_name << "ERROR! In `parse_func()':'"
                  << endl << "`yyparse()' returned with `*return value' == " 
                  << *return_value
                  << endl 
                  << "Exiting `parse_func().";
        
        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str("");

      
      }  /*   |else| (|*return_value != 0|) (failure)  */




@q ***** (5) Try to lock |scanner_node->thread_vector_mutex|.@>
@ Try to lock |scanner_node->thread_vector_mutex|.
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                << "About to try to lock `scanner_node->thread_vector_mutex'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = pthread_mutex_lock(&scanner_node->thread_vector_mutex);

    if (status != 0)
    {
      cerr_strm << "ERROR! In `Scan_Parse::parse_func()':" << endl
                << "`pthread_mutex_lock()' failed. "
                << "Returning 0." << endl;

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      return 0;
    }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      cerr_strm << "In `Scan_Parse::parse_func()':" << endl
                << "`pthread_mutex_lock()' succeeded."  << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Wait until no more outputs are pending.@>
@ Wait until no more outputs are pending.
\initials{LDF 2004.07.16.}
@<Define |Scan_Parse| functions@>=
   
  while (scanner_node->output_pending.value_1 > 0)
    {

#if DEBUG_COMPILE
        if (DEBUG)
           {

                cerr_strm << thread_name << "`Scan_Parse::parse_func()':"
                          << endl << "Output pending.  Going to sleep.";
                cerr_message(cerr_strm);
                cerr_strm.str("");

           }
#endif /* |DEBUG_COMPILE|  */@; 

        timespec timeout;

        timeout.tv_sec = time (0) + 300; /* Five minutes.  */
        timeout.tv_nsec = 0;
        
        status = scanner_node->output_pending.timedwait(&timeout);
        


@q ****** (6) Error handling:  Timout.@>
@ Error handling:  Timout.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=


  if (status == ETIMEDOUT)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::parse_func()':" 
                << endl
                << "`scanner_node->output_pending.timedwait(&timeout)' timed out "
                << "after " << timeout.tv_sec << "seconds." << endl
                << "Not performing output." << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with `*return value' ==  1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      *return_value = 1;

       return return_value;

    } /* |if (status == ETIMEDOUT)|  */


@q ******* (7) Error handling:                                   @>
@q ******* (7) |scanner_node->output_pending.timedwait| failed.@>
@ Error handling:  |scanner_node->output_pending.timedwait| failed.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>=

  else if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::parse_func()':"
                << endl << "`scanner_node->output_pending.timedwait()' failed. "
                << "Not performing output." << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with `*return value' ==  1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      *return_value = 1;

      return return_value;


    } /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::parse_func()':"
                 << endl << "`scanner_node->output_pending.timedwait()' "
                 << "succeeded.";

       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 
       

  } /* |while (scanner_node->output_pending.value_1 > 0)|  */

#if DEBUG_COMPILE
        if (DEBUG)
           {

                cerr_strm << thread_name 
                          << "`Scan_Parse::parse_func()':"
                          << endl << "Output not pending.  Continuing.";

                cerr_message(cerr_strm);
                cerr_strm.str("");

           }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Try to unlock |scanner_node->output_pending|.@>
@ Try to unlock |scanner_node->output_pending|.

\LOG
\initials{LDF 2004.07.17.}
Added this section.
@:BUG FIX@> BUG FIX:  Previously, I had forgotten to unlock 
|scanner_node->output_pending|. 
\ENDLOG

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                << "About to try to unlock `scanner_node->output_pending'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = scanner_node->output_pending.unlock();

    if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::parse_func()':" 
                << endl
                << "`scanner_node->output_pending.unlock()' failed. "
                << "Returning 0." << endl;

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);  
      cerr_strm.str("");

      return 0;
    }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                << "`scanner_node->output_pending.unlock()' succeeded."  << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Join with sub-threads.@>
@ Join with sub-threads.
@<Define |Scan_Parse| functions@>=


#if DEBUG_COMPILE
   if (DEBUG)
     {

       cerr_strm << thread_name << "In `Scan_Parse::parse_func()':"
                 << "scanner_node->thread_vector.size() == "
                 << scanner_node->thread_vector.size() << endl;
      
       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


  { /* Beginning of group.  */

    int i = 0;
    void* return_value;


  for (vector<pthread_t*>::iterator iter = scanner_node->thread_vector.begin();
       iter != scanner_node->thread_vector.end();
       iter++)
      {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "In `Scan_Parse::parse_func()': "
                 << "Waiting for sub-thread " << i++ << "." 
                 << endl;
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

        status = pthread_join(**iter, &return_value);

#if DEBUG_COMPILE
        if (DEBUG)
          {
            cerr_strm << thread_name << "In `Scan_Parse::parse_func()':"
                      << endl << "Joined sub-thread " << i << "."
                      << endl << "`status' == " << status 
                      << ", *static_cast<int*>(return_value) == " 
                      << *static_cast<int*>(return_value)
                      << "." << endl;
            cerr_message(cerr_strm);
            cerr_strm.str("");

          }
#endif /* |DEBUG_COMPILE|  */@; 
         

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::parse_func()':"
                 << endl << "Deleting `*return_value'." << endl;
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

        delete static_cast<int*>(return_value);


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::parse_func()':"
                 << "Deleted `*return_value'." << endl;
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


      } /* |for|  */
  } /* End of group.  */


@q ***** (5) Try to unlock |scanner_node->thread_vector_mutex|.@>
@ Try to unlock |scanner_node->thread_vector_mutex|.
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                << "About to try to unlock `scanner_node->thread_vector_mutex'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = pthread_mutex_unlock(&scanner_node->thread_vector_mutex);

    if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::parse_func()':" 
                << endl
                << "`pthread_mutex_unlock()' failed. "
                << "Returning 0." << endl;

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);  
      cerr_strm.str("");

      return 0;
    }
#if DEBUG_COMPILE
  else if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                << "`pthread_mutex_unlock()' succeeded."  << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Delete |scanner_node| and set it to 0.@>
@ Delete |scanner_node| and set it to 0.
\initials{LDF 2004.07.10.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
       cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                 << "About to delete `scanner_node' and set it to 0."  << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

    }
#endif /* |DEBUG_COMPILE|  */@; 


  delete scanner_node;
  scanner_node = 0;

#if DEBUG_COMPILE
  if (DEBUG)
    {
       cerr_strm << thread_name << "In `Scan_Parse::parse_func()':" << endl
                 << "Deleted `scanner_node' and set it to 0.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

    }
#endif /* |DEBUG_COMPILE|  */@; 


#if DEBUG_COMPILE
  if (DEBUG)
    {
       cerr_strm << thread_name 
                 << "Exiting `Scan_Parse::parse_func()'.";

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 


  return static_cast<void*>(return_value);

} /* End of |Scan_Parse::parse_func| definition.  */




@q *** (3) |beginfig_func|.@>
@*3 {\bf beginfig\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.15.}
Added this function.

\initials{LDF 2004.11.12.}
Added code for writing a |pickup| command to |*out_stream|, if
the |Pen| stored in the |Id_Map_Entry_Node default_pen| 
is non-null.
\ENDLOG 

@q ***** (5) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::beginfig_func(Scanner_Node scanner_node, int fig_num)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  using namespace Scan_Parse;

  int status;


@q **** (4).@>



#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "Entering `Scan_Parse::beginfig_func()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@;

  Output_Struct* os = scanner_node->out[Run_State::METAPOST];

  ofstream* out_stream  = static_cast<ofstream*>(os->stream_ptr);


@q ****** (6) Try to lock |scanner_node->output_pending|.@>  
@ Try to lock |scanner_node->output_pending|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
   if (DEBUG)
     {

      cerr_strm << thread_name << "In `Scan_Parse::beginfig_func()':"
                << endl
                << "About to call `scanner_node->output_pending.lock()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  status = scanner_node->output_pending.lock();

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl
                << "`scanner_node->output_pending.lock()' failed. "
                << "Not writing to `out_stream'."
                << endl << "Will try to continue.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

    } /* |if (status != 0)|  */

  else /* |scanner_node->output_pending.lock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "`scanner_node->output_pending.lock()' succeeded!";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |else| (|scanner_node->output_pending.lock| succeeded.)  */

#endif /* |HAVE_PTHREAD_H|  */@; 




@q ****** (6) Check whether an output operation is pending.@>
@ Check whether an output operation is pending.
\initials{LDF 2004.07.15.}
@<Define |Scan_Parse| functions@>=

  while (scanner_node->output_pending.value_0)
    {

#if DEBUG_COMPILE
        if (DEBUG)
           {

                cerr_strm << thread_name 
                          << "`Scan_Parse::beginfig_func()':"
                          << endl << "Output pending.  Going to sleep.";

                cerr_message(cerr_strm);
                cerr_strm.str("");

           }
#endif /* |DEBUG_COMPILE|  */@; 


        timespec timeout;

        timeout.tv_sec = time (0) + 300; /* Five minutes.  */
        timeout.tv_nsec = 0;
        
        status = scanner_node->output_pending.timedwait(&timeout);
        


@q ******* (7) Error handling:  Timout.@>
@ Error handling:  Timout.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=


  if (status == ETIMEDOUT)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::beginfig_func()':" 
                << endl
                << "`scanner_node->output_pending.timedwait(&timeout)' "
                << "timed out "
                << "after " << timeout.tv_sec << "seconds." << endl
                << "Not performing output." << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      return 1;

    } /* |if (status == ETIMEDOUT)|  */


@q ******* (7) Error handling:  @>
@q ******* (7) |scanner_node->output_pending.timedwait| failed.@> 

@ Error handling:  |scanner_node->output_pending.timedwait| failed.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>=


  else if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl 
                << "`scanner_node->output_pending.timedwait()' failed. "
                << "Not performing output." << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
        
      return 1;               

    } /* |else if (status != 0)|  */

@q ******* (7) @> 

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::beginfig_func()':"
                 << endl << "`scanner_node->output_pending.timedwait()' "
                 << "succeeded.";

       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 
       
@q ******* (7) @> 

  } /* |while (scanner_node->output_pending.value)|  */

@q ****** (6).@> 

#if DEBUG_COMPILE
        if (DEBUG)
           {

                cerr_strm << thread_name 
                          << "`Scan_Parse::beginfig_func()':"
                          << endl << "Output not pending.  Continuing.";

                cerr_message(cerr_strm);
                cerr_strm.str("");

           }
#endif /* |DEBUG_COMPILE|  */@; 

   scanner_node->output_pending.value_0 = true;
   scanner_node->output_pending.value_1++;



@q ****** (6) Try to lock |os->mutex|.@>  
@ Try to lock |os->mutex|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  


#if DEBUG_COMPILE
   if (DEBUG)
     {

      cerr_strm << thread_name << "In `Scan_Parse::beginfig_func()':"
                << endl
                << "About to call `os->lock()'. ";
      cerr_message(cerr_strm);
      cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 


  status = os->lock();

@q ******* (7) @> 

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl
                << "`os->lock()' failed. "
                << "Not writing to `out_stream'."
                << endl << "Will try to continue.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

    } /* |if (status != 0)|  */

@q ******* (7) @> 

  else /* |os->lock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "`os->lock()' succeeded!";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |else| (|os->lock| succeeded.)  */

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ****** (6) Write to |*out_stream|.@>
@ Write to |*out_stream|.
@<Define |Scan_Parse| functions@>= 

      *out_stream << "beginfig(" << fig_num << ");" 
                  << endl;


@q ******* (7) @> 
@ 

\LOG
\initials{LDF 2004.11.12.}
Added this section.

\initials{LDF 2004.11.12.}
Replaced the code in this section with a call to 
|operator<<(ostream& o, Pen& p)|.
\ENDLOG

@<Define |Scan_Parse| functions@>= 

      if (*(scanner_node->default_pen) != static_cast<Pen*>(0))
        {
           *out_stream << "pickup " << **(scanner_node->default_pen);
                   
        }  /* |if (*(scanner_node->default_pen) != 0)|  */

@q ****** (6) Try to unlock |os->mutex|.@>  
@ Try to unlock |os->mutex|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  
  status = os->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl
                << "`os->unlock()' failed. "
                << "Not writing to `out_stream'."
                << endl << "Will try to continue.";


      cerr_message(cerr_strm);
      cerr_strm.str("");

    } /* |if (status != 0)|  */

  else /* |os->unlock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "`os->unlock()' succeeded!";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |else| (|os->unlock| succeeded.)  */

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ****** (6) Set |scanner_node->output_pending.value_0| to |false|, @>  
@q ****** (6) decrement |scanner_node->output_pending.value_1|, and  @>  
@q ****** (6) and signal condition.                                  @>  
@ Set |scanner_node->output_pending.value_0| to |false|,  
decrement |scanner_node->output_pending.value_1|, and   
and signal condition.                                   


\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>= 



  scanner_node->output_pending.value_0 = false;
  scanner_node->output_pending.value_1--;
  
  status = scanner_node->output_pending.signal();


@q ******* (7) Error handling:  |scanner_node->output_pending.signal| failed.@>
@ Error handling:  |scanner_node->output_pending.signal| failed.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>=


  if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl << "`scanner_node->output_pending.signal()' failed. "
                << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
        
      return 1;               

    } /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::beginfig_func()':"
                 << endl << "`scanner_node->output_pending.signal()' "
                 << "succeeded.";

       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) Try to unlock |scanner_node->output_pending|.@>  
@ Try to unlock |scanner_node->output_pending|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  
  status = scanner_node->output_pending.unlock();

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::beginfig_func()':"
                << endl
                << "`scanner_node->output_pending.unlock()' failed. "
                << "Not writing to `out_stream'."
                << endl << "Will try to continue.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

    } /* |if (status != 0)|  */

  else /* |scanner_node->output_pending.unlock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "`scanner_node->output_pending.unlock()' succeeded!";
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |else| (|scanner_node->output_pending.unlock| succeeded.)  */

#endif /* |HAVE_PTHREAD_H|  */@; 



@q ***** (5) Exit function successfully.@>
@ Exit function successfully.
@<Define |Scan_Parse| functions@>=


#if DEBUG_COMPILE
   if (DEBUG)
     {
        cerr_strm << "Exiting `Scan_Parse::beginfig_func()'.";
        cerr_message(cerr_strm);
        cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

  return 0;
}


@q *** (3) |output_func|.@>
@*3 {\bf output\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.06.24.}
Added this function.

\initials{LDF 2004.06.26.}  
Added |real factor|.

\initials{LDF 2004.06.29.}
Added |int sort_value|, 
|bool do_warnings|, |real min_x_proj|, |real max_x_proj|, 
|real min_y_proj|, |real max_y_proj|, |real min_z_proj|, 
and |real max_z_proj|.

\initials{LDF 2004.07.16.}
Revised this function.

\initials{LDF 2004.07.22.}
Added calls to |log_message| and rearranged the code for debugging and error
output.  Now calling |cerr_strm.str("")| to clear 
|cerr_strm|, since |cerr_message| no longer does this.  
\ENDLOG 


@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::output_func(void* arg)
{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@;

  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info(true);
   
  string thread_name = Thread_Info_Type::get_thread_name(thread_info);

  stringstream cerr_strm;

  int status;

  int* return_value = new int;
  *return_value = 0;

  cerr_strm << thread_name << "Entering `Scan_Parse::output_func()'.";
  log_message(cerr_strm); 

#if DEBUG_COMPILE
  if (DEBUG)
      cerr_message(cerr_strm);

#endif /* |DEBUG_COMPILE|  */@;

  cerr_strm.str("");

@q ***** (5) Get |Picture_Output_Arg_Type*| argument and check that it's valid.@>
@ Get |Picture_Output_Arg_Type*| argument and check that it's valid.
If it's not, set |*return_value = 1| and exit with return value 
|static_cast<void*>(return_value)|.

\initials{LDF 2004.07.13.}
@<Define |Scan_Parse| functions@>=
  
  Picture_Output_Arg_Type* picture_ptr_arg
    = static_cast<Picture_Output_Arg_Type*>(arg); 

  if (picture_ptr_arg == static_cast<Picture_Output_Arg_Type*>(0))
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << "`arg' == 0."
                << endl << "Setting `*return_value = 1' and returning "
                << "a void pointer to `return_value'.";

#ifndef HAVE_PTHREAD_H  
      cerr_strm << endl << "The programmer should ensure "
                << "that the memory allocated to `return_value' is freed.";
#endif /* |HAVE_PTHREAD_H|  */@; 
    
      cerr_message(cerr_strm);
      log_message(cerr_strm); 

      cerr_strm.str("");

      *return_value = 1;
      return static_cast<void*>(return_value); 

    } /* |if (picture_ptr_arg == 0)|  */


  Scanner_Node scanner_node = picture_ptr_arg->scanner_node;

  bool error_stop_value = (scanner_node->get_run_state()->error_stop_mode
                     == Run_State::STOPPING)
                      ? true : false;


@q ***** (5) Error handling:  Multithreading is not supported.@>
@ Multithreading is not supported.
@<Define |Scan_Parse| functions@>=

#ifndef HAVE_PTHREAD_H  
  
  cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
            << endl << "This function should only ever be called "
            << "when multithreaded output is supported."
            << endl << "Setting `*return_value' = 1 and returning "
            << "a void pointer to `return_value'."
            << endl << "The programmer should ensure "
            << "that the memory allocated to `return_value' is freed.";

  log_message(cerr_strm); 
  cerr_message(cerr_strm, error_stop_value);
  cerr_strm.str("");

  *return_value = 1;
  return static_cast<void*>(return_value); 

#else /* |HAVE_PTHREAD_H| is defined.  */@; 

@q ***** (5) Error handling:  Multithreading is not enabled.@>
@ Multithreading is not enabled.
@<Define |Scan_Parse| functions@>=

  if (!picture_ptr_arg->scanner_node->run_state.multithread_output)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << endl << "This function should only ever be called "
                << "when multithreaded output is enabled."
                << endl << "Setting `*return_value' = 1 and returning "
                << "a void pointer to `return_value'."
                << endl << "The programmer should ensure "
                << "that the memory allocated to `return_value' is freed.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *return_value = 1;
      return static_cast<void*>(return_value); 
    
    }  /* |if (!picture_ptr_arg->run_state->multithread_output)|  */

#endif /* |HAVE_PTHREAD_H| is defined.  */@; 

@q ***** (5) Error handling for the case that                @> 
@q ***** (5) |scanner_node->output_pending.value_0 == false|.@>

@ Error handling for the case that 
|scanner_node->output_pending.value_0 == false|.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=
   
  if (!scanner_node->output_pending.value_0)
    {
      
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << endl << "`scanner_node->output_pending.value_0' == `false'."
                << endl << "This shouldn't ever happen. Exiting function "
                << endl << "with `*return_value' == 1.";
      
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

       *return_value = 1;
        return static_cast<void*>(return_value); 
  
    } /* |if (!scanner_node->output_pending.value_0)|  */
  

@q ***** (5) Lock output stream mutex.  Exit on error.@>

@ Lock output stream mutex.  Exit on error.
\initials{LDF 2004.07.14.}

\LOG
\initials{LDF 2005.03.14.}
@:BUG FIX@> BUG FIX:  Now testing for |out_stream == 0|.
@:BUG@> BUG: 
This occurs when the \.{--multithread-output} option is used 
without \.{--multithread-input}.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  Output_Struct* out_stream = picture_ptr_arg->scanner_node->out[Run_State::METAPOST];

  if (out_stream == static_cast<Output_Struct*>(0))
     {
         cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                   << endl 
                   << "`out_stream == 0."
                   << endl << "Exiting function with `*return_value' == 1.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         *return_value = 1;
         return static_cast<void*>(return_value); 

      }


  status = out_stream->lock();

  if (status != 0)
    {

        cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                  << endl 
                  << "`out_stream->lock() failed."
                  << endl << "Exiting function with `*return_value' == 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        *return_value = 1;
        return static_cast<void*>(return_value); 
    }



@q ***** (5) Call |Picture::output|.@>

@ Call |Picture::output|.
\initials{LDF 2004.07.12.}

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.07.13.}
Change return value of |Picture::output| so that I can test whether it
succeeded here.
\ENDTODO 

\LOG
\initials{LDF 2005.03.14.}
Now passing |picture_ptr_arg->surface_hiding_value| 
to |Picture::output|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  cerr_strm << thread_name << "In `output_func()':"
            << "About to output picture.";
  log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG)
     {

       cerr_message(cerr_strm);
         

       cerr_mutex.lock();

       picture_ptr_arg->picture->show("picture:");

       cerr_mutex.unlock();
     }
#endif /* |DEBUG_COMPILE|  */@; 

  cerr_strm.str("");

  picture_ptr_arg->picture->output(picture_ptr_arg->scanner_node,
                                   *(picture_ptr_arg->focus),
                                   picture_ptr_arg->projection,
                                   picture_ptr_arg->factor,
                                   picture_ptr_arg->sort_value,
                                   picture_ptr_arg->do_warnings,
                                   picture_ptr_arg->min_x_proj,
                                   picture_ptr_arg->max_x_proj,
                                   picture_ptr_arg->min_y_proj,
                                   picture_ptr_arg->max_y_proj,
                                   picture_ptr_arg->min_z_proj,
                                   picture_ptr_arg->max_z_proj,
                                   picture_ptr_arg->surface_hiding_value);

  cerr_strm << thread_name << "In `output_func()':"
            << "Finished outputting picture.";

  log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_message(cerr_strm);
     }
#endif /* |DEBUG_COMPILE|  */@; 

  cerr_strm.str("");
  


@q ***** (5) If |picture_ptr_arg->endfig|, write ``{\bf endfig;} to outstream.@>
@ If |picture_ptr_arg->endfig|, write ``{\bf endfig;} to the output stream for
MetaPost code.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=
  
  if (picture_ptr_arg->endfig)
    {


      cerr_strm << thread_name << "In `output_func()':"
                << endl << "`picture_arg->endfig' == `true'.";
      log_message(cerr_strm); 

#if DEBUG_COMPILE
      if (DEBUG)
        cerr_message(cerr_strm);
#endif /* |DEBUG_COMPILE|  */@; 

      cerr_strm.str("");


      *(out_stream->stream_ptr) << "endfig;" << endl << endl << flush;


    } /* |if (picture_ptr_arg->endfig)|  */

  else  /* (!|picture_ptr_arg->endfig|)  */
    {

      cerr_strm << thread_name << "In `output_func()':"
                << endl << "`picture_arg->endfig' == `false'.";
      log_message(cerr_strm); 

#if DEBUG_COMPILE
      if (DEBUG)
        cerr_message(cerr_strm);
#endif /* |DEBUG_COMPILE|  */@; 
      
      cerr_strm.str("");


    } /* |else| (|!picture_ptr_arg->endfig|)  */


@q ***** (5) Unlock output stream mutex.  Exit on error.@>

@ Unlock output stream mutex.  Exit on error.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=

  status = out_stream->unlock();


  if (status != 0)
    {

      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << endl 
                << "`out_stream->unlock()' failed."
                << endl << "Exiting function with `*return_value' == 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *return_value = 1;
      return static_cast<void*>(return_value); 

    } /* |if (status != 0)|  */


@q ***** (5) Try to lock |*(picture_ptr_arg->picture)| and then unlock it.@>

@ Try to lock |*(picture_ptr_arg->picture)| and then unlock it.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.

@:BUG@> BUG: 
\initials{LDF 2004.08.25.}
Now calling |picture_ptr_arg->picture->trylock| and 
|picture_ptr_arg->picture->unlock|.  This is an attempt to fix a bug
that occurs on Glen Ritchie's (GCR's) system.  I think |*(picture_ptr_arg->picture)| 
might be locked on his system.  It's not on mine, and no error occurs on my system. 

\initials{LDF 2004.08.25.}
If |*(picture_ptr_arg->picture)| isn't locked, or if it's locked by the 
thread of which this function is the start function,
then this should work.
Otherwise, i.e., if it's locked by another thread, it should fail.  
In this case, this function issues a warning, but continues.
\ENDLOG 

@q ****** (6) Try to lock |*(picture_ptr_arg->picture)|.@>

@ Try to lock |*(picture_ptr_arg->picture)|.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| functions@>=

  status = picture_ptr_arg->picture->trylock();

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                << endl 
                << "`picture_ptr_arg->picture->trylock()' returned " 
                << status << ".";
      
      log_message(cerr_strm); 
      cerr_message(cerr_strm, DEBUG); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ******* (7) |picture_ptr_arg->picture->trylock| succeeded.@>

@ |picture_ptr_arg->picture->trylock| succeeded.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  if (status == 0) /* |picture_ptr_arg->picture->trylock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                    << endl
                    << "`*(picture_ptr_arg->picture)' wasn't locked. "
                    << "Will try to unlock it.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, DEBUG); 
          cerr_strm.str("");
        }

#endif /* |DEBUG_COMPILE|  */@; 
 
    } /* |if (status == 0)| 
         (|picture_ptr_arg->picture->trylock| succeeded.)  */


@q ******* (7) |picture_ptr_arg->picture->trylock| failed.@>

@ |picture_ptr_arg->picture->trylock| failed.
Will try to unlock |*(picture_ptr_arg->picture)| anyway.  If it was
locked by this thread, it should succeed, otherwise it will fail.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  else 

@q /* (|status == 0|---|picture_ptr_arg->picture->trylock| failed.)  */ @>

    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                    << endl
                    << "`*(picture_ptr_arg->picture)' was locked. "
                    << "Will try to unlock it anyway."
                    << endl
                    << "If it was locked by this thread, this should "
                    << "succeed, otherwise it should fail.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, DEBUG); 
          cerr_strm.str("");
        }
#endif 

@q /* |DEBUG_COMPILE|  */ @>
 
    }

@q   /* |else| (|status == 0|---|picture_ptr_arg->picture->trylock| @>
@q          failed.)  */ @>

@q ****** (6) Try to unlock |*(picture_ptr_arg->picture)|.@>

@ Try to unlock |*(picture_ptr_arg->picture)|.
If it was locked by the call to |trylock| above, or if was locked 
by this thread previously, this should succeed, otherwise it should 
fail.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

       status = picture_ptr_arg->picture->unlock();

@q ******* (7) |picture_ptr_arg->picture->unlock| succeeded.@>

@ |picture_ptr_arg->picture->unlock| succeeded.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  if (status == 0) /* |picture_ptr_arg->picture->unlock| succeeded.  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                    << endl
                    << "`picture_ptr_arg->picture->unlock()' succeeded."
                    << endl
                    << "This means that `*(picture_ptr_arg->picture)' was either "
                    << "locked by the previous call to `trylock()',"
                    << endl 
                    << "or that it was locked somewhere else in this thread (this is good).";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, DEBUG); 
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 
 
    } /* |if (status == 0)| 
         (|picture_ptr_arg->picture->unlock| succeeded.)  */


@q ******* (7) |picture_ptr_arg->picture->unlock| failed.@>

@ |picture_ptr_arg->picture->unlock| failed.
This probably means that |*(picture_ptr_arg->picture)| was
locked by another thread.  Will try to continue anyway.
\initials{LDF 2004.08.25.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.
\ENDLOG 

@<Define |Scan_Parse| functions@>=


  else 

@q /* (|status == 0|---|picture_ptr_arg->picture->unlock| @>
@q   failed.)  */                                         @>

    {

      cerr_strm << thread_name << "WARNING! In `Scan_Parse::output_func()':"
                << endl
                << "`picture_ptr_arg->picture->unlock()' failed."
                << endl
                << "This probably means that `*(picture_ptr_arg->picture)' "
                << "was locked by another thread." << endl
                << "Will try to continue.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");
        
    }   /* |else| (|status == 0| XXX |picture_ptr_arg->picture->unlock| 
                   failed.)  */


@q ***** (5) Delete |picture_ptr_arg|.@>

@ Delete |picture_ptr_arg|.
\initials{LDF 2004.07.13.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                << endl << "Before deleting `picture_ptr_arg'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, DEBUG);
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 




  delete picture_ptr_arg;

  
#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "After deleting `picture_ptr_arg'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, DEBUG);
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 
  

@q ***** (5) Try to lock |scanner_node->output_pending|.@>  
@ Try to lock |scanner_node->output_pending|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

  status = scanner_node->output_pending.lock();

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << endl
                << "`scanner_node->output_pending.lock()' failed. "
                << "Exiting function with `*return value' ==  1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *return_value =  1;

      return static_cast<void*>(return_value); 


    } /* |if (status != 0)|  */

  else /* |scanner_node->output_pending.lock| succeeded.  */
    {

      cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                << endl
                << "`scanner_node->output_pending.lock()' succeeded!";
      
      log_message(cerr_strm); 

#if DEBUG_COMPILE
      if (DEBUG)
        cerr_message(cerr_strm);
#endif /* |DEBUG_COMPILE|  */@; 

      cerr_strm.str("");


    } /* |else| (|scanner_node->output_pending.lock| succeeded.)  */


@q ***** (5) Set |scanner_node->output_pending.value_0| to |false|, @>  
@q ***** (5) decrement |scanner_node->output_pending.value_0|,      @>
@q ***** (5) and signal condition.                                  @>
 

@ Set |scanner_node->output_pending.value_0| to |false|, 
decrement |scanner_node->output_pending.value_0|, and signal 
condition.                                  
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>= 

  scanner_node->output_pending.value_0 = false;
  scanner_node->output_pending.value_1--;
  
  status = scanner_node->output_pending.signal();


@q ****** (6) Error handling:  |scanner_node->output_pending.signal| failed.@>
@ Error handling:  |scanner_node->output_pending.signal| failed.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>=


  if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::output_func()':"
                << endl << "`scanner_node->output_pending.signal()' failed. "
                << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with `*return_value' == 1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      *return_value =  1;

      return static_cast<void*>(return_value); 

    } /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::output_func()':"
                 << endl << "`scanner_node->output_pending.signal()' "
                 << "succeeded.";

       log_message(cerr_strm); 

       if (DEBUG) 
         cerr_message(cerr_strm);

       cerr_strm.str("");

     } /* |else| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Try to unlock |scanner_node->output_pending|.@>  
@ Try to unlock |scanner_node->output_pending|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>= 

#ifdef HAVE_PTHREAD_H  
  status = scanner_node->output_pending.unlock();

  if (status != 0)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_func()':"
                << endl
                << "`scanner_node->output_pending.unlock()' failed. "
                << "Exiting function with `*return value' ==  1.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      *return_value =  1;

      return static_cast<void*>(return_value); 

    } /* |if (status != 0)|  */

  else /* |scanner_node->output_pending.unlock| succeeded.  */
    {

      cerr_strm << thread_name << "In `Scan_Parse::output_func()':"
                << endl
                << "`scanner_node->output_pending.unlock()' succeeded!";
      
      log_message(cerr_strm); 

#if DEBUG_COMPILE
      if (DEBUG)
        cerr_message(cerr_strm);
#endif /* |DEBUG_COMPILE|  */@; 

      cerr_strm.str("");
      

    } /* |else| (|scanner_node->output_pending.unlock| succeeded.)  */

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ***** (5) Exit function successfully.@>

@ Exit function successfully.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=


  cerr_strm << thread_info->name 
            << ". Exiting `Scan_Parse::output_func()'."
            << endl;

  log_message(cerr_strm); 

#if DEBUG_COMPILE
  if (DEBUG)
    cerr_message(cerr_strm);
#endif /* |DEBUG_COMPILE|  */@; 

  cerr_strm.str("");

  *return_value = 0;

  return static_cast<void*>(return_value); 

}  /* End of |Scan_Parse::output_func| definition.  */

@q *** (3) |output_command_func|.@>
@*3 {\bf output\_command\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.09.}
Added this function.

\initials{LDF 2004.07.16.}
Revised this function.

\initials{LDF 2004.09.09.}
Programmed the single-threaded case.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int
Scan_Parse::output_command_func(Scanner_Node scanner_node)
{

@q ***** (5) Get thread information and set |thread_name|.@>

@ Get thread information and set |thread_name|.
\initials{LDF 2004.07.15.}

@<Define |Scan_Parse| functions@>=


  string thread_name;

#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();
  
  thread_name = Thread_Info_Type::get_thread_name(thread_info);

#else /* |HAVE_PTHREAD_H| is undefined.  */

    thread_name = "";

#endif /* |HAVE_PTHREAD_H| is undefined.  */@; 

  stringstream cerr_strm;

@q ***** (5) @>   
@
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {
      cerr_strm << thread_name
                << "Entering `Scan_Parse::output_command_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

   int status;
   bool multithread_output  = scanner_node->run_state.multithread_output;
   unsigned short error_stop_mode = scanner_node->run_state.error_stop_mode;

   bool error_stop_value = (error_stop_mode == Run_State::STOPPING) ? true : false;

   bool is_endfig = false; 

@q ***** (5) Get |current_picture|, if this is for |endfig|.@>

@ Get |current_picture|, if this is for |endfig|.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=

  if (scanner_node->endfig_ptr != static_cast<void*>(0))
    {
      
      is_endfig = *static_cast<bool*>(scanner_node->endfig_ptr);
      
      if (!is_endfig) /* Error handling.  */
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl << "`scanner_node->endfig_ptr' != 0 but "
                    << "`*static_cast<bool*>(scanner_node->endfig_ptr)' "
                    << "!= `true'."
                    << endl << "This should never happen. "
                    << "Exiting function with return value 1."; 
        
          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

        } /* |if (!is_endfig)|  */


      Id_Map_Entry_Node entry = scanner_node->lookup("current_picture");
      

@q ****** (6) Error handling:  |current_picture| not found.@>

@ Error handling:  |current_picture| not found.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=


      if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
        {

          cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl << "`current_picture' not found. "
                    << "Exiting function with return value 1."; 
        
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;


          
        } /* |if (entry == 0 && entry->object == 0)|  */


@q ****** (6) Lock |entry|. Exit on error.@>

@ Lock |entry|. Exit on error.
This is just for insurance.  No other threads should be able to access |entry|
at this time.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "Trying to lock `entry'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

      status = entry->lock();

      if (status != 0)

        {

          cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl << "`entry->lock()' failed. "
                    << "Exiting function with return value 1."; 
        
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;
          
        }

@q ****** (6) Success!  Setting |scanner_node->picture_entry_ptr| to |entry|.@>

@ Success!  Setting |scanner_node->picture_entry_ptr| to |entry|.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=
  
       
     scanner_node->picture_entry_ptr = static_cast<void*>(entry);
 

#if DEBUG_COMPILE
   if (DEBUG)
     {

       cerr_mutex.lock();
       cerr << thread_name << "In `Scan_Parse::output_command_func()':"
            << endl;

       static_cast<Picture*>(entry->object)->show("current_picture on entry:");
       static_cast<Picture*>(
          static_cast<Id_Map_Entry_Node>(
             scanner_node->picture_entry_ptr)->object)->show(
                "current_picture on arg:");  
    cerr_mutex.unlock();
#if 0 
    cerr_message(cerr_strm, true);
#endif 
    cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) Unlock |entry|. Exit on error.@>

@ Unlock |entry->mutex|. Exit on error.
\initials{LDF 2004.07.14.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "Trying to unlock `entry'.";
       cerr_message(cerr_strm);
       cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 



      status = entry->unlock();

      if (status != 0)

        {

          cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl << "`entry->unlock()' failed. "
                    << "Exiting function with return value 1."; 
        
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;
          
        }


    } /* |if (scanner_node->endfig_ptr != 0)|  */
  


@q ***** (5) Get |Picture| and arguments for |Picture::output|.@>

@ Get |Picture| and arguments for |Picture::output|.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=

  Picture_Output_Arg_Type* p;
  p = scanner_node->extract_picture_output_args();

@q ****** (6) Error handling:  |Scanner_Type::extract_picture_output_args|@>
@q ****** (6)  failed.                                                      @>
@ Error handling:  |Scanner_Type::extract_picture_output_args| failed.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=

  if (p == static_cast<Picture_Output_Arg_Type*>(0))
    {
        cerr_strm << "ERROR! " << thread_name
                  << "In `Scan_Parse::output_command_func()':"
                  << endl 
                  << "`Scanner_Type::extract_picture_output_args()' failed."
                  << endl << "Exiting function with return value 1.";

        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        return 1;
    } /* |if (p == 0)|  */


@q ***** (5) If we're using multithreaded output,       @>
@q ***** (5) create new thread and call |output_func|.@>

@ If we're using multithreading, create new thread and call 
|output_func|.  
\initials{LDF 2004.07.12.}
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H    

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_mutex.lock();
      
       cerr << "In `Scan_Parse::output_command_func()':"
            << endl << "Showing `p->picture':"
            << endl;

       p->picture->show("p->picture");

       cerr_mutex.unlock();
     }
#endif /* |DEBUG_COMPILE|  */@;    

  if (multithread_output)

    {
      scanner_node->thread_vector.push_back(new pthread_t);

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << "In `Scan_Parse::output_command_func()':"
                    << endl << "scanner_node->thread_vector.size() == "
                    << scanner_node->thread_vector.size() << endl;
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@;


@q ****** (6) Try to lock |scanner_node->output_pending|, set       @>  
@q ****** (6) |scanner_node->output_pending.value_0| to |true|,     @>  
@q ****** (6) and increment |scanner_node->output_pending.value_1|. @>  

@ Try to lock |scanner_node->output_pending|, set       
|scanner_node->output_pending.value_0| to |true|,     
and increment |scanner_node->output_pending.value_1|. 
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>= 

#if DEBUG_COMPILE
  if (DEBUG)
    {

      cerr_strm << thread_name << "In `Scan_Parse::output_command_func()':"
                << endl
                  << "About to call `scanner_node->output_pending.lock()'.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

      status = scanner_node->output_pending.lock();

@q ******* (7) Error handling.  |output_pending.lock| failed.@>

@ Error handling:  |output_pending.lock| failed.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=



      if (status != 0)
        {
          cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl
                    << "`scanner_node->output_pending.lock()' failed. "
                    << "Not calling `output_func()'."
                    << endl << "Exiting function with return value 1.";


          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          return 1;

        } /* |if (status != 0)|  */


@q ******* (7) |output_pending.lock| succeeded.@>

@ |output_pending.lock| succeeded.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=


      else /* |scanner_node->output_pending.lock| succeeded.  */
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name << "In `Scan_Parse::output_command_func()':"
                        << endl << "`scanner_node->output_pending.lock()' succeeded!";
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 


@q ******** (8) Check whether an output operation is pending.@>
@ Check whether an output operation is pending.
\initials{LDF 2004.07.16.}
@<Define |Scan_Parse| functions@>=

  while (scanner_node->output_pending.value_0)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {

          cerr_strm << thread_name << "In `Scan_Parse::output_command_func()':"
                    << endl << "Output pending.  Going to sleep.";

          cerr_message(cerr_strm);
          cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 


      timespec timeout;

      timeout.tv_sec = time (0) + 300; /* Five minutes.  */
      timeout.tv_nsec = 0;
        
      status = scanner_node->output_pending.timedwait(&timeout);
        


@q ********* (9) Error handling:  Timout.@>
@ Error handling:  Timout.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=


  if (status == ETIMEDOUT)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':" 
                << endl
                << "`scanner_node->output_pending.timedwait(&timeout)' timed out "
                << "after " << timeout.tv_sec << "seconds." << endl
                << "Not performing output." << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      return 1;

    } /* |if (status == ETIMEDOUT)|  */


@q ********* (9) Error handling:  |scanner_node->output_pending.timedwait| failed.@>
@ Error handling:  |scanner_node->output_pending.timedwait| failed.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=


  else if (status != 0)
    {


      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::output_command_func()':"
                << endl << "`scanner_node->output_pending.timedwait()' failed. "
                << "Not performing output." << endl << "Will try to unlock "
                << "`scanner_node->output_pending' and "
                << "exit function with return value 1.";

      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      scanner_node->output_pending.unlock();
      
      return 1;

    } /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::output_command_func()':"
                 << endl << "`scanner_node->output_pending.timedwait()' "
                 << "succeeded.";

       cerr_message(cerr_strm);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|status == 0|)  */
#endif /* |DEBUG_COMPILE|  */@; 
       

    } /* |while (scanner_node->output_pending.value_0)|  */

#if DEBUG_COMPILE
          if (DEBUG)
            {

              cerr_strm << thread_name 
                        << "`Scan_Parse::output_command_func()':"
                        << endl << "Output not pending. "
                        << "Setting `output_pending->value' to `true' "
                        << "and continuing.";

              cerr_message(cerr_strm);
              cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@; 

          scanner_node->output_pending.value_0 = true;
          scanner_node->output_pending.value_1++;

        } /* |else| (|scanner_node->output_pending.lock| succeeded.)  */


@q ****** (6) Try to unlock |scanner_node->output_pending|.@>  
@ Try to unlock |scanner_node->output_pending|.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>= 

  status = scanner_node->output_pending.unlock();


@q ******* (7) Error handling.  |output_pending.unlock| failed.@>

@ Error handling:  |output_pending.unlock| failed.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=



      if (status != 0)
        {
          cerr_strm << thread_name << "ERROR! In `Scan_Parse::output_command_func()':"
                    << endl
                    << "`scanner_node->output_pending.unlock()' failed. "
                    << "Exiting function with return value 1.";

          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

        } /* |if (status != 0)|  */


@q ******* (7) |output_pending.unlock| succeeded.@>

@ |output_pending.unlock| succeeded.
\initials{LDF 2004.07.16.}

@<Define |Scan_Parse| functions@>=



      else /* |scanner_node->output_pending.unlock| succeeded.  */
        {

#if DEBUG_COMPILE
          if (DEBUG)
            {
              cerr_strm << thread_name << "In `Scan_Parse::output_command_func()':"
                        << endl
                        << "`scanner_node->output_pending.unlock()' succeeded!";
              cerr_message(cerr_strm);
              cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 

        } /* |else| (|scanner_node->output_pending.unlock| succeeded.)  */


@q ****** (6) Call |pthread_create|.@>

@ Call |pthread_create|.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=


      status = pthread_create(scanner_node->thread_vector.back(),
                              0,
                              output_func,
                              static_cast<void*>(p)); 


@q ******* (7) Error handling.  |pthread_create| failed.@>

@ Error handling:  |pthread_create| failed.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=

  if (status != 0)
    {
      
      cerr_strm << "ERROR! In `Scan_Parse::output_command_func()':"
                << endl << "`pthread_create()' failed."
                << endl << "Exiting function with return value 1."
                << endl; 

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      return 1;

    } /* |if (status != 0)|  */


@q ******* (7) Success!  |pthread_create| succeeded.@>

@ Success!  |pthread_create| succeeded.
\initials{LDF 2004.07.12.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::output_command_func()':"
                 << endl << "`pthread_create()' succeeded."
                 << endl; 
       cerr_message(cerr_strm);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

    } /* |if (multithread_output)|  */


@q ***** (5) Not using multithreaded output.@>

@ Not using multithreaded output.

\LOG
\initials{LDF 2004.09.09.}
Programmed this case.
\ENDLOG 

\LOG
\initials{LDF 2005.03.14.}
Now passing |picture_ptr_arg->surface_hiding_value| 
to |Picture::output|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

#else
  if (0)  /* Dummy conditional.  */
    ;
#endif /* |HAVE_PTHREAD_H|  */@; 

  else  /* (|!multithread_output|)  */

    {

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "In `Scan_Parse::output_command_func()':"
                 << endl << "Non-multithreaded output. Calling "
                 << endl << "`Picture::output()'.";
       
       log_message(cerr_strm);
       cerr_message(cerr_strm, true);
       cerr_strm.str("");

     }
#endif /* |DEBUG_COMPILE|  */@; 

#ifdef HAVE_PTHREAD_H  
   p->scanner_node->out[Run_State::METAPOST]->lock();
#endif /* |HAVE_PTHREAD_H|  */@; 

   p->picture->output(p->scanner_node,
                      *(p->focus),
                      p->projection,
                      p->factor,
                      p->sort_value,
                      p->do_warnings,
                      p->min_x_proj,
                      p->max_x_proj,
                      p->min_y_proj,
                      p->max_y_proj,
                      p->min_z_proj,
                      p->max_z_proj,
                      p->surface_hiding_value);
   

   if (is_endfig)
     *(p->scanner_node->out[Run_State::METAPOST]->stream_ptr) 
           << "endfig;" << endl << endl << flush;
            

#ifdef HAVE_PTHREAD_H  
   p->scanner_node->out[Run_State::METAPOST]->unlock();
#endif /* |HAVE_PTHREAD_H|  */@; 


    }     /* |else | (|!multithread_output|)  */


@q ***** (5) Exit function successfully with return value 0.@>   

@ Exit function successfully with return value 0.
\initials{LDF 2004.09.09.}

@<Define |Scan_Parse| functions@>=

                                                                
#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << "Exiting `Scan_Parse::output_command_func()'."
                << endl;
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 



  return 0;

}  /* End of |Scan_Parse::output_command_func(Scanner_Node scanner_node)|
     definition.  */

@q *** (3) |non_shape_decl_func|.@>
@*3 {\bf non\_shape\_decl\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.21.}
Added this function.

\initials{LDF 2004.08.24.}
Now conditionally compiling code that uses |Thread_Info_Type|.

\initials{LDF 2004.08.28.}
Now passing |scanner_node| as an argument in the call to 
|Scanner_Type::add_entry|.

\initials{LDF 2004.08.29.}
Removed the  |Scanner_Node| argument in the call to 
|Scanner_Type::add_entry|.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int 
Scan_Parse::non_shape_decl_func(Scanner_Node scanner_node,
                                int type_num)
{

  string thread_name;
  
#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

  if (scanner_node == static_cast<Scanner_Node>(0) /* Assume we're using threads.  */

      || (scanner_node->get_run_state()->multithread_input 
          || scanner_node->get_run_state()->multithread_output)      

      /* Definitely using threads.  */

      ) /* Using threads.  */

    {

      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = Thread_Info_Type::get_thread_name(thread_info);

    } /* |if| (using threads).  */

  else /* Not using threads.  */
    
    {
      thread_info = 0;
      thread_name = "";

    } /* |if| (not using threads.)  */

#else /* |HAVE_PTHREAD_H| is undefined.  */@; 
  
  thread_name = "";

#endif /* |HAVE_PTHREAD_H|  is undefined.  */@; 

  stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::non_shape_decl_func()'.";

      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "`Scan_Parse::non_shape_decl_func()':"
                << endl 
                << "   Showing `scanner_node->token_string_bool_vector':";

      cerr_message(cerr_strm);
      cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */

{ /* Begin group.  */

  int i = 0;

  for (vector<String_Bool>::const_iterator iter
         = scanner_node->token_string_bool_vector.begin();
       iter != scanner_node->token_string_bool_vector.end();
       ++iter)
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "`Scan_Parse::non_shape_decl_func()':"
                    << endl
                    << "   token_string_bool_vector[" << i << "] == "
                    << iter->first << ", " << iter->second << ".";

          if (iter->second)
            {
              cerr_strm << thread_name << "`Scan_Parse::non_shape_decl_func()':"
                        << endl
                        << "   It's an array.";

              cerr_message(cerr_strm);
              cerr_strm.str("");

            } /* |if (iter->second)|  */

          else /* (|!iter->second|)  */
            {
              cerr_strm << thread_name << "`Scan_Parse::non_shape_decl_func()':"
                       << endl
                       << "   It's not an array.";
              cerr_message(cerr_strm);
              cerr_strm.str("");

            } /* |else| (|!iter->second|)  */

        } /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@;
      
      scanner_node->add_entry(iter->first,
                              type_num,
                              Id_Map_Entry_Type::REGULAR,
                              false,
                              iter->second);
    
      ++i;

    } /* |for|  */

   } /* End of group.  */

  scanner_node->token_string_bool_vector.clear();


#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::non_shape_decl_func()' "
                << "successfully with return value 0.";
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


  return 0;

  
}  /* End of |Scan_Parse::non_shape_decl_func| definition.  */

@q *** (3) |shape_decl_func|.@>
@*3 {\bf shape\_decl\_func}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.21.}
Added this function.

\initials{LDF 2004.07.23.} 
Added default of 0 for the dummy |C*| argument.

\initials{LDF 2004.08.28.}
Now passing |scanner_node| as an argument in the call to 
|Scanner_Type::add_entry|.

\initials{LDF 2004.08.29.}
Removed the  |Scanner_Node| argument in the call to 
|Scanner_Type::add_entry|.

\initials{LDF 2004.10.27.}
@:BUG FIX@> BUG FIX:  No longer allocating memory for the 
|object| member of the |Id_Map_Entry_Node| which this function
creates.  This makes it possible to chain |point| assignments.

\initials{LDF 2004.12.28.}
Added debugging output.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=
template <class C>
int 
Scan_Parse::shape_decl_func(Scanner_Node scanner_node,
                            int type_num,
                            C* dummy)
{

  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info(true);
  
  string thread_name = Thread_Info_Type::get_thread_name(thread_info);

  stringstream cerr_strm;

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true|  */
#endif /* |DEBUG_COMPILE|  */

  cerr_strm << thread_name << "Entering `Scan_Parse::shape_decl_func()'.";

#if DEBUG_COMPILE
   if (DEBUG)
   {
     cerr_message(cerr_strm); 
     log_message(cerr_strm); 

   } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;

  cerr_strm.str(""); 

  { /* Beginning of group.  */
    
    int i = 0;

    for (vector<String_Bool>::const_iterator iter
         = scanner_node->token_string_bool_vector.begin();
         iter != scanner_node->token_string_bool_vector.end();
         ++iter)
      {


#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr << "iter->first == " << iter->first << endl;
     }
#endif /* |DEBUG_COMPILE|  */@; 
 


  
        scanner_node->add_entry(iter->first,                    // |name|
                                type_num,                       // |type|
                                Id_Map_Entry_Type::REGULAR,     // |category|
                                false,                          // |const_flag|
                                iter->second,                   // |array_flag|
                                Id_Map_Entry_Type::INDEPENDENT, // |known_state|
                                0);                             // |object|
      ++i;

    } /* |for|  */

   } /* End of group.  */


  scanner_node->token_string_bool_vector.clear();

  cerr_strm << thread_name << "Exiting `Scan_Parse::shape_decl_func()' "
            << "successfully with return value 0.";
 
#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_message(cerr_strm); 
      log_message(cerr_strm); 

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;

  cerr_strm.str(""); 

  return 0;
 
}  /* End of |Scan_Parse::shape_decl_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.

!! Please note:  This function is called for other types for which there is no
declaration for an instantiation and this doesn't cause errors.  Maybe the
compiler can handle the instantiations by itself now.
\initials{LDF 2009.11.04.}

\LOG
\initials{LDF 2004.07.22.}  
Added this section.

\initials{LDF 2004.07.23.}
Added default of 0 for the dummy arguments 
(|Point*|, |Path*|, etc.)

\initials{LDF 2004.10.08.}
Commented-in the declaration where the type parameter is
|Octahedron|. 

\initials{LDF 2005.05.18.}
Added declaration with a |Helix*| argument.

\initials{LDF 2005.05.25.}
Added two declarations:  one with a |Cone*| and the other 
with a |Cylinder*| argument.

\initials{LDF 2005.05.26.}
Added declaration with an |Ellipsoid*| argument.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=
int
shape_decl_func(Scanner_Node, int, Point* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Path* dummy = 0);

#if 0 /* Triangle doesn't exist yet!  
         \initials{LDF 2004.07.21.}  */
int
shape_decl_func(Scanner_Node, int, Triangle* dummy = 0);
#endif 

int
shape_decl_func(Scanner_Node, int, Reg_Polygon* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Rectangle* dummy = 0);

#if 0  /* !! TO DO:  Program this case!  \initials{LDF 2004.07.21.} */
int
shape_decl_func(Scanner_Node, int, Square* dummy = 0);
#endif 


int
shape_decl_func(Scanner_Node, int, Ellipse* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Circle* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Helix* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Cone* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Cylinder* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Cuboid* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Tetrahedron* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Octahedron* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Dodecahedron* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Icosahedron* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Trunc_Octahedron* dummy = 0);

int
shape_decl_func(Scanner_Node, int, Ellipsoid* dummy = 0);

@q *** (3) |assign_simple|.@>
@*2 {\bf assign\_simple}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

It is used for simple assignments to |Transform| and |Focus|, as well
as variables of |Shape| types.
\initials{LDF 2004.07.27.}

The argument |bool use_or_delete| should be |true| (the default) 
for variables of types whose |objects| are of types which are stored in the
|pointer_value| member of the union used for the values of symbols by
the Bison parser.  It should be |false| for other types, such as 
|numeric_primary|, |numeric_secondary|, |numeric_tertiary|, and 
|numeric_expression|.
\initials{LDF 2004.10.27.}
  
\item{$\bullet$}  
If the |bool use_or_delete| argument is |true| and the 
|void* object| member of the |Id_Map_Entry_Node| passed as 
the |void* var| argument is 0, |static_cast<C*>(object)| 
is assigned to from |expr|.  
%
\item{$\bullet$}  
If it's |true| and |object != 0|, |*static_cast<C*>(object)| is assigned 
to from |*expr| and |expr| is deleted.  
%
\item{$\bullet$}  
If it's |false| and |object == 0|, we try to allocate memory for a
new |C c| on the free store.  If |new C| fails, we rethrow |bad_alloc|.
Otherwise, |*c| is assigned to from |*expr| and 
|object| is set to |static_cast<void*>(c)|.  |expr| is not deleted.
%
\item{$\bullet$}  
If it's |false| and |object != 0|, |*c| is assigned to from 
|*expr| and |object| is set to |static_cast<void*>(c)|.  
|expr| is not deleted.
\initials{LDF 2004.10.27.}

\LOG
\initials{LDF 2004.07.27.}
Added this function.

\initials{LDF 2004.07.28.}
Removed |Scan_Parse::assign_simple_1| and changed the arguments to
this function so that it can be used for simple assignments to 
variables of most types.  It is not used for simple assignments 
to |Pictures| or |internal_quantities|.

\initials{LDF 2004.07.29.}
Changed |string type_name| and |C* expr| arguments to |const|.

\initials{LDF 2004.10.25.}
Made |C* expr| argument non-|const|.  This makes it possible to delete
it within this function.

\initials{LDF 2004.10.27.}
Added the argument |bool use_or_delete|.  The default is |true|.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=

template <class C>
Int_Void_Ptr
Scan_Parse::assign_simple(Scanner_Node scanner_node,
                          const string type_name,
                          void* var,
                          C* expr,
                          bool use_or_delete_expr)


{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;


  dummy_func();

@q ***** (5).@> 

#if DEBUG_COMPILE
  if (DEBUG) 
     {
        cerr_strm << thread_name 
                  << "Entering `Scan_Parse::assign_simple()'.";
   
        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(var);

  Int_Void_Ptr ivp;

@q ***** (5) Error handling for case that |entry == 0|.  @>

@ Error handling for case that |entry == 0|.
\initials{LDF 2004.07.27.}

@<Define |Scan_Parse| template functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name << "ERROR! In "
                << "`Scan_Parse::assign_simple()':"
                << endl 
                << "`entry' == 0. Not performing assignment."
                << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";
 
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 

      cerr_strm.str("");

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (entry == 0)|  */


@q ***** (5) Error handling for case that |entry->const_flag == true|.  @>
@ Error handling for case that |entry->const_flag == true|.
\initials{LDF 2004.07.27.}

@<Define |Scan_Parse| template functions@>=

  if (entry->const_flag)
    {
      cerr_strm << thread_name << "ERROR! In "
                << "`Scan_Parse::assign_simple()':"
                << endl 
                << "`entry->const_flag' == `true'. Can't assign to `"
                << entry->name << "'."
                << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 

      cerr_strm.str("");

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;


    } /* |if (entry->const_flag)|  */

@q ***** (5) Error handling for case that |expr == 0|.  @>
@ Error handling for case that |expr == 0|.
\initials{LDF 2004.07.28.}

@<Define |Scan_Parse| template functions@>=

  if (expr == static_cast<C*>(0))
    {
      cerr_strm << thread_name << "ERROR! In "
                << "`Scan_Parse::assign_simple()':"
                << endl 
                << "`expr' == 0. Can't assign to `"
                << entry->name << "'."
                << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 

      cerr_strm.str("");

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;


    } /* |if (expr == 0)|  */


@q ***** (5).@> 

  C* c = static_cast<C*>(entry->object);  


@q ***** (5) |use_or_delete_expr == true|.        @>
@q ***** (5) Assign, delete |expr|, if necessary,  @>
@q ***** (5) and return from function successfully.@>

@ |use_or_delete_expr == true|.  Assign, delete |expr|, 
if necessary, and return from function successfully.
\initials{LDF 2004.10.25.}

\LOG
\initials{LDF 2004.10.25.}
Revised this section.  Now assigning to 
|entry->object| from |static_cast<void*>(expr)| 
if |entry->object == 0|.  Otherwise, assigning to 
|*static_cast<C*>(entry->object)| from |*expr|, deleting 
|expr|, and setting it to 0.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  if (use_or_delete_expr)
    {
       if (c == static_cast<C*>(0))   
         c = expr;
    
       else /* |c != 0|  */
         {
            *c = *expr;
            delete expr;
            expr = 0;

         } /* |else| (|c != 0|)  */

    }  /* |if (use_or_delete_expr)|  */
 

@q ***** (5) |use_or_delete_expr == false|.   @>
@q ***** (5) Create new |C|, if necessary, and @> 
@q ***** (5) assign to it from |expr|.         @> 

@ |use_or_delete_expr == false|.  Create new |C|, 
if necessary, and assign to it from |expr|.         
\initials{LDF 2004.10.27.}

\LOG
\initials{LDF 2004.10.27.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| template functions@>=

  else /* |!use_or_delete_expr|  */
     {

        if (c == static_cast<C*>(0))
           {
  
              try 
                 {
                    c = new C;
                 }

              catch (bad_alloc)
               {
                  cerr_strm << thread_name 
                            << "ERROR! In `Scan_Parse::assign_simple()':"
                            << "`new C' failed.  Rethrowing `bad_alloc'.";
               
                  log_message(cerr_strm);
                  cerr_message(cerr_strm, error_stop_value);
                  cerr_strm.str("");

               } /* |catch (bad_alloc)|  */
 
           } /* |if (c == 0)|  */

        *c = *expr;

     } /* |else| (|!use_or_delete_expr|)  */


@q ***** (5).@> 
@
@<Define |Scan_Parse| template functions@>=


  entry->known_state = Id_Map_Entry_Type::KNOWN;

  ivp.v = entry->object = static_cast<void*>(c);   

  ivp.i = 0;

} /* End of |Scan_Parse::assign_simple| 
     definition.  \initials{LDF 2004.07.27.}  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.

\LOG
\initials{LDF 2004.07.24.}  
Added this section.

\initials{LDF 2004.07.26.}
Added declarations for |assign_simple<string>| and 
|assign_simple<Pen>|.

\initials{LDF 2004.07.26.}
Added declarations for |assign_simple<real>|, 
|assign_simple<Dash_Pattern>|, and 
|assign_simple<Color>|.

\initials{LDF 2004.07.29.}
Changed |string type_name| and |C* expr| arguments to |const|.

\initials{LDF 2004.10.26.}
Commented-out the declaration of the version with |C == real|, because
I've added a specialization for this type.

\initials{LDF 2004.10.27.}
Commented the declaration of the version with |C == real| back in, 
because I've changed this function to handle cases where |expr| is not
used or deleted.

\initials{LDF 2004.12.09.}
Added declaration for |assign_simple<Bool_Point>|. 

\initials{LDF 2005.05.20.}
Added declaration for |assign_simple<Helix>|. 

\initials{LDF 2005.05.25.}
Added declarations for |assign_simple<Cone>| and 
|assign_simple<Cylinder>|. 
Commented-in the declaration for |assign_simple<Triangle>|.

\initials{LDF 2005.05.26.}
Added declaration for |assign_simple<Ellipsoid>|.
\ENDLOG

@q ***** (5) Declarations. @>

@<Declare |Scan_Parse| functions@>=

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const int* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const real* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const string* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Pen* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Dash_Pattern* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Color* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Transform* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Point* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Bool_Point* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Path* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Ellipse* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Circle* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Helix* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Triangle* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Reg_Polygon* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Rectangle* expr);

#if 0 

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Square* expr);
#endif 


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Cone* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Cylinder* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Cuboid* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Tetrahedron* expr);

#if 0 

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Octahedron* expr);
#endif 

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Dodecahedron* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Icosahedron* expr);

Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Trunc_Octahedron* expr);


Int_Void_Ptr
assign_simple(Scanner_Node scanner_node,
              const string type_name,
              void* var,
              const Ellipsoid* expr);



@q *** (3) |assign_chained|.@>
@*2 {\bf assign\_chained}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.26.}
Added this function.

\initials{LDF 2004.07.27.}
Minor changes in debugging output.

\initials{LDF 2004.08.08.}
Changed the |void* expr| argument to |const C* expr| and removed the 
|const C* dummy| argument. 
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=
template <class C>
Int_Void_Ptr
Scan_Parse::assign_chained(Scanner_Node scanner_node,
                          void* var,
                          const C* expr)
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;




@q ***** (5).@> 

  Int_Void_Ptr ivp;


#if DEBUG_COMPILE
  if (DEBUG) 
    {
       cerr_strm << thread_name << "Entering `Scan_Parse::assign_chained()'.";

     log_message(cerr_strm); 
     cerr_message(cerr_strm); 
     cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

 
  Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(var);


@q ***** (5) Error handling for the case that |entry == 0|.@>

@ Error handling for the case that |entry == 0|.
\initials{LDF 2004.07.28.}

@<Define |Scan_Parse| template functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
        cerr_strm << thread_name << "ERROR! "
                  << "In `Scan_Parse::assign_chained()':"
                  << endl 
                  << "`entry' == 0. Not performing assignment."
                  << "Exiting function and returning `int' value 1 "
                  << "and `void*' value 0.";
        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 

        ivp.i = 1;
        ivp.v = static_cast<void*>(0);
        
        return ivp;

    } /* |if (entry == 0)|  */


@q ***** (5) Error handling for the case that |expr == 0|.@>

@ Error handling for the case that |expr == 0|.
\initials{LDF 2004.08.08.}

@<Define |Scan_Parse| template functions@>=


  if (expr == static_cast<const C*>(0))
    {
        cerr_strm << thread_name << "ERROR! "
                  << "In `Scan_Parse::assign_chained()':"
                  << endl 
                  << "`expr' == 0. Not performing assignment."
                  << "Exiting function and returning `int' value 1 "
                  << "and `void*' value 0.";
        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 

        ivp.i = 1;
        ivp.v = static_cast<void*>(0);
        
        return ivp;

    } /* |if (expr == 0)|  */


@q ***** (5) Allocate memory, if necessary, assign, and return  @>
@q ***** (5) from function successfully.                        @>

@ Allocate memory, if necessary, assign, and return  
from function successfully.                        
\initials{LDF 2004.07.28.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
       cerr_strm << thread_name << "In `Scan_Parse::assign_chained()':"
                 << endl 
                 << "   `entry->name' == " << entry->name << ". ";

      if (entry->object == static_cast<void*>(0))
        cerr_strm << "`entry->object' == 0. Allocating new object.";
      else
        cerr_strm << "`entry->object' != 0. Not allocating new object.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

  C* c; 
  
@q ****** (6) |entry->object == 0|.@> 
@ |entry->object == 0|.
\initials{LDF 2004.10.25.}

\LOG
\initials{LDF 2004.10.25.}
Now calling |new| in a |try| block and catching |bad_alloc|.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2004.10.25.}
Define |create_new| for all types that can be used as |C| in 
this function and call it instead of |new|.
\ENDTODO 

@<Define |Scan_Parse| template functions@>=

  if (entry->object == static_cast<void*>(0))
     {
         try  
           {
              c = new C;
           }

         catch (bad_alloc)
           {
              cerr_strm << thread_name 
                        << "ERROR! In `Scan_Parse::assign_chained()':"
                        << endl << "`new C' failed. Rethrowing `bad_alloc'.";

              log_message(cerr_strm);
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");

              throw;

           } /* |catch (bad_alloc)|  */

     } /* |if (entry->object == 0)|  */


@q ****** (6) |entry->object != 0|.@> 
@ |entry->object != 0|.
\initials{LDF 2004.10.25.}

@<Define |Scan_Parse| template functions@>=
  
  *c = *expr; 

  entry->object = static_cast<void*>(c);

  entry->known_state = Id_Map_Entry_Type::KNOWN;

  ivp.i = 0;
  ivp.v = entry->object;

  return ivp;
  
} /* End of |Scan_Parse::assign_chained| definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.

\LOG
\initials{LDF 2004.07.24.}  Added this section.

\initials{LDF 2004.07.27.}
Added default of 0 for the argument |C* dummy|.

\initials{LDF 2004.07.27.}
Added declarations for |assign_chained<real>|,
|assign_chained<Dash_Pattern>| and 
|assign_chained<Color>|.

\initials{LDF 2004.08.08.}
Changed the |void* expr| argument to |const C* expr| and removed the 
|const C* dummy| argument. 
\ENDLOG 


@<Declare |Scan_Parse| functions@>=

Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const int* expr);
               

Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const real* expr);


Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const string* expr);

Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Pen* expr);


Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Dash_Pattern* expr);

Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Color* expr);




Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Focus* expr);

Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Point* expr);



Int_Void_Ptr
assign_chained(Scanner_Node scanner_node,
               void* var,
               const Path* expr);

@q *** (3) |assign_picture_simple|.@>
@*2 {\bf assign\_picture\_simple}.     
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.12.}
Added this function.

\initials{LDF 2004.12.02.}
Changed |Id_Map_Entry_Node entry_0| argument to 
|Picture* p|.

\initials{LDF 2004.12.03.}
Changed argument |Picture* p| back to 
|Id_Map_Entry_Node entry_0|.  Reversed substantive changes made in
last version, but kept some changes in the formatting and the
debugging and error output, and made some new ones.
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=

Int_Void_Ptr
Scan_Parse::assign_picture_simple(Scanner_Node scanner_node,
                                  Id_Map_Entry_Node entry,
                                  Id_Map_Entry_Node entry_0)

{


@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  using namespace Scan_Parse;

@q ***** (5).@>

   Int_Void_Ptr ivp;

#if DEBUG_COMPILE
   if (DEBUG) 
      {
         cerr_strm << thread_name 
                   << "Entering `Scan_Parse::assign_picture_simple()'.";
 
         log_message(cerr_strm); 
         cerr_message(cerr_strm); 
         cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@; 

   Picture* s;
   Picture* t;

   int status;


@q ***** (5) Error handling for the case that |entry == 0|.@> 
@ Error handling for the case that |entry == 0|.
\initials{LDF 2004.08.08.}

@<Define |Scan_Parse| functions@>=

   if (entry == static_cast<Id_Map_Entry_Node>(0)) 
       { 
           cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                     << endl << "`entry' == 0. Not performing assignment."
                     << endl 
                     << "Exiting function and returning `int' value 1 "
                     << "and `void*' value 0.";
      
        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str("");

        ivp.i = 1;
        ivp.v = static_cast<void*>(0);
        
        return ivp;

    } /* |if (entry == 0)|  */


@q ***** (5) Error handling for the case that |entry_0 == 0|.@> 
@ Error handling for the case that |entry_0 == 0|.
\initials{LDF 2004.08.08.}

@<Define |Scan_Parse| functions@>=

   if (entry_0 == static_cast<Id_Map_Entry_Node>(0)) 
       { 
           cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                     << endl << "`Picture* p' == 0. Not performing assignment."
                     << endl 
                     << "Exiting function and returning `int' value 1 "
                     << "and `void*' value 0.";
      
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

        ivp.i = 1;
        ivp.v = static_cast<void*>(0);
        
        return ivp;

    } /* |if (entry_0 == 0)|  */

             

@q ***** (5) Try to lock |entry->mutex|.@> 
@ Try to lock |entry->mutex|.
\initials{LDF 2004.08.08.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Scan_Parse::assign_picture_simple()':"
                   << endl << "Trying to lock `entry->mutex'.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm); 
         cerr_strm.str(""); 
      }
#endif /* |DEBUG_COMPILE|  */@; 

   status = entry->lock();

   if (status != 0)
      {
           cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                     << endl 
                     << "`entry->lock' failed. Not performing assignment."
                     << endl 
                     << "Exiting function and returning `int' value 1 "
                     << "and `void*' value 0.";
      
           log_message(cerr_strm);
           cerr_message(cerr_strm, error_stop_value);
           cerr_strm.str("");

           ivp.i = 1;
           ivp.v = static_cast<void*>(0);
        
           return ivp;

      } /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG) /* (|status == 0|)  */
      {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::assign_picture_simple()':"
                    << endl << "`entry->lock()' succeeded.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 

      }    /* |else if (DEBUG)| (|status == 0|)  */

#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Allocate memory for |entry->object|, if necessary.@> 
@ Allocate memory for |entry->object|, if necessary.
\initials{LDF 2004.08.08.}

@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG) 
    {
      
      cerr_strm << thread_name << "In `Scan_Parse::assign_picture_simple()':"
                << endl << "entry->name == " << entry->name << "." << endl;

      if (entry->object == static_cast<void*>(0))
        cerr_strm << "entry->object == 0. Allocating new `picture'.";
      else
        cerr_strm << "entry->object != 0. Not allocating new `picture'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


  if (entry->object == static_cast<void*>(0))
    entry->object = static_cast<void*>(new(Picture));

@q ***** (5) Try to lock |entry_0->mutex|.@> 
@ Try to lock |entry_0->mutex|.
If it fails, try to unlock |entry->mutex|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
#if DEBUG_COMPILE
   if (DEBUG)
      {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::assign_picture_simple()':"
                    << endl 
                    << "Trying to lock `entry_0->mutex'.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry_0->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`entry_0->lock()' failed."
                << endl << "Will try to unlock `entry->mutex' and "
                << "exit function returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      status = entry->unlock();

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
  else if (DEBUG) 
    {
        cerr_strm << thread_name 
                << "In `Scan_Parse::assign_picture_simple()':"
                << endl << "`entry_0->lock()' succeeded.";

        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

  s = static_cast<Picture*>(entry_0->object);
  t = static_cast<Picture*>(entry->object);



@q ***** (5) Try to lock |s->mutex| and |t->mutex|.@> 
@ Try to lock |s->mutex| and |t->mutex|.
If either attempt fails, try to unlock the mutexes we've already locked.
\initials{LDF 2004.06.30.}

@q ****** (6) |s->mutex|.@> 

|s->mutex|.
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
  status = s->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`s->lock()' failed."
                << endl << "Will try to unlock `entry->mutex' "
                << "and `entry_0->mutex' and exit function "
                << "returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      entry->unlock();
      entry_0->unlock();
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
  else if (DEBUG) 
    {
      cerr_strm << thread_name 
                << "In `Scan_Parse::assign_picture_simple()':"
                << endl << "`s->lock()' succeeded.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****** (6) |t->mutex|.@> 
@ |t->mutex|.
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
  status = t->lock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`t->lock()' failed."
                << endl << "Will try to unlock `entry->mutex', "
                << "`entry_0->mutex', and `s->mutex' and exit function "
                << "returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");


      entry->unlock();
      entry_0->unlock();
      s->unlock();
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
  else if (DEBUG) 
    {
      cerr_strm << thread_name 
                << "In `Scan_Parse::assign_picture_simple()':"
                << endl << "`t->lock()' succeeded.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");
    }
#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ***** (5) Perform assignment and set |entry->known_state| and |ivp|.@> 
@ Perform assignment and set |entry->known_state| and |ivp|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

  *t = *s;

   entry->known_state = Id_Map_Entry_Type::KNOWN;
   
   ivp.v = static_cast<void*>(entry);

   ivp.i = 0;

@q ***** (5) Unlock mutexes in reverse order.@>
@ Unlock mutexes in reverse order.
If any attempt fails, try to unlock the mutexes that are still locked.
\initials{LDF 2004.06.30.}

@q ****** (6) |t->unlock|.@>
|t->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = t->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`t->unlock()' failed."
                << endl << "Will try to unlock `s->mutex', " 
                << "`entry_0->mutex', and `entry->mutex' "
                << "and exit function "
                << "returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      entry_0->unlock();
      entry->unlock();
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;


    } /* |if (status != 0)| */

#endif 

@q ****** (6) |s->unlock|.@>
@ |s->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = s->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`s->unlock()' failed."
                << endl 
                << "Will try to unlock `entry_0->mutex' and `entry->mutex' "
                << "and exit function "
                << "returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      entry_0->unlock();
      entry->unlock();
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;


    } /* |if (status != 0)| */

#endif 
 
@q ****** (6) |entry_0->unlock|.@>
@ |entry_0->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry_0->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`entry_0->unlock()' failed."
                << endl << "Will try to unlock `entry->mutex' and "
                << "exit function "
                << "returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str("");

      entry->unlock();
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */
  
#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****** (6) |entry->unlock|.@>
@ |entry->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry->unlock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_simple()':"
                << endl << "`entry->unlock()' failed." << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;


    } /* |if (status != 0)| (|entry->unlock| failed.)  */ 
  
#if DEBUG_COMPILE
    else if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::assign_picture_simple()':"
                  << endl 
                  << "`entry->unlock()' succeeded.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 
#endif /* |HAVE_PTHREAD_H|  */@; 

@q ****** (6) Exit function.@>
@ Exit function.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

   return ivp;


} /* End of |Scan_Parse::assign_picture_simple| definition.  */



@q *** (3) |assign_picture_chained|.@>
@*2 {\bf assign\_picture\_chained}.     
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.13.}
Added this function.
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
Int_Void_Ptr
Scan_Parse::assign_picture_chained(Scanner_Node scanner_node,
                                   Id_Map_Entry_Node entry,
                                   Id_Map_Entry_Node entry_0)

{

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 


   stringstream cerr_strm;

   string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
                    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

   cerr_strm << thread_name 
             << "Entering `Scan_Parse::assign_picture_chained()'.";
 
   log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG) 
     cerr_message(cerr_strm); 
#endif /* |DEBUG_COMPILE|  */@; 

   cerr_strm.str(""); 

   Picture* s;
   Picture* t;

   int status;



@q ***** (5) Error handling for the case that |entry == 0|.  @>
@ Error handling for the case that |entry == 0|.
@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl 
                << "`entry' == 0. "
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;
      
    } /* |if (entry == 0)|  */

@q ***** (5) Create new |Picture| for |entry->object|, if necessary.@>   
@ Create new |Picture| for |entry->object|, if necessary.
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG) 
    {
      
      cerr_strm << thread_name << "In `Scan_Parse::assign_picture_chained()':"
                << endl 
                <<  "entry->name == " << entry->name << endl;

      if (entry->object == static_cast<void*>(0))
        cerr_strm << "entry->object == 0. Creating new `Picture'.";
      else
        cerr_strm << "entry->object != 0. Not creating new `Picture'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 

    } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


  if (entry->object == static_cast<void*>(0))
    entry->object = static_cast<void*>(new(Picture));

  s = static_cast<Picture*>(entry->object); 

  t = static_cast<Picture*>(entry_0->object);
  
@q ***** (6) Error handling for the case that |t == 0|.  @>
@ Error handling for the case that |t == 0|.

@<Define |Scan_Parse| functions@>=

  if (t == static_cast<Picture*>(0))
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl
                << "`t' == 0. Not performing assignment."
                << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (t == 0)|  */


@q ***** (5) Try to lock mutexes.@>   
@ Try to lock mutexes.
\initials{LDF 2004.06.30.}

@q ****** (6) |entry|.@>   
@ |entry|.
\initials{LDF 2004.08.13.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry->lock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl
                << "`entry->lock()' failed." << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";


      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |entry->lock| failed.  */ 
  
#if DEBUG_COMPILE

    else if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::assign_picture_chained()':"
                  << "`entry->lock()' succeeded.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 

      } /* |else if (DEBUG)| (|entry->lock| succeeded)  */ 

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ****** (6) |entry_0|.@> 
@ |entry_0|.
If locking fails, try to unlock |entry->mutex|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << "Trying to lock `entry_0->mutex'.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm);
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry_0->lock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl
                << "`entry_0->lock()' failed. "
                << endl << "Will try to unlock `entry->mutex' "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      entry->unlock();

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
  else if (DEBUG) 
    {
      cerr_strm << thread_name 
                << "In `Scan_Parse::assign_picture_chained()':"
                << endl
                << "`entry_0->lock()' succeeded.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 

    } /* |else if (DEBUG)| (|entry_0->lock| succeeded)  */

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ****** (6) |s->mutex| and |t->mutex|.@> 
@ |s->mutex| and |t->mutex|.
If either attempt fails, try to unlock the mutexes we've already locked.
\initials{LDF 2004.06.30.}

@q ******* (7) |s->mutex|.@> 

|s->mutex|.
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
  status = s->lock();

  if (status != 0)
    {
      cerr_strm << thread_name
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`s->lock()' failed."
                << endl << "Will try to unlock `entry->mutex' "
                << "and `entry_0->mutex' "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      entry->unlock();
      entry_0->unlock();

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
  else if (DEBUG) 
    {


      cerr_strm << thread_name 
                << "In `Scan_Parse::assign_picture_chained()':"
                << endl  
                << "`s->lock()' succeeded.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 

    } /* |else if (DEBUG)| (|s->lock| succeeded)  */

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 

@q ******* (7) |t->mutex|.@> 
@ |t->mutex|.
@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  
  status = t->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`t->lock()' failed."
                << endl << "Will try to unlock `entry->mutex', "
                << "`entry_0->mutex', and `s->mutex' "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";

      entry->unlock();
      entry_0->unlock();
      s->unlock();
      
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#if DEBUG_COMPILE
   else if (DEBUG) 
     { 
       cerr_strm << thread_name 
                 << "In `Scan_Parse::assign_picture_chained()':"  
                 << endl  
                 << "`t->lock()' succeeded."; 

       log_message(cerr_strm);  
       cerr_message(cerr_strm); 
       cerr_strm.str("");  

     } /* |else if (DEBUG)| (|t->lock|  succeeded)  */ 

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ***** (5) Perform assignment, set |entry->known_state|, and set value of rule.@> 
@ Perform assignment, set |entry->known_state|, and set value of rule.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

  *s = *t;
   entry->known_state = Id_Map_Entry_Type::KNOWN;

   ivp.i = 0;
   ivp.v = entry;

@q ***** (5) Unlock mutexes in reverse order.@>
@ Unlock mutexes in reverse order.
If any attempt fails, try to unlock the mutexes that are still locked.
\initials{LDF 2004.06.30.}

@q ******* (7) |t->unlock|.@>
|t->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = t->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`t->unlock()' failed."
                << endl << "Will try to unlock `s->mutex', "
                << "`entry_0->mutex', and `entry->mutex', "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";

      s->unlock();
      entry_0->unlock();
      entry->unlock();

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */

#endif 

@q ******* (7) |s->unlock|.@>
@ |s->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = s->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`s->unlock()' failed."
                << endl 
                << "Will try to unlock `entry_0->mutex' and `entry->mutex' "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";


      entry_0->unlock();
      entry->unlock();
      
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;
      
    } /* |if (status != 0)| */

#endif 

@q ******* (7) |entry_0->unlock|.@>
@ |entry_0->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry_0->unlock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`entry_0->unlock()' failed."
                << endl << "Will try to unlock `entry->mutex' "
                << "and exit function returning `int' value 1 "
                << "and `void*' value 0.";

      entry->unlock();
      
      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */
  
#endif /* |HAVE_PTHREAD_H|  */@; 

@q ******* (7) |entry->unlock|.@>
@ |entry->unlock|.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=


#ifdef HAVE_PTHREAD_H  

  status = entry->unlock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::assign_picture_chained()':"
                << endl << "`entry->unlock()' failed."
                << endl << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (status != 0)| */
  
#endif /* |HAVE_PTHREAD_H|  */@; 



@q ***** (5) Exit rule.@>
@ Exit rule.
\initials{LDF 2004.06.30.}

@<Define |Scan_Parse| functions@>=

  return ivp;

}



@q *** (3) |assign_point_numeric|.@>
@*2 {\bf assign\_point\_numeric}.     
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.13.}
Added this function.
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
Int_Void_Ptr
Scan_Parse::assign_point_numeric(Scanner_Node scanner_node,
                     Id_Map_Entry_Node entry,
                     real x)
{

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
                    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

   cerr_strm << thread_name 
             << "Entering `Scan_Parse::assign_point_numeric()'.";
 
   log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG) 
     cerr_message(cerr_strm); 
#endif /* |DEBUG_COMPILE|  */@; 

   cerr_strm.str(""); 

   int status;


@q ***** (5)  Error handling for the case that |entry == 0|.  @>
@ Error handling for the case that |entry == 0|.  
\initials{LDF 2004.05.05.}
@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "ERROR! In `assign_point_numeric()':"
                << endl
                << "entry == 0. "
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |if (entry == 0)|  */



@q ***** (5)  Create new |Point| if |entry->object == 0|.  @>
@ Create new |Point| if |entry->object == 0|.
\initials{LDF 2004.05.05.}
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG) 
    {
      

      cerr_strm << thread_name << "In `assign_point_numeric()':"
                << endl
                << "entry->name == " << entry->name << "." 
                << endl;

      if (entry->object == static_cast<void*>(0))
        cerr_strm << "entry->object == 0. Allocating new `Point'.";
      else
        cerr_strm << "entry->object != 0. Not allocating new `Point'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 


  if (entry->object == static_cast<void*>(0))
    entry->object = static_cast<void*>(create_new<Point>(0));


@q ***** (5)  Look up |curr_y| and |curr_z|.  @>
@  Look up |curr_y| and |curr_z|.
\initials{LDF 2004.05.05.}
@<Define |Scan_Parse| functions@>=

  Point* r = static_cast<Point*>(entry->object); 

  real y;
  real z; 

  Id_Map_Entry_Node y_entry = scanner_node->lookup("curr_y");
  Id_Map_Entry_Node z_entry = scanner_node->lookup("curr_z");

  if (y_entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name << "WARNING! In `assign_point_numeric()':"
                << endl << "`curr_y' not found. "
                << "Using 0 instead."
                << endl;

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      y = 0;

    } /* |if (y_entry == 0)| */@;
  
  else /* |y_entry != 0| */

    y = *static_cast<real*>(y_entry->object);

@q ***** (5)  Look up |curr_z|.  @>
@  Look up |curr_z|.
\initials{LDF 2004.05.05.}
@<Define |Scan_Parse| functions@>=

  if (z_entry == static_cast<Id_Map_Entry_Node>(0))
    {

      cerr_strm << thread_name << "WARNING! In `assign_point_numeric()':"
                << endl
                << "`curr_z' not found. Using 0 instead.";



      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      z = 0;

    } /* |if (z_entry == 0)| */@;
  
  else /* |z_entry != 0| */
    z = *static_cast<real*>(z_entry->object);


@q ***** (5)  Set |entry->object| and exit rule.  @>
@ Set |entry->object| and exit rule.
\initials{LDF 2004.05.05.}
@<Define |Scan_Parse| functions@>=

  r->set(x, y, z);

   entry->known_state = Id_Map_Entry_Type::KNOWN;

   ivp.i = 0;
   ivp.v = entry->object;

   return ivp;

} /* End of |Scan_Parse::assign_point_numeric| definition.  */






@q *** (3) |log_message|.@>
@*3 {\bf log\_message}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.07.21.}
Added this function.

\initials{LDF 2004.07.22.}
Removed |Thread_Info_Type* thread_info| argument.  Now calling 
|Thread_Info_Type::get_thread_info| instead.
A bug fix in the latter function made this work.

@:??@> ??
Removed default for the |bool| argument to |log_message|.
It's now in the declaration in \filename{pspglb.web}.  Having it here too caused
a compilation error.  I don't know why.
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
int 
Scan_Parse::log_message(stringstream& s, bool do_endl)

{
  
  Thread_Info_Type* thread_info = Thread_Info_Type::get_thread_info();

  if (thread_info != static_cast<Thread_Info_Type*>(0))
    {
      thread_info->log_stream << s.str();
      if (do_endl)
        thread_info->log_stream << endl;
      thread_info->log_stream << flush;
      return 0;
    }
  
  else
    return 1;
}

@q *** (3) |set_color|.@>
@*3 {\bf set\_color}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.14.}
Added this function.  It's used in the parser rule
\set command> $\longrightarrow$ \.{SET} \color variable> 
etc., in \filename{pcommand.w}.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
Int_Void_Ptr
Scan_Parse::set_color(Scanner_Node scanner_node,
                      Id_Map_Entry_Node entry,
                      real red_part,
                      real green_part,
                      real blue_part)

{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

   cerr_strm << thread_name 
             << "Entering `Scan_Parse::set_color()'.";
 
   log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG) 
     cerr_message(cerr_strm); 
#endif /* |DEBUG_COMPILE|  */@; 

   cerr_strm.str(""); 

  int status;
  


@q ***** (5) Error handling for the case that |entry == 0|.@>
@ Error handling for the case that |entry == 0|.
\initials{LDF 2004.06.30.}
@<Define |Scan_Parse| functions@>=


  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_color()':"
                << endl << "`entry == 0'.  Not setting `color_variable'."
                << endl  
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;
      
    } /* |if (entry == 0)|  */

@q ***** (5) Try to lock |entry->mutex|.@>   
@ Try to lock |entry->mutex|.
\initials{LDF 2004.08.14.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry->lock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_color()':"
                << endl
                << "`entry->lock()' failed." << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |entry->lock| failed.  */ 
  
#if DEBUG_COMPILE

    else if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::set_color()':"
                  << "`entry->lock()' succeeded.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 

      } /* |else if (DEBUG)| (|entry->lock| succeeded)  */ 

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 




@q ****** (6) Allocate memory for a new |Color|, if |entry->object == 0|.@>
@ Allocate memory for a new |Color|, if |entry->object == 0|.
\initials{LDF 2004.06.30.}

\LOG
\initials{LDF 2005.05.12.}
@:BUG FIX@> BUG FIX:  Added the assignment
|c = static_cast<Color*>(entry->object)| for the case that
|entry->object != 0|.
\ENDLOG 

@<Define |Scan_Parse| functions@>=

  Color* c;

  if (entry->object == static_cast<void*>(0))
    {
      c = create_new<Color>(0);
      entry->object = static_cast<void*>(c); 
    }

  else
    {
       c = static_cast<Color*>(entry->object); 
    }


  c->set(red_part, green_part, blue_part);

  entry->known_state = Id_Map_Entry_Type::KNOWN;

@q ***** (5) Try to unlock |entry->mutex|.@>   
@ Try to unlock |entry->mutex|.
\initials{LDF 2004.08.14.}

@<Define |Scan_Parse| functions@>=

#ifdef HAVE_PTHREAD_H  

  status = entry->unlock();

  if (status != 0)
    {

      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_color()':"
                << endl
                << "`entry->unlock()' failed." << endl
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    } /* |entry->unlock| failed.  */ 
  
#if DEBUG_COMPILE

    else if (DEBUG) 
      {
        cerr_strm << thread_name 
                  << "In `Scan_Parse::set_color()':"
                  << "`entry->unlock()' succeeded.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 

      } /* |else if (DEBUG)| (|entry->unlock| succeeded)  */ 

#endif /* |DEBUG_COMPILE|  */@; 

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ***** (5) Exit |Scan_Parse::set_color| successfully.@>   
@ Exit |Scan_Parse::set_color| successfully.
\initials{LDF 2004.08.14.}

@<Define |Scan_Parse| functions@>=
  
  ivp.v = static_cast<void*>(entry); 
  ivp.i = 0;

  return ivp;

} /* End of |Scan_Parse::set_color| definition.  */



@q *** (3) |set_focus|.@>
@*3 {\bf set\_focus}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.14.}
Added this function.  It's used in the parser rule
\set command> $\longrightarrow$ \.{SET} \focus variable> 
etc., in \filename{pcommand.w}.


\initials{LDF 2004.08.14.}
Added the |const int| arguments |x_axis|, |y_axis|, and |z_axis|. 
This makes it possible to leave the
definition in this file (\filename{scanprse.web}).  The values passed are 
|X_AXIS|, |Y_AXIS|, and |Z_AXIS|, which are
terminal symbols declared in \filename{pbsndecl.w}, and therefore unknown when  
this file is compiled.

\initials{LDF 2004.08.16.}
Finished coding this function.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
Int_Void_Ptr
 Scan_Parse::set_focus(Scanner_Node scanner_node,
                       Id_Map_Entry_Node entry,
                       Point* position,
                       Point* direction,
                       real distance,
                       real angle,
                       int axis,
                       const int x_axis,
                       const int y_axis,
                       const int z_axis)

{

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

   cerr_strm << thread_name 
             << "Entering `Scan_Parse::set_focus()'.";
 
   log_message(cerr_strm); 

#if DEBUG_COMPILE
   if (DEBUG) 
     cerr_message(cerr_strm); 
#endif /* |DEBUG_COMPILE|  */@; 

   cerr_strm.str(""); 

  int status;


@q ***** (5) Error handling for the case that |entry == 0|.@>
@ Error handling for the case that |entry == 0|.
\initials{LDF 2004.08.14.}
@<Define |Scan_Parse| functions@>=

  if (entry == static_cast<Id_Map_Entry_Node>(0))
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_focus()':"
                << endl << "`entry == 0'.  Not setting `focus_variable'."
                << endl  
                << "Exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 

      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;
      
    } /* |if (entry == 0)|  */

@q ***** (5) @>
@ 
@<Define |Scan_Parse| functions@>=

  Focus* f = static_cast<Focus*>(entry->object); 

@q ***** (5) Try to lock |entry->mutex|.@>
@ Try to lock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.08.14.}
@<Define |Scan_Parse| functions@>=
 
#ifdef HAVE_PTHREAD_H  

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "In `Scan_Parse::set_focus()':"
                << endl << "About to call `entry->lock()'.";
      log_message(cerr_strm); 
      cerr_message(cerr_strm); 
      cerr_strm.str(""); 
    }
#endif /* |DEBUG_COMPILE|  */@; 

  status = entry->lock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_focus()':"
                << endl << "`entry->lock()' failed. "
                << "Not setting `focus_variable', "
                << "exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;

    }   /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
     {
       cerr_strm << thread_name << "In `Scan_Parse::set_focus()':"
                 << endl << "`entry->lock()' succeeded.";
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 



#endif /* |HAVE_PTHREAD_H|  */@; 


@q ***** (5) Allocate memory for new |Focus|, if necessary.@>  
@ Allocate memory for new |Focus|, if necessary.
\initials{LDF 2004.08.14.}

@<Define |Scan_Parse| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG) 
     {
      
        cerr_strm << thread_name << "In `Scan_Parse::set_focus()':"
                  << endl
                  << "entry->name == " << entry->name << endl;

        if (entry->object == static_cast<void*>(0))
           cerr_strm << "entry->object == 0. Allocating new `focus'.";
        else
           cerr_strm << "entry->object != 0. Not allocating new `focus'.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 

    } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

  if (entry->object == static_cast<void*>(0))
    entry->object = static_cast<void*>(create_new<Focus>(0));

  f = static_cast<Focus*>(entry->object); 

@q ***** (5) Allocate memory for new |Focus|, if necessary.@>  
@ Allocate memory for new |Focus|, if necessary.
\initials{LDF 2004.08.14.}

@<Define |Scan_Parse| functions@>= 

#if DEBUG_COMPILE
   if (DEBUG)
      {
        cerr_mutex.lock();
        cerr << thread_name << "In `Scan_Parse::set_focus()':" 
             << endl;
        position->show("position:");
        direction->show("direction:");
        cerr << "distance == " << distance << endl
             << "angle == " << angle << endl;

        if (axis == x_axis)
          cerr << "axis == " << "X_AXIS" << endl;

        else if (axis == y_axis)
          cerr << "axis == " << "Y_AXIS" << endl;

        else if (axis == z_axis)
          cerr << "axis == " << "Z_AXIS" << endl;

        else 
          cerr << "Invalid value for `axis'." << endl;

        cerr_mutex.unlock();

      } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;   

@q ***** (5) Test value of |axis|.@>   
@ Test value of |axis|.
 It's most likely that |axis == Z_AXIS|, so we test this case first.
\initials{LDF 2004.06.08.}
@<Define |Scan_Parse| functions@>= 

  if (axis == z_axis)
     axis = 'z';
  else if (axis == x_axis)
     axis = 'x';
  else if (axis == y_axis)
     axis = 'y';

@q ****** (6) Error handling for the case that |axis| has an invalid value.@>  
@  Error handling for the case that |axis| has an invalid value.
\initials{LDF 2004.06.08.}
@<Define |Scan_Parse| functions@>= 

  else /* |axis| has invalid value.  */
     {
       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::set_focus()':"
                 << endl << "Invalid value for `with_axis_optional': "
                 << axis << endl 
                 << "Setting `axis' to 'z' and will try to continue.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value); 
       cerr_strm.str(""); 
       
       axis = 'z';

     }  /* |else|  (|axis| has invalid value.)  */


@q ****** (6) Set |Focus|.@>  
@ Set |Focus|.
@<Define |Scan_Parse| functions@>= 

  f->set(*position, *direction, distance, angle, axis);

  entry->known_state = Id_Map_Entry_Type::KNOWN;

  ivp.v = entry->object; 
  ivp.i = 0;


  
@q ****** (6) Try to unlock |entry->mutex|.@>
@ Try to unlock |entry->mutex|.  Exit function upon failure.
\initials{LDF 2004.06.24.}
@<Define |Scan_Parse| functions@>= 


#ifdef HAVE_PTHREAD_H  
  status = entry->unlock();

  if (status != 0)
    {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::set_focus()':"
                << endl << "`entry->unlock()' failed. "
                << endl 
                << "Not setting `focus_variable', "
                << "exiting function and returning `int' value 1 "
                << "and `void*' value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm, error_stop_value); 
      cerr_strm.str(""); 
      
      ivp.i = 1;
      ivp.v = static_cast<void*>(0);
      
      return ivp;
 
    }   /* |if (status != 0)|  */

#endif /* |HAVE_PTHREAD_H|  */@; 


@q ****** (6) Exit function successfully.@>
@ Exit function successfully.
\initials{LDF 2004.06.24.}
@<Define |Scan_Parse| functions@>= 

  return ivp;

} /* End of |Scan_Parse::set_focus| definition.  */


@q *** (3) |on_picture_optional_0|.@>
@*3 {\bf on\_picture\_optional\_0}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.08.17.}
Added this function.  It's used in the parser rule
|@=on_picture_optional: /* Empty */@>| in \filename{pcommand.w}.  
\ENDLOG 

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| functions@>=
void*
Scan_Parse::on_picture_optional_0(Scanner_Node scanner_node)
{
#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  string thread_name = "";

  bool error_stop_value = (scanner_node->run_state.error_stop_mode == Run_State::STOPPING)
    ? true : false;

#ifdef HAVE_PTHREAD_H  
  Thread_Info_Type* thread_info;
  if (   scanner_node->run_state.multithread_input 
      || scanner_node->run_state.multithread_output
      || scanner_node->run_state.multithread_include)
    {
      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = thread_info->name;
    }
  else
    {
      thread_info = 0;
      thread_name = "";
    }
#endif /* |HAVE_PTHREAD_H|  */@; 

   Int_Void_Ptr ivp;

#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_strm << thread_name 
                 << "Entering `Scan_Parse::on_picture_optional_0()'.";
       
       log_message(cerr_strm); 
       cerr_message(cerr_strm); 
       cerr_strm.str(""); 
     }
#endif /* |DEBUG_COMPILE|  */@; 

  Picture* picture_ptr;

  Id_Map_Entry_Node entry = scanner_node->lookup("current_picture");

@q ***** (5) Error handling for the case that     @>
@q ***** (5) |entry == 0 || entry->object == 0|.  @>
@ Error handling for the case that 
|entry == 0 || entry->object == 0|.
\initials{LDF 2004.06.21.}

@<Define |Scan_Parse| functions@>=

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
      {

        cerr_strm << thread_name 
                  << "ERROR! In `Scan_Parse::on_picture_optional_0():"
                  << endl << "`current_picture' doesn't seem to exist."
                  << endl << "Exiting function with return value "
                  << "`static_cast<void*>(0)'.";


        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value); 
        cerr_strm.str(""); 
        
        return static_cast<void*>(0); 

      } /* |if (entry == 0)|  */@;

@q ***** (5) Success!  |current_picture| exists.  @>
@ Success!  |current_picture| exists.
\initials{LDF 2004.06.21.}
@<Define |Scan_Parse| functions@>=

  else
    {



#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::on_picture_optional_0():"
                    << endl << "Success! `current_picture' exists."
                    << endl << "Returning `static_cast<void*>(entry)'.";
        
        log_message(cerr_strm); 
        cerr_message(cerr_strm); 
        cerr_strm.str(""); 
        
      }
#endif /* |DEBUG_COMPILE|  */@; 

      return static_cast<void*>(entry);

    } /* |else| (|current_picture| exists).  */

} /* End of |Scan_Parse::on_picture_optional_0| definition.  */


@q *** (3) |vector_type_decl|.@>
@*2 {\bf vector\_type\_decl}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

It is used in the parser rule
``\color vector declaration> $\longrightarrow$ 
\.{COLOR\_DECLARATOR} \declaration list>'' in 
\filename{pldfdcl.w}.
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.24.}
Added this function.

\initials{LDF 2004.08.24.}
Changed this function to a non-template function and 
changed its arguments.  

\initials{LDF 2004.08.25.}
Made this function a template function again
and added the argument |C* dummy|, which defaults to 0.

\initials{LDF 2004.08.25.}
Added the |const bools| |not_const|, |is_array|, and |not_array| for use in 
calls to |Scanner_Type::add_entry|.

\initials{LDF 2004.08.27.}
Changed the behavior of this function works when |vector_entry| and/or
|array_entry| already exists.  Now, warnings are issued, but 
execution continues and the old entries are destroyed.

\initials{LDF 2004.08.28.}
Now passing |scanner_node| as an argument in calls to 
|Scanner_Type::add_entry|.

\initials{LDF 2004.08.29.}
Removed the  |Scanner_Node| argument in all but one call to 
|Scanner_Type::add_entry|.  In that call, I moved it.

\initials{LDF 2004.12.28.}
Now using the character octal 243 (British Pound) as the placeholder
for subscripts rather than \.{-}.
\ENDLOG

@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=
template <class C>
int 
Scan_Parse::vector_type_decl(Scanner_Node scanner_node,
                             int vector_type_num,
                             int array_type_num,
                             C* dummy = 0)
{


#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */@; 
#endif /* |DEBUG_COMPILE|  */@; 

   bool error_stop_value;

   error_stop_value = (scanner_node->get_run_state()->error_stop_mode
                    == Run_State::STOPPING) 
                ? true : false;
   
@q ***** (5) Get thread information.@>   

@ Get thread information.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

  string thread_name;
  
#ifdef HAVE_PTHREAD_H  

  Thread_Info_Type* thread_info;

  if (scanner_node->get_run_state()->multithread_input 
          || scanner_node->get_run_state()->multithread_output) 
     
     /* Using threads.  */

    {

      thread_info = Thread_Info_Type::get_thread_info();
      thread_name = Thread_Info_Type::get_thread_name(thread_info);

    } /* |if| (using threads).  */

  else /* Not using threads.  */
    
    {
      thread_info = 0;
      thread_name = "";

    } /* |if| (not using threads.)  */

#else /* |HAVE_PTHREAD_H| is undefined.  */@; 
  
  thread_name = "";

#endif /* |HAVE_PTHREAD_H|  is undefined.  */@; 

  stringstream cerr_strm;

  int status;

@q ***** (5).@>   
@ 

\LOG
\initials{LDF 2004.08.25.}
Added |bool declaration_succeeded = false|.  It's set to |true| if a declaration 
succeeds.  If any declarations succeed, and no errors cause this function 
to return prematurely, it returns 0.  Otherwise, it returns 1.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=



#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::vector_type_decl()'.";

      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


  bool declaration_succeeded = false;

  const bool not_const = false;

  const bool is_array  = true;
  const bool not_array = false;



@q ***** (5) Cycle through |scanner_node->token_string_bool_vector|.@>   

@ Cycle through |scanner_node->token_string_bool_vector|.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=



#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name << "`Scan_Parse::vector_type_decl()':"
                << endl 
                << "   Showing `scanner_node->token_string_bool_vector':";

      cerr_message(cerr_strm);
      cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */



{ /* Begin group.  */

  int i = 0;
  
  bool used_array_syntax = false;

  string array_name;
  string vector_name;

  for (vector<String_Bool>::const_iterator iter
         = scanner_node->token_string_bool_vector.begin();
       iter != scanner_node->token_string_bool_vector.end();
       ++iter)
    {

#if DEBUG_COMPILE

      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::vector_type_decl()':"
                    << endl
                    << "   token_string_bool_vector[" << i << "] == "
                    << iter->first << ", " << iter->second << ".";
          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
        } /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@;



@q ****** (6) It's an array declaration.@>   

@ It's an array declaration.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

  if (iter->second) /* It's an array declaration.  */
    {
#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::vector_type_decl()':"
                    << endl
                    << "   It's an array.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@;




   int j = 0;


   string::const_iterator last_iter;

   for (string::const_iterator s_iter = iter->first.begin();
        s_iter != iter->first.end();
        s_iter++)
      {

        if (*s_iter == '')
           {
               ++j;
               last_iter = s_iter;
           
           } /* |if|  */

      } /* |for|  */   


#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr_strm << thread_name 
                    << "In `Scan_Parse::vector_type_decl()':"
                    << endl
                    << "j == " << j << ".";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
     }
#endif /* |DEBUG_COMPILE|  */@; 



  
@q ******* (7) Error handling for the case that it's an array of @>
@q ******* (7) degree $> 1$.                                     @>   

@ Error handling for the case that it's an array of degree $> 1$.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

   if (j > 1)
      {

          cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::vector_type_decl()':"
                     << endl
                     << iter->first << " is an array of degree " 
                     << j << "." << endl
                     << "Vector type declarations can't handle array " 
                     << "declarations of degree > 1."
                     << endl
                     << "Ignoring and continuing.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          ++i;
          continue;

      } /* |if (j > 1)|  */



@q ******* (7) It's an array of degree 1.@>   

@ It's an array of degree 1.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


#if DEBUG_COMPILE
   if (DEBUG)
      {
         cerr_strm << thread_name 
                   << "In `Scan_Parse::vector_type_decl()':"
                   << endl
                   << iter->first << " is an array of degree 1.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm);
         cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

@q ******** (7) Error handling for the case          @>   
@q ******** (7) that the subscript is not at the end.@>   

@ Error handling for the case that the subscript is not 
at the end.   
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


   if (last_iter != iter->first.end() - 1)
      {
         cerr_strm << thread_name 
                   << "ERROR! In `Scan_Parse::vector_type_decl()':"
                   << endl
                   << "The subscript in " << iter->first 
                   << " is not at the end.  Can't handle this case."
                   << endl 
                   << "Ignoring and continuing.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");        

         ++i;
         continue;

      } /* |if (s_iter != iter->first.end() - 1)|  */



#if DEBUG_COMPILE
   else if (DEBUG)
     {
         cerr_strm << thread_name 
                   << "In `Scan_Parse::vector_type_decl()':"
                   << endl
                   << "The subscript in " << iter->first 
                   << " is at the end.";

         log_message(cerr_strm); 
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");        
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
   used_array_syntax = true;

   array_name = iter->first;
   vector_name = array_name;

   vector_name.erase(vector_name.end() - 1);




@q ******* (7) End of ``array declaration'' case.@>   

@ End of ``array declaration'' case.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


    } /* |if (iter->second)| 
         (it's an array declaration).  */


@q ****** (6) It's not an array declaration.@>   

@ It's not an array declaration.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


  else /* (|!iter->second| XXX it's not an array declaration.)  */
    {

#if DEBUG_COMPILE
      if (DEBUG)
        {
          cerr_strm << thread_name << "In `Scan_Parse::vector_type_decl()':"
                    << endl
                    << "   It's not an array.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
        }
#endif /* |DEBUG_COMPILE|  */@; 

      used_array_syntax = false;

      vector_name = array_name = iter->first;
      array_name += "";
 
    } /* |else| (|!iter->second|---it's 
                 not an array declaration.)  */




@q ****** (6) Check for existing variables.@>   

@ Check for existing variables.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


#if DEBUG_COMPILE
         if (DEBUG)
            {
               cerr_strm << thread_name 
                         << "In `Scan_Parse::vector_type_decl()':"
                         << endl
                         << "`array_name' == " << array_name
                         << endl
                         << "`vector_name' == " << vector_name << ".";

               log_message(cerr_strm); 
               cerr_message(cerr_strm, error_stop_value);
               cerr_strm.str("");
            }
#endif /* |DEBUG_COMPILE|  */@; 


   Id_Map_Entry_Node vector_entry = scanner_node->lookup(vector_name);

   Id_Map_Entry_Node array_entry = scanner_node->lookup(array_name);



@q ******* (7) Check |vector_entry|, issue a warning if it exists, @>   
@q ******* (7) and continue.@>   

@ Check |vector_entry|, issue a warning if it exists, 
and continue.
\initials{LDF 2004.08.27.}

@q ******** (8) |vector_entry| exists.@>   

@ |vector_entry| exists.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

   if (vector_entry != static_cast<Id_Map_Entry_Node>(0))
      {

        cerr_strm << thread_name 
                  << "WARNING! In `Scan_Parse::vector_type_decl()':"
                  << endl
                  << "Declaring `" << vector_name;

        if (used_array_syntax)
          cerr_strm << "[]";
        
        cerr_strm << "' will cause existing entry for `" << vector_name 
                  << "' to be destroyed.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

      } /* |if (vector_entry != 0)| */




@q ******** (8) |vector_entry| doesn't exist.@>   

@ |vector_entry| doesn't exist.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)  /* (|vector_entry == 0|) */
     {
                
       cerr_strm << thread_name 
                 << "In `Scan_Parse::vector_type_decl()':"
                 << endl 
                 << "Entry doesn't exist for `" << vector_name 
                 << "'.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

     } /* |else if (DEBUG)| (|vector_entry == 0|) */    

#endif /* |DEBUG_COMPILE|  */@; 



@q ******* (7) Check |array_entry|, issue a warning if it exists, @>   
@q ******* (7) and continue.@>   

@ Check |array_entry|, issue a warning if it exists, 
and continue.
\initials{LDF 2004.08.27.}

@q ******** (8) |array_entry| exists.@>   

@ |array_entry| exists.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

   if (array_entry != static_cast<Id_Map_Entry_Node>(0))
      {

        cerr_strm << thread_name 
                  << "WARNING! In `Scan_Parse::vector_type_decl()':"
                  << endl 
                  << "Declaring `" << vector_name;

        if (used_array_syntax)
          cerr_strm << "[]";

        
        cerr_strm << "' will cause existing entry for `" << vector_name 
                  << "[]' to be destroyed.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
 

      } /* |if (array_entry != 0)| */


@q ******** (8) |array_entry| doesn't exist.@>   

@ |array_entry| doesn't exist.
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.27.}
Now conditionally compiling this section.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE

   else if (DEBUG)  /* (|array_entry == 0|) */
     {
                
       cerr_strm << thread_name 
                 << "In `Scan_Parse::vector_type_decl()':"
                 << endl 
                 << "Entry doesn't exist for `" << array_name 
                 << "'.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

     }  /* |else if (DEBUG)| (|array_entry == 0|) */    

#endif /* |DEBUG_COMPILE|  */@;    




@q ****** (6) Try to create a new |Pointer_Vector<C>|.@>  
@q ****** (6) Rethrow |bad_alloc| upon error.         @>  

@ Try to create a new |Pointer_Vector<C>|.  
Rethrow |bad_alloc| upon error.
\initials{LDF 2004.12.10.}

\LOG
\initials{LDF 2004.08.25.}
Added this section.

\initials{LDF 2004.12.10.}
Now calling |new Pointer_Vector<C>| in a |try| block and 
catching |bad_alloc|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  Pointer_Vector<C>* curr_ptr;

  curr_ptr = new Pointer_Vector<C>;

@q ****** (6) Call |add_entry| for |array_entry|.@>  

@ Call |add_entry| for |array_entry|.
\initials{LDF 2004.08.24.}


\LOG
\initials{LDF 2006.10.08.}
@q { @>
@:Kludge}{{\bf Kludge}@>
@q } @> 
!! Kludge:  Now passing |(new Id_Map_Entry_Type)| to |Scanner_Type::add_entry| as its
``|left|'' argument.  This prevents the run-time system from issuing the following 
error message (or warning?) when a vector-type variable is declared, but no 
assignment to it ever takes place:
``{\tt \*\*\* glibc detected \*\*\* double free or corruption 
(fasttop): 0x08511b30 \*\*\*}''.
The condition that caused the message to be issued apparently didn't arise when
an assignment was made.

\initials{LDF 2006.10.08.}
According to something I read in a newsgroup, the problem may have something 
to do with the use of the Standard Template Library type |vector| 
in |Pointer_Vector|.
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
Find a better solution to this problem.
\ENDTODO 
\ENDLOG 

@<Define |Scan_Parse| template functions@>=


   array_entry = scanner_node->add_entry(array_name,
                                         array_type_num,
                                         Id_Map_Entry_Type::REGULAR,  
                                         not_const,
                                         is_array,
                                         Id_Map_Entry_Type::KNOWN,
                                         0,
                                         0,
                                         (new Id_Map_Entry_Type));

@q ******* (7) Error handling for the case that calling @>
@q ******* (7) |add_entry| to create |array_entry| failed.  @>
@ Error handling for the case that calling |add_entry| 
to create |array_entry| failed.  
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

      if (array_entry == static_cast<Id_Map_Entry_Node>(0))
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::vector_type_decl()':"
                    << endl 
                    << "Failed to create `array_entry'."
                    << endl << "Deleting `curr_ptr' and exiting function "
                    << "with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
          
          delete curr_ptr;

          return 1;

        } /* |if (array_entry == 0)|  */


@q ******* (7) Success! Calling |add_entry| for |array_entry| succeeded.@>  

@ Success! Calling |add_entry| for |array_entry| succeeded.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::vector_type_decl()':"
                 << endl 
                 << "Creating `array_entry' succeeded.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 
 



@q ****** (6) Call |add_entry| for |vector_entry|.@>  

@ Call |add_entry| for |vector_entry|.
\initials{LDF 2004.08.24.}

\LOG
Now passing |static_cast<void*>(curr_ptr)| as the |object| argument 
and |array_entry| as the |subordinate_array| argument to 
|Scanner_Type::add_entry|.

\initials{LDF 2004.12.10.}
No longer casting 0 arguments to 
|Id_Map_Entry_Node|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  vector_entry
    = scanner_node->add_entry(vector_name, 
                              vector_type_num, /* |type|  */
                              Id_Map_Entry_Type::REGULAR, /* |category|  */
                              not_const, 
                              not_array,
                              Id_Map_Entry_Type::KNOWN,
                              static_cast<void*>(curr_ptr),
                              0, /* |up|  */ 
                              0, /* |left|  */ 
                              0, /* |right|  */ 
                              0, /* |superordinate_vector|  */ 
                              array_entry /* |subordinate_array|  */
                              );

@q ******* (7) Error handling for the case that calling        @>
@q ******* (7) |add_entry| to create |vector_entry| failed.  @>

@ Error handling for the case that calling |add_entry| 
to create |vector_entry| failed.  
\initials{LDF 2004.08.24.}

\LOG
\initials{LDF 2004.08.25.}
Added a call to |scanner_node->erase_entry| with 
error handling if it fails.  
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

      if (vector_entry == static_cast<Id_Map_Entry_Node>(0))
        {

          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::vector_type_decl()':"
                    << endl 
                    << "Failed to create `vector_entry'."
                    << endl 
                    << "Deleting and erasing `array_entry' and "
                    << "exiting function with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");

          status = scanner_node->erase_entry(array_name);

@q ******** (8) Error handling for the case that      @>
@q ******** (8) |scanner_node->erase_entry| failed. @>

@ Error handling for the case that |scanner_node->erase_entry| 
failed. 
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=


          if (status != 0) /* |scanner_node->erase_entry| failed.  */
            {

              cerr_strm << thread_name 
                        << "ERROR! In `Scan_Parse::vector_type_decl()':"
                        << endl 
                        << "`scanner_node->erase_entry(" << array_name 
                        << ")' failed." << endl
                        << "Exiting function with return value 1.";

              log_message(cerr_strm); 
              cerr_message(cerr_strm, error_stop_value);
              cerr_strm.str("");
              
            }  /* |if (status != 0)| (|scanner_node->erase_entry| failed).  */

@q ******** (8) |scanner_node->erase_entry(array_name)| succeeded.@>

@ |scanner_node->erase_entry(array_name)| succeeded.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
          else if (DEBUG) /* (|status == 0|---|scanner_node->erase_entry(array_name)|
                              succeeded).  */
            {
                  cerr_strm << thread_name 
                            << "In `Scan_Parse::vector_type_decl()':"
                            << endl 
                            << "`scanner_node->erase_entry(" << array_name 
                            << ")' succeeded." << endl
                            << "Will delete `curr_ptr' and "
                            << "`array_entry' and exit function "
                            << "with return value 1.";

                  log_message(cerr_strm); 
                  cerr_message(cerr_strm);
                  cerr_strm.str("");

            } 

@q |else if (DEBUG)| @>
@q    (|status == 0|---|scanner_node->erase_entry| @>
@q                 succeeded).  */@>

#endif 

@q /* |DEBUG_COMPILE|  */@>

@q ******** (8) Delete |curr_ptr| and |array_entry| and return 1.@>
@ Delete |curr_ptr| and |array_entry| and return 1.

\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

          delete curr_ptr;
          curr_ptr = 0;

          delete array_entry;
          array_entry = 0;
          
          return 1;



        } /* |if (vector_entry == 0)|  */


@q ******* (7) Success! Calling |add_entry| for |vector_entry| succeeded.@>  

@ Success! Calling |add_entry| for |vector_entry| succeeded.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::vector_type_decl()':"
                 << endl 
                 << "Creating `vector_entry' succeeded.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) Try to set |superordinate_vector| on |array_entry|.@>  

@ Try to set |superordinate_vector| on |array_entry|.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

      status = array_entry->set_superordinate_vector(vector_entry);

@q ******* (7) Error handling:  Failed to set      @>
@q ******* (7) |array_entry->superordinate_vector|.@>

@ Error handling:  Failed to set 
|array_entry->superordinate_vector|.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

      if (status != 0)
        {
          cerr_strm << thread_name 
                    << "ERROR! In `Scan_Parse::vector_type_decl()':"
                    << endl 
                    << "Failed to set `superordinate_vector' on `array_entry'."
                    << endl << "Will try to delete `curr_ptr', "
                    << "delete and erase `array_entry' and `vector_entry'," 
                    << endl 
                    << "and exit function with return value 1.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm, error_stop_value);
          cerr_strm.str("");
          
          delete curr_ptr;
          delete array_entry;
          delete vector_entry;

          curr_ptr = 0;
          array_entry = 0;
          vector_entry = 0;

          scanner_node->erase_entry(array_name);
          scanner_node->erase_entry(vector_name);

          return 1;

        } /* |if (vector_entry == 0)|  */

@q ******* (7) Success!  Setting |array_entry->superordinate_vector| worked.@>  

@ Success!  Setting |array_entry->superordinate_vector| worked.
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   else if (DEBUG)
     {

       cerr_strm << thread_name 
                 << "In `Scan_Parse::vector_type_decl()':"
                 << endl 
                 << "Setting `array_entry->superordinate_vector' "
                 << "succeeded.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm);
          cerr_strm.str("");
      }
#endif /* |DEBUG_COMPILE|  */@; 

@q ****** (6) @>  
@ 
\initials{LDF 2004.08.24.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
      {
           cerr_mutex.lock();
           cerr << thread_name 
                     << "In `Scan_Parse::vector_type_decl()':"
                     << endl
                     << "Showing `array_entry':" << endl;
           array_entry->show();
           cerr << "Type <RETURN> to continue: ";
           getchar(); 

           cerr << thread_name 
                     << "In `Scan_Parse::vector_type_decl()':"
                     << endl
                     << "Showing `vector_entry':" << endl;
           vector_entry->show();
           cerr << "Type <RETURN> to continue: ";
           getchar(); 
           cerr_mutex.unlock();
      }
#endif /* |DEBUG_COMPILE|  */@; 


@q ****** (6) End of |for| loop for cycling through    @>   
@q ****** (6) |scanner_node->token_string_bool_vector|.@>   

@ End of |for| loop for cycling through  
|scanner_node->token_string_bool_vector|.
\initials{LDF 2004.08.24.}

If we've reached this code, entries have successfully been added to 
|scanner_node->id_map_node->id_map|.
\initials{LDF 2004.08.25.}

@<Define |Scan_Parse| template functions@>=

  declaration_succeeded = true;

  ++i;
      
    } /* |for|  */

  } /* End of group.  */

  scanner_node->token_string_bool_vector.clear();


#if DEBUG_COMPILE
   if (DEBUG)
     {
       cerr_message(cerr_strm, error_stop_value); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 
@q ***** (5) Exit function.@>   
@ Exit function.
\initials{LDF 2004.08.25.}

@q ****** (6) At least one declaration succeeded.@>   

@ At least one declaration succeeded.  Exit with return value 0. 
\initials{LDF 2004.08.25.}

@<Define |Scan_Parse| template functions@>=


   if (declaration_succeeded)
      {
#if DEBUG_COMPILE
        if (DEBUG)
          {
            cerr_strm << thread_name 
                      << "Exiting `Scan_Parse::vector_type_decl()' "
                      << "successfully with return value 0.";
            cerr_message(cerr_strm);
            cerr_strm.str("");
            
          }
#endif /* |DEBUG_COMPILE|  */@; 
        
        return 0;
      } /* |if (declaration_succeeded)|  */


@q ****** (6) No declarations succeeded.@>   
@ No declarations succeeded.  Exit with return value 1. 
\initials{LDF 2004.08.25.}

@<Define |Scan_Parse| template functions@>=

   else /* (|!declaration_succeeded|)  */
      {
        cerr_strm << thread_name 
                  << "WARNING! In `Scan_Parse::vector_type_decl()':"
                  << endl << "No declarations succeeded."
                  << endl << "Exiting function with return value 1.";

        log_message(cerr_strm); 
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        return 1;
            
      } /* |(!declaration_succeeded)|  */

} /* End of |Scan_Parse::vector_type_decl| definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.

\LOG
\initials{LDF 2004.08.25.}
Added this section.

\initials{LDF 2004.11.05.}
Added declaration for the version with |Bool_Point| as the type 
parameter.  I was actually already using this version, so this 
declaration doesn't seem to be necessary.

\initials{LDF 2004.12.10.}
Added declaration for the version with |Path| as the type 
parameter.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=
int 
vector_type_decl(Scanner_Node scanner_node,
                 int vector_type_num,
                 int array_type_num,
                 Color* dummy = 0);

int 
vector_type_decl(Scanner_Node scanner_node,
                 int vector_type_num,
                 int array_type_num,
                 Point* dummy = 0);

int 
vector_type_decl(Scanner_Node scanner_node,
                 int vector_type_num,
                 int array_type_num,
                 Bool_Point* dummy = 0);

int 
vector_type_decl(Scanner_Node scanner_node,
                 int vector_type_num,
                 int array_type_num,
                 Path* dummy = 0);



@q *** (3) |vector_type_plus_assign|.@>
@*2 {\bf vector\_type\_plus\_assign}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Added this function.
It's called in the parser rule 
``\color vector assignment> $\longrightarrow$ 
\color vector variable> \.{PLUS\_ASSIGN} \color expression>'' in
\filename{passign.w}. 

\initials{LDF 2004.11.06.}
Put calls to |new| inside |try|--|catch| blocks.
Now calling |new Pointer_Vector<C>| if |entry->object == 0|.

\initials{LDF 2004.11.08.}
Now calling |scanner_node->get_thread_name_and_stop_values|.

\initials{LDF 2005.01.03.}
Added |bool copy_object| argument.
\ENDLOG 


@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=
template <class C>
int 
Scan_Parse::vector_type_plus_assign(Scanner_Node scanner_node,
                                    Id_Map_Entry_Node entry,
                                    int vector_type_num,
                                    int array_type_num,
                                    C* object,
                                    bool copy_object)
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);
  stringstream cerr_strm;

  int status;

@q ***** (5).@>   
@ 
@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::vector_type_plus_assign()'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) If |copy_object == true|, Copy |object| and put copy onto |vector<C*>|.@>   
@q ***** (5) Otherwise put |object| itself onto |vector<C*>|.@> 

@ If |copy_object == true|, copy |object| and put copy onto |vector<C*>|.
Otherwise put |object| itself onto |vector<C*>|.
\initials{LDF 2005.01.03.}

\LOG
\initials{LDF 2004.09.07.}
@:BUG FIX@> BUG FIX:  Now copying |object| and putting the copy onto  
|vector<C*>|.  Previously, I put |object| itself onto it.

\initials{LDF 2005.01.03.}
Now putting |object| itself onto |vector<C*>| if the 
|bool copy_object| argument is |false|.  The default is |true|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  typedef Pointer_Vector<C> PV;

  PV*  pv = static_cast<PV*>(entry->object);
   
@q ****** (6) |pv == 0|.@> 
@ |pv == 0|.  Try to allocate memory for a new |PV|.
Rethrow |bad_alloc| upon failure.
\initials{LDF 2004.11.06.}

\LOG
\initials{LDF 2004.11.06.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| template functions@>=


  if (pv == static_cast<PV*>(0))
    {     
       try 
         {
            pv = new PV;
         }

       catch (bad_alloc)
         {
            cerr_strm << thread_name 
                      << "ERROR! In `Scan_Parse::vector_type_plus_assign():"
                      << endl 
                      << "`new Pointer_Vector<C>' failed. "
                      << "Rethrowing `bad_alloc'.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            throw;
           
         } /* |catch (bad_alloc)|  */

       entry->object = static_cast<void*>(pv); 

    }  /* |if (pv == 0)|  */


@q ****** (6)  Try to allocate memory for a new |C|.@> 

@ Try to allocate memory for a new |C|.
Rethrow |bad_alloc| upon failure.
\initials{LDF 2004.11.06.}

@<Define |Scan_Parse| template functions@>=

   C* new_object;

   if (copy_object) 
      {

          try        
             {
                new_object = new C;
             }
           
          catch (bad_alloc)
             {

                 cerr_strm << thread_name 
                           << "ERROR! In `Scan_Parse::vector_type_plus_assign():"
                           << endl 
                           << "`new C' failed. Deleting `pv' and "
                           << "rethrowing `bad_alloc'.";

                 log_message(cerr_strm);
                 cerr_message(cerr_strm, error_stop_value);
                 cerr_strm.str("");
 
                 delete pv;  
 
                 throw;
                   
             }  /* |catch (bad_alloc)|  */

@q ****** (6).@> 

          *new_object = *object;

      }  /* |if (copy_object) |  */

   else  /* |!copy_object |  */
      {
         new_object = object;

      }  /* |else| (|!copy_object |)  */

   pv->v.push_back(new_object);

@q ***** (5) Get |array_entry|.@>   
@ Get |array_entry|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   Id_Map_Entry_Node array_entry
     = static_cast<Id_Map_Entry_Node>(entry->subordinate_array);

@q ****** (6) Error handling for the case that |array_entry == 0|.@>   

@ Error handling for the case that |array_entry == 0|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   if (array_entry == static_cast<Id_Map_Entry_Node>(0))
     {

       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::vector_type_plus_assign():"
                 << endl 
                 << "`array_entry' == 0.  Not setting `"
                 << entry->name << "[" << pv->ctr << "]'."
                 << endl << "Exiting function with return value 1.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value); 
       cerr_strm.str(""); 

       return 1;

     } /* |if (array_entry == 0)|  */


@q ****** (6) Success! |array_entry != 0|.@>   

@ Success! |array_entry != 0|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   else /* |array_entry != 0|  */
     {
      
#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << thread_name 
                     << "In `Scan_Parse::vector_type_plus_assign():"
                     << endl 
                     << "`array_entry' != 0.  Will try to set `"
                     << entry->name << "[" << pv->ctr << "]'.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm); 
           cerr_strm.str(""); 
         }
#endif /* |DEBUG_COMPILE|  */@; 

       stringstream s;

       s << entry->name << "[" << pv->ctr << "]";

       Id_Map_Entry_Node c_entry
         = scanner_node->get_array_entry(s.str(), array_entry);

@q ******* (7) Error handling:  |get_array_entry| failed.@>   

@ Error handling:  |get_array_entry| failed.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

       if (c_entry == static_cast<Id_Map_Entry_Node>(0))
         {
           cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::vector_type_plus_assign():"
                     << endl
                     << "`get_array_entry()' failed.  Not setting `"
                     << entry->name << "[" << pv->ctr << "]'."
                     << endl << "Exiting function with return value 1.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm, error_stop_value); 
           cerr_strm.str(""); 

           return 1;
           
         } /* |if (c_entry == 0)|  */

@q ******* (7) Success!  |get_array_entry| succeeded.@>   

@ Success!  |get_array_entry| succeeded.
\initials{LDF 2004.09.01.}

\LOG
\initials{LDF 2004.09.01.}
Now setting |c_entry->known_state| to |Id_Map_Entry_Type::KNOWN|. 

\initials{LDF 2004.09.07.}
@:BUG FIX@> BUG FIX:  Now copying |object| and setting
|c_entry->object| to the copy, namely |new_object|.
Previously, I set it to |object| itself.

\initials{LDF 2004.11.08.}
@:BUG FIX@> BUG FIX:  Now casting |c_entry->object| to |C*| rather
than |Color*| when deleting it.

\initials{LDF 2004.11.11.}
@:BUG FIX@> BUG FIX:  No longer deleting |c_entry->object| 
if it's non-null.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  else /* |c_entry != 0|  */
    {
      
#if DEBUG_COMPILE
      if (DEBUG)
        {

          cerr_strm << thread_name 
                     << "In In `Scan_Parse::vector_type_plus_assign():"
                     << endl 
                     << "`get_array_entry()' succeeded.  Will try to set `"
                     << entry->name << "[" << pv->ctr << "]'.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
        }
#endif /* |DEBUG_COMPILE|  */@; 
      
      c_entry->object = static_cast<void*>(new_object);
      c_entry->known_state = Id_Map_Entry_Type::KNOWN;


    }    /* |else| (|c_entry != 0|)  */

@q ******* (7).@>   
@ 
@<Define |Scan_Parse| template functions@>=


     }   /* |else| (|array_entry != 0|)  */


@q ***** (5).@>   
@ 
@<Define |Scan_Parse| template functions@>=

  pv->ctr++;


@q ***** (5).@>   
@ 
@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::vector_type_plus_assign()' "
                << "successfully with return value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


  return 0;

} /* End of |Scan_Parse::vector_type_plus_assign| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2004.08.31.}

\LOG
\initials{LDF 2004.08.31.}
Added this section.

\initials{LDF 2004.09.01.}
Added declaration for |vector_type_plus_assign<Bool_Point>|.

\initials{LDF 2004.12.12.}
Added declaration for |vector_type_plus_assign<Path>|.

\initials{LDF 2005.01.03.}
Added declaration for |vector_type_plus_assign<Definition_Info_Type>|.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

   int 
   vector_type_plus_assign(Scanner_Node scanner_node,
                           int vector_type_num,
                           int array_type_num,
                           Color* object);

   int 
   vector_type_plus_assign(Scanner_Node scanner_node,
                           int vector_type_num,
                           int array_type_num,
                           Point* object);


   int 
   vector_type_plus_assign(Scanner_Node scanner_node,
                           int vector_type_num,
                           int array_type_num,
                           Bool_Point* object);


   int 
   vector_type_plus_assign(Scanner_Node scanner_node,
                           int vector_type_num,
                           int array_type_num,
                           Path* object);


   int 
   vector_type_plus_assign(Scanner_Node scanner_node,
                           int vector_type_num,
                           int array_type_num,
                           Definition_Info_Node object);






@q *** (3) |vector_type_assign|.@>
@*2 {\bf vector\_type\_assign}.
This function is declared in \filename{pspglb.web}.
\initials{LDF 2004.11.08.}

\LOG
\initials{LDF 2004.11.08.}
Added this function.
\ENDLOG 


@q **** (4) Definition.@>
@
@<Define |Scan_Parse| template functions@>=
template <class C, class D>
int 
Scan_Parse::vector_type_assign(Scanner_Node scanner_node,
                               Id_Map_Entry_Node entry,
                               const Pointer_Vector<D>* object_vector,
                               C* dummy)
{

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  using namespace Scan_Parse;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);
  stringstream cerr_strm;

  int status;

@q ***** (5).@>   
@ 
@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Entering `Scan_Parse::vector_type_assign()'.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Error handling:  |entry == 0|.@> 
@ Error handling:  |entry == 0|.  Return 1.
\initials{LDF 2005.03.01.}

\LOG
\initials{LDF 2005.03.01.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| template functions@>=

   if (entry == static_cast<Id_Map_Entry_Node>(0))
      {
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::vector_type_assign()':"
                   << endl << "`entry' == 0.  Can't assign."
                   << endl << "Exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         return 1;

      }  /* |if (entry == 0)|  */

@q ***** (5) Error handling:  |object_vector == 0|.@> 
@ Error handling:  |object_vector == 0|.  Return 1.
\initials{LDF 2004.12.13.}

\LOG
\initials{LDF 2004.12.13.}
@:BUG FIX@> BUG FIX: 
Added this section.
\ENDLOG

@<Define |Scan_Parse| template functions@>=

   if (object_vector == static_cast<const Pointer_Vector<D>*>(0))
      {
         cerr_strm << thread_name 
                   << "ERROR!  In `Scan_Parse::vector_type_assign()':"
                   << endl << "`object_vector' == 0.  Can't assign."
                   << endl << "Exiting function with return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");

         return 1;

      }  /* |if (object_vector == 0)|  */

@q ***** (5) Copy the elements of |object_vector| and put @>   
@q ***** (5) the copies onto |vector<C*>|.@> 

@ Copy the elements of |object_vector| and put    
the copies onto |vector<C*>|.
\initials{LDF 2004.11.08.}

\LOG
\initials{LDF 2005.03.01.}
Now calling |Scan_Parse::clear_vector_func| on |entry|.

\initials{LDF 2005.08.30.}
Now deleting |pv| and setting it to 0, if it's not 0 already.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=

  clear_vector_func(scanner_node, entry);

  typedef Pointer_Vector<C> PV;

  PV*  pv = static_cast<PV*>(entry->object);

  if (pv != static_cast<PV*>(0))
     {
         delete pv;
         pv = 0;
     }

@q ****** (6) |pv == 0|.@> 
@ |pv == 0|.  Try to allocate memory for a new |PV|.
Rethrow |bad_alloc| upon failure.
\initials{LDF 2004.11.08.}

@<Define |Scan_Parse| template functions@>=


  if (pv == static_cast<PV*>(0))
    {     
       try 
         {
            pv = new PV;
         }

       catch (bad_alloc)
         {
            cerr_strm << thread_name 
                      << "ERROR! In `Scan_Parse::vector_type_assign():"
                      << endl 
                      << "`new Pointer_Vector<C>' failed. "
                      << "Rethrowing `bad_alloc'.";

            log_message(cerr_strm);
            cerr_message(cerr_strm, error_stop_value);
            cerr_strm.str("");

            throw;
           
         } /* |catch (bad_alloc)|  */

       entry->object = static_cast<void*>(pv); 

    }  /* |if (pv == 0)|  */



@q ****** (6) Loop over |object_vector|.@> 


   C* new_object;

   for (typename vector<D*>::const_iterator iter = object_vector->v.begin();
        iter != object_vector->v.end();
        ++iter)
      {

@q ******** (7)  Try to allocate memory for a new |C|.@> 

@ Try to allocate memory for a new |C|.
Rethrow |bad_alloc| upon failure.
\initials{LDF 2004.11.06.}

@<Define |Scan_Parse| template functions@>=


  try 
     {
        new_object = new C;
     }
   
  catch (bad_alloc)
     {

         cerr_strm << thread_name 
                   << "ERROR! In `Scan_Parse::vector_type_assign():"
                   << endl 
                   << "`new C' failed. Deleting `pv' and "
                   << "rethrowing `bad_alloc'.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, error_stop_value);
         cerr_strm.str("");
 
         delete pv;  
 
         throw;
           
     }  /* |catch (bad_alloc)|  */

@q ******* (7).@> 



   *new_object = **iter;

   pv->v.push_back(new_object);


@q ******* (7) Get |array_entry|.@>   
@ Get |array_entry|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   Id_Map_Entry_Node array_entry
     = static_cast<Id_Map_Entry_Node>(entry->subordinate_array);

@q ******* (7) Error handling for the case that |array_entry == 0|.@>   

@ Error handling for the case that |array_entry == 0|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   if (array_entry == static_cast<Id_Map_Entry_Node>(0))
     {

       cerr_strm << thread_name 
                 << "ERROR! In `Scan_Parse::vector_type_assign():"
                 << endl 
                 << "`array_entry' == 0.  Not setting `"
                 << entry->name << "[" << pv->ctr << "]'."
                 << endl << "Exiting function with return value 1.";

       log_message(cerr_strm); 
       cerr_message(cerr_strm, error_stop_value); 
       cerr_strm.str(""); 

       return 1;

     } /* |if (array_entry == 0)|  */


@q ******* (7) Success! |array_entry != 0|.@>   

@ Success! |array_entry != 0|.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

   else /* |array_entry != 0|  */
     {
      
#if DEBUG_COMPILE
       if (DEBUG)
         {
           cerr_strm << thread_name 
                     << "In `Scan_Parse::vector_type_assign():"
                     << endl 
                     << "`array_entry' != 0.  Will try to set `"
                     << entry->name << "[" << pv->ctr << "]'.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm); 
           cerr_strm.str(""); 
         }
#endif /* |DEBUG_COMPILE|  */@; 

       stringstream s;

       s << entry->name << "[" << pv->ctr << "]";

       Id_Map_Entry_Node c_entry
         = scanner_node->get_array_entry(s.str(), array_entry);

@q ******** (8) Error handling:  |get_array_entry| failed.@>   

@ Error handling:  |get_array_entry| failed.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

       if (c_entry == static_cast<Id_Map_Entry_Node>(0))
         {
           cerr_strm << thread_name 
                     << "ERROR! In `Scan_Parse::vector_type_assign():"
                     << endl
                     << "`get_array_entry()' failed.  Not setting `"
                     << entry->name << "[" << pv->ctr << "]'."
                     << endl << "Exiting function with return value 1.";

           log_message(cerr_strm); 
           cerr_message(cerr_strm, error_stop_value); 
           cerr_strm.str(""); 

           return 1;
           
         } /* |if (c_entry == 0)|  */

@q ******** (8) Success!  |get_array_entry| succeeded.@>   

@ Success!  |get_array_entry| succeeded.
\initials{LDF 2004.09.01.}

@<Define |Scan_Parse| template functions@>=

  else /* |c_entry != 0|  */
    {
      
#if DEBUG_COMPILE
      if (DEBUG)
        {

          cerr_strm << thread_name 
                     << "In `Scan_Parse::vector_type_assign():"
                     << endl 
                     << "`get_array_entry()' succeeded.  Will try to set `"
                     << entry->name << "[" << pv->ctr << "]'.";

          log_message(cerr_strm); 
          cerr_message(cerr_strm); 
          cerr_strm.str(""); 
        }
#endif /* |DEBUG_COMPILE|  */@; 
      

      c_entry->object = static_cast<void*>(new_object); 
      c_entry->known_state = Id_Map_Entry_Type::KNOWN;

    }    /* |else| (|c_entry != 0|)  */

@q ******** (8).@>   
@ 
@<Define |Scan_Parse| template functions@>=


     }   /* |else| (|array_entry != 0|)  */


@q ******* (7).@>   
@ 
@<Define |Scan_Parse| template functions@>=

      pv->ctr++;

   } /* |for|  */


@q ****** (6).@> 

@q ***** (5).@>   
@ 
@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
    {
      cerr_strm << thread_name 
                << "Exiting `Scan_Parse::vector_type_assign()' "
                << "successfully with return value 0.";

      log_message(cerr_strm); 
      cerr_message(cerr_strm);
      cerr_strm.str("");
      
    }
#endif /* |DEBUG_COMPILE|  */@; 


  return 0;

} /* End of |Scan_Parse::vector_type_assign| definition.  */


@q *** (3) Cull.@> 
@*2 Cull.
\initials{LDF 2007.07.23.}

\LOG
\initials{LDF 2007.07.23.}
Added this function.

\initials{LDF 2007.07.23.}
Finished writing this function.

\initials{LDF 2007.07.23.}
Added optional |const unsigned short comparison| argument
with the default 0.

\initials{LDF 2007.07.27.}
Added optional |real tolerance| argument with the default -1.

\initials{LDF 2007.07.27.}
Added arguments to call to |Pointer_Vector::cull|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
int 
Scan_Parse::cull_func(void* v, 
                      const unsigned short comparison,
                      Scanner_Node scanner_node, 
                      real tolerance = -1,
                      C* c = 0)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

     if (v == static_cast<void*>(0))
     {
         cerr_strm << thread_name 
                   << "WARNING!  In `Scan_Parse::cull_func':"
                   << endl 
                   << "`Pointer_Vector*' argument is null.  "
                   << "Can't cull `Pointer_Vector'."
                   << endl  
                   << "Exiting function unsuccessfully with "
                   << "return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, warning_stop_value);
         cerr_strm.str("");

         return 1;

     } /* |if (v == 0)|  */

@q ***** (5)@> 


     Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(v);

     if (entry->object == static_cast<void*>(0))
     {
         cerr_strm << thread_name 
                   << "WARNING!  In `Scan_Parse::cull_func':"
                   << endl 
                   << "`entry->object' argument is null.  "
                   << "Can't cull `Pointer_Vector'."
                   << endl  
                   << "Exiting function unsuccessfully with "
                   << "return value 1.";

         log_message(cerr_strm);
         cerr_message(cerr_strm, warning_stop_value);
         cerr_strm.str("");

         return 1;

     } /* |if (entry->object == 0)|  */


@q ***** (5)@> 

     int status;

     Pointer_Vector<C>* pv = static_cast<Pointer_Vector<C>*>(entry->object);
     Pointer_Vector<C>* qv = new Pointer_Vector<C>;
    
     for (typename vector<C*>::iterator iter = pv->v.begin();
          iter != pv->v.end();
          ++iter)
     {
        qv->v.push_back(new C);
        *(qv->v.back()) = **iter;
        ++qv->ctr;
     }

@q ***** (5)@> 
@
\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2007.07.27.}
Add error handling.
\ENDTODO 

@<Define |Scan_Parse| template functions@>=

     status = Scan_Parse::clear_vector_func(scanner_node,
                                            entry); 
     if (status != 0)
        return status;
      

     status = qv->cull(comparison,
                       tolerance,
                       scanner_node,
                       c);      

     if (status != 0)
        return status;

     status = vector_type_assign<C, C>(scanner_node,
                                       entry,
                                       qv);

     return status;

}  /* End of |Scan_Parse::cull_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2007.07.23.}

\LOG
\initials{LDF 2007.07.23.}
Added this section.

\initials{LDF 2007.07.23.}
Added optional |const unsigned short comparison| argument
with the default 0.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

int
cull_func(void* v, 
          const unsigned short comparison = 0,
          Scanner_Node scanner_node = 0, 
          Point* p = 0);

@q **** (4)@> 

@q *** (3) Rectify.@> 
@*2 Rectify.
\initials{LDF 2007.07.27.}

\LOG
\initials{LDF 2007.07.27.}
Added this function.

\initials{LDF 2007.07.29.}
@:BUG FIX@> BUG FIX:  Now calling |Scan_Parse::clear_vector_func| and 
|Scan_Parse::vector_type_assign|.

\initials{LDF 2007.08.06.}
Added optional |Transform* transform| argument.  
The default is 0.  It's passed to |Pointer_Vector::rectify|.

\initials{LDF 2007.08.06.}
Added optional |bool do_transform| argument with the default |true|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
int 
Scan_Parse::rectify_func(void* v,
                         Scanner_Node scanner_node,
                         bool do_test,
                         bool do_cull,
                         bool do_transform,
                         real tolerance,
                         Transform* t,
                         C* c)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Scan_Parse::rectify_func'.";
      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Error handling:  |void* v == 0|.@> 
@ Error handling:  |void* v == 0|.
\initials{LDF 2007.07.27.}

@<Define |Scan_Parse| template functions@>=

   if (v == static_cast<void*>(0))
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::rectify_func':"
                 << endl 
                 << "`void* v' argument is null.  "
                 << "Can't rectify vector-type object."
                 << endl
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |if (v == 0)|  */


@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=

   Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(v);

@q ***** (5) Error handling:  |entry->object == 0|.@> 
@ Error handling:  |entry->object == 0|.
\initials{LDF 2007.07.27.}

@<Define |Scan_Parse| template functions@>=

   if (entry->object == static_cast<void*>(0))
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::rectify_func':"
                 << endl 
                 << "`entry->object' is null.  "
                 << "Can't rectify vector-type object."
                 << endl
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |if (entry->object == 0)|  */


@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=

   int status;

   Pointer_Vector<C>* pv = static_cast<Pointer_Vector<C>*>(entry->object);

   Pointer_Vector<C>* qv = new Pointer_Vector<C>;
   
   for (typename vector<C*>::iterator iter = pv->v.begin();
        iter != pv->v.end();
        ++iter)
   {
      qv->v.push_back(new C);
      *(qv->v.back()) = **iter;
      ++qv->ctr;
   }


@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=


   status = clear_vector_func(scanner_node,
                              entry); 


@q ****** (6)@> 

   if (status != 0)
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::rectify_func':"
                 << endl 
                 << "`Scan_Parse::clear_vector_func' failed, "
                 << "returning " << status << "."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |if (status != 0)|  */


@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=


   status = qv->rectify(scanner_node, 
                        do_test, 
                        do_cull, 
                        do_transform,
                        tolerance, 
                        t,
                        c);

@q ****** (6) Error handling:  |Pointer_Vector::rectify| failed, @> 
@q ****** (6) returning a non-zero value.@> 

@ Error handling:  |Pointer_Vector::rectify| failed, returning a non-zero value.
\initials{LDF 2007.07.27.}

@<Define |Scan_Parse| template functions@>=

   if (status != 0)
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::rectify_func':"
                 << endl 
                 << "`Pointer_Vector::rectify' failed, "
                 << "returning " << status << "."
                 << endl 
                 << "Couldn't rectify vector-type object."
                 << endl
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=

   status = vector_type_assign<C, C>(scanner_node,
                                     entry,
                                     qv);   

@q ****** (6)@> 

   if (status != 0)
   {
       cerr_strm << thread_name << "ERROR!  In `Scan_Parse::rectify_func':"
                 << endl 
                 << "`Scan_Parse::vector_type_assign' failed, "
                 << "returning " << status << "."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1.";

       log_message(cerr_strm);
       cerr_message(cerr_strm, error_stop_value);
       cerr_strm.str("");

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5)@> 
@
@<Define |Scan_Parse| template functions@>=

   else  /* |status == 0|  */
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
          cerr_strm << thread_name << "Exiting `Scan_Parse::rectify_func' "
                    << "successfully with return value 0.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");

       }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */@; 

      return 0;

   }  /* |else| (|status == 0|)  */

@q ***** (5)@> 

} /* End of |Scan_Parse::rectify_func| definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2007.07.27.}

\LOG
\initials{LDF 2007.07.27.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

int
rectify_func(void* v, 
             Scanner_Node scanner_node = 0, 
             bool do_test = true,
             bool do_cull = true,
             real tolerance = -1,
             Point* p = 0);

@q **** (4)@> 

@q *** (3) |reverse_func|.@>
@*2 {\bf reverse\_func}.
\initials{LDF 2007.08.14.}

\LOG
\initials{LDF 2007.08.14.}
Added this function.

\initials{LDF 2007.08.16.}
Made this function a template function and removed the code 
that tested for specific types.  Also moved this definition from 
\filename{scanprsf.web} to this file (\filename{scanprse.web}).
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=
template<class C>
int
Scan_Parse::reverse_func(void* v, void* parameter, C* c)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 

    Id_Map_Entry_Node entry = static_cast<Id_Map_Entry_Node>(v);

    if (entry == static_cast<Id_Map_Entry_Node>(0) || entry->object == static_cast<void*>(0))
       return 1;

#if 0 
/* LDF 2008.10.09.  */
#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr_strm << thread_name << "In `Scan_Parse::reverse_func':"
                 << endl
                 << "entry->type == " << name_map[entry->type] 
                 << " (" << entry->type << ")"
                 << endl;

       log_message(cerr_strm);
       cerr_message(cerr_strm);
       cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 
#endif 

@q ***** (5)@> 

        Pointer_Vector<C>* pv 
           = static_cast<Pointer_Vector<C>*>(entry->object); 

        Pointer_Vector<C>* qv = new Pointer_Vector<C>;
        *qv = *pv;

        qv->reverse();

        clear_vector_func(scanner_node,
                          entry); 

        vector_type_assign<C, C>(scanner_node,
                                 entry,
                                 qv);   

@q ***** (5)@> 

    return 0;


}  /* End of |Scan_Parse::reverse_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2007.08.16.}

\LOG
\initials{LDF 2007.08.16.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=
int
reverse_func(void* v, void* parameter, bool* c);

int
reverse_func(void* v, void* parameter, string* c);

int
reverse_func(void* v, void* parameter, real* c);

int
reverse_func(void* v, void* parameter, ulong_long* c);

int
reverse_func(void* v, void* parameter, Transform* c);

int
reverse_func(void* v, void* parameter, Color* c);

int
reverse_func(void* v, void* parameter, Pen* c);

int
reverse_func(void* v, void* parameter, Dash_Pattern* c);

int
reverse_func(void* v, void* parameter, Focus* c);

int
reverse_func(void* v, void* parameter, Picture* c);

int
reverse_func(void* v, void* parameter, Point* c);

int
reverse_func(void* v, void* parameter, Bool_Point* c);

int
reverse_func(void* v, void* parameter, Nurb* c);

int
reverse_func(void* v, void* parameter, Path* c);

int
reverse_func(void* v, void* parameter, Triangle* c);

int
reverse_func(void* v, void* parameter, Polygon* c);

int
reverse_func(void* v, void* parameter, Reg_Polygon* c);

int
reverse_func(void* v, void* parameter, Rectangle* c);

int
reverse_func(void* v, void* parameter, Ellipse* c);

int
reverse_func(void* v, void* parameter, Circle* c);

int
reverse_func(void* v, void* parameter, Conic_Section_Lattice* c);

int
reverse_func(void* v, void* parameter, Helix* c);

int
reverse_func(void* v, void* parameter, Cuboid* c);

int
reverse_func(void* v, void* parameter, Polyhedron* c);

int
reverse_func(void* v, void* parameter, Cone* c);

int
reverse_func(void* v, void* parameter, Cylinder* c);

int
reverse_func(void* v, void* parameter, Ellipsoid* c);

int
reverse_func(void* v, void* parameter, Sphere* c);

int
reverse_func(void* v, void* parameter, Parabola* c);

int
reverse_func(void* v, void* parameter, Hyperbola* c);

int
reverse_func(void* v, void* parameter, Paraboloid* c);

int
reverse_func(void* v, void* parameter, Hyperboloid* c);

int
reverse_func(void* v, void* parameter, Parabola_Slice* c);

int
reverse_func(void* v, void* parameter, Hyperbola_Slice* c);

int
reverse_func(void* v, void* parameter, Paraboloid_Slice* c);

int
reverse_func(void* v, void* parameter, Hyperboloid_Slice* c);

int
reverse_func(void* v, void* parameter, Glyph* c);

int
reverse_func(void* v, void* parameter, Plane* c);

int
reverse_func(void* v, void* parameter, Origami_Figure* c);

int
reverse_func(void* v, void* parameter, Ellipse_Slice* c);

int
reverse_func(void* v, void* parameter, Circle_Slice* c);

int
reverse_func(void* v, void* parameter, Helix_Slice* c);

int
reverse_func(void* v, void* parameter, Polyhedron_Slice* c);

int
reverse_func(void* v, void* parameter, Cone_Slice* c);

int
reverse_func(void* v, void* parameter, Cylinder_Slice* c);

int
reverse_func(void* v, void* parameter, Ellipsoid_Slice* c);

int
reverse_func(void* v, void* parameter, Sphere_Slice* c);

int
reverse_func(void* v, void* parameter, Glyph_Slice* c);

@*2 {\bf reflect\_in\_func}.@> 
\initials{LDF 2004.10.03.}

\LOG
\initials{LDF 2004.10.03.}
Added this function.

\initials{LDF 2004.10.12.}
Now trying to allocate memory on the free store for |C* reflection|.

\initials{LDF 2004.10.12.}
Changed the name of this function from |reflect_func| to 
|reflect_in_func|.

\initials{LDF 2004.11.15.}
Removed |using namespace Scan_Parse| declaration.
\ENDLOG


@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
C*
Scan_Parse::reflect_in_func(Scanner_Node scanner_node,
			 C* object,
			 Path* plane_path)
{


@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;

@q ***** (5) Check |object|.@> 

@ Check |object|.
\initials{LDF 2004.10.03.}

@q ****** (6) Error handling:  |object == 0|. Delete |plane_path| @> 
@q ****** (6) and return 0.                                       @> 

Error handling:  |object == 0|.  Delete |plane_path| and
return 0.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>= 

  if (object == static_cast<C*>(0))
     {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                << "`object' == 0."
                << endl 
                << "Deleting `plane_path' and returning 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete plane_path;

      return 0;

    }  /* |if (object == 0)|  */@;


@q ****** (6) |object != 0|.@> 

@ |object != 0|.  
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>= 

#if DEBUG_COMPILE
    else if (DEBUG)   /* |object != 0|  */
       {
           cerr_strm << thread_name << "`Scan_Parse::reflect_in_func()':"
                     << "`object' != 0.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

       }
#endif /* |DEBUG_COMPILE|  */ 

@q ***** (5) Check |plane_path|.@> 
@ Check |plane_path|.
\initials{LDF 2004.10.03.}

@q ****** (6) Error handling:  |plane_path == 0|. Delete |object| @> 
@q ****** (6) and return 0.                                       @> 

@ Error handling:  |plane_path == 0|.  Delete |object| and
return 0.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>= 

  if (plane_path == static_cast<Path*>(0))
     {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                << "`plane_path' == 0."
                << endl 
                << "Deleting `object' and returning 0.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete object;

      return 0;

    }  /* |if (plane_path == 0)|  */@;



@q ****** (6).@> 
  
    if (!plane_path->is_planar())
      {

        cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                  << "`plane_path->is_planar()' == `false'."
                  << endl 
                  << "Deleting `object' and `plane_path' "
                  << "and returning 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
        
        delete object;
        delete plane_path;

        return 0;
      
      }  /* |if (!plane_path->is_planar())|  */


@q ****** (6) |plane_path != 0 && plane_path->is_planar|.@> 

@ |plane_path != 0 && plane_path->is_planar|.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
    else if (DEBUG)   /* |plane_path != 0|  */
       {
           cerr_strm << thread_name << "`Scan_Parse::reflect_in_func()':"
                     << "`plane_path' != 0 && "
                     << "`plane_path->is_planar()' == `true'.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

       }
#endif /* |DEBUG_COMPILE|  */ 


  C* reflection;

@q ***** (5) Try to allocate memory on the free store for |reflection|.@> 
@ Try to allocate memory on the free store for |reflection|.
\initials{LDF 2004.10.12.}

@<Define |Scan_Parse| template functions@>=


   try 
    {
       reflection = create_new<C>(0, scanner_node);
    }

@q ****** (6) Error handling:  |create_new<C>| failed.@> 

@ Error handling:  |create_new<C>| failed.
\initials{LDF 2004.10.12.}

@<Define |Scan_Parse| template functions@>=

  catch (bad_alloc)
     {

        cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                  << endl 
                  << "`create_new<C>()' failed to allocate memory for "
                  << "reflection."
                  << endl 
                  << "Deleting `object' and `plane_path' "
                  << "and rethrowing `bad_alloc'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
        
        delete object;
        delete plane_path;

        throw;

     } /* |catch (bad_alloc)|  */


@q ****** (6) |create_new<C>| succeeded.@> 

@ |create_new<C>| succeeded.
\initials{LDF 2004.10.12.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
     {
          cerr_strm << thread_name << "In `Scan_Parse::reflect_in_func()': "
                    << endl 
                    << "`create_new<C>()' succeeded.";

          log_message(cerr_strm);
          cerr_message(cerr_strm);
          cerr_strm.str("");
 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

@q ***** (5) Call |object->reflect_in|.@> 
@ Call |object->reflect_in|.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>=


  int status;

  try 
    {
      
      status = object->reflect_in(plane_path->get_plane(),
                                  static_cast<void*>(reflection),
                                  scanner_node); 

    } /* |try|  */


@q ****** (6) Error handling:  |object->reflect_in| threw |bad_alloc|.@>  

@ Error handling:  |object->reflect_in| threw |bad_alloc|.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>=

  catch (bad_alloc)
    {
      cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                << "`object->reflect_in()' failed and threw `bad_alloc'."
                << endl 
                << "Deleting `object' and `plane_path' and "
                << "rethrowing `bad_alloc'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete object;
      delete plane_path;

      throw;

    } /* |catch (bad_alloc)|  */
    
@q ****** (6) Error handling:  |reflection == 0|.@>  

@ Error handling:  |reflection == 0|.
\initials{LDF 2004.10.03.}

@<Define |Scan_Parse| template functions@>=

  if (reflection == static_cast<C*>(0))
     {

        cerr_strm << thread_name << "ERROR! In `Scan_Parse::reflect_in_func()': "
                  << "`object->reflect_in()' failed and returned 0."
                  << endl 
                  << "Deleting `object' and `plane_path' and "
                  << "exiting function with return value 0.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
        
        delete object;
        delete plane_path;

        return 0;
        
     } /* |if (reflection == 0)|  */


@q ***** (5) Exit function successfully with return value |reflection|.@> 

@ Exit function successfully with return value |reflection|.
\initials{LDF 2004.10.03.}

\LOG
@:BUG FIX@> BUG FIX: 
Now deleting |object| and |plane_path|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>=


  delete object;
  delete plane_path;

  return reflection;

} /* End of |Scan_Parse::reflect_in_func| definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2004.09.08.}

\LOG
\initials{LDF 2004.09.08.}
Added this section.

\initials{LDF 2004.10.05.}
Commented-in the declaration for the version of this function 
with |Rectangle| as the template type parameter.

\initials{LDF 2004.10.05.}
Commented-in the declaration for the version of this function 
with |Ellipse| as the template type parameter.

\initials{LDF 2004.10.05.}
Commented-in the declaration for the version of this function 
with |Circle| as the template type parameter.

\initials{LDF 2004.10.12.}
Changed the name of this function from |reflect_func| to 
|reflect_in_func|.

\initials{LDF 2004.12.03.}
Commented-in the declaration for the version of this function 
with |Octahedron| as the template type parameter.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

Point*
reflect_in_func(Scanner_Node scanner_node,
                Point* object,
                Path* plane_path);

Path*
reflect_in_func(Scanner_Node scanner_node,
                Path* object,
                Path* plane_path);

Reg_Polygon*
reflect_in_func(Scanner_Node scanner_node,
                Reg_Polygon* object,
                Path* plane_path);


Rectangle*
reflect_in_func(Scanner_Node scanner_node,
             Rectangle* object,
             Path* plane_path);



Ellipse*
reflect_in_func(Scanner_Node scanner_node,
             Ellipse* object,
             Path* plane_path);

Circle*
reflect_in_func(Scanner_Node scanner_node,
             Circle* object,
             Path* plane_path);


Cuboid*
reflect_in_func(Scanner_Node scanner_node,
             Cuboid* object,
             Path* plane_path);



Tetrahedron*
reflect_in_func(Scanner_Node scanner_node,
             Tetrahedron* object,
             Path* plane_path);


Octahedron*
reflect_in_func(Scanner_Node scanner_node,
             Octahedron* object,
             Path* plane_path);

Dodecahedron*
reflect_in_func(Scanner_Node scanner_node,
             Dodecahedron* object,
             Path* plane_path);



Icosahedron*
reflect_in_func(Scanner_Node scanner_node,
             Icosahedron* object,
             Path* plane_path);

#if 0 
Trunc_Octahedron*
reflect_in_func(Scanner_Node scanner_node,
             Trunc_Octahedron* object,
             Path* plane_path);

Triangle*
reflect_in_func(Scanner_Node scanner_node,
             Triangle* object,
             Path* plane_path);

Ellipsoid*
reflect_in_func(Scanner_Node scanner_node,
             Ellipsoid* object,
             Path* plane_path);
#endif 

@q *** (3) |reflect_off_func|.@> 

@*2 {\bf reflect\_off\_func}.@> 
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.12.04.}
Added this function.

\initials{LDF 2004.12.06.}
No longer trying to allocation memory for |reflection| 
in this function.  It didn't work to pass an uninitialized or 
null pointer for |reflection|.

\initials{LDF 2004.12.08.}
@:BUG FIX@> BUG FIX:  Now deleting |reflection| in error handling code, 
except when |C::reflect_off| fails.  |Point::reflect_off| deletes 
its version of |reflection| in its error handling code, and 
all other versions of |Shape::reflect_off| should do so, too.

\initials{LDF 2004.12.09.}
Changed |C* reflection| argument to |Point_Vector<C>* pv|.
It's passed to |C::reflect_off|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
int
Scan_Parse::reflect_off_func(Scanner_Node scanner_node,
                             C* object,
                             Path* plane_path,
                             Point* direction,
                             Pointer_Vector<C>* pv)
{


@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;

@q ***** (5) Check |object|.@> 

@ Check |object|.
\initials{LDF 2004.12.04.}

@q ****** (6) Error handling:  |object == 0|. Delete |plane_path|, @> 
@q ****** (6) |direction|, and |pv| and return 1.                  @> 

Error handling:  |object == 0|.  Delete |plane_path|,
|direction|, and |pv|,  and return 1.
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.12.06.}
Now deleting |reflection|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>= 

  if (object == static_cast<C*>(0))
     {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::reflect_off_func()': "
                << "`object' == 0."
                << endl 
                << "Deleting `plane_path', `direction', and "
                << "`pv', and returning 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete plane_path;
      delete direction;
      delete pv;

      return 1;

    }  /* |if (object == 0)|  */@;


@q ****** (6) |object != 0|.@> 

@ |object != 0|.  
\initials{LDF 2004.12.04.}

@<Define |Scan_Parse| template functions@>= 

#if DEBUG_COMPILE
    else if (DEBUG)   /* |object != 0|  */
       {
           cerr_strm << thread_name << "`Scan_Parse::reflect_off_func()':"
                     << "`object' != 0.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");

       }
#endif /* |DEBUG_COMPILE|  */ 

@q ***** (5) Check |pv|.@> 

@ Check |pv|.
\initials{LDF 2004.12.06.}

@q ****** (6) Error handling:  |pv == 0|. Delete |object|, @> 
@q ****** (6) |plane_path|, and |direction| and return 1.  @> 

Error handling:  |pv == 0|. Delete |object|, |plane_path| and
|direction| and return 1.
\initials{LDF 2004.12.06.}

@<Define |Scan_Parse| template functions@>= 

  if (pv == static_cast<Pointer_Vector<C>*>(0))
     {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::reflect_off_func()': "
                << "`pv' == 0."
                << endl 
                << "Deleting `object', `plane_path', and `direction' "
                << "and returning 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete object;
      delete plane_path;
      delete direction;

      return 1;

    }  /* |if (pv == 0)|  */@;

@q ***** (5) Check |plane_path|.@> 
@ Check |plane_path|.
\initials{LDF 2004.12.04.}

@q ****** (6) Error handling:  |plane_path == 0|. Delete |object| @> 
@q ****** (6) |direction|, and |pv| and return 1.         @> 

@ Error handling:  |plane_path == 0|.  Delete |object| and |direction| 
and |pv| and return 1.
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.12.08.}
Now deleting |reflection|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>= 

  if (plane_path == static_cast<Path*>(0))
     {
      cerr_strm << thread_name 
                << "ERROR! In `Scan_Parse::reflect_off_func()': "
                << "`plane_path' == 0."
                << endl 
                << "Deleting `object', `direction', and `pv' "
                << "and returning 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete object;
      delete direction;
      delete pv;

      return 1;

    }  /* |if (plane_path == 0)|  */@;

@q ***** (5) Check |direction|.@> 
@ Check |direction|.
\initials{LDF 2004.12.04.}

@q ****** (6) Error handling:  |direction == 0|. Delete |object|, @> 
@q ****** (6) plane_path|, and |pv| and return 1.         @> 

@ Error handling:  |direction == 0|.  Delete |object|, |plane_path| 
and |pv| and return 1.
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.12.08.}
Now deleting |reflection|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>= 

  if (direction == static_cast<Point*>(0))
     {
         cerr_strm << thread_name 
                   << "ERROR! In `Scan_Parse::reflect_off_func()': "
                   << "`direction' == 0."
                   << endl 
                   << "Deleting `object', `plane_path',  and "
                   << "`pv' and returning 1.";

      log_message(cerr_strm);
      cerr_message(cerr_strm, error_stop_value);
      cerr_strm.str("");
      
      delete object;
      delete plane_path;
      delete pv;

      return 1;

    }  /* |if (direction == 0)|  */@;



@q ****** (6) Error handling:  |plane_path| is non-planar.@> 

@ Error handling:  |plane_path| is non-planar.
\initials{LDF 2004.12.08.}

\LOG
\initials{LDF 2004.12.08.}
Now deleting |reflection|.
\ENDLOG 

@<Define |Scan_Parse| template functions@>= 


    if (!plane_path->is_planar())
      {

        cerr_strm << thread_name 
                  << "ERROR! In `Scan_Parse::reflect_off_func()': "
                  << "`plane_path->is_planar()' == `false'."
                  << endl 
                  << "Deleting `object', `plane_path', `direction', "
                  << "and `pv' and returning 1.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
        
        delete object;
        delete plane_path;
        delete direction;
        delete pv;

        return 1;
      
      }  /* |if (!plane_path->is_planar())|  */


@q ****** (6) |plane_path->is_planar|.@> 

@ |plane_path->is_planar|.
\initials{LDF 2004.12.04.}

@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
    else if (DEBUG)   
       {
           cerr_strm << thread_name << "`Scan_Parse::reflect_off_func()':"
                     << "`plane_path->is_planar()' == `true'.";

           log_message(cerr_strm);
           cerr_message(cerr_strm);
           cerr_strm.str("");
       }
#endif /* |DEBUG_COMPILE|  */ 

@q ***** (5) Call |object->reflect_off|.@> 
@ Call |object->reflect_off|.
\initials{LDF 2004.12.04.}

\LOG
\initials{LDF 2004.12.08.}
No longer calling |C::reflect_off| in a |try| block and catching
|bad_alloc|.  |Point::reflect_off| no longer tries to allocate
memory for |reflection| if the latter is null, 
so it never throws |bad_alloc|.  I haven't yet defined 
|reflect_off| functions for any other types, but they won't either. 
\ENDLOG 

@<Define |Scan_Parse| template functions@>=


  int status = object->reflect_off(plane_path->get_plane(),
                                   *direction,
                                   static_cast<void*>(pv),
                                   scanner_node); 



@q ****** (6) Error handling:  |status != 0|.@>  

@ Error handling:  |status != 0|.
\initials{LDF 2004.12.04.}

@<Define |Scan_Parse| template functions@>=

  if (status != 0)
     {

        cerr_strm << thread_name 
                  << "ERROR! In `Scan_Parse::reflect_off_func()': "
                  << "`object->reflect_off()' failed and returned " 
                  << status << "."
                  << endl 
                  << "Deleting `object', `plane_path', and `direction' and "
                  << "exiting function with return value 1.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");
        
        delete object;
        delete plane_path;
        delete direction;

        return 1;
        
     } /* |if (status != 0)|  */


@q ***** (5) Delete |object|, |plane_path|, and |direction|     @> 
@q ***** (5) and exit function successfully with return value 0.@> 

@ Delete |object|, |plane_path|, and |direction|    
@ and exit function successfully with return value 0.
\initials{LDF 2004.12.04.}

@<Define |Scan_Parse| template functions@>=

  delete object;
  delete plane_path;
  delete direction;

#if DEBUG_COMPILE
   if (DEBUG)
     {

        cerr_mutex.lock(); 
        cerr_strm << thread_name 
                   << "In `Scan_Parse::reflect_off_func()': "
                   << "`object->reflect_off()' succeeded." << endl;


        if (pv == static_cast<Pointer_Vector<C>*>(0))
           cerr_strm << "`pv' == 0." << endl;
        else 
           cerr_strm << "`pv' != 0." << endl;

        log_message(cerr_strm);
        cerr << cerr_strm.str();
        cerr_strm.str("");

        if (pv != static_cast<Pointer_Vector<C>*>(0))
           pv->show("pv in `Scan_Parse::reflect_off_func()':");

        cerr_mutex.unlock(); 
     }
#endif /* |DEBUG_COMPILE|  */@; 
 

  return 0;

} /* End of |Scan_Parse::reflect_off_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2004.09.08.}

\LOG
\initials{LDF 2004.09.08.}
Added this section with declarations for the versions of this function 
with |Point| and |Path| as the template type parameters.

\initials{LDF 2004.12.09.}
Changed the |C* reflection| argument to |Point_Vector<C>* pv|.
It's passed to |C::reflect_off|.  

\initials{LDF 2005.01.18.}
Added declaration for the version of this function 
with |Focus| as the template type parameter.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

int
reflect_off_func(Scanner_Node scanner_node,
                 Point* object,
                 Path* plane_path,
                 Point* direction,
                 Pointer_Vector<Point>* pv);

int
reflect_off_func(Scanner_Node scanner_node,
                 Path* object,
                 Path* plane_path,
                 Path* direction,
                 Pointer_Vector<Path>* pv);


int
reflect_off_func(Scanner_Node scanner_node,
                 Path* object,
                 Path* plane_path,
                 Path* direction,
                 Pointer_Vector<Focus>* pv);

@q *** (3) |pickup_command|.@> 




@*2 {\bf pickup\_command}.
\initials{LDF 2004.11.13.}

\LOG
\initials{LDF 2004.11.13.}
Added this function.
\ENDLOG

@q **** (4) Definition.@>

@<Define |Scan_Parse| template functions@>=
template<class C>
int
Scan_Parse::pickup_command(Scanner_Node scanner_node,
                           C* expression,
                           C** pointer)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
  bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

  stringstream cerr_strm;

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5).@>

@q ***** (5) Error handling:  |expression == 0|.@>   

@ Error handling:  |expression == 0|.
\initials{LDF 2004.11.12.}

\LOG
\initials{LDF 2004.11.12.}
Added this section.
\ENDLOG


@<Define |Scan_Parse| template functions@>=

   if (expression == static_cast<C*>(0))
     {
        cerr_strm << thread_name << "ERROR! In `Scan_Parse::pickup_command<C>()':"
                  << endl << "`C* expression' is null. "
                  << "Not changing `C** pointer' and exiting function "
                  << "with return value 1.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        return 1;

     }  /* |if (expression == 0)|  */

@q ***** (5) |expression != 0|.@>   

@ |expression != 0|.
\initials{LDF 2004.11.12.}


@<Define |Scan_Parse| template functions@>=
   else /* |expression != 0|  */
      {
         C* q = *pointer;

@q ****** (6) |q == 0|.  Try to allocate memory for a new |C|.@> 
@ |q == 0|.  Try to allocate memory for a new |C|.
\initials{LDF 2004.11.12.}

\LOG
\initials{LDF 2004.11.12.}
Added this section.
\ENDLOG

@<Define |Scan_Parse| template functions@>=
         if (q == static_cast<C*>(0))
            {
               try 
                  {
                     q = create_new<C>(0);
                  }

@q ******* (7).@> 

               catch (bad_alloc)
                  {
                      cerr_strm << thread_name 
                                << "ERROR! In `Scan_Parse::pickup_command<C>()':"
                                << endl << "`create_new<C>()' failed. "
                                << "Deleting `C*_expression' and "
                                << "rethrowing `bad_alloc'.";

                      log_message(cerr_strm);
                      cerr_message(cerr_strm, error_stop_value);
                      cerr_strm.str("");                     

                      delete expression;

                      throw;

                  }  /* |catch (bad_alloc)|  */
                 
@q ******* (7).@> 

               *pointer = q;

            }  /* |if (q == 0)|  */


@q ****** (6).@> 

         *q = *expression;

         delete expression;

      }   /* |else| (|expression != 0|)  */


    return 0;

}   /* End of |Scan_Parse::pickup_command| definition.  */   

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.

\LOG
\initials{LDF 2004.11.13.}
Added this section.
\ENDLOG

@<Declare |Scan_Parse| functions@>=

int
pickup_command(Scanner_Node scanner_node,
               Color* expression,
               Color** pointer);

int
pickup_command(Scanner_Node scanner_node,
               Dash_Pattern* expression,
               Dash_Pattern** pointer);

int
pickup_command(Scanner_Node scanner_node,
               Pen* expression,
               Pen** pointer);


@q *** (3) |drop_command|.@> 

@*2 {\bf drop\_command}.
\initials{LDF 2004.11.14.}

\LOG
\initials{LDF 2004.11.14.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
int
Scan_Parse::drop_command(Scanner_Node scanner_node,
                         C** pointer,
                         string pointer_name)
{
                

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;


@q ***** (5) WARNING:  |*pointer == 0|.@>   

@ WARNING:  |*pointer == 0|.
\initials{LDF 2004.11.14.}

@<Define |Scan_Parse| template functions@>=

   if (*pointer == static_cast<C*>(0))
      {

          cerr_strm << thread_name << "WARNING!  In "
                    << "Scan_Parse::drop_command():"
                    << endl 
                    << "`*" << pointer_name << "' is null.  "
                    << "Can't drop.";

          log_message(cerr_strm);
          cerr_message(cerr_strm, warning_stop_value);
          cerr_strm.str();

      } /* |if (*pointer == 0)|  */

@q ***** (5) |*pointer != 0|.@>   

@ |*pointer != 0|.
\initials{LDF 2004.11.14.}

@<Define |Scan_Parse| template functions@>=

   else /* |*pointer != 0|  */
      {
         delete *pointer; 
         *pointer = 0; 

      }  /* |else| (|*pointer != 0|)  */

@q ***** (5) .@> 

   return 0;
  

}  /* End of |Scan_Parse::drop_command| definition.  */
   

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2004.11.14.}

\LOG
\initials{LDF 2004.11.14.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

int
drop_command(Scanner_Node scanner_node,
             Color** pointer,
             string pointer_name);

int
drop_command(Scanner_Node scanner_node,
             Dash_Pattern** pointer,
             string pointer_name);

int
drop_command(Scanner_Node scanner_node,
             Pen** pointer,
             string pointer_name);



@q *** (3) |sub_binary_number_string_func|.@> 

@*2 {\bf sub\_binary\_number\_string\_func}.
\initials{LDF 2005.09.09.}

\LOG
\initials{LDF 2005.09.09.}
Added this function.

\initials{LDF 2005.09.10.}
Added code for handling numbers that need to be represented 
as |long longs|.  However, GCC interprets some |reals| 
that are actually less than or equal to |ULONG_LONG_MAX| 
and greater than or equal to |ULONG_LONG_MIN| as lying outside
of these limits.  I assume this has to do with the way floating
point numbers are represented.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
string*
Scan_Parse::sub_binary_number_string_func(C c, 
                              bool oversize_switch,
                              Scanner_Node scanner_node)
{
                

@q ***** (5) Preliminaries.@> 

  bool DEBUG = false; /* |true|  */

  bool error_stop_value   = true;
  bool warning_stop_value = true;
  string thread_name      = "";

  if (scanner_node)
     scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                   &error_stop_value,
                                                   &warning_stop_value);

  stringstream cerr_strm;

@q ***** (5)@>  

   unsigned int size = sizeof(C) * CHAR_BIT;

   bitset<sizeof(C) * CHAR_BIT> b;

   string* s = new string;
   stringstream t;


@q ***** (5)@>  

   if (oversize_switch)
      {

#if DEBUG_COMPILE
         if (DEBUG)
           {
                cerr_strm << thread_name 
                          << "In `sub_binary_number_string_func()':"
                          << endl 
                          << "`oversize_switch == true'."
                          << endl;

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");
           }   


#endif /* |DEBUG_COMPILE|  */@; 
 

          int i;
   
#if DEBUG_COMPILE
         if (DEBUG)
            {
                cerr_strm << thread_name 
                          << "In `sub_binary_number_string_func()':"
                          << endl 
                          << "c (hex) == " << hex << c << endl;

                log_message(cerr_strm);
                cerr_message(cerr_strm);
                cerr_strm.str("");

            }
#endif /* |DEBUG_COMPILE|  */@; 
 
          long long llng_0 = c;
          long long llng_1 = c;

          long long pattern = 0;

          for (i = 0; i < size / 2; ++i)
             {
                pattern <<= 1;
                pattern += 1;
             }

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "pattern (hex) == " << hex << pattern 
                       << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 


          for (i = size / 2; i < size; ++i)
             {
                pattern <<= 1;
             }

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "pattern (hex) == " << hex << pattern 
                       << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 
          llng_0 &= pattern;

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "llng_0 (hex) after &=:  " << hex << llng_0 
                       << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 


          llng_0 >>= size / 2;
 
#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "llng_0 (hex) after >>=:  " << hex << llng_0 
                       << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 

          llng_0 &= ~pattern;


#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "llng_0 (hex) after &=:  " << hex << llng_0 
                       << endl
                       << "llng_1 (hex)" << hex << llng_1 << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 
 

@q **** (4) @>   

          llng_1 &= ~pattern;

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "llng_1 (hex) after &=" << hex << llng_1 
                       << endl;

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 


          long lng_0 = static_cast<long>(llng_0);
          long lng_1 = static_cast<long>(llng_1);

          b = lng_0;

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "`b' == " << b << endl; 

             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 

         
          b <<= size / 2;

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "`b' == " << b << endl; 


             log_message(cerr_strm);
             cerr_message(cerr_strm);
             cerr_strm.str("");

        }
#endif /* |DEBUG_COMPILE|  */@; 


          b |= lng_1;           

#if DEBUG_COMPILE
      if (DEBUG)
        {
             cerr_strm << thread_name 
                       << "In `sub_binary_number_string_func()':"
                       << endl 
                       << "`b' == " << b << endl; 
        }
#endif /* |DEBUG_COMPILE|  */@; 


      }  /* |if (oversize_switch)|  */
   
@q ***** (5)@>  

   else  /* |!oversize_switch|  */

      b = c;


@q ***** (5)@>  

   t << b;
  
   *s = t.str();

   return s;  

@q ***** (5)@>  

}  /* End of |Scan_Parse::sub_binary_number_string_func| 
      definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.09.09.}

\LOG
\initials{LDF 2005.09.09.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

string*
sub_binary_number_string_func(short c, 
                              bool oversize_switch,
                              Scanner_Node scanner_node);

string*
sub_binary_number_string_func(int c, 
                              bool oversize_switch,
                              Scanner_Node scanner_node);

string*
sub_binary_number_string_func(long c, 
                              bool oversize_switch,
                              Scanner_Node scanner_node);

string*
sub_binary_number_string_func(long long c, 
                              bool oversize_switch,
                              Scanner_Node scanner_node);



@q *** (3) Get |Point|.@> 
@*2 Get {\bf Point}.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.  It contains code taken from the parser rule
\point primary> $\longrightarrow$ \.{GET\_POINT} 
\.{numeric\_secondary} \path primary> in \filename{ppntexpr.w}.

\initials{LDF 2005.11.09.}
Now calling |c->get_last_point|, if |r == MAX_REAL|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::get_point_func(real r, C* c, void* parameter)
{

    Point* p = create_new<Point>(0, static_cast<Scanner_Node>(parameter));

    *p = (r == MAX_REAL) ?   c->get_last_point() 
                           : c->get_point(
                                static_cast<unsigned short>(
                                   floor(fabs(r) + .5))); 

@q ***** (5) Error handling:  |get_point| returned |INVALID_POINT|.@>   

@ Error handling:  |get_point| returned |INVALID_POINT|.
\initials{LDF 2004.10.20.}

@<Define |Scan_Parse| template functions@>=

    if (*p == INVALID_POINT)
      {

           delete p;
 
           delete c;
   
           return 0;

      } /* |if (*p == INVALID_POINT)|  */

@q ***** (5) Delete |c|, set |point_primary| to @>   
@q ***** (5) |static_cast<void*>(p)|, and exit function successfully.@>   

@ Delete |c|, set |point_primary| to |static_cast<void*>(p)|, 
and function rule successfully.
\initials{LDF 2004.10.20.}

@<Define |Scan_Parse| template functions@>=

   else /* |*p != INVALID_POINT|  */
     {
        delete c;

        return static_cast<void*>(p);

     }  /* |else| (|*p != INVALID_POINT|)  */

}  /* End of |Scan_Parse::get_point_func| definition.  */


@q **** (4) Specialization for |Conic_Section_Lattice|.@> 
@ Specialization for {\bf Conic\_Section\_Lattice}.
\initials{LDF 2007.08.03.}

\LOG
\initials{LDF 2007.08.03.}
Added this function specialization.
\ENDLOG

@<Define |Scan_Parse| functions@>=
template <>
void*
Scan_Parse::get_point_func<Conic_Section_Lattice>(real r, 
                           Conic_Section_Lattice* c, 
                           void* parameter)
{

@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5)@> 
@
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Entering `Scan_Parse::get_point_func'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 


@q ***** (5) Error handling:  |c == 0|.@> 
@ Error handling:  |c == 0|.
\initials{LDF 2007.08.03.}

@<Define |Scan_Parse| functions@>=

    if (c == static_cast<Conic_Section_Lattice*>(0))
    {
        
        cerr_strm << thread_name << "ERROR! In `Scan_Parse::get_point_func':"
                  << endl 
                  << "`Conic_Section_Lattice*' is null.  "
                  << "Exiting function unsuccessfully with return value "
                  << "`(void*) 0'.";

        log_message(cerr_strm);
        cerr_message(cerr_strm, error_stop_value);
        cerr_strm.str("");

        delete scanner_node->conic_section_lattice_options;
        scanner_node->conic_section_lattice_options = 0;
  
        return 0;
    }

@q ***** (5)@> 
@
@<Define |Scan_Parse| functions@>=

    Conic_Section_Lattice_Options* opt = 0;
    
    if (scanner_node && scanner_node->conic_section_lattice_options)
       opt = scanner_node->conic_section_lattice_options;

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_mutex.lock(); 
      cerr << thread_name << "In `Scan_Parse::get_point_func':" << endl;

       if (opt) 
          opt->show("`opt':");

       else
          cerr_strm << "`opt' is null." << endl;

       cerr_mutex.unlock();  

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5)@> 
@
@<Define |Scan_Parse| functions@>=

    Point* p = 0;
    real*  q = 0;

    if (opt->increment_vector.size() > 0)
       q = new real(opt->increment_vector.back());

    if (opt)
       p = c->get_point(scanner_node, 
                        opt->cycle_value,
                        q, 
                        opt->do_shift,
                        opt->lattice_point_flag);
     else 
       p = c->get_point(scanner_node);

@q ***** (5)@> 
@
@<Define |Scan_Parse| functions@>=


    if (scanner_node)
    {
        delete scanner_node->conic_section_lattice_options;
        scanner_node->conic_section_lattice_options = 0;
    }

@q ***** (5)@> 
@
@<Define |Scan_Parse| functions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr_strm << thread_name << "Exiting `Scan_Parse::get_point_func'.";

      log_message(cerr_strm);
      cerr_message(cerr_strm);
      cerr_strm.str("");

   }  /* |if (DEBUG)|  */

#endif /* |DEBUG_COMPILE|  */@; 

    return static_cast<void*>(p);

}  /* End of |Scan_Parse::get_point_func<Conic_Section_Lattice>| definition.  */



@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
get_point_func(real r, Path* c, void* parameter = 0);

void*
get_point_func(real r, Ellipse* c, void* parameter = 0);

void*
get_point_func(real r, Circle* c, void* parameter = 0);

void*
get_point_func(real r, Parabola* c, void* parameter = 0);

void*
get_point_func(real r, Hyperbola* c, void* parameter = 0);

void*
get_point_func(real r, Polygon* c, void* parameter = 0);

void*
get_point_func(real r, Reg_Polygon* c, void* parameter = 0);

void*
get_point_func(real r, Triangle* c, void* parameter = 0);

void*
get_point_func(real r, Rectangle* c, void* parameter = 0);


@q *** (3) |get_center_func|.@> 

@*2 {\bf get\_center\_func}.
\initials{LDF 2005.10.25.}

\LOG
\initials{LDF 2005.10.25.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::get_center_func(C* c, void* parameter)
{

    Point* p  = create_new<Point>(0);

    *p = c->get_center(); 

    delete c;
    c = 0;

    return static_cast<void*>(p);

}  /* End of |Scan_Parse::get_center_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.25.}

\LOG
\initials{LDF 2005.10.25.}
Added this section.

\initials{LDF 2006.11.06.}
Added declarations for |Cylinder| and |Ellipsoid|.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
get_center_func(Ellipse* e, void* parameter = 0);

void*
get_center_func(Circle* c, void* parameter = 0);

void*
get_center_func(Polygon* p, void* parameter = 0);

void*
get_center_func(Reg_Polygon* rp, void* parameter = 0);

void*
get_center_func(Rectangle* r, void* parameter = 0);

void*
get_center_func(Triangle* t, void* parameter = 0);

void*
get_center_func(Cuboid* c, void* parameter = 0);

void*
get_center_func(Polyhedron* p, void* parameter = 0);

void*
get_center_func(Sphere* s, void* parameter = 0);

void*
get_center_func(Ellipsoid* e, void* parameter = 0);

void*
get_center_func(Cylinder* c, void* parameter = 0);


@q *** (3) |normal_func|.@> 
@*2 {\bf normal\_func}.
\initials{LDF 2005.12.09.}

\LOG
\initials{LDF 2005.12.09.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::normal_func(C* c, Scanner_Node scanner_node)
{

@q **** (4) Error handling:  |c == 0|.@>   
@ Error handling:  |c == 0|.
\initials{LDF 2004.10.06.}

@<Define |Scan_Parse| template functions@>=

  if (c == static_cast<C*>(0))
    {

      return 0;

    }  /* |if (c == 0)|  */

@q **** (4) Error handling:  |c| is non-planar.@>   
@ Error handling:  |c| is non-planar.
\initials{LDF 2004.10.06.}

@<Define |Scan_Parse| template functions@>=

  else if (!c->is_planar())
    {

      delete c;
      c = 0;

      return 0;


    }  /* |else if (!c->is_planar())|  */



@q **** (4) |c| is planar.@>   
@ |c| is planar.
\initials{LDF 2004.10.06.}

@<Define |Scan_Parse| template functions@>=

  else /* |c && c->is_planar|  */
    {
 
      Point* p = create_new<Point>(0, scanner_node);
      
      *p = c->get_normal();

      delete c;
      c = 0;

      return static_cast<void*>(p); 

    }   /* |else| (|c && c->is_planar|)  */

}  /* End of |Scan_Parse::normal_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.12.09.}

\LOG
\initials{LDF 2005.12.09.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
normal_func(Path* c, void* parameter = 0);

void*
normal_func(Ellipse* c, void* parameter = 0);

void*
normal_func(Circle* c, void* parameter = 0);

void*
normal_func(Parabola* c, void* parameter = 0);

void*
normal_func(Hyperbola* c, void* parameter = 0);

void*
normal_func(Polygon* c, void* parameter = 0);

void*
normal_func(Reg_Polygon* c, void* parameter = 0);

void*
normal_func(Rectangle* c, void* parameter = 0);

void*
normal_func(Triangle* c, void* parameter = 0);

@q *** (3) |get_focus_func|.@> 

@*2 {\bf get\_focus\_func}.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.

\initials{LDF 2005.11.14.}
Changed the name of this function from |get_focus0_func| to |get_focus_0_func|.
Now calling |c->get_focus_0| instead of |c->get_focus0|.

\initials{LDF 2005.11.17.}
Changed the name of this function from |get_focus_0_func| to |get_focus_func|.
Now calling |c->get_focus| instead of |c->get_focus_0|.
Added optional |const unsigned short s| argument with the default 0.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::get_focus_func(C* c, const unsigned short s, void* parameter)
{

    Point* p  = create_new<Point>(0);

    *p = c->get_focus(s, static_cast<Scanner_Node>(parameter)); 

    delete c;
    c = 0;

    return static_cast<void*>(p);

}  /* End of |Scan_Parse::get_focus_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
get_focus_func(Ellipse* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Circle* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Parabola* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Hyperbola* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Ellipsoid* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Sphere* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Paraboloid* c, const unsigned short s = 0, void* parameter = 0);

void*
get_focus_func(Hyperboloid* c, const unsigned short s = 0, void* parameter = 0);


@q *** (3) |get_vertex_func|.@> 

@*2 {\bf get\_vertex\_func}.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this function.

\initials{LDF 2005.11.14.}
Changed the name of this function from |get_vertex_func| to |get_vertex_0_func|.
Now calling |c->get_vertex_0| instead of |c->get_vertex|.

\initials{LDF 2005.11.17.}
Changed the name of this function from |get_vertex_0_func| back 
to |get_vertex_func|.  Now calling |c->get_vertex| instead of |c->get_vertex_0|.
Added optional |const unsigned short s| argument with the default 0.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::get_vertex_func(C* c, const unsigned short s, void* parameter)
{

    Point* p  = create_new<Point>(0);

    *p = c->get_vertex(s, static_cast<Scanner_Node>(parameter)); 

    delete c;
    c = 0;

    return static_cast<void*>(p);

}  /* End of |Scan_Parse::get_vertex_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.09.}

\LOG
\initials{LDF 2005.11.09.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
get_vertex_func(Ellipse* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Circle* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Parabola* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Hyperbola* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Ellipsoid* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Sphere* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Paraboloid* c, const unsigned short s = 0, void* parameter = 0);

void*
get_vertex_func(Hyperboloid* c, const unsigned short s = 0, void* parameter = 0);

@q *** (3) |is_whatever_func|.@> 

@*2 {\bf is\_whatever\_func}.
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::is_whatever_func(C* c, void* parameter)
{

   bool* b = new bool;
 
   *b = (c && c->is_whatever(static_cast<Scanner_Node>(parameter))); 

   return static_cast<void*>(b);

}  /* End of |Scan_Parse::is_whatever_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.26.}

\LOG
\initials{LDF 2005.10.26.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
is_whatever_func(Point* c, void* parameter = 0);

void*
is_whatever_func(Nurb* c, void* parameter = 0);

void*
is_whatever_func(Path* c, void* parameter = 0);

void*
is_whatever_func(Ellipse* c, void* parameter = 0);

void*
is_whatever_func(Circle* c, void* parameter = 0);

void*
is_whatever_func(Polygon* c, void* parameter = 0);

void*
is_whatever_func(Reg_Polygon* c, void* parameter = 0);

void*
is_whatever_func(Rectangle* c, void* parameter = 0);

void*
is_whatever_func(Triangle* c, void* parameter = 0);

void*
is_whatever_func(Cuboid* c, void* parameter = 0);

void*
is_whatever_func(Polyhedron* c, void* parameter = 0);

void*
is_whatever_func(Sphere* c, void* parameter = 0);


@q *** (3) Standardize.@> 
@*2 Standardize.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this function.

\initials{LDF 2005.11.27.}
Changed to account for the fact that the |standardize| functions 
for the conic section types now return a |Transform*| 
rather than a |Transform|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=
template<class C>
void*
Scan_Parse::standardize_func(C* c, void* v)
{
   if (c == static_cast<C*>(0))
      return 0;

   Transform* t = c->standardize(static_cast<Scanner_Node>(v));

   delete c;
   c = 0;

   return static_cast<void*>(t); 

}

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.18.}

\LOG
\initials{LDF 2005.11.18.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
standardize_func(Ellipse* c, void* v);

void*
standardize_func(Circle* c, void* v);

void*
standardize_func(Parabola* c, void* v);

void*
standardize_func(Hyperbola* c, void* v);

#if 0 
void*
standardize_func(Polygon* c, void* v);

void*
standardize_func(Reg_Polygon* c, void* v);

void*
standardize_func(Rectangle* c, void* v);

void*
standardize_func(Triangle* c, void* v);

void*
standardize_func(Polyhedron* c, void* v);

void*
standardize_func(Ellipsoid* c, void* v);

void*
standardize_func(Sphere* c, void* v);
#endif 


@q *** (3) |intersection_points_func|.@> 

@*2 {\bf intersection\_points\_func}.
\initials{LDF 2005.10.27.}

\LOG
\initials{LDF 2005.10.27.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C, class D, class E>
void*
Scan_Parse::intersection_points_func(C* c, 
                                     D* d, 
                                     void* parameter, 
                                     E* e)
{

    E* return_value = 0;

    if (c && d)
       {
            return_value = new E;

            *return_value = c->intersection_points(*d, 
                                                   static_cast<Scanner_Node>(
                                                      parameter));
       }

    delete c;
    delete d;
    c = 0;
    d = 0;

    return static_cast<void*>(return_value);

}  /* End of |Scan_Parse::intersection_points_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.27.}

\LOG
\initials{LDF 2005.10.27.}
Added this section.

\initials{LDF 2005.10.27.}
Added declaration for template instantiation for |Ellipse| and 
|Path| type arguments.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
intersection_points_func(Path* c, 
                         Path* d, 
                         void* parameter = 0,
                         Bool_Point* e = 0);

void*
intersection_points_func(Ellipse* c, 
                         Path* d, 
                         void* parameter = 0,
                         Bool_Point_Pair* e = 0);

@q *** (3) |conic_section_line_intersection_func|.@> 
@*2  {\bf conic\_section\_line\_intersection\_func}.
\initials{LDF 2005.11.17.}

\LOG
\initials{LDF 2005.11.17.}
Added this function.

\initials{LDF 2005.11.21.}
Changed the type of the object pointed to by the |void*| return value from 
|Pointer_Vector<Point>| to |Pointer_Vector<Bool_Point>|.


\initials{LDF 2005.11.21.}
Changed the name of this function from |conic_section_line_intersection_func|
to |conic_section_intersection_func| and added a second 
template parameter.  Changed the |Path*| argument to 
a pointer to the type of the new template parameter.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=
template<class C, class D>
void*
Scan_Parse::conic_section_intersection_func(C* c, D* d, void* parameter)
{

    Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

    if (!(c && d))
       {
           delete c;
           c = 0;

           delete d;
           d = 0;
        
           return 0;

       }  /* |if (!(c && d))|  */


   
    Pointer_Vector<Bool_Point>* bpv = c->intersection_points(d, scanner_node);

    delete c;
    c = 0;

    delete d;
    d = 0;

    return static_cast<void*>(bpv);

}  /* End of |Scan_Parse::conic_section_intersection_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.17.}

\LOG
\initials{LDF 2005.11.17.}
Added this section.

\initials{LDF 2005.11.21.}
Added the declaration with a |Parabola*| and a |Plane*| argument.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
conic_section_intersection_func(Ellipse* c, Path* d, void* parameter);

void*
conic_section_intersection_func(Circle* c, Path* d, void* parameter);

void*
conic_section_intersection_func(Parabola* c, Path* d, void* parameter);

void*
conic_section_intersection_func(Hyperbola* c, Path* d, void* parameter);

void*
conic_section_intersection_func(Parabola* c, Plane* d, void* parameter);


@q *** (3) |ellipse_like_intersection_func|.@> 
@*2  {\bf ellipse\_like\_intersection\_func}.
\initials{LDF 2005.10.28.}

\LOG
\initials{LDF 2005.10.28.}
Added this function.

\initials{LDF 2005.10.28.}
@:BUG FIX@> BUG FIX:  Now deleting |C* c| and |D* d| and setting them to 0.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=
template<class C, class D>
void*
Scan_Parse::ellipse_like_intersection_func(C* c, D* d, void* parameter)
{

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (!(c && d))
      {
          delete c;
          c = 0;

          delete d;
          d = 0;
       
          return 0;

      }  /* |if (!(c && d))|  */

   Bool_Point_Quadruple bpq;
   bpq = c->intersection_points(*d, scanner_node);

   Pointer_Vector<Bool_Point>* bpv = new Pointer_Vector<Bool_Point>;

   Bool_Point* bp;

   bp = new Bool_Point;
   *bp = bpq.first;
   *bpv += bp;

   bp = new Bool_Point;
   *bp = bpq.second;
   *bpv += bp;

   bp = new Bool_Point;
   *bp = bpq.third;
   *bpv += bp;

   bp = new Bool_Point;
   *bp = bpq.fourth;
   *bpv += bp;

   delete c;
   c = 0;

   delete d;
   d = 0;


   return bpv;

}  /* End of |Scan_Parse::ellipse_like_intersection_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.28.}

\LOG
\initials{LDF 2005.10.28.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
ellipse_like_intersection_func(Ellipse* c, Ellipse* d, void* parameter);

void*
ellipse_like_intersection_func(Ellipse* c, Circle* d, void* parameter);

void*
ellipse_like_intersection_func(Circle* c, Ellipse* d, void* parameter);

void*
ellipse_like_intersection_func(Circle* c, Circle* d, void* parameter);


@q *** (3) |ellipse_like_plane_intersection_func|.@> 
@*2  {\bf ellipse\_like\_plane\_intersection\_func}.
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
void*
Scan_Parse::ellipse_like_plane_intersection_func(C* c, void* w, void* parameter)
{

    Plane* p = static_cast<Plane*>(w); 
      
    if (!(c && p))
       { 
           delete c;
           delete p;
           return 0;
       }

    Plane c_plane = c->get_plane();

    if (c_plane == INVALID_PLANE || *p == INVALID_PLANE)
       {
           delete c;
           delete p;
           return 0;
       }

    Pointer_Vector<Point>* pv = new Pointer_Vector<Point>;

    Line line = c_plane.intersection_line(*p);

    if (line == INVALID_LINE)
       { 
           delete c;
           delete p;
           return 0;
       }

    Bool_Point_Pair bpp = c->intersection_points(line.position, line.direction);

    Point* q = 0;

    if (bpp.first.pt != INVALID_POINT)
       {
           q = create_new<Point>(0);
           *q = bpp.first.pt;
           *pv += q;
       }

    if (bpp.second.pt != INVALID_POINT)
       {
           q = create_new<Point>(0);
           *q = bpp.second.pt;
           *pv += q;
       }

    if (pv->v.size() <= 0)
       {
           delete pv;
           delete c;
           delete p;
           return 0;
       }

    delete c;
    delete p;

    return static_cast<void*>(pv); 

}  /* End of |Scan_Parse::ellipse_plane_intersection_func| definition.  */ 

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.11.04.}

\LOG
\initials{LDF 2005.11.04.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
ellipse_like_plane_intersection_func(Ellipse* c, void* w, void* parameter = 0);

void*
ellipse_like_plane_intersection_func(Circle* c, void* w, void* parameter = 0);


@q *** (3) |conic_section_lattice_intersection_func|.@> 
@*2  {\bf conic\_section\_lattice\_intersection\_func}.
\initials{LDF 2007.08.17.}

\LOG
\initials{LDF 2007.08.17.}
Added this function.

\initials{LDF 2007.08.21.}
Added the |real| arguments |tolerance| and |increment|.
They're passed to |Conic_Section_Lattice::intersection_points|.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
void*
Scan_Parse::conic_section_lattice_intersection_func(
                                   Scanner_Node scanner_node,
                                   Conic_Section_Lattice* conic_section_lattice,
                                   C* c,
                                   real tolerance,
                                   real increment)
{
@q ***** (5) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;
   string thread_name      = "";

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

   using namespace Scan_Parse;

@q ***** (5) Error handling:  |conic_section_lattice| or |c| is null.@>

@ Error handling:  |conic_section_lattice| or |c| is null.
Delete them (in case one is not null) and return 0 immediately.
\initials{LDF 2007.08.21.}

\LOG
\initials{LDF 2007.08.21.}
Added this section.
\ENDLOG
@<Define |Scan_Parse| template functions@>=

    if (   conic_section_lattice == static_cast<Conic_Section_Lattice*>(0) 
        || c == static_cast<C*>(0))
    {
        delete conic_section_lattice;
        delete c;
        return 0;
    } 

@q ***** (5)@>

    Pointer_Vector<Bool_Point>* bpv 
       = conic_section_lattice->intersection_points(*c,
                                                    tolerance,
                                                    increment,
                                                    scanner_node);

    delete conic_section_lattice;
    delete c;

    return bpv;

}  /* End of |Scan_Parse::conic_section_lattice_intersection_func|
      definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2007.08.17.}

\LOG
\initials{LDF 2007.08.17.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
conic_section_lattice_intersection_func(Scanner_Node,
                                        Conic_Section_Lattice*,
                                        Path*);

void*
conic_section_lattice_intersection_func(Scanner_Node,
                                        Conic_Section_Lattice*,
                                        Ellipse*);

void*
conic_section_lattice_intersection_func(Scanner_Node,
                                        Conic_Section_Lattice*,
                                        Circle*);

void*
conic_section_lattice_intersection_func(Scanner_Node,
                                        Conic_Section_Lattice*,
                                        Polygon*);

void*
conic_section_lattice_intersection_func(Scanner_Node,
                                        Conic_Section_Lattice*,
                                        Reg_Polygon*);

@q *** (3) |polygon_like_intersection_func|.@> 
@*2  {\bf polygon\_like\_intersection\_func}.
\initials{LDF 2005.10.28.}

\LOG
\initials{LDF 2005.10.28.}
Added this function.
\ENDLOG

@q *** (3) Definition.@> 

@<Define |Scan_Parse| template functions@>=
template<class C, class D>
void*
Scan_Parse::polygon_like_intersection_func(C* c, D* d, void* parameter)
{

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter); 

   if (!(c && d))
      {
          delete c;
          c = 0;

          delete d;
          d = 0;
       
          return 0;

      }  /* |if (!(c && d))|  */


   vector<Point> v;
   v  = c->intersection_points(*d);

   Pointer_Vector<Point>* pv = new Pointer_Vector<Point>;

   *pv = v;

   delete c;
   c = 0;

   delete d;
   d = 0;

   return static_cast<void*>(pv);

}  /* End of |Scan_Parse::polygon_like_intersection_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.28.}

\LOG
\initials{LDF 2005.10.28.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
polygon_like_intersection_func(Polygon* c, Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Polygon* c, Reg_Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Polygon* c, Rectangle* d, void* parameter);

void*
polygon_like_intersection_func(Polygon* c, Triangle* d, void* parameter);


@q ***** (5).@> 

void*
polygon_like_intersection_func(Reg_Polygon* c, Reg_Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Reg_Polygon* c, Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Reg_Polygon* c, Rectangle* d, void* parameter);

void*
polygon_like_intersection_func(Reg_Polygon* c, Triangle* d, void* parameter);


@q ***** (5).@> 

void*
polygon_like_intersection_func(Rectangle* c, Rectangle* d, void* parameter);

void*
polygon_like_intersection_func(Rectangle* c, Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Rectangle* c,  Reg_Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Rectangle* c,  Triangle* d, void* parameter);


@q ***** (5).@> 

void*
polygon_like_intersection_func(Triangle* c, Triangle* d, void* parameter);


void*
polygon_like_intersection_func(Triangle* c, Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Triangle* c,  Reg_Polygon* d, void* parameter);

void*
polygon_like_intersection_func(Triangle* c,  Rectangle* d, void* parameter);


@q *** (3) |plane_cast_func|.@> 
@*2 {\bf plane\_cast\_func}.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this function.
\ENDLOG

@<Define |Scan_Parse| template functions@>=

template<class C>
void*
Scan_Parse::plane_cast_func(C* c, void* parameter) 
{
    if (c == static_cast<C*>(0))
       return 0;
    else if (!c->is_planar())
       {
          delete c;
          c = 0;
          return 0;
       }
    else
       { 
           Plane* p = new Plane;
           *p = c->get_plane();   
           delete c;
           c = 0;
           return static_cast<void*>(p); 
       }

}  /* End of |Scan_Parse::plane_cast_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
plane_cast_func(Path* c, void* parameter = 0);

void*
plane_cast_func(Ellipse* c, void* parameter = 0);

void*
plane_cast_func(Circle* c, void* parameter = 0);

void*
plane_cast_func(Polygon* c, void* parameter = 0);

void*
plane_cast_func(Reg_Polygon* c, void* parameter = 0);

void*
plane_cast_func(Rectangle* c, void* parameter = 0);

void*
plane_cast_func(Triangle* c, void* parameter = 0);

@q *** (3) |plane_assignment_func|.@> 
@*2 {\bf plane\_assignment\_func}.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this function.
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::plane_assignment_func(void* entry, C* c, void* parameter)
{
   if (c == static_cast<C*>(0))
      return 0;

   else if (!c->is_planar())
      {
         delete c;
         c = 0;
         return 0;
      }

   Plane* p = create_new<Plane>(0);

   *p = c->get_plane();

   Int_Void_Ptr ivp = assign_simple<Plane>(static_cast<Scanner_Node>(parameter),
                                            "Plane",
                                            entry,
                                            p);

   return ivp.v;

}  /* End of |Scan_Parse::plane_assignment_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.30.}

\LOG
\initials{LDF 2005.10.30.}
Added this section.
\ENDLOG 

@<Declare |Scan_Parse| functions@>=

void*
plane_assignment_func(void* entry, Path* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Ellipse* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Circle* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Polygon* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Reg_Polygon* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Rectangle* c, void* parameter = 0);

void*
plane_assignment_func(void* entry, Triangle* c, void* parameter = 0);


@q *** (3) |show_func|.@> 
@*2 {\bf show\_func}.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
\ENDLOG

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
int
Scan_Parse::show_func(C* c, string text, void* parameter)
{

@q **** (4) Preliminaries.@>   

#if DEBUG_COMPILE
   bool DEBUG = false; /* |true| */ @; 
#endif /* |DEBUG_COMPILE|  */@; 

   stringstream cerr_strm;

   bool error_stop_value   = true;
   bool warning_stop_value = true;

   string thread_name      = "";

   Scanner_Node scanner_node = static_cast<Scanner_Node>(parameter);

   if (scanner_node)
      scanner_node->get_thread_name_and_stop_values(&thread_name,
                                                    &error_stop_value,
                                                    &warning_stop_value);

@q **** (4).@>
@
@<Define |Scan_Parse| template functions@>=

#if DEBUG_COMPILE
  if (DEBUG)
        {
           cerr_strm << thread_name << "Entering `Scan_Parse::show_func().'";
           cerr_message(cerr_strm);
           cerr_strm.str("");
           cerr << "Type <RETURN> to continue." << endl;
           getchar(); 
        }
#endif /* |DEBUG_COMPILE|  */@; 



@q **** (4).@>

   string s;

   cerr_strm << thread_name << ">> ";

   if (c)
      {
          cerr_mutex.lock(); 
          cerr << cerr_strm.str();
          text += ":";
          c->show(text);
          log_message(cerr_strm);
          cerr_strm.str("");
          cerr_mutex.unlock(); 

      }  /* |if (p)|  */
 

   else  /* |!c|  */
     {
        cerr_strm << "(unknown " << text << ")";
        log_message(cerr_strm);
        cerr_message(cerr_strm);
        cerr_strm.str("");

     }  /* |else| (|!c|)  */

   return 0;

}  /* End of |Scan_Parse::show_func| definition.  */


@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
Added this section.

\initials{LDF 2005.11.14.}
Added declarations for versions with |Parabola*| and |Hyperbola*| arguments.

\initials{LDF 2005.12.01.}
Added declarations for versions with |Pointer_Vector<Ellipse>*|,
|Pointer_Vector<Circle>*|, |Pointer_Vector<Parabola>*|, 
|Pointer_Vector<Hyperbola>*|, |Pointer_Vector<Ellipsoid>*|, 
|Pointer_Vector<Sphere>*|, and |Pointer_Vector<Cuboid>*| arguments.

\initials{LDF 2007.10.13.}
Added declaration for version with |Pointer_Vector<Arc>*|.

\initials{LDF 2005.12.01.}
Added declarations for version with |Pointer_Vector<Sphere_Development>*|.
\ENDLOG 

\TODO
@q { @>
@:TO DO}{{\bf TO DO}@>
@q } @> 
@q !! TO DO:  @>
\initials{LDF 2005.10.31.}
These types require special handling:
|bool|,
|numeric|,
|string|,
|macro|.

\initials{LDF 2007.11.28.}
Added declarations for versions with 
|Matrix| and |Pointer_Vector<Matrix>*| as arguments.
\ENDTODO 

@q ***** (5) Declarations.@> 

@<Declare |Scan_Parse| functions@>=

int
show_func(Matrix* m, string text = "", void* parameter = 0);

int
show_func(Transform* c, string text = "", void* parameter = 0);

int
show_func(Color* c, string text = "", void* parameter = 0);

int
show_func(Dash_Pattern* c, string text = "", void* parameter = 0);

int
show_func(Pen* c, string text = "", void* parameter = 0);

int
show_func(Picture* c, string text = "", void* parameter = 0);

int
show_func(Glyph* c, string text = "glyph", void* parameter = 0);

int
show_func(Plane* c, string text = "", void* parameter = 0);

int
show_func(Origami_Figure* c, string text = "origami_figure", void* parameter = 0);

int
show_func(Focus* c, string text = "focus", void* parameter = 0);

int
show_func(Point* c, string text = "point", void* parameter = 0);

int
show_func(Bool_Point* c, string text = "bool_point", void* parameter = 0);

int
show_func(Path* c, string text = "", void* parameter = 0);

int
show_func(Ellipse* c, string text = "ellipse", void* parameter = 0);

int
show_func(Parabola* c, string text = "parabola", void* parameter = 0);

int
show_func(Hyperbola* c, string text = "hyperbola", void* parameter = 0);

int
show_func(Circle* c, string text = "circle", void* parameter = 0);

int
show_func(Arc* a, string text = "arc", void* parameter = 0);

int
show_func(Polygon* c, string text = "polygon", void* parameter = 0);

int
show_func(Reg_Polygon* c, string text = "reg_polygon", void* parameter = 0);

int
show_func(Rectangle* c, string text = "rectangle", void* parameter = 0);

int
show_func(Triangle* c, string text = "triangle", void* parameter = 0);

int
show_func(Cuboid* c, string text = "cuboid", void* parameter = 0);

int
show_func(Cylinder* c, string text = "cylinder", void* parameter = 0);

int
show_func(Sphere* s, string text = "sphere", void* parameter = 0);

int
show_func(Sphere_Development* s, string text = "sphere", void* parameter = 0);

int
show_func(Polyhedron* c, string text = "polyhedron", void* parameter = 0);

int
show_func(Ellipsoid* c, string text = "ellipsoid", void* parameter = 0);

int
show_func(Cone* c, string text = "cone", void* parameter = 0);

int
show_func(Helix* c, string text = "helix", void* parameter = 0);

int
show_func(Nurb* c, string text = "nurb", void* parameter = 0);

int
show_func(Ellipse_Slice* c, string text = "ellipse_slice", void* parameter = 0);

int
show_func(Circle_Slice* c, string text = "circle_slice", void* parameter = 0);

int
show_func(Polyhedron_Slice* c, 
                      string text = "polyhedron_slice", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Matrix>* c, 
          string text = "matrix_vector", 
          void* parameter = 0);

int
show_func(Pointer_Vector<Ellipse>* c, 
                      string text = "ellipse_vector", 
                      void* parameter = 0);


int
show_func(Pointer_Vector<Parabola>* c, 
                      string text = "parabola_vector", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Hyperbola>* c, 
                      string text = "hyperbola_vector", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Ellipsoid>* c, 
                      string text = "ellipsoid_vector", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Sphere>* s, 
                      string text = "sphere_vector", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Sphere_Development>* s, 
                      string text = "sphere_development_vector", 
                      void* parameter = 0);

int
show_func(Pointer_Vector<Cuboid>* c, 
                      string text = "Cuboid_vector", 
                      void* parameter = 0);



@q *** (3) |ellipsoid_like_plane_intersection_func|.@> 
@*2  {\bf ellipsoid\_like\_plane\_intersection\_func}.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
Added this function.
\ENDLOG 

@q **** (4) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template <class C>
void*
Scan_Parse::ellipsoid_like_plane_intersection_func(C* c, Plane* p, void* parameter)
{

    void* v = 0;

    if (c && p)
       {
           v = static_cast<void*>(c->intersection(*p, 
                                                  static_cast<Scanner_Node>(parameter)));

       }  /* |if (c && p)|  */

    delete c;
    c = 0;

    delete p;
    p = 0;

    return v;

}  /* End of |Scan_Parse::ellipsoid_like_plane_intersection_func| definition.  */

@q **** (4) Template function instantiations. @>
@*3 Template function instantiations.
\initials{LDF 2005.10.31.}

\LOG
\initials{LDF 2005.10.31.}
Added this section.
\ENDLOG 

@q ***** (5) Declarations.@> 

@<Declare |Scan_Parse| functions@>=

void*
ellipsoid_like_plane_intersection_func(Ellipsoid* c, 
                                       Plane* p, 
                                       void* parameter = 0);
void*
ellipsoid_like_plane_intersection_func(Sphere* c, 
                                       Plane* p, 
                                       void* parameter = 0);


@q *** (3) Functions for |Conic_Sections|.@> 
@*2 Functions for {\bf Conic\_Sections}.
\initials{LDF 2007.07.03.}

\LOG
\initials{LDF 2007.07.03.}
Added this section.
\ENDLOG

@q **** (4) Get |Conic_Section|.@> 
@*3 Get {\bf Conic\_Section}.
\initials{LDF 2007.07.03.}

\LOG
\initials{LDF 2007.07.03.}
Added this function.

\initials{LDF 2007.07.03.}
Added |const unsigned short conic_section_type| argument.

\initials{LDF 2007.07.15.}
Added |real tolerance| and |bool ignore_extra_points| arguments.  
They're passed to |Conic_Section::generate|.

\initials{LDF 2007.07.20.}
Added |bool test_points| argument.  It's passed to |Conic_Section::generate|.

\initials{LDF 2007.07.20.}
Added |bool rectify_points| argument.  It's passed to |Conic_Section::generate|.
\ENDLOG

@q ***** (5) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
void*
Scan_Parse::get_conic_section_func(Pointer_Vector<Point>* pv,
                                   int increment_value,
                                   const unsigned short conic_section_type,
                                   C* c,
                                   void* parameter,
                                   bool test_points,
                                   bool rectify_points,
                                   real tolerance,
                                   bool ignore_extra_points) 
{

   Path* p = Conic_Section::generate(pv, 
                                     increment_value, 
                                     conic_section_type, 
                                     parameter,
                                     test_points,
                                     rectify_points,
                                     tolerance, 
                                     ignore_extra_points);
                              
   C* q = create_new<C>(0);

   *static_cast<Path*>(q) = *p;

   delete p;
   p = 0; 

   return static_cast<void*>(q); 

}  /* End of |Scan_Parse::get_conic_section_func| definition.  */


@q ***** (5) Template function instantiations.@>
@*4 Template function instantiations.
\initials{LDF 2007.07.03.}

\LOG
\initials{LDF 2007.07.03.}
Added this section.

\initials{LDF 2007.07.15.}
@:BUG FIX@> BUG FIX:  Added |const unsigned short conic_section_type| 
argument.  This argument was already present in the other declarations
and the definition above.

\initials{LDF 2007.07.15.}
Added |real tolerance| and |bool ignore_extra_points| arguments.

\initials{LDF 2007.07.20.}
Added optional |bool test_points| argument with the default |true|.

\initials{LDF 2007.07.20.}
Added optional |bool rectify_points| argument with the default |true|.

\initials{LDF 2007.07.20.}
In the declarations of |Scan_Parse::get_conic_section|:
Changed the default value of |real tolerance| argument from |INVALID_REAL|
to -1.
\ENDLOG 

@q ****** (6) Declarations.@> 

@<Declare |Scan_Parse| functions@>=


#if 0
/* !! Porting:  LDF 2008.10.09.  */
void*
Scan_Parse::get_conic_section_func(Pointer_Vector<Point>* pv,
                                   int increment_value,
                                   const unsigned short conic_section_type,
                                   Ellipse* e,
                                   void* parameter = 0,
                                   bool test_points = true,
                                   bool rectify_points = true,
                                   real tolerance = -1,
                                   bool ignore_extra_points = true);

void*
Scan_Parse::get_conic_section_func(Pointer_Vector<Point>* pv,
                                   int increment_value,
                                   const unsigned short conic_section_type,
                                   Circle* c,
                                   void* parameter = 0,
                                   bool test_points = true,
                                   bool rectify_points = true,
                                   real tolerance = -1,
                                   bool ignore_extra_points = true);


void*
Scan_Parse::get_conic_section_func(Pointer_Vector<Point>* pv,
                                   int increment_value,
                                   const unsigned short conic_section_type,
                                   Parabola* p,
                                   void* parameter = 0,
                                   bool test_points = true,
                                   bool rectify_points = true,
                                   real tolerance = -1,
                                   bool ignore_extra_points = true);


void*
Scan_Parse::get_conic_section_func(Pointer_Vector<Point>* pv,
                                   int increment_value,
                                   const unsigned short conic_section_type,
                                   Hyperbola* h,
                                   void* parameter = 0,
                                   bool test_points = true,
                                   bool rectify_points = true,
                                   real tolerance = -1,
                                   bool ignore_extra_points = true);


#endif

@q *** (3) Functions for |Cuboids|.@> 
@*2 Functions for {\bf Cuboids}.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this section.
\ENDLOG

@q **** (4) Inscribed |Cuboid|.@> 
@*3 Inscribed {\bf Cuboid}.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this function.
\ENDLOG


@q ***** (5) Definition.@> 

@<Define |Scan_Parse| template functions@>=


template<class C>
void*
Scan_Parse::in_cuboid_func(C* c, void* parameter)
{

   if (c == static_cast<C*>(0))
      return 0;

   Cuboid* d = c->in_cuboid(static_cast<Scanner_Node>(parameter));   

   delete c;
   c = 0;

   return static_cast<void*>(d);

}  /* End of |Scan_Parse::in_cuboid_func| definition.  */


@q ***** (5) Template function instantiations. @>
@*4 Template function instantiations.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this section.
\ENDLOG 

@q ****** (6) Declarations.@> 

@<Declare |Scan_Parse| functions@>=

void*
in_cuboid_func(Ellipsoid* e, void* parameter = 0);

void*
in_cuboid_func(Sphere* s, void* parameter = 0);

@q **** (4) Surrounding |Cuboid|.@> 
@*3 Surrounding {\bf Cuboid}.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this function.
\ENDLOG


@q ***** (5) Definition.@> 

@<Define |Scan_Parse| template functions@>=

template<class C>
void*
Scan_Parse::out_cuboid_func(C* c, void* parameter)
{
   if (c == static_cast<C*>(0))
      return 0;

   Cuboid* d = c->out_cuboid(static_cast<Scanner_Node>(parameter));   

   delete c;
   c = 0;

   return static_cast<void*>(d);

}  /* End of |Scan_Parse::out_cuboid_func| definition.  */

@q ***** (5) Template function instantiations. @>
@*4 Template function instantiations.
\initials{LDF 2005.12.07.}

\LOG
\initials{LDF 2005.12.07.}
Added this section.
\ENDLOG 

@q ****** (6) Declarations.@> 

@<Declare |Scan_Parse| functions@>=

void*
out_cuboid_func(Ellipsoid* c, void* parameter = 0);

void*
out_cuboid_func(Sphere* c, void* parameter = 0);


@q * (1) Putting namespace Scan_Parse together.@>
@* Putting {\bf namespace Scan\_Parse} together.

\immediate\write\functexifile{^^JEnd of file:  scanprse.web^^J}

@q ** (2) This is what's compiled.@>
@ This is what's compiled.
@c
@<Include files@>@;
@<Preprocessor macro definitions@>@;
@<Declare |namespace Scan_Parse|@>@;
@<Define |struct Picture_Output_Arg_Type| functions@>@;
@<Define |Scan_Parse| functions@>@;
@<Define |Scan_Parse| template functions@>@;

@q **  (2) This is what's written to \filename{scanprse.h}. @>
@ This is what's written to \filename{scanprse.h}. 
@(scanprse.h@>=
@<Preprocessor macro definitions@>@;
@<|extern| |namespace Scan_Parse| declaration@>@;
@<Define |Scan_Parse| template functions@>@;



@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>


  
@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q run-cweave-on-file:"3DLDFprg.web" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
