
@q *** (3) path_vector_primary --> RESOLVE path_vector_variable TO numeric_expression resolve_option_list.@> 
@*2 \§path_vector_primary> $\longrightarrow$ \.{RESOLVE} \§path vector variable> \.{TO} \§numeric expression>
\§resolve option list>.
\initials{LDF 2022.01.25.}

!!PLEASE NOTE:  There is no corresponding ``resolve'' rule
for a |path_vector| with a pair of |numerical_expressions| as a ``subpath'' argument.
At the present time, I don't see a use for such a rule.  However, if I ever do, I can
easily add it.
\initials{LDF 2022.04.20.}

\LOG
\initials{LDF 2022.01.25.}
\ENDLOG

@<Define rules@>=
@=path_vector_primary: RESOLVE path_vector_variable TO numeric_expression resolve_option_list@>@/
{
@q **** (4) @>

  @<Common declarations for rules@>@; 

#if DEBUG_COMPILE
  DEBUG = true; /* |false| */ @; 
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `path_vector_primary --> RESOLVE path_vector_variable TO "
              << "numeric_expression resolve_option_list'.";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>

  entry = static_cast<Id_Map_Entry_Node>(@=$2@>); 

  bool save             = @=$5@> &  1U; 
  bool with_transform   = @=$5@> &  2U; 
  bool with_ampersand   = @=$5@> &  4U; 
  bool test_planar      = @=$5@> &  8U; 
  bool make_planar      = @=$5@> & 16U; 



@q **** (4) @>


  status = static_cast<Pointer_Vector<Path>*>(entry->object)->resolve(
                                                                 static_cast<int>(@=$4@>), 
                                                                 0,
                                                                 -1,
                                                                 scanner_node,
                                                                 !save,
                                                                 with_transform,
                                                                 test_planar,
                                                                 make_planar,
                                                                 with_ampersand);

@q **** (4) @>

  if (status != 0)
  {
     cerr_strm << "ERROR!  In parser, rule `path_vector_primary --> RESOLVE path_vector_variable"
               << endl 
               << "TO numeric_expression save_temp_file_optional resolve_option_list':"
               << endl 
               << "`Pointer_Vector<Path>::resolve' failed, returning " << status << "."
               << endl
               << "Failed to resolve `path'.  Continuing.";

     log_message(cerr_strm);
     cerr_message(cerr_strm);
     cerr_strm.str("");

  } /* |if (status != 0)| */

@q **** (4) @>

#if DEBUG_COMPILE
  else if (DEBUG)
  {
    cerr_strm << "*** Parser: `path_vector_primary --> RESOLVE path_vector_variable"
              << endl 
              << "TO numeric_expression save_temp_file_optional resolve_option_list':"
              << endl 
              << "`Pointer_Vector<Path>::resolve' succeeded, returning 0.";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>
    
  Pointer_Vector<Path> *pv = create_new<Pointer_Vector<Path> >(0);

  @=$$@> =  static_cast<void*>(pv);


};

