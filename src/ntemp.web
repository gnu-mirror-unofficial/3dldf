
@q ***** (5) @>

   if (!r.is_rectangular())
   {
       cerr << "ERROR!  In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`r.is_rectangular' failed.  `Path r' isn't rectangular."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;
   }

#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr << "In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`r.is_rectangular' succeeded.  `Path r' is rectangular."
            << endl;

   }  
#endif /* |DEBUG_COMPILE|  */@;

@q ***** (5) @>


@ Calculations of |beta| and |superness| in Emacs-Lisp:
{\tt (setq beta (expt 2 (/ -1 2.5))) 
(setq superness (/ -1 (/ (log 0.757858283255199) (log 2))))}
\initials{LDF 2022.04.26.}


(setq superness (expt 2 (/ -1 2.5))) 

@ The following is Emacs-Lisp code for calculating $\beta$ and $\superness$ 
when the other quantity is known.
\initials{LDF 2022.04.26.}

\begingroup
\obeylines
\obeyspaces
\tt 
;; set beta with superness known.
(progn
   ;; (setq superness 0.0)
   ;; (setq superness 2.5)
   ;; (setq superness 0.5)
    (setq superness 0.75)
   ;; (setq superness 0.757858283255199) ;; --> beta == 2.5, Piet Hein's value for the superegg.
   ;; (setq superness 1.0)               ;; --> beta == infinity (rectangle)
   (setq beta (/ -1 (/ (log superness) (log 2))))
)

;; set superness with beta known.
(progn
   (setq beta 0.757858283255199)
   (setq superness (/ -1 (/ (log beta) (log 2))))
)
\endgroup

@<Define |Path| functions@>=



@q ***** (5) @>
@
@<Define |Path| functions@>=


  /* !!START HERE:  LDF 2022.04.25.  Align rectangle along x-axis.  */ 

  Point origin(0, 0, 0);  

  Point center = r.get_point(0).mediate(r.get_point(2));
  Point normal = r.get_normal();

#if DEBUG_COMPILE
   if (DEBUG)
   { 
      center.show("center:");
      normal.show("normal:");
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Path| functions@>=

  Point up(       0.0,  1.0,  0.0);
  Point down(     0.0, -1.0,  0.0);    
  Point left(    -1.0,  0.0,  0.0);         
  Point right(    1.0,  0.0,  0.0);
  Point forwards( 0.0,  0.0,  1.0);
  Point backwards(0.0,  0.0, -1.0);

  Transform t;

  /* !!START HERE:  LDF 2022.04.25.  Test this.  Make sure all cases work right.  */

  if (normal == up)
  {
      cerr << "`normal' == `up'.  `r' lies right-side-up in the x-z plane." << endl;
  }

  else if (normal == down)
  {
      cerr << "`normal' == `down'.  `r' lies up-side-down in the x-z plane." << endl;
      t.rotate(180, 0);
      center *= r *= t;
     
  }

  else if (normal == left)
  {
      cerr << "`normal' == `left'.  `r' lies in the y-z plane, facing left." << endl;
      t.rotate(0, 0, 90);
      center *= r *= t;
  }

  else if (normal == right)
  {
      cerr << "`normal' == `right'.  `r' lies in the y-z plane, facing right." << endl;
      t.rotate(0, 0, -90);
      center *= r *= t;
  }

  else if (normal == forwards)
  {
      cerr << "`normal' == `forwards'.  `r' lies in the x-y plane, facing forwards." << endl;
      t.rotate(-90, 0, 0);
      center *= r *= t;
  }

  else if (normal == backwards)
  {
      cerr << "`normal' == `backwards'.  `r' lies in the x-y plane, facing backwards." << endl;
      t.rotate(90, 0, 0);
      center *= r *= t;
  }
  else
  {
     cerr << "`r' doesn't lie in one of the major planes." << endl;
     Path axis;
     Point s = normal;
     s.shift(center);
     axis += center;
     axis += s;
     axis += "--";

     t = axis.align_with_axis('y', scanner_node);
     center *= r *= t;
  }

  normal = r.get_normal();

  normal.show("normal after transformation, if any:");

  if (normal != up)
  {
       cerr << "ERROR!  In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`normal' is not equal to `up' after `r' has been transformed."
            << endl  
            << "`r' does not now lie right-side-up in the x-z plane."
            << endl 
            << "Can't generate superellipse."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       return 1;

  }
#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr << "In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`normal' == `up' after `r' has been transformed."
            << endl  
            << "`r' now lies right-side-up in the x-z plane."
            << endl 
            << "Will generate superellipse."
            << endl;
   
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) @>
@
@<Define |Path| functions@>=

   if (center != origin)
   {
       cerr << "In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`center' != `origin'.  Shifting." << endl;

       center *= r *= t.shift(-center);

       center.show("center after shift:");
       r.show("r after shift:");

   }  
#if DEBUG_COMPILE
   else if (DEBUG)
   { 
       cerr << "In `Superellipse::generate_path' with `Path' argument:"
            << endl
            << "`center' == `origin'.  Not shifting." << endl;
       
   }  
#endif /* |DEBUG_COMPILE|  */@; 

@q ***** (5) Align rectangle along the x-axis.  @>

@ Align rectangle along the x-axis.  
\initials{LDF 2022.04.26.}

@<Define |Path| functions@>=

  Point p0 = r.get_point(0);
  Point p1 = r.get_point(1);
  Point p2 = r.get_point(2);
  Point p3 = r.get_point(3);

  Point p4 = p1 - p0;
  p4.unit_vector(true);

  r.show("r:");
  p4.show("p4:");

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 


@q ***** (5) @>
@
@<Define |Path| functions@>=

    float x;
    float z;



    real a = 2.0;
    real b = 3.0;
 



    for (float f = 0.0; f <= 1; f += .1)
    {
       x = a * powf(cosf(f), (2.0F / beta));
       cerr << "x == " << x << endl;
       z = b * powf(sinf(f), (2.0F / beta));
       cerr << "z == " << z << endl << endl;

       

      

    }

cerr << "XXX Enter <RETURN> to continue: ";
getchar(); 




