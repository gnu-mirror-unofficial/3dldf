@q *** (3) command --> RESOLVE path_variable TO numeric_expression.@> 
@*2 \§command> $\longrightarrow$ \.{RESOLVE} \§path variable> \.{TO} \§numeric expression>.
\§resolve option list>.
\initials{LDF 2022.01.18.}

\LOG
\initials{LDF 2022.01.18.}
\ENDLOG

@<Define rules@>=
@=command: RESOLVE path_variable TO numeric_expression resolve_option_list@>@/
{
  @<Common declarations for rules@>@; 

#if DEBUG_COMPILE
  DEBUG = true; /* |false| */ @; 
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_variable TO numeric_expression "
              << "resolve_option_list'."; 

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");

    cerr << "resolve_option_list == " << @=$5@> << " == 0x" << hex << @=$5@> 
         << dec << endl;

cerr << "YYY Enter <RETURN> to continue: ";
getchar();  

  }
#endif /* |DEBUG_COMPILE|  */@;


  entry = static_cast<Id_Map_Entry_Node>(@=$2@>); 

  bool save             = @=$5@> &  1U; 
  bool with_transform   = @=$5@> &  2U; 
  bool with_ampersand   = @=$5@> &  4U; 
  bool test_planar      = @=$5@> &  8U; 
  bool make_planar      = @=$5@> & 16U; 

#if DEBUG_COMPILE
  if (DEBUG)
  { 
     cerr << "resolve_option_list == " << @=$5@> << " == 0x" << hex << @=$5@> 
          << dec << endl
          << "save == " << save << endl
          << "with_transform == " << with_transform << endl
          << "with_ampersand == " << with_ampersand << endl
          << "test_planar == " << test_planar << endl
          << "make_planar == " << make_planar << endl;

cerr << "ZZZ Enter <RETURN> to continue: ";
getchar();  

  }  
#endif /* |DEBUG_COMPILE|  */@; 

  status = static_cast<Path*>(entry->object)->resolve(static_cast<int>(@=$4@>), 
                                                 0,
                                                 -1,
                                                 scanner_node,
                                                 !save,
                                                 with_transform,
                                                 test_planar,
                                                 make_planar,
                                                 with_ampersand);

#if DEBUG_COMPILE
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_variable TO numeric_expression "
              << "resolve_option_list':"
              << endl 
              << "`Path::resolve' returned " << status << "." << endl;

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;
    
  @=$$@> =  static_cast<void*>(0);

};

@q *** (3) command: RESOLVE path_variable LEFT_PARENTHESIS numeric_expression COMMA   @>
@q         numeric_expression RIGHT_PARENTHESIS TO numeric_expression                 @>
@q         resolve_option_list                                                        @>

@ \§command> $\longrightarrow$ \.{RESOLVE} \§path variable> \.{LEFT\_PARENTHESIS} 
\§numeric expression> \.{COMMA} \§numeric expression> \.{RIGHT\_PARENTHESIS} 
\.{TO} \§numeric expression> \§resolve option list>.
\initials{LDF 2022.01.18.}

\LOG
\initials{LDF 2022.01.18.}
\ENDLOG

@<Define rules@>=
@=command: RESOLVE path_variable LEFT_PARENTHESIS numeric_expression COMMA   @>
@=numeric_expression RIGHT_PARENTHESIS TO numeric_expression                 @>
@=resolve_option_list @>@/
{
@q **** (4) @>

  @<Common declarations for rules@>@; 

#if DEBUG_COMPILE
  DEBUG = true; /* |false| */ @; 
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_variable"
              << endl 
              << "LEFT_PARENTHESIS numeric_expression COMMA "
              << "numeric_expression RIGHT_PARENTHESIS"
              << endl 
              << "TO numeric_expression resolve_option_list'.";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>

  bool save             = @=$10@> &  1U; 
  bool with_transform   = @=$10@> &  2U; 
  bool with_ampersand   = @=$10@> &  4U; 
  bool test_planar      = @=$10@> &  8U; 
  bool make_planar      = @=$10@> & 16U; 

#if DEBUG_COMPILE
  if (DEBUG)
  { 
     cerr << "resolve_option_list == " << @=$10@> << " == 0x" << hex << @=$10@> 
          << dec << endl
          << "save == " << save << endl
          << "with_transform == " << with_transform << endl
          << "with_ampersand == " << with_ampersand << endl
          << "test_planar == " << test_planar << endl
          << "make_planar == " << make_planar << endl;

cerr << "XXX Enter <RETURN> to continue: ";
getchar();  

  }  
#endif /* |DEBUG_COMPILE|  */@; 

@q **** (4) @>

  entry = static_cast<Id_Map_Entry_Node>(@=$2@>); 

  status = static_cast<Path*>(entry->object)->resolve(
                              static_cast<int>(@=$9@>), 
                              static_cast<int>(@=$4@>), 
                              static_cast<int>(@=$6@>), 
                              scanner_node,
                              !save,
                              with_transform,
                              test_planar,
                              make_planar,
                              with_ampersand);

@q **** (4) @>

#if DEBUG_COMPILE
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_variable "
              << "LEFT_PARENTHESIS numeric_expression COMMA"
              << endl 
              << "numeric_expression RIGHT_PARENTHESIS "
              << "TO numeric_expression resolve_option_list:"
              << endl 
              << "`Path::resolve' returned " << status << ".";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>

  @=$$@> =  static_cast<void*>(0);

};

@q *** (3) command --> RESOLVE path_vector_variable TO numeric_expression resolve_option_list.@> 
@*2 \§command> $\longrightarrow$ \.{RESOLVE} \§path vector variable> \.{TO} \§numeric expression>
\§resolve option list>.
\initials{LDF 2022.01.25.}

!!PLEASE NOTE:  There is no corresponding ``resolve'' rule
for a |path_vector| with a pair of |numerical_expressions| as a ``subpath'' argument.
At the present time, I don't see a use for such a rule.  However, if I ever do, I can
easily add it.
\initials{LDF 2022.04.20.}

\LOG
\initials{LDF 2022.01.25.}
\ENDLOG

@<Define rules@>=
@=command: RESOLVE path_vector_variable TO numeric_expression resolve_option_list@>@/
{
@q **** (4) @>

  @<Common declarations for rules@>@; 

#if DEBUG_COMPILE
  DEBUG = true; /* |false| */ @; 
  if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_vector_variable TO "
              << "numeric_expression resolve_option_list'.";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>

  entry = static_cast<Id_Map_Entry_Node>(@=$2@>); 

  bool save             = @=$5@> &  1U; 
  bool with_transform   = @=$5@> &  2U; 
  bool with_ampersand   = @=$5@> &  4U; 
  bool test_planar      = @=$5@> &  8U; 
  bool make_planar      = @=$5@> & 16U; 



@q **** (4) @>


  status = static_cast<Pointer_Vector<Path>*>(entry->object)->resolve(
                                                                 static_cast<int>(@=$4@>), 
                                                                 0,
                                                                 -1,
                                                                 scanner_node,
                                                                 !save,
                                                                 with_transform,
                                                                 test_planar,
                                                                 make_planar,
                                                                 with_ampersand);

@q **** (4) @>

  if (status != 0)
  {
     cerr_strm << "ERROR!  In parser, rule `command --> RESOLVE path_vector_variable"
               << endl 
               << "TO numeric_expression save_temp_file_optional resolve_option_list':"
               << endl 
               << "`Pointer_Vector<Path>::resolve' failed, returning " << status << "."
               << endl
               << "Failed to resolve `path'.  Continuing.";

     log_message(cerr_strm);
     cerr_message(cerr_strm);
     cerr_strm.str("");

  } /* |if (status != 0)| */

@q **** (4) @>

#if DEBUG_COMPILE
  else if (DEBUG)
  {
    cerr_strm << "*** Parser: `command --> RESOLVE path_vector_variable"
              << endl 
              << "TO numeric_expression save_temp_file_optional resolve_option_list':"
              << endl 
              << "`Pointer_Vector<Path>::resolve' succeeded, returning 0.";

    log_message(cerr_strm);
    cerr_message(cerr_strm);
    cerr_strm.str("");
    
  }
#endif /* |DEBUG_COMPILE|  */@;

@q **** (4) @>
    
  @=$$@> =  static_cast<void*>(0);

};

@q *** (3) resolve_option_list @>
@
\LOG
\initials{LDF 2022.04.19.}
Added this type declaration.
\ENDLOG 

@<Type declarations for non-terminal symbols@>=
@=%type <uint_value> resolve_option_list@>

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: /* Empty  */@>
{
   @=$$@> = (2U | 8U | 16U);
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list SAVE@>
{

   @=$$@> = @=$1@> |= 1U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list NO_SAVE@>
{

   @=$$@> = @=$1@> &= ~1U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list WITH_TRANSFORM@>
{

   @=$$@> = @=$1@> |= 2U;
};


@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list WITH_NO_TRANSFORM@>
{

   @=$$@> = @=$1@> &= ~2U;
};


@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list WITH_AMPERSAND@>
{

   @=$$@> = @=$1@> |= 4U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list WITH_NO_AMPERSAND@>
{

   @=$$@> = @=$1@> &= ~4U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list TEST_PLANAR@>
{

   @=$$@> = @=$1@> |= 8U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list NO_TEST_PLANAR@>
{

   @=$$@> = @=$1@> &= ~8U;
};

@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list MAKE_PLANAR@>
{

   @=$$@> = @=$1@> |= 16U;
};


@q **** (4) @>
@
@<Define rules@>= 
@=resolve_option_list: resolve_option_list NO_MAKE_PLANAR@>
{

   @=$$@> = @=$1@> &= ~16U;
};

