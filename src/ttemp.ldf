%% ttemp.ldf

verbatim_metapost "prologues := 3;outputtemplate := \"%j%3c.eps\";";

input "plain.lmc";

path q[];

pen dot_pen;
dot_pen := pencircle scaled (2mm, 2mm, 2mm);

pen medium_pen;

medium_pen := pencircle scaled (.5mm, .5mm, .5mm);

beginfig(0);

  pickup medium_pen;

  circle c;

  set c with_diameter 3cm with_point_count 8;

  rotate c (90, 0);

  q0 := c;
  
  draw q0;

  point p[];

  for i = 0 upto 7:
    p[i] := get_point (i) q0;
  endfor;

  dotlabel.rt("$p_0$", p0);
  dotlabel.urt("$p_1$", p1);
  dotlabel.top("$p_2$", p2);
  dotlabel.ulft("$p_3$", p3);
  dotlabel.lft("$p_4$", p4);
  dotlabel.llft("$p_5$", p5);
  dotlabel.bot("$p_6$", p6);
  dotlabel.lrt("$p_7$", p7);
  
  for i = 0 upto (size q0 - 1):
    %drawdot get_point (i) q0 with_pen dot_pen with_color blue;
  endfor;

  path_vector pv;
  
  pv := resolve q0 to 18 with_no_transform save;

  % message "size pv:";
  % show size pv;
  % pause;
  
  % for i = 0 upto (size pv0 - 1):
  %   p[10+i] := get_point (i) pv0;
  %   drawdot p[10+i] with_pen dot_pen with_color red;
  % endfor;

  % message "size pv0:";
  % show size pv0;
  % pause;

  
  % dotlabel.rt("$p_{10}$", p10);
  % dotlabel.urt("$p_{11}$", p11);
  % dotlabel.top("$p_{12}$", p12);
  % dotlabel.ulft("$p_{13}$", p13);
  % dotlabel.lft("$p_{14}$", p14);
  % dotlabel.llft("$p_{15}$", p15);
  % dotlabel.bot("$p_{16}$", p16);
  % dotlabel.lrt("$p_{17}$", p17);
  % dotlabel.lrt("$p_{18}$", p18);
  % dotlabel.lrt("$p_{19}$", p19);
  % dotlabel.lrt("$p_{20}$", p20);
  % dotlabel.lrt("$p_{21}$", p21);
  
  
  
endfig with_projection parallel_x_y;

end_mp;
end;


  message "size pv:";
  show size pv;
  pause;
  
  for i = 0 upto (size pv0 - 1):
    drawdot get_point (i) pv0 with_pen dot_pen with_color blue;
  endfor;

  % for i = 0 upto (size pv1 - 1):
  %   drawdot get_point (i) pv1 with_pen dot_pen with_color red;
  % endfor;
  


endfig with_projection parallel_x_y;

end_mp;
end;

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%   	 GNU Emacs editor.  The local variable list is not evaluated when an 
%%   	 indirect buffer is visited, so it's necessary to evaluate the       
%%   	 following s-expression in order to use the facilities normally      
%%   	 accessed via the local variables list.                              
%%   	 \initials{LDF 2004.02.12}.                                          

%% (progn (metapost-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:metapost
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% outline-regexp:"%% [*\f]+"
%% End:
