

beginfig(0);

  point p[][];
  reg_polygon r[];
  r0 := unit_dodecagon scaled (6cm, 0, 6cm);
  draw r0;
  label("$r_0$", get_center r0);

  for i = 0 upto 11:
    p[0][i] := get_point (i) r0;
  endfor;

  r1 := r0 shifted by (p[0][8] - p[0][3]);
  draw r1;
  label("$r_1$", get_center r1);

  for i = 0 upto 11:
    p[1][i] := get_point (i) r1;
  endfor;
  
  r2 := r0 shifted by (p[0][11] - p[0][6]);
  draw r2;
  label("$r_2$", get_center r2);

  for i = 0 upto 11:
    p[2][i] := get_point (i) r2;
  endfor;

  r3 := r2 shifted by (p[1][0] - p[0][0]);
  draw r3;
  label("$r_3$", get_center r3);

  for i = 0 upto 11:
    p[3][i] := get_point (i) r3;
  endfor;


  
    
  dotlabel.bot("$p_0^0$",    p[0][0]);
  dotlabel.top("$p_0^1$",    p[0][1]);
  dotlabel.top("$p_0^2$",    p[0][2]);
  dotlabel.top("$p_0^3$",    p[0][3]);
  dotlabel.top("$p_0^4$",    p[0][4]);
  dotlabel.top("$p_0^5$",    p[0][5]);
  dotlabel.top("$p_0^6$",    p[0][6]);
  dotlabel.top("$p_0^7$",    p[0][7]);
  dotlabel.top("$p_0^8$",    p[0][8]);
  dotlabel.top("$p_0^9$",    p[0][9]);
  dotlabel.top("$p_0^{10}$", p[0][10]);
  dotlabel.bot("$p_0^{11}$", p[0][11]);

  dotlabel.top("$p_1^0$",    p[1][0]);
  dotlabel.top("$p_1^1$",    p[1][1]);
  dotlabel.top("$p_1^2$",    p[1][2]);
  dotlabel.top("$p_1^3$",    p[1][3]);
  dotlabel.top("$p_1^4$",    p[1][4]);
  dotlabel.top("$p_1^5$",    p[1][5]);
  dotlabel.top("$p_1^6$",    p[1][6]);
  dotlabel.top("$p_1^7$",    p[1][7]);
  dotlabel.top("$p_1^8$",    p[1][8]);
  dotlabel.top("$p_1^9$",    p[1][9]);
  dotlabel.top("$p_1^{10}$", p[1][10]);
  dotlabel.top("$p_1^{11}$", p[1][11]);


  dotlabel.top("$p_2^0$",    p[2][0]);
  dotlabel.top("$p_2^1$",    p[2][1]);
  dotlabel.top("$p_2^2$",    p[2][2]);
  dotlabel.top("$p_2^3$",    p[2][3]);
  dotlabel.top("$p_2^4$",    p[2][4]);
  dotlabel.top("$p_2^5$",    p[2][5]);
  dotlabel.top("$p_2^6$",    p[2][6]);
  dotlabel.top("$p_2^7$",    p[2][7]);
  dotlabel.top("$p_2^8$",    p[2][8]);
  dotlabel.top("$p_2^9$",    p[2][9]);
  dotlabel.top("$p_2^{10}$", p[2][10]);
  dotlabel.top("$p_2^{11}$", p[2][11]);


  dotlabel.rt("$p_3^0$",    p[3][0]);
  dotlabel.rt("$p_3^1$",    p[3][1]);
  dotlabel.rt("$p_3^2$",    p[3][2]);
  dotlabel.rt("$p_3^3$",    p[3][3]);
  dotlabel.rt("$p_3^4$",    p[3][4]);
  dotlabel.rt("$p_3^5$",    p[3][5]);
  dotlabel.rt("$p_3^6$",    p[3][6]);
  dotlabel.rt("$p_3^7$",    p[3][7]);
  dotlabel.rt("$p_3^8$",    p[3][8]);
  dotlabel.rt("$p_3^9$",    p[3][9]);
  dotlabel.rt("$p_3^{10}$", p[3][10]);
  dotlabel.rt("$p_3^{11}$", p[3][11]);


  

endfig with_projection parallel_x_z;

verbatim_metapost "end;";


end;



%% *** (3) The intersection points of a linear `path' and an `ellipsoid'.
%%         LDF 2005.12.09.

verbatim_metapost "verbatimtex \magnification=\magstep5 etex";

pickup pencircle scaled (.75mm, .75mm);

focus f;
set f with_position (-10, 15, -30) with_direction (-10, 15, 100) with_distance 20; 

picture save_picture;

beginfig(1); 

transform t;
%t := identity rotated (15, 15) shifted (1, 1, 1);
t := identity;

ellipsoid e;
 set e with_center origin with_axis_x 20 with_axis_y 16 with_axis_z 10
       with_divisions_x 6 with_divisions_y 6 with_divisions_z 2
       with_point_count 64;

e *= t;

draw e;

% cuboid c;
% c := out_cuboid e;
% draw c with_color red;

path q[];
q0 := ((-10, -10) -- (10, 10)) rotated -90 shifted (0, 1);
%q0 := (0, -10) -- (0, 10);

q0 *= t;

draw q0 with_color blue;

bool_point_vector bpv;
bpv := e intersection_points q0;

message "bpv:";
show bpv;

point p[];
p0 := bpv0;
p1 := bpv1;

message "p0 location e:";
show p0 location e;

drawdot bpv0 with_color green with_pen pencircle scaled (1.5mm, 1.5mm);
label.top("$i_0$", p0 shifted (0, .2));

drawdot bpv1 with_color green with_pen pencircle scaled (1.5mm, 1.5mm);
label.lrt("$i_1$", p1 shifted (0, .2));

save_picture := current_picture;

label("Perspective Projection", (0, -11));

endfig with_focus f no_sort; 

point label_pt;
label_pt := (0, -10);

beginfig(2); 
current_picture := save_picture;
label("Parallel Projection, X-Z Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(3);
  current_picture := save_picture;
  label("Parallel Projection, X-Y Plane", label_pt);
endfig with_projection parallel_x_y;

beginfig(4); 
  current_picture := save_picture;
  label("Parallel Projection, Z-Y Plane", label_pt);
endfig with_projection parallel_x_y;

verbatim_metapost "end;";

end;



beginfig(0);
  point p[];
  path q[];
  
  ellipse e;
  
  message "sqrt 2:";
  show sqrt 2;


  e := unit_ellipse scaled (5, 0, 3);

  rotate e (90, 0);

  show e;
  
  q0 := origin -- (5, 0) rotated (0, 0, 20); 
  q1 := origin -- (10, 0) rotated (0, 0, 60);

  bool_point_vector cpv;

  cpv := q0 intersection_points e;

  boolean b[];

  b0 := cpv0;
  b1 := cpv1;
  
  if b0:
    message "b0 is true";
    p0 := cpv0;
  else:
    message "b0 is false";
  fi;
  
  if b1:
    message "b1 is true";
    p0 := cpv1;
  else:
    message "b1 is false";
  fi;
  
  cpv := q1 intersection_points e;

  if b0:
    message "b0 is true";
    p1 := cpv0;
  else:
    message "b0 is false";
  fi;

  b1 := cpv1;
  
  if b1:
    message "b1 is true";
    p1 := cpv1;
  else:
    message "b1 is false";
  fi;

    
  dotlabel.top("$p_0$", p0);
  dotlabel.top("$p_1$", p1);

  draw p0 -- p1 with_color red;
  
  message "magnitude (p1 - p0):";
  show magnitude (p1 - p0);

  m := magnitude (p1 - p0);
    
  message "pi:";
  show pi;

  a := ((sqrt 2) * 2);

  message "a:";
  show a;
  
  a := (m*pi)/a;

  message "a:";
  show a;
  
  pause;
  
  draw e;


  
  
endfig with_projection parallel_x_y;

verbatim_metapost "end;";

end;


if file_exists "abc":
  message "abc exists.";
else:
    message "abc doesn't exist.";
fi;

if !file_exists "abc":
  message "abc doesn't exist.";
else:
  message "abc exists.";
fi;


end;

if is_known a:
  message "a is known.";
else:
    message "a is unknown.";
fi;

numeric a;
a := 1;

if is_known a:
  message "a is known.";
else:
    message "a is unknown.";
fi;

end;

picture v[];

beginfig(0);

  draw (-2, 0) -- (2, 0);
  
  label("ABC", (0, 1));

  shift current_picture (1, 2, 3);
  
  v0 := current_picture;
  
endfig with_projection parallel_x_y;

beginfig(1);

  drawdot origin;
  current_picture := v0;
  rotate current_picture (0, 0, 45);

  output current_picture with_projection parallel_x_y;
  clear current_picture;

  current_picture:= v0;

  %rotate current_picture (0, 0, -45);


endfig with_projection parallel_x_y;




verbatim_metapost "end;";

end;




%% ** (2) macro draw_stitches
    
macro draw_stitches;

def draw_stitches {numeric RA, numeric Decl, point stitch_point, numeric bi_ang_one,
                   boolean left_or_right, boolean bottom_or_top, boolean do_labels} =

    message "Entering draw_stitches.";

    message "Exiting draw_stitches.";
    
  % point P[];
  
  % color ccolor;

  % if do_black:
  %   ccolor := white;
  % else:
  %   ccolor := black;
  % fi;

  % path curr_edge[];

  draw edge0 with_pen pencircle scaled (3pt, 3pt) with_color green on_picture qv[bi_ang_one];
  draw edge1 with_pen pencircle scaled (3pt, 3pt) with_color cyan on_picture qv[bi_ang_one];
  draw edge2 with_pen pencircle scaled (3pt, 3pt) with_color blue on_picture qv[bi_ang_one];
  draw edge3 with_pen pencircle scaled (3pt, 3pt) with_color red on_picture qv[bi_ang_one];
  
  % if bottom_or_top and left_or_right:         %% top right
  %   %message "top right.";
  %   curr_edge0 := edge1;                      %% top right 

  % elseif bottom_or_top and not left_or_right: %% top left

  %   %message "top left.";                     
  %   curr_edge0 := edge0;                      %% top left

  % elseif not bottom_or_top and left_or_right: %% bottom right
  %   %message "bottom right.";
  %   curr_edge0 := edge3;                      %% bottom right

  % else:                                       %% bottom left
  %   %message "bottom left.";
  %   curr_edge0 := edge2;                      %% bottom left
  % fi;

  % for i = 0 upto (length Q - 1):
  %   P[i] := get_point (i) Q;
  % endfor;

  % if do_labels:
  %   dotlabel.rt("$P_{0}$", P0) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{1}$", P1) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{2}$", P2) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{3}$", P3) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{4}$", P4) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{5}$", P5) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{6}$", P6) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{7}$", P7) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{8}$", P8) on_picture qv[bi_ang_one];
  %   dotlabel.rt("$P_{9}$", P9) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{10}$", P10) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{11}$", P11) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{12}$", P12) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{13}$", P13) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{14}$", P14) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{15}$", P15) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{16}$", P16) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{17}$", P17) on_picture qv[bi_ang_one];
  %   dotlabel.rt("$P_{18}$", P18) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{19}$", P19) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{20}$", P20) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{21}$", P21) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{22}$", P22) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{23}$", P23) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{24}$", P24) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{25}$", P25) on_picture qv[bi_ang_one];
  %   dotlabel.rt("$P_{26}$", P26) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{27}$", P27) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{28}$", P28) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{29}$", P29) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{30}$", P30) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{31}$", P31) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{32}$", P32) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{33}$", P33) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{34}$", P34) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{35}$", P35) on_picture qv[bi_ang_one];
  % fi;
  
  % P36 :=stitch_point shifted (-1cm, 0);
  % P37 := stitch_point shifted (1cm, 0);

  % %draw P36 -- P37 with_color red on_picture qv[bi_ang_one];

  % P38 := (P36 -- P37) intersection_point (P27 -- P8);

  % if do_labels:
  %   dotlabel.urt("$P_{38}$", P38) on_picture qv[bi_ang_one];
  % fi;
  
  % numeric mag[];

  % mag0 := magnitude(xpart stitch_point - xpart P38);

  % circle c;

  % P39 := (radius, 0);    
  
  % P40 := P39 rotated (0, 0, declination_decimal_degrees S);

  % numeric rad;
  % rad := xpart P40;

  % c := unit_circle scaled (rad, 0, rad) rotated (90, 0);

  % numeric circum;

  % circum := circumference c;
  
  % mag0 := circum / 16;

  % % message "mag0:";
  % % show mag0;

  % P41 := P38 shifted (-mag0, 0);
  % P42 := P38 shifted (mag0, 0);

  % if do_labels:
  %   dotlabel.lft("$P_{41}$", P41) on_picture qv[bi_ang_one];
  %   dotlabel.lft("$P_{42}$", P42) on_picture qv[bi_ang_one];
  % fi;
  
  % % message "P41:";
  % % show P42;

  % % message "P42:";
  % % show P42;

  % %pause;
  
  % %draw P41 -- P42 with_color red on_picture qv[bi_ang_one];

  % mag1 := magnitude(xpart P41 - xpart stitch_point);
  % mag2 := magnitude(xpart P42 - xpart stitch_point);
 
  % if mag1 < mag2:
  %   P43 := P41 shifted (0, -1cm);
  %   P44 := P41 shifted (0, 1cm);
  % else:
  %   P43 := P42 shifted (0, -1cm);
  %   P44 := P42 shifted (0, 1cm);
  % fi;

  % % dotlabel.lft("$P_{41}$", P41) with_text_color red with_dot_color red on_picture qv[bi_ang_one];
  % % dotlabel.lft("$P_{43}$", P43) with_text_color red with_dot_color red on_picture qv[bi_ang_one];
  % % dotlabel.rt("$P_{44}$", P44) with_text_color red with_dot_color red on_picture qv[bi_ang_one];
  % % dotlabel.top("$P_{8}$", P8) with_text_color red with_dot_color red on_picture qv[bi_ang_one];
  % % dotlabel.top("$P_{27}$", P27) with_text_color red with_dot_color red on_picture qv[bi_ang_one];

  % P45 := (stitch_point rotated_around (P43, P44) 180) rotated_around (P8, P27) 180;

  % % dotlabel.rt("$P_{45}$", P45) with_text_color red with_dot_color red on_picture qv[bi_ang_one];

  
  % drawdot P45 with_pen sstar_pen with_color red on_picture qv[bi_ang_one]; % white

enddef;

%% ** (2) End of 3DLDF code.

%% * (1) Emacs-Lisp code for use in indirect buffers when using the          
%%       GNU Emacs editor.  The local variable list is not evaluated when an 
%%       indirect buffer is visited, so it's necessary to evaluate the       
%%       following s-expression in order to use the facilities normally      
%%       accessed via the local variables list.                              
%%       \initials{LDF 2004.02.12}.                                          

%% (progn (metafont-mode) (outline-minor-mode t) (setq fill-column 80))    

%% * (1) Local variables for Emacs.

%% Local Variables:
%% mode:Metapost
%% eval:(outline-minor-mode t)
%% eval:(read-abbrev-file abbrev-file-name)
%% abbrev-mode:t
%% outline-regexp:"%% [*\f]+"
%% End:
