@q accsdtbs.web  @>
@q Created by Laurence D. Finston (LDF) Thu 24 Jun 2021 08:45:33 PM CEST @>

@q * (1) Copyright and License. @>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing.  @>
@q Copyright (C) 2021 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify  @>
@q it under the terms of the GNU General Public License as published by  @>
@q the Free Software Foundation; either version 3 of the License, or  @>
@q (at your option) any later version.   @>

@q GNU 3DLDF is distributed in the hope that it will be useful,  @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of  @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  @>
@q GNU General Public License for more details.   @>

@q You should have received a copy of the GNU General Public License  @>
@q along with GNU 3DLDF; if not, write to the Free Software  @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.   @>
@q It is part of the GNU Project of the   @>
@q Free Software Foundation  @>
@q and is published under the GNU General Public License.  @>
@q See the website http://www.gnu.org  @>
@q for more information.    @>
@q GNU 3DLDF is available for downloading from  @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q Please send bug reports to Laurence.Finston@gmx.de @>
@q The mailing list help-3dldf@gnu.org is available for people to  @>
@q ask other users for help.   @>
@q The mailing list info-3dldf@gnu.org is for sending  @>
@q announcements to users. To subscribe to these mailing lists, send an  @>
@q email with ``subscribe <email-address>'' as the subject.   @>

@q The author can be contacted at:     @>

@q Laurence D. Finston 		       @>
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor 	       @>
@q Boston, MA  02110-1301  	       @>
@q USA                                 @>                             

@q Laurence.Finston@gmx.de  @>


@ Access database.

This program can be used to access the database.                                 
It can contain ``one-off'' or ``"throwaway'' code for updating tables in 
the database with calculated values or for other purposes.                                    
\initials{LDF 2021.09.10.}

https://www.timecalculator.net/time-to-decimal

How to Calculate Decimal from Time

To get the total decimal hours we use the formula: h = hours + (minutes / 60) + (seconds / 3600).
To get the total decimal minutes we use the formula: m = (hours * 60) + minutes + (seconds / 60).
To get the total decimal seconds we use the formula: s = (hours * 3600) + (minutes * 60) + seconds.

@ As of 2021.6.27.:  Call like this, for example, to calculate right_ascension_decimal_hours and */
declination_decimal_degrees:  accsdtbs "common_name = \"Cor Caroli\""

@q ** (2) @>
@
@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

#include <mysql.h>

#include <ios>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <new>
#include <algorithm>
#include <string> 
#include <exception>
#include <stdexcept>
#include <sstream>   
#include <fstream>   
#include <vector>
#include <deque>
#include <map>

using namespace std;

typedef void* yyscan_t;

#include "parser.hxx"
#include "scanner.hxx"
#include "stars.hxx"
#include "classes.hxx"
#include "accsgtpt.hxx"

@q ** (2) @>
@
@<Global variable declarations@>=

MYSQL_RES *result;
MYSQL_ROW curr_row;
MYSQL *mysql;
unsigned int row_ctr; 
unsigned int field_ctr;
long affected_rows;

stringstream sql_strm;

int trace_value = 0;

int
submit_mysql_query(string query_str);

@q ** (2) @>
@
@<|main| definition@>=
int
main(int argc, char *argv[])
{
@q *** (3) @>


   bool DEBUG = true; /* |false| */ 

   ifstream in_strm;

   FILE *fp = 0;

   char buffer[32];
   memset(buffer, '\0', 32);

   cerr << "accsdtbs 1.0" << endl
        << "Copyright (C) 2021 The Free Software Foundation, Inc."
        << endl 
        << "Author:  Laurence D. Finston"
        << endl;

   int status = 0;

   unsigned int mysql_timeout = 120;


   cerr << "argc == " << argc << "." << endl;

@q *** (3) @>
@
@<|main| definition@>=

   table_field_map[COMMON_NAME]                        = "common_name";
   table_field_map[GREEK_NAME]                         = "greek_name";
   table_field_map[LATIN_NAME]                         = "latin_name";
   table_field_map[ARABIC_NAME]                        = "arabic_name"; 
   table_field_map[FLAMSTEED_DESIGNATION_NUMBER]       = "flamsteed_designation_number";
   table_field_map[BAYER_DESIGNATION_GREEK_LETTER]     = "bayer_designation_greek_letter";
   table_field_map[BAYER_DESIGNATION_GREEK_LETTER_TEX] = "bayer_designation_greek_letter_tex";
   table_field_map[BAYER_DESIGNATION_EXTENSION]        = "bayer_designation_extension";
   table_field_map[BS_HR_NUMBER]                       = "bs_hr_number";
   table_field_map[APPROX_RANK_APPARENT_MAGNITUDE]     = "approx_rank_apparent_magnitude";
   table_field_map[APPARENT_MAGNITUDE]                 = "apparent_magnitude";
   table_field_map[ABSOLUTE_MAGNITUDE]                 = "absolute_magnitude";
   table_field_map[APPARENT_MAGNITUDE_VARIES]          = "apparent_magnitude_varies";
   table_field_map[ABSOLUTE_MAGNITUDE_VARIES]          = "absolute_magnitude_varies";
   table_field_map[CONSTELLATION_ABBREVIATION]         = "constellation_abbreviation";
   table_field_map[CONSTELLATION_FULL_NAME]            = "constellation_full_name";
   table_field_map[CONSTELLATION_NAME_GENITIVE]        = "constellation_name_genitive";
   table_field_map[CONSTELLATION_NUMBER]               = "constellation_number";
   table_field_map[RIGHT_ASCENSION_HOURS]              = "right_ascension_hours";
   table_field_map[RIGHT_ASCENSION_MINUTES]            = "right_ascension_minutes";
   table_field_map[RIGHT_ASCENSION_SECONDS]            = "right_ascension_seconds";
   table_field_map[RIGHT_ASCENSION_DECIMAL_HOURS]      = "right_ascension_decimal_hours";
   table_field_map[RIGHT_ASCENSION_DECIMAL_DEGREES]    = "right_ascension_decimal_degrees";
   table_field_map[DECLINATION_DEGREES]                = "declination_degrees";
   table_field_map[DECLINATION_MINUTES]                = "declination_minutes";
   table_field_map[DECLINATION_SECONDS]                = "declination_seconds";
   table_field_map[DECLINATION_DECIMAL_DEGREES]        = "declination_decimal_degrees";
   table_field_map[IS_BINARY]                          = "is_binary";
   table_field_map[IS_MULTIPLE]                        = "is_multiple";
   table_field_map[IS_BINARY_COMPONENT]                = "is_binary_component";
   table_field_map[IS_ECLIPSING_BINARY]                = "is_eclipsing_binary";
   table_field_map[NOTES]                              = "notes";

@q *** (3) @>
@
@<|main| definition@>=

   operator_map[Where_Type::NULL_TYPE]                  = "";
   operator_map[Where_Type::EQUAL_TYPE]                 = "=";
   operator_map[Where_Type::NOT_EQUAL_TYPE]             = "!=";
   operator_map[Where_Type::GREATER_THAN_TYPE]          = ">";
   operator_map[Where_Type::GREATER_THAN_OR_EQUAL_TYPE] = ">=";
   operator_map[Where_Type::LESS_THAN_TYPE]             = "<";
   operator_map[Where_Type::LESS_THAN_OR_EQUAL_TYPE]    = "<=";
   operator_map[Where_Type::AND_TYPE]                   = "and";
   operator_map[Where_Type::OR_TYPE]                    = "or";
   operator_map[Where_Type::XOR_TYPE]                   = "xor";
   operator_map[Where_Type::NOT_TYPE]                   = "not";
   operator_map[Where_Type::NOT_AND_TYPE]               = "nand";
   operator_map[Where_Type::NOT_OR_TYPE]                = "nor";
   operator_map[Where_Type::NOT_XOR_TYPE]               = "nxor";     


@q *** (3) @>
@
@<|main| definition@>=

   compare_function_map[COMMON_NAME]                        = compare_common_name;
   compare_function_map[FLAMSTEED_DESIGNATION_NUMBER]       = compare_flamsteed_designation_number;
   compare_function_map[BAYER_DESIGNATION_GREEK_LETTER]     = compare_bayer_designation_greek_letter;
   compare_function_map[BAYER_DESIGNATION_GREEK_LETTER_TEX] = compare_bayer_designation_greek_letter_tex;
   compare_function_map[BS_HR_NUMBER]                       = compare_bs_hr_number;
   compare_function_map[APPROX_RANK_APPARENT_MAGNITUDE]     = compare_approx_rank_apparent_magnitude;
   compare_function_map[APPARENT_MAGNITUDE]                 = compare_apparent_magnitude ;
   compare_function_map[ABSOLUTE_MAGNITUDE]                 = compare_absolute_magnitude     ;
   compare_function_map[CONSTELLATION_ABBREVIATION]         = compare_constellation_abbreviation;
   compare_function_map[CONSTELLATION_FULL_NAME]            = compare_constellation_full_name;
   compare_function_map[CONSTELLATION_NAME_GENITIVE]        = compare_constellation_name_genitive;
   compare_function_map[CONSTELLATION_NUMBER]               = compare_constellation_number;
   compare_function_map[RIGHT_ASCENSION_HOURS]              = compare_right_ascension_hours;
   compare_function_map[RIGHT_ASCENSION_MINUTES]            = compare_right_ascension_minutes;
   compare_function_map[RIGHT_ASCENSION_SECONDS]            = compare_right_ascension_seconds;
   compare_function_map[RIGHT_ASCENSION_DECIMAL_HOURS]      = compare_right_ascension_decimal_hours;
   compare_function_map[RIGHT_ASCENSION_DECIMAL_DEGREES]    = compare_right_ascension_decimal_degrees;
   compare_function_map[DECLINATION_DEGREES]                = compare_declination_degrees;
   compare_function_map[DECLINATION_MINUTES]                = compare_declination_minutes;
   compare_function_map[DECLINATION_SECONDS]                = compare_declination_seconds;
   compare_function_map[DECLINATION_DECIMAL_DEGREES]        = compare_declination_decimal_degrees;
   compare_function_map[IS_BINARY]                          = compare_is_binary;


@q *** (3) @>
@
@<|main| definition@>=

   status = process_command_line_options(argc, argv);

   if (status != 0)
   {
       cerr << "ERROR!  In `main':  `process_command_line_options' failed, returning " << status << "."
            << endl 
            << "Exiting `accsdtbs' unsuccessfully with exit status 1." 
            << endl;

       exit(1);
   }
   else if (DEBUG)
   { 
       cerr << "In `main':  `process_command_line_options' succeeded, returning 0."
            << endl;
   }  

@q *** (3) @>
@
@<|main| definition@>=

   mysql = mysql_init(0);

    if (mysql != 0) 
    {
          cerr << "In `main':"
                    << endl
                    << "mysql_init succeeded." << endl; 
    }
    else
    {
       cerr << "ERROR!"
            << endl
            << "`mysql_init failed'.  Failed to access database." 
            << endl
            << "Exiting program unsuccessfully with exit status 1."
            << endl;

       exit(1);

    }

    mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, &mysql_timeout); 

@q *** (3) @>
@
@<|main| definition@>=

    errno = 0;
    status = getlogin_r(buffer, 32);

    if (status != 0)
    {
        cerr << "ERROR! In `main':  `getlogin_r' failed, returning " << status << ":" 
             << endl 
             << "Error:  " << strerror(errno)
             << endl 
             << "Failed to find username.  Can't connect to MySQL database."
             << endl
             << "Exiting program unsuccessfully with exit status 1."
             << endl;

        exit(1);

    }

@q **** (4) @>

    else if (DEBUG)
    {
        cerr << "In `main':  `getlogin_r' succeeded, returning 0." << endl 
             << "Username:  " << buffer << endl;              

    }  /* |else if (DEBUG)|  */
   
@q *** (3) @>
@
@<|main| definition@>=

    if (!mysql_real_connect(mysql, "localhost", buffer, 0, "3dldf", 0, NULL, 0))
    {
        cerr << "ERROR! In `main':  `mysql_real_connect' failed, returning NULL." 
             << endl 
             << "Failed to connect to database: Error: " << mysql_error(mysql) 
             << endl
             << "Exiting program unsuccessfully with exit status 1."
             << endl;

        exit(1);
    }
    else
    { 
        cerr << "In `main':  `mysql_real_connect' succeeded." << endl;
    }  


    memset(buffer, '\0', 32);

@q **** (4) @>

@q *** (3) @>
@
@<|main| definition@>=

   Scanner_Node scanner_node = new Scanner_Type(1);

   yyscan_t parameter;

   parameter = static_cast<void*>(scanner_node);

   yylex_init(&parameter);      

   yyset_extra(scanner_node, parameter);

   YY_BUFFER_STATE yy_buffer_state;

   if (trace_value > 0)
      yydebug = 1; 
   else 
      yydebug = 0; 

@q *** (3) @>

   deque<IO_Type>::iterator iter;

   IO_Type curr_io_type;

   while (io_deque.size() > 0)
   {
@q **** (4) @>

      iter = io_deque.begin();
      cerr << "iter->in_filename == " << iter->in_filename << endl;

      if (iter->in_file != 0)
      {
          cerr << "`iter->in_file' != 0 is non-NULL."
               << endl 
               << "Will continue reading from `iter->in_filename' == " << iter->in_filename
               << endl;
      }
      else /* |iter->in_file == 0|  */
      {
@q ***** (5) @>
          cerr << "`iter->in_file' is NULL."
               << endl 
               << "Will open `iter->in_filename' == " << iter->in_filename << " for reading."
               << endl;

          errno = 0;
          iter->in_file = fopen(iter->in_filename.c_str(), "r");

          if (iter->in_file == 0)
          {
             cerr << "ERROR!  In `main':  `fopen' failed, returning NULL." << endl
                  << "Failed to open file `" << iter->in_filename << "' for reading." << endl 
                  << "`errno' == " << errno << " == " << strerror(errno) << endl
                  << "Will try to continue."
                  << endl;

             continue;
          }
          else if (DEBUG)
          { 
             cerr << "In `main':  `fopen' succeeded, returning non-NULL." << endl
                  << "Opened file `" << iter->in_filename << "' for reading successfully." << endl; 
          }    

          yypush_buffer_state(yy_create_buffer(iter->in_file, YY_BUF_SIZE, parameter), parameter);

@q ***** (5) @>

      }  /* |else| (|!YY_CURRENT_BUFFER|)  */

@q **** (4) @>
@
@<|main| definition@>=

      status = yyparse(parameter);

      if (DEBUG)
      { 
          cerr << "`yyparse' returned " << status << "." << endl;
      }  

      if (status == 2)
      {
@q ***** (5) @>

          if (DEBUG)
          { 
              cerr << "`yyparse' returned 2.  Read `input' command." 
                   << endl
                   << "`scanner_node->input_filename' == " << scanner_node->input_filename
                   << endl;
          }     

          io_deque.push_front(IO_Type());
          io_deque.front().in_filename = scanner_node->input_filename;
          io_deque.front().in_file = 0;

          continue;
      

@q ***** (5) @>

      }  /* |if (status == 2)|  */

@q *** (3) @>
@
@<|main| definition@>=

      else
      {

          if (DEBUG)
          { 
              cerr << "`yyparse' returned " << status << "."
                   << endl 
                   << "Read to `endinput' command, `end' command or EOF (end of file)." 
                   << endl 
                   << "Closing `iter->infile'."
                   << endl;
          }     

           fclose(iter->in_file);
           io_deque.pop_front();
           yypop_buffer_state(parameter);     			

      }

@q **** (4) @>
@
@<|main| definition@>=

      if (scanner_node->end_flag)
      {
         if (DEBUG)
         { 
            cerr << "In `main':  `scanner_node->end_flag' is `true'." << endl
                 << "Not reading any more input from files."
                 << endl;
         }      

         for (deque<IO_Type>::iterator a_iter = io_deque.begin(); 
              a_iter != io_deque.end(); 
              ++a_iter)
         {
             fclose(iter->in_file);
         }

         io_deque.clear(); 

         break; 

      }  /* |if (scanner_node->end_flag)|  */

@q **** (4) @>

   }  /* |while|  */

@q *** (3) @>
@
@<|main| definition@>=

   if (!scanner_node->end_flag)
   {

      if (DEBUG)
      { 
          cerr << "Setting `fp' to `stdin' and calling `yyparse' again." << endl;
      }  

      fp = stdin;
       
      yyrestart(fp, parameter);

      status = yyparse(parameter);

      if (DEBUG)
      { 
          cerr << "`yyparse' returned " << status << "." << endl;
      }  

   }  /* |if (!scanner_node->end_flag)| */

@q *** (3) @>

   else if (DEBUG)
   { 
       cerr << "In `main':  `scanner_node->end_flag' is `true'." << endl
            << "Not reading from standard input."
            << endl;
   }  

@q *** (3) @>

   cerr << "Exiting `accsdtbs' successfully with exit status 0." << endl;

   exit(0);

}  /* End of |main| definition  */


@q ** (2) @>
@      
@<Function declarations@>=
int
submit_mysql_query(string query_str);

@q *** (3) Definition @>
@
@<|submit_mysql_query| definition@>=      
int
submit_mysql_query(string query_str)
{
 
   bool DEBUG = true; /* |false| */ 

   if (DEBUG)
   { 
      cerr << "Entering `submit_mysql_query'." << endl
           << "`query_str' == " << query_str << endl;
   }  

   int status = 0;

   mysql_query(mysql, query_str.c_str());

   if (status != 0)
     {
          
       cerr  << "ERROR!  In `|submit_mysql_query|':"
	     << endl 
	     << "`mysql_query' failed, returning " << status << ":"
	     << endl 
	     << "Error:  " << mysql_error(mysql)
	     << endl 
	     << "Error number:  " << mysql_errno(mysql)
	     << endl 
	     << "Exiting function unsuccessfully with return value 1." 
	     << endl;

       return 1;
         
     }  /* |if| (|mysql_query| failed.)  */
     else
        cerr << "`mysql_query' succeeded, returning 0." << endl;

   result = mysql_store_result(mysql);        

   if (result == 0)
   {
     cerr  << "In `submit_mysql_query':  "
          << "`mysql_store_result' returned 0." << endl 
          << "No results.  Exiting function successfully with return value 2."
          << endl;
          
     return 2;

   }  /* |if| (No result)  */

   else
   {
       row_ctr   = mysql_num_rows(result);
       field_ctr = mysql_num_fields(result);

       cerr << "In `|submit_mysql_query|':  "
            << "`mysql_store_result' returned results." 
            << endl
            << "`row_ctr' == " << row_ctr 
            << endl
            << "`field_ctr' == " << field_ctr 
            << endl;

   
       affected_rows = (long) mysql_affected_rows(mysql);

       cerr << "`affected_rows' == " << affected_rows
            << endl;

   }

   return 0;
   
}  /* |submit_mysql_query| definition */

@q *** (3) @>

@q ** (2) @>
@
@c
typedef float real;
class Scanner_Type;
typedef Scanner_Type *Scanner_Node;
@<Include files@>@;
typedef float real;
@<Global variable declarations@>@;
@<Function declarations@>@;
@<|main| definition@>@;
@<|submit_mysql_query| definition@>@;

/* Local Variables:       */
/* mode:CWEB              */
/* auto-fill-function:nil */
/* End:                   */
