@q classes.web @>
          
@q Created by Laurence D. Finston (LDF) Wed 15 Sep 2021 02:30:53 PM CEST @>

@q * (1) Copyright and License. @>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing.  @>
@q Copyright (C) 2021 The Free Software Foundation, Inc. @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify  @>
@q it under the terms of the GNU General Public License as published by  @>
@q the Free Software Foundation; either version 3 of the License, or  @>
@q (at your option) any later version.   @>

@q GNU 3DLDF is distributed in the hope that it will be useful,  @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of  @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  @>
@q GNU General Public License for more details.   @>

@q You should have received a copy of the GNU General Public License  @>
@q along with GNU 3DLDF; if not, write to the Free Software  @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.   @>
@q It is part of the GNU Project of the   @>
@q Free Software Foundation  @>
@q and is published under the GNU General Public License.  @>
@q See the website http://www.gnu.org  @>
@q for more information.    @>
@q GNU 3DLDF is available for downloading from  @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q Please send bug reports to Laurence.Finston@gmx.de @>
@q The mailing list help-3dldf@gnu.org is available for people to  @>
@q ask other users for help.   @>
@q The mailing list info-3dldf@gnu.org is for sending  @>
@q announcements to users. To subscribe to these mailing lists, send an  @>
@q email with ``subscribe <email-address>'' as the subject.   @>

@q The author can be contacted at:     @>

@q Laurence D. Finston 		       @>
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor 	       @>
@q Boston, MA  02110-1301  	       @>
@q USA                                 @>                             

@q Laurence.Finston@gmx.de  @>



@q * (1)  Include files.@>
@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <mysql.h>
#include <errno.h>
#include <float.h>
#include <fstream>
#include <limits.h>
#include <stdarg.h>
#include <stdexcept>

#include <mysql.h>

#include <algorithm>
#include <exception>
#include <functional>
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <new>
#include <sstream>   
#include <fstream>   
#include <string> 
#include <vector>
#include <deque>
#include <map>

using namespace std;

#include "../config.h"

typedef void* yyscan_t;  

#include "stars.hxx"
#include "parser.hxx"
#include "scanner.hxx"

@q * (1) Class declarations.  @>
@* Class declarations.
\initials{LDF 2021.08.15.}

@q ** (2) @>

@
@<class declarations@>=
struct
IO_Type
{
   string in_filename;
   string out_filename;

   FILE *in_file;

   long in_file_pos;

   ofstream out_file_tex;
   ofstream out_file_html;

   IO_Type(void) {in_file_pos = 0; in_file = static_cast<FILE *>(0); return;}
   IO_Type(const IO_Type &i) {in_filename = i.in_filename; 
                              out_filename = i.out_filename; 
                              in_file = 0;
                              in_file_pos = 0;
                              return;}

};

@q ** (2) @>
@
@<class declarations@>=
struct
Where_Type
{
   static const unsigned int NULL_TYPE                  =  0;
   static const unsigned int INT_TYPE                   =  1;
   static const unsigned int FLOAT_TYPE                 =  2;
   static const unsigned int STRING_TYPE                =  3;         
   static const unsigned int BOOL_TYPE                  =  4;
   static const unsigned int EQUAL_TYPE                 =  5; 
   static const unsigned int NOT_EQUAL_TYPE             =  6;
   static const unsigned int GREATER_THAN_TYPE          =  7;
   static const unsigned int GREATER_THAN_OR_EQUAL_TYPE =  8;
   static const unsigned int LESS_THAN_TYPE             =  9;
   static const unsigned int LESS_THAN_OR_EQUAL_TYPE    = 10;
   static const unsigned int AND_TYPE                   = 11;
   static const unsigned int OR_TYPE                    = 12;
   static const unsigned int XOR_TYPE                   = 13;
   static const unsigned int NOT_TYPE                   = 14;
   static const unsigned int NOT_AND_TYPE               = 15;
   static const unsigned int NOT_OR_TYPE                = 16;
   static const unsigned int NOT_XOR_TYPE               = 17;             
   static const unsigned int LEFT_PARENTHESIS_TYPE      = 18;             
   static const unsigned int RIGHT_PARENTHESIS_TYPE     = 19;             

   int field;
   int operator_wt;
   int logical_operator;
   int arg_type;
   int arg_int;
   float arg_float;
   string arg_str;
   bool arg_bool;
   bool left_paren_flag;
   bool right_paren_flag;

   void show(string s = "Where_Type:");

   Where_Type(void) 
   {
       field            = 0; 
       operator_wt      = 0; 
       logical_operator = 0;
       arg_type         = 0;
       arg_int          = 0;
       arg_float        = 0.0;
       arg_str          = "";
       arg_bool         = false;
       left_paren_flag  = false;
       right_paren_flag = false;

   }

   Where_Type(const Where_Type &w) 
   {
       field            = w.field;
       operator_wt      = w.operator_wt;
       logical_operator = w.logical_operator;
       arg_type         = w.arg_type;
       arg_int          = w.arg_int;
       arg_float        = w.arg_float;
       arg_str          = w.arg_str;
       arg_bool         = w.arg_bool;
       left_paren_flag  = w.left_paren_flag;
       right_paren_flag = w.right_paren_flag;
   }
};

@q *** (3) @>
@
@<Define |Where_Type| functions@>=
void 
Where_Type::show(string s)
{
   cerr << s << endl 
        << "logical_operator:  ";

   if (operator_map[logical_operator].empty())
      cerr << "(Empty string)";
   else
      cerr << operator_map[logical_operator];

   cerr << " (" << logical_operator << ")" << endl
        << "field:             " << table_field_map[field] << " (" << field << ")" << endl  
        << "operator_wt:       " << operator_map[operator_wt] << " (" << operator_wt << ")" << endl;

   if (arg_type == Where_Type::INT_TYPE)
   {
      cerr << "arg_type:          Where_Type::INT_TYPE" << endl
           << "arg_int:           " << arg_int << endl;
   }
   else if (arg_type == Where_Type::FLOAT_TYPE)
   {
      cerr << "arg_type:          Where_Type::FLOAT_TYPE" << endl 
           << "arg_float:         " << arg_float << endl;
   }
   else if (arg_type == Where_Type::STRING_TYPE)
   {
      cerr << "arg_type:          Where_Type::STRING_TYPE" << endl
           << "arg_str:           " << arg_str << endl;
   }
   else if (arg_type == Where_Type::BOOL_TYPE)
   {
      cerr << "arg_type:          Where_Type::BOOL_TYPE" << endl
           << "arg_bool:          " << arg_bool << endl;
   }
   cerr << "left_paren_flag:   " << left_paren_flag << endl 
        << "right_paren_flag:  " << right_paren_flag << endl
        << endl; 

   return;

}  /* End of |Where_Type::show| definition  */


@q ** (2) @>

@*1 |class Scanner_Type|.
@
@<class declarations@>=
class
Scanner_Type
{
    friend int yyparse(yyscan_t);
    friend int yylex(YYSTYPE* lvalp, yyscan_t parameter);
    friend int main(int argc, char *argv[]);
    friend int query_database_for_stars(Scanner_Node, std::string, std::string, int, int);

    int id;
    bool end_flag;
    string input_filename;
    int limit;
    int offset;
    int count;
    int lowest;
    int highest;
    string where_str;
    string order_by_str;

    int ascending_descending_flag;
    bool append_flag;

    vector<int> table_field_vector;
    vector<int> table_field_exclude_vector;
    vector<Star> star_vector;
    vector<Song> song_vector;
    vector<Where_Type> where_vector;

    public:

       @<Declare |Scanner_Type| functions@>@;

};

@q ** (2) |Scanner_Type| functions.  @>

@ |Scanner_Type| functions.  

@q *** (3) Constructors @>

@q **** (4) Default constructor @>

@ Default constructor.

@q ***** (5) Declaration  @>


@<Declare |Scanner_Type| functions@>=
Scanner_Type(void);

@q ***** (5) Definition  @>
@
@<Define |Scanner_Type| functions@>=
Scanner_Type::Scanner_Type(void)
{
  id       = 0; 
  end_flag = false; 
  limit    = 0; 
  offset   = 0; 
  count    = 0; 
  lowest   = 0;
  highest  = 0;
  ascending_descending_flag = 0;
  append_flag = false;

  return;
}

@q **** (4) Constructor with single |int| argument.  @>

@ Constructor with single |int| argument.

@q ***** (5) Declaration  @>

@<Declare |Scanner_Type| functions@>=
Scanner_Type(int iid);

@q ***** (5) Definition  @>
@
@<Define |Scanner_Type| functions@>=
Scanner_Type::Scanner_Type(int iid) : id(iid)
{
  end_flag = false; 
  limit    = 0; 
  offset   = 0; 
  count    = 0; 
  lowest   = 0;
  highest  = 0;
  ascending_descending_flag  = 0;
  append_flag = false;

  return;
}

@q *** (3) Clear.  @>

@ Clear.

@q **** (4) Declaration  @>

@<Declare |Scanner_Type| functions@>=
int clear(void);

@q **** (4) Definition  @>
@
@<Define |Scanner_Type| functions@>=
int Scanner_Type::clear(void) 
{
   id       = 0; 
   end_flag = false; 
   limit    = 0; 
   offset   = 0; 
   count    = 0; 
   lowest   = 0;
   highest  = 0;


   where_str    = "";
   order_by_str = "";
   ascending_descending_flag = 0;
   append_flag = false;

   table_field_vector.clear();
   table_field_exclude_vector.clear();
   star_vector.clear();
   where_vector.clear();
  
   return 0;

}  /* End of |Scanner_Type::clear| definition  */

@q ** (2) @>

@q * (1) Putting classes together.@>
@* Putting classes together.

@q ** (2) This is what's compiled.@>
@ This is what's compiled.

@c
typedef float real;
class Scanner_Type;
typedef Scanner_Type *Scanner_Node;
@<Include files@>@;
class Song {};
map<int, string> table_field_map;
map<int, string> operator_map;
@<class declarations@>@;@/
typedef Scanner_Type *Scanner_Node;
deque<IO_Type> io_deque;
@<Define |Where_Type| functions@>@;
@<Define |Scanner_Type| functions@>@;



@q **** (4) This is what's written to the header file `classes.hxx'.  @>

@ This is what's written to the header file \filename{classes.hxx}.
@
@(classes.hxx@>=
#ifndef CLASSES_H
#define CLASSES_H 1
using namespace std;
typedef float real;
class Song;
@<class declarations@>@;@/
typedef Scanner_Type *Scanner_Node;
extern deque<IO_Type> io_deque;
extern map<int, string> table_field_map;
extern map<int, string> operator_map;
#endif 



@q * Emacs-Lisp code for use in indirect buffers when using the          @>
@q   GNU Emacs editor.  The local variable list is not evaluated when an @>
@q   indirect buffer is visited, so it's necessary to evaluate the       @>
@q   following s-expression in order to use the facilities normally      @>
@q   accessed via the local variables list.                              @>
@q   \initials{LDF 2004.02.12}.                                          @>
@q   (progn (cweb-mode) (outline-minor-mode)                   (ignore " @>
@q ")  (setq fill-column 80) (column-number-mode 1))                     @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q makefile:"makefile" @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q End: @>

