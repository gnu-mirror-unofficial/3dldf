b@c /home/laurence/3DLDF-2.0.4/doc/paths.texi

@c Created by Laurence D. Finston (LDF) Sun 04 Apr 2021 01:22:29 PM CEST

@c This file is part of the 3DLDF 2.0.4 User Manual.
@c Copyright (C) 2021 The Free Software Foundation

@c See the section "GNU Free Documentation License" in the file 
@c fdl.texi for copying conditions.

@c Author:  Laurence D. Finston (LDF)

@c * (1) Transforms

@node Paths, FDL, Transforms, Top
@chapter Paths

To make drawings, it's necessary to combine @code{points} and transforms into
more complex @dfn{compound objects}.  The simplest of these is the @code{path},
which consists of @code{points} connected by @dfn{connectors}, as in @MF and @MP.

Unlike @MF and @MP, however, 3DLDF only defines the two connectors @code{..}
and @code{--};  3DLDF doesn't define @MF and @MP's means for specifying @code{paths}
more exactly, i.e., @code{controls}, directions, etc.  This would be much more
difficult in three dimensions.

A simple @code{path} can be declared and assigned to like this:

@example
path r;
r := (0, 0) .. (1, 1);
show r;
@result{}
path:
type:  PATH_TYPE
surface_hiding_ctr:  0
decomposition_level:  0
points.size() == 2
connectors.size() == 1
(0.00000000, 0.00000000, 0.00000000) .. (1.00000000, 1.00000000, 0.00000000);
fill_draw_value == 0
`fill_color_vector' == 0
`draw_color_vector' == 0
`pen_vector' == 0
`dash_pattern_vector' == 0
`arrow' == `Path::NO_ARROW'.
@end example

Here, the @code{points} on the @code{path} are specified as unnamed @code{point}
@dfn{expressions}, which are not saved in variables.  A @code{path} can also
be assigned to using @code{point} variables:

@example
point p[];
path r;
p0 := origin; %% Equivalent to @code{(0, 0, 0)}
p1 := (1cm, 1cm);
r := p0 .. p1;
show r;
@result{}
path:
type:  PATH_TYPE
surface_hiding_ctr:  0
decomposition_level:  0
points.size() == 2
connectors.size() == 1
(0.00000000, 0.00000000, 0.00000000) .. (1.00000000, 1.00000000, 0.00000000);
fill_draw_value == 0
`fill_color_vector' == 0
`draw_color_vector' == 0
`pen_vector' == 0
`dash_pattern_vector' == 0
`arrow' == `Path::NO_ARROW'.
@end example

The result is exactly the same.

Now, we can draw @code{r} and label the endpoints to make our first drawing:

@example
beginfig(1);
draw p;
dotlabel.lft("$p_0$", p0);
dotlabel.rt("$p_1$", p1);
endfig with_projection parallel_x_y;
@result{}
@image{example_1}
@end example

It's necessary to call @code{endfig} with the argument @code{with_projection parallel_x_y}
in order to project the drawing onto the x-y plane because the default projection is
the @dfn{projective projection} (@pxref{Projective Projection}).

The @code{label} and @code{dotlabel} commands are similar to the corresponding commands in
@MF and @MP.

Of course, @code{paths} can consist of more than two points and can describe curves:

@example
beginfig(2);
point p[];
path q;
p0 := origin;
p1 := (1, 0, 1);
p2 := (3, 0, 2);
p3 := (2, 0, 5);
p4 := (4, 0, 1);
q := p0 .. p1 .. p2 .. p3 .. p4 .. p0;
draw q;
dotlabel.lft("$p_0$", p0);
dotlabel.ulft("$p_1$", p1);
dotlabel.lft("$p_2$", p2);
dotlabel.rt("$p_3$", p3);
dotlabel.lrt("$p_4$", p4);
endfig with_projection parallel_x_z;
@result{}
@image{example_2}
@end example

In this example, the @code{points} are all on the x-z plane and the drawing is projected
onto that plane.



@c ** (2)

@c * (1) Local Variables for Emacs

@c For use in indirect buffers:
@c
@c (progn (texinfo-mode) (outline-minor-mode t) (setq outline-regexp "@c *\\*+") (ignore (quote 
@c )) (set (make-local-variable 'run-texi2dvi-on-file) "3dldf.texi"))
  
@c Local Variables:
@c mode:Texinfo
@c abbrev-mode:t
@c eval:(outline-minor-mode t)
@c outline-regexp:"@c *\\*+"
@c eval:(set (make-local-variable 'run-texi2dvi-on-file) "3dldf.texi")
@c fill-column:80
@c End:


